;	Static Name Aliases
;
;	$S4061__aam	EQU	_aam
;	$S3813_?toggle@?1??wait_for_time_tick@@ZAXXZ@4IE	EQU	?toggle@?1??wait_for_time_tick@@ZAXXZ@4IE
;	$S4069__aao	EQU	_aao
	TITLE   c:\dmmtest\dmmtest.cpp
	.286p
INCLUDELIB      LLIBCE
INCLUDELIB	OLDNAMES.LIB
DMMTEST_TEXT	SEGMENT  WORD PUBLIC 'CODE'
DMMTEST_TEXT	ENDS
_DATA	SEGMENT  WORD PUBLIC 'DATA'
_DATA	ENDS
CONST	SEGMENT  WORD PUBLIC 'CONST'
CONST	ENDS
_BSS	SEGMENT  WORD PUBLIC 'BSS'
_BSS	ENDS
XIFCB	SEGMENT  WORD PUBLIC 'DATA'
XIFCB	ENDS
XIFU	SEGMENT  WORD PUBLIC 'DATA'
XIFU	ENDS
XIFL	SEGMENT  WORD PUBLIC 'DATA'
XIFL	ENDS
XIFM	SEGMENT  WORD PUBLIC 'DATA'
XIFM	ENDS
XIFCE	SEGMENT  WORD PUBLIC 'DATA'
XIFCE	ENDS
XOB	SEGMENT  WORD PUBLIC 'BSS'
XOB	ENDS
XO	SEGMENT  WORD PUBLIC 'BSS'
XO	ENDS
XOE	SEGMENT  WORD PUBLIC 'BSS'
XOE	ENDS
DMMTEST13_DATA	SEGMENT  PARA PUBLIC 'FAR_DATA'
DMMTEST13_DATA	ENDS
DGROUP	GROUP	CONST, _BSS, _DATA
	ASSUME DS: DGROUP, SS: DGROUP
PUBLIC  ?obc_mac@@3QEEE
PUBLIC  ?data_ready@@3IE
PUBLIC  ?control_mac@@3QEEE
PUBLIC  ?broadcast_mac@@3QEEE
PUBLIC  ?prop@@3UPROP@@E
PUBLIC  ?shore_mac@@3QEEE
PUBLIC  ?cmd_buffer@@3QEEE
PUBLIC  ?sys_frame@@3KE
PUBLIC  ?sys_status@@3IE
PUBLIC  ?time_since_last_command@@3HE
PUBLIC  ?adcp@@3UADCP@@E
PUBLIC  ?mux_addr@@3IE
PUBLIC  ?ln200@@3ULN200@@E
PUBLIC  ?gps@@3UGPS@@E
PUBLIC  ?sys@@3USYS@@E
PUBLIC  ?prop_position@@3JE
PUBLIC  ?prop_index@@3JE
PUBLIC  ?prop_position_absolute_current@@3JE
PUBLIC  ?prop_position_absolute_previous@@3JE
PUBLIC  ?commands@@3UCOMMANDS@@E
PUBLIC  ?sys_timer@@3UTIMER@@E
PUBLIC  ?frame_time@@3UTIMER@@E
PUBLIC  ?obs_time@@3UTIMER@@E
PUBLIC  ?obs@@3UOBS@@E
PUBLIC  ?dyno_time@@3UTIMER@@E
PUBLIC  ?ln200_rx_num@@3KE
PUBLIC  ?prop_rpm_time@@3UTIMER@@E
PUBLIC  ?prop_position_time@@3UTIMER@@E
PUBLIC  ?prop_position_time_previous@@3UTIMER@@E
PUBLIC  ?prop_adc_time@@3UTIMER@@E
PUBLIC  ?ln200_time@@3UTIMER@@E
PUBLIC  ?echo@@3UECHO@@E
PUBLIC  ?cmds_time@@3UTIMER@@E
PUBLIC  ?ds_time@@3UTIMER@@E
PUBLIC  ?adcp_time@@3UTIMER@@E
PUBLIC  ?gps_time@@3UTIMER@@E
PUBLIC  ?settings@@3Uescc_regs@@E
PUBLIC  ?escc1@@3VCescc@@E
PUBLIC  ?dyno@@3UDYNO@@E
PUBLIC  ?stern1_cmd@@3IE
PUBLIC  ?stern2_cmd@@3IE
PUBLIC  ?ds@@3UDS@@E
PUBLIC  ?fore_cmd@@3IE
PUBLIC  ?pcm_sent@@3IE
PUBLIC  ?rudder_cmd@@3IE
PUBLIC  ?prop_cmd@@3IE
PUBLIC  ?send_message@@3HE
EXTRN	__acrtused:ABS
EXTRN	__fltused:ABS
EXTRN	?write_bit@@ZAXHH@Z:FAR
EXTRN	_te5650CaptureIndex:FAR
EXTRN	_memcpy:FAR
EXTRN	?set_bit@@ZAXH@Z:FAR
EXTRN	??6ostream@@RECAEV0@E@Z:FAR
EXTRN	_te5650CapturePos:FAR
EXTRN	?set_tx_type@Cescc@@RECIII@Z:FAR
EXTRN	??6ostream@@RECAEV0@F@Z:FAR
EXTRN	_te5650MotorOff:FAR
EXTRN	??6ostream@@RECAEV0@H@Z:FAR
EXTRN	_te5650SetAxis:FAR
EXTRN	??6ostream@@RECAEV0@I@Z:FAR
EXTRN	?read_port@@ZAIH@Z:FAR
EXTRN	__chain_intr:FAR
EXTRN	??0Cescc@@REC@XZ:FAR
EXTRN	__disable:FAR
EXTRN	??1Cescc@@REC@XZ:FAR
EXTRN	??6ostream@@RECAEV0@N@Z:FAR
EXTRN	_te5650SetMotor:FAR
EXTRN	_te5650PhasesPolarity:FAR
EXTRN	?set_clock_generator@Cescc@@RECXIKI@Z:FAR
EXTRN	_system:FAR
EXTRN	__fatexit:FAR
EXTRN	_te5650InitServo:FAR
EXTRN	?receiver@@ZAXIIIIIIIIIIIII@Z:FAR
EXTRN	_te5650InitSw:FAR
EXTRN	?add_port@Cescc@@RECIIIIII@Z:FAR
EXTRN	?driver_info@@ZAHI@Z:FAR
EXTRN	?kill_port@Cescc@@RECII@Z:FAR
EXTRN	?init_port@Cescc@@RECIIIPEUescc_regs@@II@Z:FAR
EXTRN	__dos_setvect:FAR
EXTRN	?init_com1@@ZAXXZ:FAR
EXTRN	_sprintf:FAR
EXTRN	_te5650IsCapture:FAR
EXTRN	?init_com2@@ZAXXZ:FAR
EXTRN	_te5650ActPos:FAR
EXTRN	__aFeldw:FAR
EXTRN	__getch:FAR
EXTRN	?init_com4@@ZAXXZ:FAR
EXTRN	__aFdcvt:FAR
EXTRN	?tx_port@Cescc@@RECIIPEDI@Z:FAR
EXTRN	__aFfmuld:FAR
EXTRN	?flush@ostream@@RECAEV1@XZ:FAR
EXTRN	?shutdown_com1@@ZAXXZ:FAR
EXTRN	__enable:FAR
EXTRN	__aFfstdp:FAR
EXTRN	_te5650Update:FAR
EXTRN	_exit:FAR
EXTRN	__inp:FAR
EXTRN	__fmemcpy:FAR
EXTRN	?shutdown_com2@@ZAXXZ:FAR
EXTRN	__aFflds:FAR
EXTRN	__inpw:FAR
EXTRN	?access_type@@ZAHHHHPEDIP7AXIIIIIIIIIIIII@Z@Z:FAR
EXTRN	?shutdown_com4@@ZAXXZ:FAR
EXTRN	__aFfldl:FAR
EXTRN	__aFfmul:FAR
EXTRN	__kbhit:FAR
EXTRN	__aFftol:FAR
EXTRN	__outp:FAR
EXTRN	?send_pkt@@ZAHPEEI@Z:FAR
EXTRN	?clear_rx_buffer@Cescc@@RECII@Z:FAR
EXTRN	_te5650ResetCapture:FAR
EXTRN	?terminate@@ZAHH@Z:FAR
EXTRN	?clear_tx_buffer@Cescc@@RECII@Z:FAR
EXTRN	??6ostream@@RECAEV0@PFD@Z:FAR
EXTRN	?init_io@@ZAXI@Z:FAR
EXTRN	__dos_getvect:FAR
EXTRN	?read_bit@@ZAHH@Z:FAR
EXTRN	__fmemset:FAR
EXTRN	?handle@@3HE:WORD
EXTRN	?packets_rcvd@@3KE:DWORD
EXTRN	?ax0_counter@@3KE:DWORD
EXTRN	?ax1_counter@@3KE:DWORD
EXTRN	?discards@@3KE:DWORD
EXTRN	?receiver_calls@@3KE:DWORD
EXTRN	?basefield@ios@@2JF:DWORD
EXTRN	?x_statebuf@ios@@0PEJE:DWORD
EXTRN	?cout@@3Vostream_withassign@@E:BYTE
_DATA      SEGMENT
?pcm_sent@@3IE	DW	00H
?send_message@@3HE	DW	00H
?obc_mac@@3QEEE	DB	00H
	DB	01H
	DB	045H
	DB	00H
	DB	07aH
	DB	09cH
?control_mac@@3QEEE	DB	00H
	DB	01H
	DB	045H
	DB	00H
	DB	08aH
	DB	021H
?broadcast_mac@@3QEEE	DB	0ffH
	DB	0ffH
	DB	0ffH
	DB	0ffH
	DB	0ffH
	DB	0ffH
?shore_mac@@3QEEE	DB	00H
	DB	0eH
	DB	0a6H
	DB	0b6H
	DB	0c0H
	DB	04eH
?sys_frame@@3KE	DD	00H
?sys_status@@3IE	DW	00H
?time_since_last_command@@3HE	DW	00H
?mux_addr@@3IE	DW	00H
?prop_position@@3JE	DD	00H
?prop_index@@3JE	DD	00H
?prop_position_absolute_current@@3JE	DD	00H
?prop_position_absolute_previous@@3JE	DD	00H
?ln200_rx_num@@3KE	DD	00H
?stern1_cmd@@3IE	DW	00H
?stern2_cmd@@3IE	DW	00H
?fore_cmd@@3IE	DW	00H
?rudder_cmd@@3IE	DW	00H
?prop_cmd@@3IE	DW	00H
?data_ready@@3IE	DW	00H
$SG3699	DB	'Stern1:    %04x',  00H
$SG3707	DB	'Stern2:    %04x',  00H
$SG3721	DB	'Rudder:    %04x',  00H
$SG3729	DB	'Prop:      %04x',  00H
$SG3731	DB	'Ballast:   %04x',  00H
$SG3750	DB	'te5650InitSw:    ',  00H
$SG3751	DB	'te5650InitServo: ',  00H
$SG3752	DB	'te5650SetAxis:   ',  00H
$SG3753	DB	'Tech80 5650 Installed.',  00H
$SG3758	DB	'Initializing packet driver.',  00H
$SG3761	DB	'c:\packet\pktdrv\ne2000 0x7e 10 0x300',  00H
$SG3762	DB	'Access_type() error: ',  00H
$SG3763	DB	'Handle: ',  00H
$SG3764	DB	'Driver_info() error: ',  00H
$SG3765	DB	'Rpm_sf: ',  00H
$SG3766	DB	'Packet driver initialized.',  00H
$SG3769	DB	'Initializing ESCC.',  00H
$SG3774	DB	'Channel A = ',  00H
$SG3775	DB	'Channel B = ',  00H
$SG3776	DB	'initializing channel A',  00H
$SG3778	DB	'Intialize Channel A OK.',  00H
$SG3780	DB	'Initialize Channel A FAILED!',  00H
$SG3782	DB	'Channel A rx buffer cleared OK.  ',  00H
$SG3784	DB	'Channel A rx buffer clear FAILED!',  00H
$SG3786	DB	'Channel A tx buffer cleared OK.',  00H
$SG3788	DB	'Channel A tx buffer clear FAILED!',  00H
$SG3790	DB	'Channel A set to Transparent Mode.  ',  00H
$SG3792	DB	'Channel A Transparent Mode not set!  Channel not open!',  00H
$SG3794	DB	'Intialize Channel B OK.',  00H
$SG3796	DB	'Initialize Channel B FAILED!',  00H
$SG3798	DB	'Channel B rx buffer cleared OK.  ',  00H
$SG3800	DB	'Channel B rx buffer clear FAILED!',  00H
$SG3802	DB	'Channel B tx buffer cleared OK.',  00H
$SG3804	DB	'Channel B tx buffer clear FAILED!',  00H
$SG3806	DB	'Channel B set to Transparent Mode.  ',  00H
$SG3808	DB	'Channel B Transparent Mode not set!  Channel not open!',  00H
$SG3809	DB	'ESCC initialized.',  00H
$S3813_?toggle@?1??wait_for_time_tick@@ZAXXZ@4IE	DW	00H
$SG3820	DB	'Pitch:   %04x  %10.2f deg',  00H
$SG3822	DB	'Roll:    %04x  %10.2f deg',  00H
$SG3824	DB	'Heading: %04x  %10.2f deg',  00H
$SG3826	DB	'Stern 1: %04x',  00H
$SG3828	DB	'Stern 2: %04x',  00H
$SG3830	DB	'Rudder:  %04x',  00H
$SG3832	DB	'Fore:    %04x',  00H
$SG3834	DB	'RawPos:    %08ld',  00H
$SG3836	DB	'RawIndex:    %08ld',  00H
$SG3838	DB	'PPos:    %08d',  00H
$SG3846	DB	'Initializing DMM32a.',  00H
$SG3850	DB	'DMM32a initialized.',  00H
$SG3868	DB	'Initializing DMM32b.',  00H
$SG3872	DB	'DMM32b initialized.',  00H
$SG3909	DB	'    Frame # ',  00H
$SG3910	DB	'Frame start:   ',  00H
$SG3911	DB	'%s%8lu %5u%s%8lu',  00H
$SG3913	DB	'OBS data:      ',  00H
$SG3914	DB	'%s%8lu %5u',  00H
$SG3916	DB	'Dyno data:     ',  00H
$SG3917	DB	'%s%8lu %5u',  00H
$SG3919	DB	'Prop adc:      ',  00H
$SG3920	DB	'%s%8lu %5u',  00H
$SG3922	DB	'Prop position: ',  00H
$SG3923	DB	'%s%8lu %5u',  00H
$SG3925	DB	'Commands rcvd: ',  00H
$SG3926	DB	'%s%8lu %5u',  00H
$SG3928	DB	'ADCP rcvd:     ',  00H
$SG3929	DB	'%s%8lu %5u',  00H
$SG3931	DB	'DS rcvd:       ',  00H
$SG3932	DB	'%s%8lu %5u',  00H
$SG3934	DB	'    LN200 # ',  00H
$SG3935	DB	'LN200 rcvd:    ',  00H
$SG3936	DB	'%s%8lu %5u%s%8lu ',  00H
$SG3938	DB	'Received packets: ',  00H
$SG3939	DB	'%s%lu',  00H
$SG3941	DB	'Ax0 count:        ',  00H
$SG3942	DB	'%s%lu',  00H
$SG3944	DB	'Ax1 count:        ',  00H
$SG3945	DB	'%s%lu',  00H
$SG3947	DB	'Discards:         ',  00H
$SG3948	DB	'%s%lu',  00H
$SG3950	DB	'Receiver calls:   ',  00H
$SG3951	DB	'%s%lu',  00H
$SG4018	DB	'                       Autonomous Model Onboard Computer    '
	DB	'                    ',  00H
$SG4019	DB	'%s',  00H
$SG4021	DB	'                               NSWC-CD Code 5600            '
	DB	'                    ',  00H
$SG4022	DB	'%s',  00H
$SG4024	DB	'                             March 8, 2004 Rev 0.8          '
	DB	'                    ',  00H
$SG4025	DB	'%s',  00H
_DATA      ENDS
XIFU      SEGMENT
$S4069__aao	DD	_aan
XIFU      ENDS
_BSS      SEGMENT
	ORG	$+3500
PUBLIC  ?com4_tx@@3IE
?com4_tx@@3IE	DW 01H DUP (?)
PUBLIC  ?ip_id@@3IE
?ip_id@@3IE	DW 01H DUP (?)
_BSS      ENDS
DMMTEST13_DATA      SEGMENT
	ORG	$+362
?prop@@3UPROP@@E	DW 015H DUP (?)
	ORG	$+1096
?cmd_buffer@@3QEEE	DW 03ecH DUP (?)
DMMTEST13_DATA      ENDS
_BSS      SEGMENT
	ORG	$-3158
PUBLIC  ?data_pkt@@3QEEE
?data_pkt@@3QEEE	DW 02f5H DUP (?)
PUBLIC  ?channela@@3IE
?channela@@3IE	DW 01H DUP (?)
_BSS      ENDS
DMMTEST13_DATA      SEGMENT
	ORG	$-2884
?adcp@@3UADCP@@E	DB 0e1H DUP (?)
DMMTEST13_DATA      ENDS
_BSS      SEGMENT
PUBLIC  ?channelb@@3IE
?channelb@@3IE	DW 01H DUP (?)
PUBLIC  ?frame@@3KE
?frame@@3KE	DW 02H DUP (?)
PUBLIC  ?next_frame@@3KE
?next_frame@@3KE	DW 02H DUP (?)
PUBLIC  ?reading_prop@@3IE
?reading_prop@@3IE	DW 01H DUP (?)
PUBLIC  ?obs_new_data@@3IE
?obs_new_data@@3IE	DW 01H DUP (?)
PUBLIC  ?obs_data_frame@@3KE
?obs_data_frame@@3KE	DW 02H DUP (?)
PUBLIC  ?obs_array@@3QEIE
?obs_array@@3QEIE	DW 020H DUP (?)
_BSS      ENDS
DMMTEST13_DATA      SEGMENT
	ORG	$-445
?ln200@@3ULN200@@E	DW 016H DUP (?)
DMMTEST13_DATA      ENDS
_BSS      SEGMENT
PUBLIC  ?obs_buffer@@3QEEE
?obs_buffer@@3QEEE	DW 020H DUP (?)
PUBLIC  ?dyno_new_data@@3IE
?dyno_new_data@@3IE	DW 01H DUP (?)
PUBLIC  ?dyno_data_frame@@3KE
?dyno_data_frame@@3KE	DW 02H DUP (?)
PUBLIC  ?dyno_array@@3QEIE
?dyno_array@@3QEIE	DW 080H DUP (?)
PUBLIC  ?dyno_buffer@@3QEEE
?dyno_buffer@@3QEEE	DW 080H DUP (?)
PUBLIC  ?prop_new_data@@3IE
?prop_new_data@@3IE	DW 01H DUP (?)
_BSS      ENDS
DMMTEST13_DATA      SEGMENT
	ORG	$+402
?gps@@3UGPS@@E	DW 02eH DUP (?)
DMMTEST13_DATA      ENDS
_BSS      SEGMENT
PUBLIC  ?prop_data_frame@@3KE
?prop_data_frame@@3KE	DW 02H DUP (?)
PUBLIC  ?prop_rpm@@3HE
?prop_rpm@@3HE	DW 01H DUP (?)
_BSS      ENDS
DMMTEST13_DATA      SEGMENT
	ORG	$-942
?sys@@3USYS@@E	DW 09H DUP (?)
DMMTEST13_DATA      ENDS
_BSS      SEGMENT
PUBLIC  ?prop_report@@3JE
?prop_report@@3JE	DW 02H DUP (?)
PUBLIC  ?index_report@@3JE
?index_report@@3JE	DW 02H DUP (?)
_BSS      ENDS
XO      SEGMENT
$S4061__aam	DW 02H DUP (?)
XO      ENDS
DMMTEST13_DATA      SEGMENT
	ORG	$+430
?commands@@3UCOMMANDS@@E	DW 012H DUP (?)
DMMTEST13_DATA      ENDS
_BSS      SEGMENT
PUBLIC  ?rpm_sf@@3ME
?rpm_sf@@3ME	DW 02H DUP (?)
PUBLIC  ?prop_array@@3QEIE
?prop_array@@3QEIE	DW 06H DUP (?)
PUBLIC  ?prop_buffer@@3QEEE
?prop_buffer@@3QEEE	DW 06H DUP (?)
PUBLIC  ?ln200_new_data@@3IE
?ln200_new_data@@3IE	DW 01H DUP (?)
PUBLIC  ?ln200_data_frame@@3KE
?ln200_data_frame@@3KE	DW 02H DUP (?)
_BSS      ENDS
DMMTEST13_DATA      SEGMENT
	ORG	$+458
?sys_timer@@3UTIMER@@E	DW 03H DUP (?)
DMMTEST13_DATA      ENDS
_BSS      SEGMENT
PUBLIC  ?ln200_buffer@@3QEEE
?ln200_buffer@@3QEEE	DW 010H DUP (?)
_BSS      ENDS
DMMTEST13_DATA      SEGMENT
?frame_time@@3UTIMER@@E	DW 03H DUP (?)
?obs_time@@3UTIMER@@E	DW 03H DUP (?)
DMMTEST13_DATA      ENDS
_BSS      SEGMENT
PUBLIC  ?ln200_command@@3QEDE
?ln200_command@@3QEDE	DW 07H DUP (?)
_BSS      ENDS
DMMTEST13_DATA      SEGMENT
	ORG	$-942
?obs@@3UOBS@@E	DW 026H DUP (?)
	ORG	$+866
?dyno_time@@3UTIMER@@E	DW 03H DUP (?)
?prop_rpm_time@@3UTIMER@@E	DW 03H DUP (?)
DMMTEST13_DATA      ENDS
_BSS      SEGMENT
PUBLIC  ?echo_new_data@@3IE
?echo_new_data@@3IE	DW 01H DUP (?)
_BSS      ENDS
DMMTEST13_DATA      SEGMENT
?prop_position_time@@3UTIMER@@E	DW 03H DUP (?)
DMMTEST13_DATA      ENDS
_BSS      SEGMENT
PUBLIC  ?echo_data_frame@@3KE
?echo_data_frame@@3KE	DW 02H DUP (?)
_BSS      ENDS
DMMTEST13_DATA      SEGMENT
?prop_position_time_previous@@3UTIMER@@E	DW 03H DUP (?)
DMMTEST13_DATA      ENDS
_BSS      SEGMENT
PUBLIC  ?echo_array@@3QEIE
?echo_array@@3QEIE	DW 08H DUP (?)
PUBLIC  ?echo_buffer@@3QEEE
?echo_buffer@@3QEEE	DW 08H DUP (?)
_BSS      ENDS
DMMTEST13_DATA      SEGMENT
?prop_adc_time@@3UTIMER@@E	DW 03H DUP (?)
DMMTEST13_DATA      ENDS
_BSS      SEGMENT
PUBLIC  ?ds_new_data@@3IE
?ds_new_data@@3IE	DW 01H DUP (?)
_BSS      ENDS
DMMTEST13_DATA      SEGMENT
?ln200_time@@3UTIMER@@E	DW 03H DUP (?)
	ORG	$-512
?echo@@3UECHO@@E	DW 018H DUP (?)
DMMTEST13_DATA      ENDS
_BSS      SEGMENT
PUBLIC  ?ds_data_frame@@3KE
?ds_data_frame@@3KE	DW 02H DUP (?)
_BSS      ENDS
DMMTEST13_DATA      SEGMENT
	ORG	$+464
?cmds_time@@3UTIMER@@E	DW 03H DUP (?)
DMMTEST13_DATA      ENDS
_BSS      SEGMENT
PUBLIC  ?ds_array@@3QEIE
?ds_array@@3QEIE	DW 04H DUP (?)
_BSS      ENDS
DMMTEST13_DATA      SEGMENT
?ds_time@@3UTIMER@@E	DW 03H DUP (?)
DMMTEST13_DATA      ENDS
_BSS      SEGMENT
PUBLIC  ?ds_buffer@@3QEEE
?ds_buffer@@3QEEE	DW 028H DUP (?)
_BSS      ENDS
DMMTEST13_DATA      SEGMENT
?adcp_time@@3UTIMER@@E	DW 03H DUP (?)
DMMTEST13_DATA      ENDS
_BSS      SEGMENT
PUBLIC  ?adcp_new_data@@3IE
?adcp_new_data@@3IE	DW 01H DUP (?)
_BSS      ENDS
DMMTEST13_DATA      SEGMENT
?gps_time@@3UTIMER@@E	DW 03H DUP (?)
DMMTEST13_DATA      ENDS
_BSS      SEGMENT
PUBLIC  ?adcp_data_frame@@3KE
?adcp_data_frame@@3KE	DW 02H DUP (?)
_BSS      ENDS
DMMTEST13_DATA      SEGMENT
?settings@@3Uescc_regs@@E	DW 01fH DUP (?)
?escc1@@3VCescc@@E	DW 0d1H DUP (?)
DMMTEST13_DATA      ENDS
_BSS      SEGMENT
PUBLIC  ?adcp_array@@3QEEE
?adcp_array@@3QEEE	DB 0d5H DUP (?)
	ORG	$+1
PUBLIC  ?adcp_buffer@@3QEEE
?adcp_buffer@@3QEEE	DB 0d5H DUP (?)
	ORG	$+1
PUBLIC  ?adcp_test@@3QEEE
?adcp_test@@3QEEE	DB 0d5H DUP (?)
_BSS      ENDS
DMMTEST13_DATA      SEGMENT
	ORG	$-1406
?dyno@@3UDYNO@@E	DW 086H DUP (?)
DMMTEST13_DATA      ENDS
_BSS      SEGMENT
	ORG	$+1
PUBLIC  ?gps_new_data@@3IE
?gps_new_data@@3IE	DW 01H DUP (?)
	ORG	$-3404
PUBLIC  ?old_dmm32a_vect@@3P7AXXZE
?old_dmm32a_vect@@3P7AXXZE	DW 02H DUP (?)
	ORG	$+3400
PUBLIC  ?gps_data_frame@@3KE
?gps_data_frame@@3KE	DW 02H DUP (?)
PUBLIC  ?gps_array@@3QEIE
?gps_array@@3QEIE	DW 04H DUP (?)
	ORG	$-3412
PUBLIC  ?old_dmm32b_vect@@3P7AXXZE
?old_dmm32b_vect@@3P7AXXZE	DW 02H DUP (?)
	ORG	$+3408
PUBLIC  ?gps_buffer@@3QEEE
?gps_buffer@@3QEEE	DW 028H DUP (?)
	ORG	$-3488
PUBLIC  ?rtc_vect@@3P7AXXZE
?rtc_vect@@3P7AXXZE	DW 02H DUP (?)
_BSS      ENDS
DMMTEST13_DATA      SEGMENT
	ORG	$+170
?ds@@3UDS@@E	DW 02eH DUP (?)
DMMTEST13_DATA      ENDS
_BSS      SEGMENT
PUBLIC  ?pcm@@3QEDE
?pcm@@3QEDE	DW 078H DUP (?)
PUBLIC  ?s@@3QEDE
?s@@3QEDE	DB 051H DUP (?)
	ORG	$+3163
PUBLIC  ?com1_tx@@3IE
?com1_tx@@3IE	DW 01H DUP (?)
	ORG	$-3164
PUBLIC  ?acoustic_message@@3QEDE
?acoustic_message@@3QEDE	DW 06H DUP (?)
	ORG	$+3152
PUBLIC  ?com2_tx@@3IE
?com2_tx@@3IE	DW 01H DUP (?)
_BSS      ENDS
DMMTEST_TEXT      SEGMENT
	ASSUME	CS: DMMTEST_TEXT
	PUBLIC	?PC_DispChar@@ZAXEEEE@Z	; PC_DispChar
?PC_DispChar@@ZAXEEEE@Z	PROC FAR	; PC_DispChar
;|*** /*
;|***  dmmtest.cpp
;|***  original 02/18/2004
;|***  updated  03/02/2007 for auto2 centerbody
;|***  modified 12/07/2007 enlarge char strings for ADCP PD0 messages
;|*** */
;|*** 
;|*** #include <bios.h>
;|*** #include <time.h>
;|*** #include <process.h>
;|*** #include <stdlib.h>
;|*** #include "dmmtest.h"
;|*** #include "esccauto.h"
;|*** #include "dmm32.h"
;|*** #include "rs232.h"
;|*** #include "uio48.h"
;|*** #include "ether.h"
;|*** #include "pc.c"
;|*** #include "commands.h"
;|*** #include <conio.h>
;|*** #include <stdio.h>
;|*** #include <iostream.h>
;|*** #include <dos.h>
;|*** #include <string.h>
;|*** extern "C"
;|*** {
;|***  //#include "c:\tech80\c\te5650.h"
;|***  #include "te5650.h"
;|*** }
;|*** 
;|*** struct SYS
;|***   {
;|***   unsigned int  packet_type;
;|***   unsigned int  packet_number;
;|***   unsigned long frame;
;|***   unsigned int  fs_status;
;|***   unsigned int  op_status;
;|***   unsigned long time_high;
;|***   unsigned int  time_low;
;|***   } sys;
;|***   
;|*** struct OBS
;|***   {
;|***   unsigned int  new_data;
;|***   long unsigned frame;
;|***   unsigned long time_high;
;|***   unsigned int  time_low;
;|***   unsigned int  data[32];
;|***   } obs;  
;|*** 
;|*** struct DYNO
;|***   {
;|***   unsigned int  new_data;
;|***   long unsigned frame;
;|***   unsigned long time_high;
;|***   unsigned int  time_low;
;|***   unsigned int  data[128];
;|***   } dyno;
;|***   
;|*** struct PROP
;|***   {
;|***   unsigned int  new_data;
;|***   long unsigned frame;
;|***   unsigned long rpm_time_high;
;|***   unsigned int  rpm_time_low;
;|***   unsigned long position_time_high;
;|***   unsigned int  position_time_low;
;|***   unsigned long adc_time_high;
;|***   unsigned int  adc_time_low;
;|***   int           rpm;
;|***   long int      position;
;|***   unsigned int  data[6];    
;|***   } prop;
;|***   
;|*** struct LN200
;|***   {
;|***   unsigned int  new_data;
;|***   long unsigned frame;
;|***   unsigned long time_high;
; Line 79
	*** 000000	c8 06 00 00 		enter	6,0
	*** 000004	57 			push	di
	*** 000005	56 			push	si
;	pscr = -4
;	offset = -6
;	color = 12
;	c = 10
;	y = 8
;	x = 6
;|***   unsigned int  time_low;
;|***   int  data[16];
;|***   } ln200;
;|*** 
;|*** struct COMMANDS
; Line 84
	*** 000006	b0 50 			mov	al,80	;0050H
	*** 000008	f6 66 08 		mul	BYTE PTR [bp+8]	;y
	*** 00000b	8a 4e 06 		mov	cl,BYTE PTR [bp+6]	;x
	*** 00000e	2a ed 			sub	ch,ch
	*** 000010	03 c1 			add	ax,cx
	*** 000012	d1 e0 			shl	ax,1
	*** 000014	89 46 fa 		mov	WORD PTR [bp-6],ax	;offset
;|***   {
; Line 85
	*** 000017	8b 46 fa 		mov	ax,WORD PTR [bp-6]	;offset
	*** 00001a	2b d2 			sub	dx,dx
	*** 00001c	2d 00 00 		sub	ax,0
	*** 00001f	81 da 00 48 		sbb	dx,18432	;4800H
	*** 000023	89 46 fc 		mov	WORD PTR [bp-4],ax	;pscr
	*** 000026	89 56 fe 		mov	WORD PTR [bp-2],dx
;|***   unsigned int  sync_word;
; Line 86
	*** 000029	8a 46 0a 		mov	al,BYTE PTR [bp+10]	;c
	*** 00002c	c4 5e fc 		les	bx,DWORD PTR [bp-4]	;pscr
	*** 00002f	ff 46 fc 		inc	WORD PTR [bp-4]	;pscr
	*** 000032	26 88 07 		mov	BYTE PTR es:[bx],al
;|***   unsigned int  mode;
; Line 87
	*** 000035	8a 46 0c 		mov	al,BYTE PTR [bp+12]	;color
	*** 000038	c4 5e fc 		les	bx,DWORD PTR [bp-4]	;pscr
	*** 00003b	26 88 07 		mov	BYTE PTR es:[bx],al
;|***   unsigned int  rpm;
; Line 88
	*** 00003e	e9 00 00 		jmp	$EX1505
					$EX1505:
	*** 000041	5e 			pop	si
	*** 000042	5f 			pop	di
	*** 000043	c9 			leave	
	*** 000044	cb 			ret	

?PC_DispChar@@ZAXEEEE@Z	ENDP
	PUBLIC	?PC_DispClrCol@@ZAXEE@Z	; PC_DispClrCol
?PC_DispClrCol@@ZAXEE@Z	PROC FAR	; PC_DispClrCol
;|***   unsigned int  rudder;
;|***   unsigned int  stern1;
;|***   unsigned int  stern2;
;|***   unsigned int  fore;  
;|***   unsigned int  ballast;
;|***   unsigned int  ln200_mode;
;|***   unsigned int  ln200_init_heading;
;|***   unsigned int  ln200_init_latitude;   
;|*** //  unsigned int  actuator5;
;|***   
;|***   unsigned int  adcp_reset;     // for future use
;|***   unsigned int  adcp_heading;
;|***   unsigned int  ds_send_message;
;|***   unsigned int  ds_dmgx;
;|***   unsigned int  ds_dmgy;
;|***   unsigned int  ds_dmgz;
;|***   unsigned int  spare1;
;|*** 
;|*** /*
;|***   unsigned int  ds_send_message;
;|***   unsigned int  ds_dmgx1;
;|***   unsigned int  ds_dmgx2;
; Line 110
	*** 000045	c8 06 00 00 		enter	6,0
	*** 000049	57 			push	di
	*** 00004a	56 			push	si
;	pscr = -4
;	i = -6
;	color = 8
;	x = 6
;|***   unsigned int  ds_dmgy1;
;|***   unsigned int  ds_dmgy2;
;|***   unsigned int  ds_dmgz1;
;|***   unsigned int  ds_dmgz2;
;|*** */
; Line 115
	*** 00004b	8a 46 06 		mov	al,BYTE PTR [bp+6]	;x
	*** 00004e	2a e4 			sub	ah,ah
	*** 000050	2b d2 			sub	dx,dx
	*** 000052	2d 00 00 		sub	ax,0
	*** 000055	81 da 00 24 		sbb	dx,9216	;2400H
	*** 000059	d1 e0 			shl	ax,1
	*** 00005b	d1 d2 			rcl	dx,1
	*** 00005d	89 46 fc 		mov	WORD PTR [bp-4],ax	;pscr
	*** 000060	89 56 fe 		mov	WORD PTR [bp-2],dx
;|***   } commands;  
; Line 116
	*** 000063	c6 46 fa 00 		mov	BYTE PTR [bp-6],0	;i
	*** 000067	e9 03 00 		jmp	$F1526
					$FC1527:
	*** 00006a	fe 46 fa 		inc	BYTE PTR [bp-6]	;i
					$F1526:
	*** 00006d	80 7e fa 19 		cmp	BYTE PTR [bp-6],25	;0019H	;i
	*** 000071	72 03 			jb	$JCC113
	*** 000073	e9 1b 00 		jmp	$FB1528
					$JCC113:
;|*** 
; Line 117
	*** 000076	c4 5e fc 		les	bx,DWORD PTR [bp-4]	;pscr
	*** 000079	ff 46 fc 		inc	WORD PTR [bp-4]	;pscr
	*** 00007c	26 c6 07 20 		mov	BYTE PTR es:[bx],32	;0020H
;|*** struct ECHO
; Line 118
	*** 000080	8a 46 08 		mov	al,BYTE PTR [bp+8]	;color
	*** 000083	c4 5e fc 		les	bx,DWORD PTR [bp-4]	;pscr
	*** 000086	26 88 07 		mov	BYTE PTR es:[bx],al
;|***   {
; Line 119
	*** 000089	81 46 fc a0 00 		add	WORD PTR [bp-4],160	;00a0H	;pscr
;|***   unsigned int  new_data;
; Line 120
	*** 00008e	e9 d9 ff 		jmp	$FC1527
					$FB1528:
;|***   unsigned long frame;
; Line 121
	*** 000091	e9 00 00 		jmp	$EX1517
					$EX1517:
	*** 000094	5e 			pop	si
	*** 000095	5f 			pop	di
	*** 000096	c9 			leave	
	*** 000097	cb 			ret	

?PC_DispClrCol@@ZAXEE@Z	ENDP
	PUBLIC	?PC_DispClrRow@@ZAXEE@Z	; PC_DispClrRow
?PC_DispClrRow@@ZAXEE@Z	PROC FAR	; PC_DispClrRow
;|***   unsigned long time_high;
;|***   unsigned int  time_low;
;|***   unsigned char data[sizeof(commands)];
;|***   } echo;
;|*** 
;|*** struct DS
;|***   {
;|***   unsigned int  new_data;
;|***   long unsigned frame;
;|***   unsigned long time_high;
;|***   unsigned int  time_low;
;|***   unsigned char  data[80];
;|***   } ds;
;|***   
;|*** struct ADCP
;|***   {
;|***   unsigned int  new_data;
;|***   long unsigned frame;
;|***   unsigned long time_high;
;|***   unsigned int  time_low;
;|***   //unsigned char  data[88];  //for PD? file format   
;|***   unsigned char  data[213];  //for PD0 file format 11/16/2007 db & jtm
; Line 143
	*** 000098	c8 06 00 00 		enter	6,0
	*** 00009c	57 			push	di
	*** 00009d	56 			push	si
;	pscr = -4
;	i = -6
;	color = 8
;	y = 6
;|***   } adcp;
;|*** 
;|*** struct GPS
;|***   {
;|***   unsigned int  new_data;
; Line 148
	*** 00009e	8a 46 06 		mov	al,BYTE PTR [bp+6]	;y
	*** 0000a1	2a e4 			sub	ah,ah
	*** 0000a3	b9 a0 00 		mov	cx,160	;00a0H
	*** 0000a6	f7 e1 			mul	cx
	*** 0000a8	2d 00 00 		sub	ax,0
	*** 0000ab	81 da 00 48 		sbb	dx,18432	;4800H
	*** 0000af	89 46 fc 		mov	WORD PTR [bp-4],ax	;pscr
	*** 0000b2	89 56 fe 		mov	WORD PTR [bp-2],dx
;|***   long unsigned frame;
; Line 149
	*** 0000b5	c6 46 fa 00 		mov	BYTE PTR [bp-6],0	;i
	*** 0000b9	e9 03 00 		jmp	$F1540
					$FC1541:
	*** 0000bc	fe 46 fa 		inc	BYTE PTR [bp-6]	;i
					$F1540:
	*** 0000bf	80 7e fa 50 		cmp	BYTE PTR [bp-6],80	;0050H	;i
	*** 0000c3	72 03 			jb	$JCC195
	*** 0000c5	e9 19 00 		jmp	$FB1542
					$JCC195:
;|***   unsigned long time_high;
; Line 150
	*** 0000c8	c4 5e fc 		les	bx,DWORD PTR [bp-4]	;pscr
	*** 0000cb	ff 46 fc 		inc	WORD PTR [bp-4]	;pscr
	*** 0000ce	26 c6 07 20 		mov	BYTE PTR es:[bx],32	;0020H
;|***   unsigned int  time_low;
; Line 151
	*** 0000d2	8a 46 08 		mov	al,BYTE PTR [bp+8]	;color
	*** 0000d5	c4 5e fc 		les	bx,DWORD PTR [bp-4]	;pscr
	*** 0000d8	ff 46 fc 		inc	WORD PTR [bp-4]	;pscr
	*** 0000db	26 88 07 		mov	BYTE PTR es:[bx],al
;|***   unsigned char  data[80];
; Line 152
	*** 0000de	e9 db ff 		jmp	$FC1541
					$FB1542:
;|***   } gps;
; Line 153
	*** 0000e1	e9 00 00 		jmp	$EX1531
					$EX1531:
	*** 0000e4	5e 			pop	si
	*** 0000e5	5f 			pop	di
	*** 0000e6	c9 			leave	
	*** 0000e7	cb 			ret	

?PC_DispClrRow@@ZAXEE@Z	ENDP
	PUBLIC	?PC_DispClrScr@@ZAXE@Z	; PC_DispClrScr
?PC_DispClrScr@@ZAXE@Z	PROC FAR	; PC_DispClrScr
;|***  
;|*** struct TIMER
;|***   {
;|***   unsigned long high;
;|***   unsigned int  low;
;|***   }     sys_timer,
;|***         frame_time,
;|***         obs_time,
;|***         dyno_time,
;|***         prop_rpm_time,
;|***         prop_position_time,
;|***         prop_position_time_previous,
;|***         prop_adc_time,        
;|***         ln200_time,
;|***         cmds_time,
;|***         ds_time,
;|***         adcp_time,
;|***         gps_time;
;|*** 
; Line 172
	*** 0000e8	c8 06 00 00 		enter	6,0
	*** 0000ec	57 			push	di
	*** 0000ed	56 			push	si
;	pscr = -4
;	i = -6
;	color = 6
;|*** struct escc_regs settings;
;|*** Cescc escc1;
;|*** 
;|*** void (interrupt far * old_dmm32a_vect)();
;|*** void (interrupt far * old_dmm32b_vect)();
; Line 177
	*** 0000ee	c7 46 fc 00 00 		mov	WORD PTR [bp-4],0	;pscr
	*** 0000f3	c7 46 fe 00 b8 		mov	WORD PTR [bp-2],-18432	;b800H
;|*** void (interrupt far * rtc_vect)();
; Line 178
	*** 0000f8	c7 46 fa 00 00 		mov	WORD PTR [bp-6],0	;i
	*** 0000fd	e9 03 00 		jmp	$F1552
					$FC1553:
	*** 000100	ff 46 fa 		inc	WORD PTR [bp-6]	;i
					$F1552:
	*** 000103	81 7e fa d0 07 		cmp	WORD PTR [bp-6],2000	;07d0H	;i
	*** 000108	72 03 			jb	$JCC264
	*** 00010a	e9 19 00 		jmp	$FB1554
					$JCC264:
;|*** 
; Line 179
	*** 00010d	c4 5e fc 		les	bx,DWORD PTR [bp-4]	;pscr
	*** 000110	ff 46 fc 		inc	WORD PTR [bp-4]	;pscr
	*** 000113	26 c6 07 20 		mov	BYTE PTR es:[bx],32	;0020H
;|*** //char          pcm[96];                    // pcm data string
; Line 180
	*** 000117	8a 46 06 		mov	al,BYTE PTR [bp+6]	;color
	*** 00011a	c4 5e fc 		les	bx,DWORD PTR [bp-4]	;pscr
	*** 00011d	ff 46 fc 		inc	WORD PTR [bp-4]	;pscr
	*** 000120	26 88 07 		mov	BYTE PTR es:[bx],al
;|*** char          pcm[240];                    // pcm data string
; Line 181
	*** 000123	e9 da ff 		jmp	$FC1553
					$FB1554:
;|*** unsigned      pcm_sent = 0;               // flag; pcm data was sent or not
; Line 182
	*** 000126	e9 00 00 		jmp	$EX1544
					$EX1544:
	*** 000129	5e 			pop	si
	*** 00012a	5f 			pop	di
	*** 00012b	c9 			leave	
	*** 00012c	cb 			ret	

?PC_DispClrScr@@ZAXE@Z	ENDP
	PUBLIC	?PC_DispStr@@ZAXEEPEEE@Z	; PC_DispStr
?PC_DispStr@@ZAXEEPEEE@Z	PROC FAR	; PC_DispStr
;|*** char          s[81];                      // for screen writes
;|*** 
;|*** char          acoustic_message[12];       // acoustic modem
;|*** int           send_message = 0;           // flag; valid acoustic message is ready to send
;|*** 
;|*** unsigned char obc_mac[6]       = {0x00, 0x01, 0x45, 0x00, 0x7a, 0x9c};
;|*** unsigned char control_mac[6]   = {0x00, 0x01, 0x45, 0x00, 0x8a, 0x21};
;|*** unsigned char broadcast_mac[6] = {0xff, 0xff, 0xff, 0xff, 0xff, 0xff};
;|*** unsigned char shore_mac[6]     = {0x00, 0x0e, 0xa6, 0xb6, 0xc0, 0x4e};
;|*** 
;|*** unsigned char far cmd_buffer[2008];       // command packet buffer
;|*** unsigned char data_pkt[1514];             // data packet buffer
;|*** 
;|*** long unsigned sys_frame  = 0;
;|*** unsigned int  sys_status = 0;
;|*** 
;|*** int           time_since_last_command = 0;
;|*** 
;|*** unsigned      channela, channelb;         // escc104 channels; a = LN200, b = pcm data stream
;|*** unsigned long frame, next_frame;          // frame counter, etc.
;|*** unsigned      reading_prop;               // flag; a/d's reading either prop or mux boxes
;|*** unsigned      mux_addr = 0;               // mux box channel addresses
;|*** 
;|*** unsigned      obs_new_data;
;|*** unsigned long obs_data_frame;
;|*** unsigned      obs_array[32];
;|*** unsigned char obs_buffer[64];
; Line 209
	*** 00012d	c8 06 00 00 		enter	6,0
	*** 000131	57 			push	di
	*** 000132	56 			push	si
;	pscr = -4
;	offset = -6
;	color = 14
;	s = 10
;	y = 8
;	x = 6
;|*** 
;|*** unsigned      dyno_new_data;
;|*** unsigned long dyno_data_frame;
;|*** unsigned      dyno_array[128];
;|*** unsigned char dyno_buffer[256];
; Line 214
	*** 000133	b0 50 			mov	al,80	;0050H
	*** 000135	f6 66 08 		mul	BYTE PTR [bp+8]	;y
	*** 000138	8a 4e 06 		mov	cl,BYTE PTR [bp+6]	;x
	*** 00013b	2a ed 			sub	ch,ch
	*** 00013d	03 c1 			add	ax,cx
	*** 00013f	d1 e0 			shl	ax,1
	*** 000141	89 46 fa 		mov	WORD PTR [bp-6],ax	;offset
;|*** 
; Line 215
	*** 000144	8b 46 fa 		mov	ax,WORD PTR [bp-6]	;offset
	*** 000147	2b d2 			sub	dx,dx
	*** 000149	2d 00 00 		sub	ax,0
	*** 00014c	81 da 00 48 		sbb	dx,18432	;4800H
	*** 000150	89 46 fc 		mov	WORD PTR [bp-4],ax	;pscr
	*** 000153	89 56 fe 		mov	WORD PTR [bp-2],dx
;|*** unsigned      prop_new_data;
; Line 216
					$FC1570:
	*** 000156	c4 5e 0a 		les	bx,DWORD PTR [bp+10]	;s
	*** 000159	26 80 3f 00 		cmp	BYTE PTR es:[bx],0
	*** 00015d	75 03 			jne	$JCC349
	*** 00015f	e9 21 00 		jmp	$FB1571
					$JCC349:
;|*** unsigned long prop_data_frame;
; Line 217
	*** 000162	c4 5e 0a 		les	bx,DWORD PTR [bp+10]	;s
	*** 000165	ff 46 0a 		inc	WORD PTR [bp+10]	;s
	*** 000168	26 8a 07 		mov	al,BYTE PTR es:[bx]
	*** 00016b	c4 5e fc 		les	bx,DWORD PTR [bp-4]	;pscr
	*** 00016e	ff 46 fc 		inc	WORD PTR [bp-4]	;pscr
	*** 000171	26 88 07 		mov	BYTE PTR es:[bx],al
;|*** int           prop_rpm;
; Line 218
	*** 000174	8a 46 0e 		mov	al,BYTE PTR [bp+14]	;color
	*** 000177	c4 5e fc 		les	bx,DWORD PTR [bp-4]	;pscr
	*** 00017a	ff 46 fc 		inc	WORD PTR [bp-4]	;pscr
	*** 00017d	26 88 07 		mov	BYTE PTR es:[bx],al
;|*** long int      prop_position = 0;
; Line 219
	*** 000180	e9 d3 ff 		jmp	$FC1570
					$FB1571:
;|*** long int      prop_report;
; Line 220
	*** 000183	e9 00 00 		jmp	$EX1559
					$EX1559:
	*** 000186	5e 			pop	si
	*** 000187	5f 			pop	di
	*** 000188	c9 			leave	
	*** 000189	cb 			ret	

?PC_DispStr@@ZAXEEPEEE@Z	ENDP

_aaj	PROC FAR
;|*** /*
;|***  dmmtest.cpp
;|***  original 02/18/2004
;|***  updated  03/02/2007 for auto2 centerbody
;|***  modified 12/07/2007 enlarge char strings for ADCP PD0 messages
;|*** */
;|*** 
;|*** #include <bios.h>
;|*** #include <time.h>
;|*** #include <process.h>
;|*** #include <stdlib.h>
;|*** #include "dmmtest.h"
;|*** #include "esccauto.h"
;|*** #include "dmm32.h"
;|*** #include "rs232.h"
;|*** #include "uio48.h"
;|*** #include "ether.h"
;|*** #include "pc.c"
;|*** #include "commands.h"
;|*** #include <conio.h>
;|*** #include <stdio.h>
;|*** #include <iostream.h>
;|*** #include <dos.h>
;|*** #include <string.h>
;|*** extern "C"
;|*** {
;|***  //#include "c:\tech80\c\te5650.h"
;|***  #include "te5650.h"
;|*** }
;|*** 
;|*** struct SYS
;|***   {
;|***   unsigned int  packet_type;
;|***   unsigned int  packet_number;
;|***   unsigned long frame;
;|***   unsigned int  fs_status;
;|***   unsigned int  op_status;
;|***   unsigned long time_high;
;|***   unsigned int  time_low;
;|***   } sys;
;|***   
;|*** struct OBS
;|***   {
;|***   unsigned int  new_data;
;|***   long unsigned frame;
;|***   unsigned long time_high;
;|***   unsigned int  time_low;
;|***   unsigned int  data[32];
;|***   } obs;  
;|*** 
;|*** struct DYNO
;|***   {
;|***   unsigned int  new_data;
;|***   long unsigned frame;
;|***   unsigned long time_high;
;|***   unsigned int  time_low;
;|***   unsigned int  data[128];
;|***   } dyno;
;|***   
;|*** struct PROP
;|***   {
;|***   unsigned int  new_data;
;|***   long unsigned frame;
;|***   unsigned long rpm_time_high;
;|***   unsigned int  rpm_time_low;
;|***   unsigned long position_time_high;
;|***   unsigned int  position_time_low;
;|***   unsigned long adc_time_high;
;|***   unsigned int  adc_time_low;
;|***   int           rpm;
;|***   long int      position;
;|***   unsigned int  data[6];    
;|***   } prop;
;|***   
;|*** struct LN200
;|***   {
;|***   unsigned int  new_data;
;|***   long unsigned frame;
;|***   unsigned long time_high;
;|***   unsigned int  time_low;
;|***   int  data[16];
;|***   } ln200;
;|*** 
;|*** struct COMMANDS
;|***   {
;|***   unsigned int  sync_word;
;|***   unsigned int  mode;
;|***   unsigned int  rpm;
;|***   unsigned int  rudder;
;|***   unsigned int  stern1;
;|***   unsigned int  stern2;
;|***   unsigned int  fore;  
;|***   unsigned int  ballast;
;|***   unsigned int  ln200_mode;
;|***   unsigned int  ln200_init_heading;
;|***   unsigned int  ln200_init_latitude;   
;|*** //  unsigned int  actuator5;
;|***   
;|***   unsigned int  adcp_reset;     // for future use
;|***   unsigned int  adcp_heading;
;|***   unsigned int  ds_send_message;
;|***   unsigned int  ds_dmgx;
;|***   unsigned int  ds_dmgy;
;|***   unsigned int  ds_dmgz;
;|***   unsigned int  spare1;
;|*** 
;|*** /*
;|***   unsigned int  ds_send_message;
;|***   unsigned int  ds_dmgx1;
;|***   unsigned int  ds_dmgx2;
;|***   unsigned int  ds_dmgy1;
;|***   unsigned int  ds_dmgy2;
;|***   unsigned int  ds_dmgz1;
;|***   unsigned int  ds_dmgz2;
;|*** */
;|***   } commands;  
;|*** 
;|*** struct ECHO
;|***   {
;|***   unsigned int  new_data;
;|***   unsigned long frame;
;|***   unsigned long time_high;
;|***   unsigned int  time_low;
;|***   unsigned char data[sizeof(commands)];
;|***   } echo;
;|*** 
;|*** struct DS
;|***   {
;|***   unsigned int  new_data;
;|***   long unsigned frame;
;|***   unsigned long time_high;
;|***   unsigned int  time_low;
;|***   unsigned char  data[80];
;|***   } ds;
;|***   
;|*** struct ADCP
;|***   {
;|***   unsigned int  new_data;
;|***   long unsigned frame;
;|***   unsigned long time_high;
;|***   unsigned int  time_low;
;|***   //unsigned char  data[88];  //for PD? file format   
;|***   unsigned char  data[213];  //for PD0 file format 11/16/2007 db & jtm
;|***   } adcp;
;|*** 
;|*** struct GPS
;|***   {
;|***   unsigned int  new_data;
;|***   long unsigned frame;
;|***   unsigned long time_high;
;|***   unsigned int  time_low;
;|***   unsigned char  data[80];
;|***   } gps;
;|***  
;|*** struct TIMER
;|***   {
;|***   unsigned long high;
;|***   unsigned int  low;
;|***   }     sys_timer,
;|***         frame_time,
;|***         obs_time,
;|***         dyno_time,
;|***         prop_rpm_time,
;|***         prop_position_time,
;|***         prop_position_time_previous,
;|***         prop_adc_time,        
;|***         ln200_time,
;|***         cmds_time,
;|***         ds_time,
;|***         adcp_time,
;|***         gps_time;
;|*** 
;|*** struct escc_regs settings;
;|*** Cescc escc1;
; Line 174
	*** 00018a	c8 00 00 00 		enter	0,0
	*** 00018e	57 			push	di
	*** 00018f	56 			push	si
	*** 000190	68 00 00 		push	SEG ?escc1@@3VCescc@@E	;escc1
	*** 000193	68 00 00 		push	OFFSET ?escc1@@3VCescc@@E	;escc1
	*** 000196	9a 00 00 00 00 		call	FAR PTR ??0Cescc@@REC@XZ	; Cescc::Cescc
	*** 00019b	e9 00 00 		jmp	$EX3572
					$EX3572:
	*** 00019e	5e 			pop	si
	*** 00019f	5f 			pop	di
	*** 0001a0	c9 			leave	
	*** 0001a1	cb 			ret	

_aaj	ENDP
	PUBLIC	_main
_main	PROC FAR
;|*** 
;|*** void (interrupt far * old_dmm32a_vect)();
;|*** void (interrupt far * old_dmm32b_vect)();
;|*** void (interrupt far * rtc_vect)();
;|*** 
;|*** //char          pcm[96];                    // pcm data string
;|*** char          pcm[240];                    // pcm data string
;|*** unsigned      pcm_sent = 0;               // flag; pcm data was sent or not
;|*** char          s[81];                      // for screen writes
;|*** 
;|*** char          acoustic_message[12];       // acoustic modem
;|*** int           send_message = 0;           // flag; valid acoustic message is ready to send
;|*** 
;|*** unsigned char obc_mac[6]       = {0x00, 0x01, 0x45, 0x00, 0x7a, 0x9c};
;|*** unsigned char control_mac[6]   = {0x00, 0x01, 0x45, 0x00, 0x8a, 0x21};
;|*** unsigned char broadcast_mac[6] = {0xff, 0xff, 0xff, 0xff, 0xff, 0xff};
;|*** unsigned char shore_mac[6]     = {0x00, 0x0e, 0xa6, 0xb6, 0xc0, 0x4e};
;|*** 
;|*** unsigned char far cmd_buffer[2008];       // command packet buffer
;|*** unsigned char data_pkt[1514];             // data packet buffer
;|*** 
;|*** long unsigned sys_frame  = 0;
;|*** unsigned int  sys_status = 0;
;|*** 
;|*** int           time_since_last_command = 0;
;|*** 
;|*** unsigned      channela, channelb;         // escc104 channels; a = LN200, b = pcm data stream
;|*** unsigned long frame, next_frame;          // frame counter, etc.
;|*** unsigned      reading_prop;               // flag; a/d's reading either prop or mux boxes
;|*** unsigned      mux_addr = 0;               // mux box channel addresses
;|*** 
;|*** unsigned      obs_new_data;
;|*** unsigned long obs_data_frame;
;|*** unsigned      obs_array[32];
;|*** unsigned char obs_buffer[64];
;|*** 
;|*** unsigned      dyno_new_data;
;|*** unsigned long dyno_data_frame;
;|*** unsigned      dyno_array[128];
;|*** unsigned char dyno_buffer[256];
;|*** 
;|*** unsigned      prop_new_data;
;|*** unsigned long prop_data_frame;
;|*** int           prop_rpm;
;|*** long int      prop_position = 0;
;|*** long int      prop_report;
;|*** long int      index_report;
;|*** long int      prop_index = 0;
;|*** long int      prop_position_absolute_current = 0;
;|*** long int      prop_position_absolute_previous = 0;
;|*** float         rpm_sf;
;|*** unsigned      prop_array[6];
;|*** unsigned char prop_buffer[12];
;|*** 
;|*** unsigned      ln200_new_data;
;|*** unsigned long ln200_data_frame;
;|*** unsigned char ln200_buffer[32];
;|*** char          ln200_command[14];
;|*** unsigned long ln200_rx_num = 0;
;|*** 
;|*** unsigned      echo_new_data;
;|*** unsigned long echo_data_frame;
;|*** unsigned      echo_array[8];
;|*** unsigned char echo_buffer[16];
;|*** 
;|*** unsigned      ds_new_data;
;|*** unsigned long ds_data_frame;
;|*** unsigned      ds_array[4];
;|*** unsigned char ds_buffer[80];
;|*** 
;|*** unsigned      adcp_new_data;
;|*** unsigned long adcp_data_frame;
;|*** //unsigned char adcp_array[88];
;|*** //unsigned char adcp_buffer[88];
;|*** //unsigned char adcp_test[88];
;|*** unsigned char adcp_array[213];  // for PD0 file format 11/16/2007 db & jtm
;|*** unsigned char adcp_buffer[213];
;|*** unsigned char adcp_test[213];
;|*** 
;|*** unsigned      gps_new_data;
;|*** unsigned long gps_data_frame;
;|*** unsigned      gps_array[4];
;|*** unsigned char gps_buffer[80];
;|*** 
;|*** unsigned      stern1_cmd = 0;
;|*** unsigned      stern2_cmd = 0;
;|*** unsigned      fore_cmd   = 0;
;|*** unsigned      rudder_cmd = 0;
;|*** unsigned      prop_cmd   = 0;
;|*** unsigned      com1_tx;
;|*** unsigned      com2_tx;
;|*** unsigned      com4_tx;
;|*** unsigned      data_ready = 0;
;|*** unsigned int  ip_id;
;|*** 
;|*** extern int           handle;              // packet driver and enet variables
;|*** extern unsigned long packets_rcvd;        // from other source modules
;|*** extern unsigned long ax0_counter;
;|*** extern unsigned long ax1_counter;
;|*** extern unsigned long discards;
;|*** extern unsigned long receiver_calls;
;|*** extern unsigned char pc1_addr[6];
;|*** extern unsigned char pc2_addr[6];
;|*** extern unsigned char pc3_addr[6];
;|*** extern unsigned char jim_pc[6];
;|*** extern unsigned char control_mac[6];
;|*** extern unsigned char broadcast_addr[6];
;|*** extern unsigned tx2_len;
;|*** extern unsigned tx2_counter;
;|*** extern unsigned tx2_index;
;|*** 
;|*** void main(void)
;|***   {
; Line 287
	*** 0001a2	c8 00 00 00 		enter	0,0
	*** 0001a6	57 			push	di
	*** 0001a7	56 			push	si
;|***   configure_obc();
; Line 288
	*** 0001a8	9a 00 00 00 00 		call	FAR PTR ?configure_obc@@ZAXXZ	; configure_obc
;|***   wait_for_time_tick();
; Line 289
	*** 0001ad	9a 00 00 00 00 		call	FAR PTR ?wait_for_time_tick@@ZAXXZ	; wait_for_time_tick
;|***   while(1)
; Line 290
					$FC3669:
;|***     {
; Line 291
;|***     get_frame_time();
; Line 292
	*** 0001b2	9a 00 00 00 00 		call	FAR PTR ?get_frame_time@@ZAXXZ	; get_frame_time
;|***     send_data_packet();
; Line 293
	*** 0001b7	9a 00 00 00 00 		call	FAR PTR ?send_data_packet@@ZAXXZ	; send_data_packet
;|***     start_data_collection();    
; Line 294
	*** 0001bc	9a 00 00 00 00 		call	FAR PTR ?start_data_collection@@ZAXXZ	; start_data_collection
;|***     apply_commands();
; Line 295
	*** 0001c1	9a 00 00 00 00 		call	FAR PTR ?apply_commands@@ZAXXZ	; apply_commands
;|***     heartbeat();
; Line 296
	*** 0001c6	9a 00 00 00 00 		call	FAR PTR ?heartbeat@@ZAXXZ	; heartbeat
;|***     send_acoustic_message();
; Line 297
	*** 0001cb	9a 00 00 00 00 		call	FAR PTR ?send_acoustic_message@@ZAXXZ	; send_acoustic_message
;|***     wait_for_time_tick();
; Line 298
	*** 0001d0	9a 00 00 00 00 		call	FAR PTR ?wait_for_time_tick@@ZAXXZ	; wait_for_time_tick
;|***     if(_kbhit()) break;
; Line 299
	*** 0001d5	9a 00 00 00 00 		call	FAR PTR __kbhit
	*** 0001da	3d 00 00 		cmp	ax,0
	*** 0001dd	75 03 			jne	$JCC477
	*** 0001df	e9 03 00 		jmp	$I3671
					$JCC477:
	*** 0001e2	e9 03 00 		jmp	$FB3670
;|***     }
; Line 300
					$I3671:
	*** 0001e5	e9 ca ff 		jmp	$FC3669
					$FB3670:
;|***   terminate();
; Line 301
	*** 0001e8	9a 00 00 00 00 		call	FAR PTR ?terminate@@ZAXXZ	; terminate
;|***   exit(0);
; Line 302
	*** 0001ed	6a 00 			push	0
	*** 0001ef	9a 00 00 00 00 		call	FAR PTR _exit
	*** 0001f4	83 c4 02 		add	sp,2
;|***   }
; Line 303
	*** 0001f7	e9 00 00 		jmp	$EX3667
					$EX3667:
	*** 0001fa	5e 			pop	si
	*** 0001fb	5f 			pop	di
	*** 0001fc	c9 			leave	
	*** 0001fd	cb 			ret	

_main	ENDP
	PUBLIC	?send_acoustic_message@@ZAXXZ	; send_acoustic_message
?send_acoustic_message@@ZAXXZ	PROC FAR	; send_acoustic_message
;|*** 
;|*** 
;|*** void send_acoustic_message(void)
;|***   {
; Line 307
	*** 0001fe	c8 02 00 00 		enter	2,0
	*** 000202	57 			push	di
	*** 000203	56 			push	si
;|***   if(send_message != 0)
; Line 308
	*** 000204	83 3e 00 00 00 		cmp	WORD PTR ?send_message@@3HE,0	;send_message
	*** 000209	75 03 			jne	$JCC521
	*** 00020b	e9 43 00 		jmp	$I3674
					$JCC521:
;|***     {
; Line 309
;|***     send_message = 0;
; Line 310
	*** 00020e	c7 06 00 00 00 00 	mov	WORD PTR ?send_message@@3HE,0	;send_message
;|***     if(_inp(COM2_LSR) & TXB_EMPTY)                   // if com2 tx is idle
; Line 311
	*** 000214	68 fd 02 		push	765	;02fdH
	*** 000217	9a 00 00 00 00 		call	FAR PTR __inp
	*** 00021c	83 c4 02 		add	sp,2
	*** 00021f	a8 60 			test	al,96	;0060H
	*** 000221	75 03 			jne	$JCC545
	*** 000223	e9 2b 00 		jmp	$I3675
					$JCC545:
;|***       {                                              // send the message
; Line 312
;	i = -2
;|***       for(int i=0; i<sizeof(acoustic_message); i++)  
; Line 313
	*** 000226	c7 46 fe 00 00 		mov	WORD PTR [bp-2],0	;i
	*** 00022b	e9 03 00 		jmp	$F3677
					$FC3678:
	*** 00022e	ff 46 fe 		inc	WORD PTR [bp-2]	;i
					$F3677:
	*** 000231	83 7e fe 0c 		cmp	WORD PTR [bp-2],12	;000cH	;i
	*** 000235	72 03 			jb	$JCC565
	*** 000237	e9 17 00 		jmp	$FB3679
					$JCC565:
;|***         {
; Line 314
;|***         _outp(COM2_TX, acoustic_message[i]);
; Line 315
	*** 00023a	8b 5e fe 		mov	bx,WORD PTR [bp-2]	;i
	*** 00023d	8a 87 00 00 		mov	al,BYTE PTR ?acoustic_message@@3QEDE[bx]	;acoustic_message
	*** 000241	98 			cbw	
	*** 000242	50 			push	ax
	*** 000243	68 f8 02 		push	760	;02f8H
	*** 000246	9a 00 00 00 00 		call	FAR PTR __outp
	*** 00024b	83 c4 04 		add	sp,4
;|***         }
; Line 316
	*** 00024e	e9 dd ff 		jmp	$FC3678
					$FB3679:
;|***       }
; Line 317
;|***     }    
; Line 318
					$I3675:
;|***   }
; Line 319
					$I3674:
	*** 000251	e9 00 00 		jmp	$EX3673
					$EX3673:
	*** 000254	5e 			pop	si
	*** 000255	5f 			pop	di
	*** 000256	c9 			leave	
	*** 000257	cb 			ret	

?send_acoustic_message@@ZAXXZ	ENDP
	PUBLIC	?send_pcm@@ZAXXZ	; send_pcm
?send_pcm@@ZAXXZ	PROC FAR	; send_pcm
;|*** 
;|*** 
;|*** void send_pcm(void)
;|***   {
; Line 323
	*** 000258	c8 00 00 00 		enter	0,0
	*** 00025c	57 			push	di
	*** 00025d	56 			push	si
;|***   if(escc1.istxing[channelb]==0)
; Line 324
DMMTEST_TEXT      ENDS
CONST      SEGMENT
$T4071	DW SEG ?escc1@@3VCescc@@E 
CONST      ENDS
DMMTEST_TEXT      SEGMENT
	ASSUME	CS: DMMTEST_TEXT
	*** 00025e	8e 06 00 00 		mov	es,WORD PTR $T4071
	*** 000262	8b 1e 00 00 		mov	bx,WORD PTR ?channelb@@3IE	;channelb
	*** 000266	d1 e3 			shl	bx,1
	*** 000268	26 83 bf 92 01 00 	cmp	WORD PTR es:?escc1@@3VCescc@@E[bx+402],0	;escc1
	*** 00026e	74 03 			je	$JCC622
	*** 000270	e9 1b 00 		jmp	$I3682
					$JCC622:
;|***     {
; Line 325
;|***     pack_pcm();
; Line 326
	*** 000273	9a 00 00 00 00 		call	FAR PTR ?pack_pcm@@ZAXXZ	; pack_pcm
;|***     //escc1.tx_port(channelb, pcm, 96);
;|***     escc1.tx_port(channelb, pcm,240);
; Line 328
	*** 000278	ff 36 00 00 		push	WORD PTR ?channelb@@3IE	;channelb
	*** 00027c	1e 			push	ds
	*** 00027d	68 00 00 		push	OFFSET DGROUP:?pcm@@3QEDE	;pcm
	*** 000280	68 f0 00 		push	240	;00f0H
	*** 000283	68 00 00 		push	SEG ?escc1@@3VCescc@@E	;escc1
	*** 000286	68 00 00 		push	OFFSET ?escc1@@3VCescc@@E	;escc1
	*** 000289	9a 00 00 00 00 		call	FAR PTR ?tx_port@Cescc@@RECIIPEDI@Z	; Cescc::tx_port
;|***     }
; Line 329
;|***   }
; Line 330
					$I3682:
	*** 00028e	e9 00 00 		jmp	$EX3681
					$EX3681:
	*** 000291	5e 			pop	si
	*** 000292	5f 			pop	di
	*** 000293	c9 			leave	
	*** 000294	cb 			ret	

?send_pcm@@ZAXXZ	ENDP
	PUBLIC	?pack_pcm@@ZAXXZ	; pack_pcm
?pack_pcm@@ZAXXZ	PROC FAR	; pack_pcm
;|***   
;|*** 
;|*** 
;|*** void pack_pcm(void)  // new decom
;|***   {
; Line 335
	*** 000295	c8 f0 00 00 		enter	240,0
	*** 000299	57 			push	di
	*** 00029a	56 			push	si
;	data = -240
;|***     
;|***   // Prepare pcm data to be sent up the telemetry link in biphase-m (76.8 KHz)
;|***   // The telemetry frame is 120 16-bit words x 12.
;|***   //
;|***   // All ln200 and a/d data was first collected and stored in separate structures
;|***   // in a total of 48 16-bit words.  For pcm transmission, the data must be:
;|***   // 1) scaled, converted to offset-binary and placed in proper channel slots
;|***   // 2) shifted down from 16-bit to 12-bit (shift and mask) (keep high byte 0000 hex
;|***   // 3) converted from from lsb first to msb first for the bit synchronizer
;|***   // 4) repacked for the escc from 64 12-bit words to 96 8-bit bytes (shift and mask) for the escc 
;|***   
;|***   unsigned data[120];
;|***   //unsigned i = 0;
;|*** /*  
;|***     // first scale the numbers, add the offset, place in slots
;|***   data2[0] = 0x0faf;         // decom sync 1
;|***   data2[1] = 0x0321;         // decom sync 2
;|***   data2[2] = 5 << 1;         // CB ID, 5 << 1
;|***   data2[7] = (sys.frame >> 4) & 0x0ffe; // most significant 11 bits of 16 bit frame counter
;|***   data2[8] = (sys.frame << 7) & 0x0f80; // least sig 5 bits of 16 bit frame counter, LEFT ADJUSTED
;|*** 
;|***   //  "R"
;|***   data2[10] = ((long)ln200.data[5] * 2)    + d_offset;       // z axis angular rate low
;|***   data2[9]  = (data2[10] >> 12) * 2 + d_offset;  // high
;|***   
;|***   //  "Q"
;|***   data2[12] = ((long)ln200.data[3] * 2)    + d_offset;       // y axis angular rate low
;|***   data2[11] = (data2[12] >> 12) * 2 + d_offset;  // high
;|***     
;|***   // "P"
;|***   data2[14] = ((long)ln200.data[4] * 2)    + d_offset;       // x axis angular rate low
;|***   data2[13] = (data2[14] >> 12) * 2 + d_offset;  // high
;|***     
;|***   
;|***   //new 2/10/2005
;|***   //data2[16] = ((long)ln200.data[2] * 2)    + d_offset;       // x axis linear accel low
;|***   //data2[15] = (data2[16] >> 12) * 2 + d_offset;  // high
;|*** 
;|***   //new 2/10/2005
;|***   //data2[18] = ((long)ln200.data[1] * 2)    + d_offset;       // y axis linear accel low
;|***   //data2[17] = (data2[18] >> 12) * 2 + d_offset;  // high
;|*** 
;|***   // compensate LN200 Z accel reading for standard gravity: (32.17405 / 2^-6 counts )
;|***   //new 2/10/2005
;|***   //data2[20] = (((long)ln200.data[0] + ((long)(32.17405 * 64))) * 2)    + d_offset;       // z axis linear accel
;|***   //data2[19] =  (data2[20] >> 12) * 2 + d_offset;
;|*** 
;|***   data2[15] = 0;
;|***   data2[16] = 0;
;|***   data2[17] = 0;
;|***   data2[18] = 0;
;|***   data2[19] = 0;
;|***   data2[20] = 0;
;|*** 
;|***   data2[21] = 0;
;|***   data2[22] = 0;
;|***   data2[23] = 0;
;|***   data2[24] = 0;
;|***   data2[25] = 0;
;|***   data2[26] = 0;
;|***     
;|***  //  ln200 single channel scale factors
;|***  //  convert 16-bit LN200 native data to 12-bit pcm data
;|***  //  to provide desired full-scale range for each channel
;|***  //  scale factor = ln200 lsb value * 2^12 counts / desired full-scale range EUs
;|***  
;|***     // roll_accel (Pdot), ln200 lsb = 2^-4 deg/sec^2
;|***   //data2[27] = data[7];
;|***     // limit roll_accel to 12-bits and max +- 128 deg/sec^2 range
;|***   //if(data2[27] >  2047) data2[27] =  2047;
;|***   //if(data2[27] < -2048) data2[27] = -2048;
;|***   //data2[27] = data2[27] + s_offset;
;|***   //new 2/10/2005
;|***   //data2[27] = ln200.data[7];
;|***     // limit roll_accel to 12-bits and max +- 128 deg/sec^2 range
;|***   //if(data2[27] >  2047) data2[27] =  2047;
;|***   //if(data2[27] < -2048) data2[27] = -2048;
;|***   //data2[27] = data2[27] + s_offset;
;|***     
;|***     // pitch_accel (Qdot), lsb = 2^-6 deg/sec^2/count, range = +-70 deg/sec^2    
;|*** //  data2[28] = int(data[6]  * 0.457142857) + s_offset; // pitch_FAST_ACCEL
;|***   //data2[28] = data[6];
;|***   // limit pitch_accel to 12-bits and max +- 128 deg/sec^2 range  
;|***   //if(data2[28] >  8191) data2[28] =  8191;
;|***   //if(data2[28] < -8192) data2[28] = -8192;
;|***   //data2[28] = (data2[28] >> 2) + s_offset;
;|***   //new 2/10/2005
;|***   //data2[28] = (long)ln200.data[6];
;|***   // limit pitch_accel to 12-bits and max +- 128 deg/sec^2 range  
;|***   //if(data2[28] >  8191) data2[28] =  8191;
;|***   //if(data2[28] < -8192) data2[28] = -8192;
;|***   //data2[28] = (data2[28] >> 2) + s_offset;
;|*** 
;|***     // yaw_accel (Rdot), lsb = 2^-7 deg/sec^2/count, range = +-70 deg/sec^2    
;|***   //data2[29] = int(data[8]  * 0.228571429) + s_offset; // yaw_FAST_ACCEL
;|***   //data2[29] = data[8];
;|***   // limit yaw_accel to 12-bits and max +- 128 deg/sec^2 range  
;|***   //if(data2[29] >  16383) data2[29] =  16383;
;|***   //if(data2[29] < -16384) data2[29] = -16384;
;|***   //data2[29] = (data2[29] >> 3) + s_offset;
;|***   //new 2/10/2005
;|***   //data2[29] = (long)ln200.data[8];
;|***   // limit yaw_accel to 12-bits and max +- 128 deg/sec^2 range  
;|***   //if(data2[29] >  16383) data2[29] =  16383;
;|***   //if(data2[29] < -16384) data2[29] = -16384;
;|***   //data2[29] = (data2[29] >> 3) + s_offset;
;|***   
;|***   data2[26] = 0;
;|***   data2[27] = 0;
;|***   data2[28] = 0;
;|***   data2[29] = 0;
;|***   
;|***     // scale 16-bit data to 12-bit by dividing by 2^4
;|***   data2[30] = ((long)obs.data[21] >> 4)      + s_offset; // prop_cmd
;|***   data2[31] = ((long)obs.data[25] >> 4)      + s_offset; // fwd_cmd
;|***   data2[32] = ((long)obs.data[22] >> 4)      + s_offset; // strn_cmd
;|***   data2[33] = ((long)obs.data[24] >> 4)      + s_offset; // rudd_cmd
;|***   data2[34] = ((long)obs.data[28] >> 4)      + s_offset; // failsafe
;|***   data2[35] = ((long)obs.data[26] >> 4)      + s_offset; // cage/mode
;|***   data2[36] = ((long)obs.data[16] >> 4)      + s_offset; // e_bat
;|***   
;|***     // yaw, ln200 lsb = (2^-15) * 180 deg/count, range = +-180 deg    
;|***   data2[37] = ((long)ln200.data[11] >> 4)      + s_offset; // yaw180  
;|*** 
;|***     // yaw_exp, lsb = (2^-15) * 180 deg/count, range = +-45 deg      
;|***   data2[38] = 0;
;|***   
;|***     // pitch_exp, ln200 lsb = (2^-15) * 180 deg/count, range = +-22.5 deg      
;|***   data2[39] = 0;
;|***   
;|***     // roll, ln200 lsb = (2^-15) * 180 deg/count, range = +-180 deg      
;|***   data2[40] = ((long)ln200.data[10] >> 3) + s_offset; // roll  
;|*** 
;|***     // roll_rate_exp, lsb = 2^-6 deg/sec/count, range = +-14 deg/sec  
;|***     // deleted 2/21/2002 jtm    
;|***   
;|***     // pitch_rate_exp, lsb = 2^-8 deg/sec/count, range = +-14 deg/sec    
;|***     // deleted 2/21/2002 jtm    
;|***   
;|***   // new depth gauges 2/17/2005 jtm
;|***   data2[41] = ((long)obs.data[0] >> 4) + s_offset; // depth 1
;|***   data2[42] = ((long)obs.data[1] >> 4) + s_offset; // depth 2
;|***   data2[43] = ((long)obs.data[2] >> 4) + s_offset; // depth 3
;|***   
;|***   // new status bits
;|***   data2[44] = sys.fs_status & 0x0fff;
;|***   data2[45] = commands.mode  & 0x0fff;
;|*** 
;|***     // yaw_rate_exp, lsb = 2^-9 deg/sec/count, range = +-14 deg/sec  
;|***     // deleted 2/21/2002 jtm
;|***   
;|***     // x_accel_exp, lsb = (2^-6) ft/sec^2/count, range = +-17 ft/sec^2      
;|***     // deleted 2/21/2002 jtm    
;|***     
;|***     // y_accel_exp, lsb = (2^-6) ft/sec^2/count, range = +-17 ft/sec^2        
;|***     // deleted 2/21/2002 jtm    
;|***   
;|***     // z_accel_exp, lsb = (2^-6) ft/sec^2/count, range = +-17 ft/sec^2
;|***     // NOTE:  LN200 reading is compensated for standard gravity: (32.17405 / 2^-6 counts)
;|***     // deleted 2/21/2002 jtm    
;|***   data2[46] = 0;
;|***   
;|***     // Pdot_exp, lsb = 2^-4 deg/sec^2, range = +-17 deg/sec^2
;|***     // deleted 2/21/2002 jtm    
;|***   data2[47] = 0;
;|*** 
;|***   status_word = 0;
;|***   data2[48] = status_word;                          
;|*** 
;|***     // Qdot_exp, lsb = (2^-6) ft/sec^2/count, range = +-17 ft/sec^2                                
;|***     // deleted 2/21/2002 jtm    
;|***   data2[49] = 0;
;|***   
;|***     // Rdot_exp, lsb = (2^-7) ft/sec^2/count, range = +-17 ft/sec^2        
;|***     // deleted 2/21/2002 jtm    
;|***   data2[50] = 0;
;|***     
;|***     //fore plane lvdt
;|***   data2[52] = (long)obs.data[7];
;|***   data2[52] = (data2[52] >> 4) + s_offset;
;|*** 
;|***     //rudder lvdt
;|***   data2[53] = obs.data[6];
;|***   data2[53] = (data2[53] >> 4) + s_offset;
;|*** 
;|***     //stern lvdt
;|***   data2[54] = obs.data[4];  
;|***   data2[54] = (data2[54] >> 4) + s_offset;
;|***   
;|***     // stern tips lvdt
;|***   data2[55] = obs.data[5];
;|***   data2[55] = (data2[55] >> 4) + s_offset;
;|*** 
;|***   
;|***    // prop_voltage, sc1 ch3, mm32 adc ch3; mc output is +- 5V, 40V/V; module is +-10V
;|***    // NOTE:  data is shifted by 3 instead of 4 because 5B module has
;|***    // +/-10 volt input instead of +/- 5 volt input.  ??????????
;|***   //new 2/10/2005
;|***   data2[56] = ((long)obs.data[18] >> 4) + s_offset;  
;|***   //data2[56] = 0;
;|***   
;|***    // prop_current, sc1 ch2, mm32 adc ch2; mc output is +- 5V, 20V/V; module is +-10V
;|***    // NOTE:  data is shifted by 3 instead of 4 because 5B module has
;|***    // +/-10 volt input instead of +/- 5 volt input.  
;|***   //new 2/10/2005
;|***   data2[57] = ((long)obs.data[19] >> 4) + s_offset;
;|***   //data2[57] = 0;
;|*** 
;|***     // pitch, lsb = (2^-15) * 180 deg/count, range = +-90 deg        
;|***   data2[58] = ((long)ln200.data[9] >> 2) + s_offset; // pitch
;|*** 
;|***     // paddle_wheel, module is 500Hz 0-5Volt
;|***   data2[59] = obs.data[3];
;|***   if(data2[59] < 0) data2[59] = 0;    
;|***   data2[59] = (data2[59] >> 4) + s_offset;
;|*** 
;|***     // rpm, 2540 or 5000 pulse/rev, module is 100KHz 0-5Volt
;|***   data2[60] = obs.data[20];
;|***   if(data2[60] < 0) data2[60] = 0;  
;|***   data2[60] = (data2[60] >> 4) + s_offset;  
;|***   
;|*** */    
;|***   
;|***   data[0]  = 0x7e7e;        // sync word
; Line 559
	*** 00029b	c7 86 10 ff 7e 7e 	mov	WORD PTR [bp-240],32382	;7e7eH	;data
;|***   data[1]  = sys.fs_status;
; Line 560
	*** 0002a1	8e 06 00 00 		mov	es,WORD PTR $T4071
	*** 0002a5	26 a1 08 00 		mov	ax,WORD PTR es:?sys@@3USYS@@E+8	;sys
	*** 0002a9	89 86 12 ff 		mov	WORD PTR [bp-238],ax
;|***   //data[1]  = 0xa5a5;
;|***   data[2]  = sys.op_status;
; Line 562
	*** 0002ad	26 a1 0a 00 		mov	ax,WORD PTR es:?sys@@3USYS@@E+10	;sys
	*** 0002b1	89 86 14 ff 		mov	WORD PTR [bp-236],ax
;|***   data[3]  = obs.data[0];  // depth 1
; Line 563
	*** 0002b5	8e 06 00 00 		mov	es,WORD PTR $T4071
	*** 0002b9	26 a1 0c 00 		mov	ax,WORD PTR es:?obs@@3UOBS@@E+12	;obs
	*** 0002bd	89 86 16 ff 		mov	WORD PTR [bp-234],ax
;|***   data[4]  = obs.data[1];  // depth 2
; Line 564
	*** 0002c1	26 a1 0e 00 		mov	ax,WORD PTR es:?obs@@3UOBS@@E+14	;obs
	*** 0002c5	89 86 18 ff 		mov	WORD PTR [bp-232],ax
;|***   data[5]  = obs.data[2];  // depth 3
; Line 565
	*** 0002c9	26 a1 10 00 		mov	ax,WORD PTR es:?obs@@3UOBS@@E+16	;obs
	*** 0002cd	89 86 1a ff 		mov	WORD PTR [bp-230],ax
;|***   data[6]  = obs.data[3];  // paddle wheel
; Line 566
	*** 0002d1	26 a1 12 00 		mov	ax,WORD PTR es:?obs@@3UOBS@@E+18	;obs
	*** 0002d5	89 86 1c ff 		mov	WORD PTR [bp-228],ax
;|***   data[7]  = obs.data[4];  // stern1 lvdt
; Line 567
	*** 0002d9	26 a1 14 00 		mov	ax,WORD PTR es:?obs@@3UOBS@@E+20	;obs
	*** 0002dd	89 86 1e ff 		mov	WORD PTR [bp-226],ax
;|***   data[8]  = obs.data[5];  // stern2 lvdt
; Line 568
	*** 0002e1	26 a1 16 00 		mov	ax,WORD PTR es:?obs@@3UOBS@@E+22	;obs
	*** 0002e5	89 86 20 ff 		mov	WORD PTR [bp-224],ax
;|***   data[9]  = obs.data[6];  // rudder lvdt
; Line 569
	*** 0002e9	26 a1 18 00 		mov	ax,WORD PTR es:?obs@@3UOBS@@E+24	;obs
	*** 0002ed	89 86 22 ff 		mov	WORD PTR [bp-222],ax
;|***   data[10] = obs.data[7];  // fore lvdt
; Line 570
	*** 0002f1	26 a1 1a 00 		mov	ax,WORD PTR es:?obs@@3UOBS@@E+26	;obs
	*** 0002f5	89 86 24 ff 		mov	WORD PTR [bp-220],ax
;|***   data[11] = obs.data[8];  // spare lvdt
; Line 571
	*** 0002f9	26 a1 1c 00 		mov	ax,WORD PTR es:?obs@@3UOBS@@E+28	;obs
	*** 0002fd	89 86 26 ff 		mov	WORD PTR [bp-218],ax
;|***   data[12] = obs.data[16];  // ebat volts
; Line 572
	*** 000301	26 a1 2c 00 		mov	ax,WORD PTR es:?obs@@3UOBS@@E+44	;obs
	*** 000305	89 86 28 ff 		mov	WORD PTR [bp-216],ax
;|***   data[13] = obs.data[17];  // pbat volts
; Line 573
	*** 000309	26 a1 2e 00 		mov	ax,WORD PTR es:?obs@@3UOBS@@E+46	;obs
	*** 00030d	89 86 2a ff 		mov	WORD PTR [bp-214],ax
;|***   data[14] = obs.data[18];  // prop volts
; Line 574
	*** 000311	26 a1 30 00 		mov	ax,WORD PTR es:?obs@@3UOBS@@E+48	;obs
	*** 000315	89 86 2c ff 		mov	WORD PTR [bp-212],ax
;|***   data[15] = obs.data[19];  // prop amps
; Line 575
	*** 000319	26 a1 32 00 		mov	ax,WORD PTR es:?obs@@3UOBS@@E+50	;obs
	*** 00031d	89 86 2e ff 		mov	WORD PTR [bp-210],ax
;|***   data[16] = obs.data[20];  // 5B module rpm (unsigned)
; Line 576
	*** 000321	26 a1 34 00 		mov	ax,WORD PTR es:?obs@@3UOBS@@E+52	;obs
	*** 000325	89 86 30 ff 		mov	WORD PTR [bp-208],ax
;|***   data[17] = obs.data[21];  // prop discriminator
; Line 577
	*** 000329	26 a1 36 00 		mov	ax,WORD PTR es:?obs@@3UOBS@@E+54	;obs
	*** 00032d	89 86 32 ff 		mov	WORD PTR [bp-206],ax
;|***   data[18] = obs.data[22];   // stern1 discriminator
; Line 578
	*** 000331	26 a1 38 00 		mov	ax,WORD PTR es:?obs@@3UOBS@@E+56	;obs
	*** 000335	89 86 34 ff 		mov	WORD PTR [bp-204],ax
;|***   data[19] = obs.data[23];   // stern2 discriminator
; Line 579
	*** 000339	26 a1 3a 00 		mov	ax,WORD PTR es:?obs@@3UOBS@@E+58	;obs
	*** 00033d	89 86 36 ff 		mov	WORD PTR [bp-202],ax
;|***   data[20] = obs.data[24];   // rudder discriminator
; Line 580
	*** 000341	26 a1 3c 00 		mov	ax,WORD PTR es:?obs@@3UOBS@@E+60	;obs
	*** 000345	89 86 38 ff 		mov	WORD PTR [bp-200],ax
;|***   data[21] = obs.data[25];   // fore discriminator
; Line 581
	*** 000349	26 a1 3e 00 		mov	ax,WORD PTR es:?obs@@3UOBS@@E+62	;obs
	*** 00034d	89 86 3a ff 		mov	WORD PTR [bp-198],ax
;|***   data[22] = obs.data[26];   // mode discriminator
; Line 582
	*** 000351	26 a1 40 00 		mov	ax,WORD PTR es:?obs@@3UOBS@@E+64	;obs
	*** 000355	89 86 3c ff 		mov	WORD PTR [bp-196],ax
;|***   data[23] = obs.data[27];   // ballast discriminator
; Line 583
	*** 000359	26 a1 42 00 		mov	ax,WORD PTR es:?obs@@3UOBS@@E+66	;obs
	*** 00035d	89 86 3e ff 		mov	WORD PTR [bp-194],ax
;|***   data[24] = obs.data[28];   // failsafe discriminator
; Line 584
	*** 000361	26 a1 44 00 		mov	ax,WORD PTR es:?obs@@3UOBS@@E+68	;obs
	*** 000365	89 86 40 ff 		mov	WORD PTR [bp-192],ax
;|***   data[25] = obs.data[29];   // radio mode discriminator
; Line 585
	*** 000369	26 a1 46 00 		mov	ax,WORD PTR es:?obs@@3UOBS@@E+70	;obs
	*** 00036d	89 86 42 ff 		mov	WORD PTR [bp-190],ax
;|***   data[26] = obs.data[30];   // key discriminator
; Line 586
	*** 000371	26 a1 48 00 		mov	ax,WORD PTR es:?obs@@3UOBS@@E+72	;obs
	*** 000375	89 86 44 ff 		mov	WORD PTR [bp-188],ax
;|***   data[27] = prop.rpm;
; Line 587
	*** 000379	8e 06 00 00 		mov	es,WORD PTR $T4071
	*** 00037d	26 a1 18 00 		mov	ax,WORD PTR es:?prop@@3UPROP@@E+24	;prop
	*** 000381	89 86 46 ff 		mov	WORD PTR [bp-186],ax
;|***   data[28] = (int)prop.position;           
; Line 588
	*** 000385	26 a1 1a 00 		mov	ax,WORD PTR es:?prop@@3UPROP@@E+26	;prop
	*** 000389	89 86 48 ff 		mov	WORD PTR [bp-184],ax
;|***   data[29] = ln200.data[0];  // z linear accel 
; Line 589
	*** 00038d	8e 06 00 00 		mov	es,WORD PTR $T4071
	*** 000391	26 a1 0c 00 		mov	ax,WORD PTR es:?ln200@@3ULN200@@E+12	;ln200
	*** 000395	89 86 4a ff 		mov	WORD PTR [bp-182],ax
;|***   data[30] = ln200.data[1];  // y linear accel
; Line 590
	*** 000399	26 a1 0e 00 		mov	ax,WORD PTR es:?ln200@@3ULN200@@E+14	;ln200
	*** 00039d	89 86 4c ff 		mov	WORD PTR [bp-180],ax
;|***   data[31] = ln200.data[2];  // x linear accel
; Line 591
	*** 0003a1	26 a1 10 00 		mov	ax,WORD PTR es:?ln200@@3ULN200@@E+16	;ln200
	*** 0003a5	89 86 4e ff 		mov	WORD PTR [bp-178],ax
;|***   data[32] = ln200.data[3];  // y angular rate
; Line 592
	*** 0003a9	26 a1 12 00 		mov	ax,WORD PTR es:?ln200@@3ULN200@@E+18	;ln200
	*** 0003ad	89 86 50 ff 		mov	WORD PTR [bp-176],ax
;|***   data[33] = ln200.data[4];  // x angular rate
; Line 593
	*** 0003b1	26 a1 14 00 		mov	ax,WORD PTR es:?ln200@@3ULN200@@E+20	;ln200
	*** 0003b5	89 86 52 ff 		mov	WORD PTR [bp-174],ax
;|***   data[34] = ln200.data[5];  // z angular rate
; Line 594
	*** 0003b9	26 a1 16 00 		mov	ax,WORD PTR es:?ln200@@3ULN200@@E+22	;ln200
	*** 0003bd	89 86 54 ff 		mov	WORD PTR [bp-172],ax
;|***   data[35] = ln200.data[6];  // y angular accel
; Line 595
	*** 0003c1	26 a1 18 00 		mov	ax,WORD PTR es:?ln200@@3ULN200@@E+24	;ln200
	*** 0003c5	89 86 56 ff 		mov	WORD PTR [bp-170],ax
;|***   data[36] = ln200.data[7];  // x angular accel
; Line 596
	*** 0003c9	26 a1 1a 00 		mov	ax,WORD PTR es:?ln200@@3ULN200@@E+26	;ln200
	*** 0003cd	89 86 58 ff 		mov	WORD PTR [bp-168],ax
;|***   data[37] = ln200.data[8];  // z angular accel
; Line 597
	*** 0003d1	26 a1 1c 00 		mov	ax,WORD PTR es:?ln200@@3ULN200@@E+28	;ln200
	*** 0003d5	89 86 5a ff 		mov	WORD PTR [bp-166],ax
;|***   data[38] = ln200.data[9];  // pitch
; Line 598
	*** 0003d9	26 a1 1e 00 		mov	ax,WORD PTR es:?ln200@@3ULN200@@E+30	;ln200
	*** 0003dd	89 86 5c ff 		mov	WORD PTR [bp-164],ax
;|***   data[39] = ln200.data[10]; // roll 
; Line 599
	*** 0003e1	26 a1 20 00 		mov	ax,WORD PTR es:?ln200@@3ULN200@@E+32	;ln200
	*** 0003e5	89 86 5e ff 		mov	WORD PTR [bp-162],ax
;|***   data[40] = ln200.data[11]; // heading 
; Line 600
	*** 0003e9	26 a1 22 00 		mov	ax,WORD PTR es:?ln200@@3ULN200@@E+34	;ln200
	*** 0003ed	89 86 60 ff 		mov	WORD PTR [bp-160],ax
;|***   data[41] = commands.mode;
; Line 601
	*** 0003f1	8e 06 00 00 		mov	es,WORD PTR $T4071
	*** 0003f5	26 a1 02 00 		mov	ax,WORD PTR es:?commands@@3UCOMMANDS@@E+2	;commands
	*** 0003f9	89 86 62 ff 		mov	WORD PTR [bp-158],ax
;|***   data[42] = commands.rpm;
; Line 602
	*** 0003fd	26 a1 04 00 		mov	ax,WORD PTR es:?commands@@3UCOMMANDS@@E+4	;commands
	*** 000401	89 86 64 ff 		mov	WORD PTR [bp-156],ax
;|***   data[43] = commands.rudder;
; Line 603
	*** 000405	26 a1 06 00 		mov	ax,WORD PTR es:?commands@@3UCOMMANDS@@E+6	;commands
	*** 000409	89 86 66 ff 		mov	WORD PTR [bp-154],ax
;|***   data[44] = commands.stern1;
; Line 604
	*** 00040d	26 a1 08 00 		mov	ax,WORD PTR es:?commands@@3UCOMMANDS@@E+8	;commands
	*** 000411	89 86 68 ff 		mov	WORD PTR [bp-152],ax
;|***   data[45] = commands.stern2;
; Line 605
	*** 000415	26 a1 0a 00 		mov	ax,WORD PTR es:?commands@@3UCOMMANDS@@E+10	;commands
	*** 000419	89 86 6a ff 		mov	WORD PTR [bp-150],ax
;|***   data[46] = commands.fore;
; Line 606
	*** 00041d	26 a1 0c 00 		mov	ax,WORD PTR es:?commands@@3UCOMMANDS@@E+12	;commands
	*** 000421	89 86 6c ff 		mov	WORD PTR [bp-148],ax
;|***   data[47] = commands.ballast;
; Line 607
	*** 000425	26 a1 0e 00 		mov	ax,WORD PTR es:?commands@@3UCOMMANDS@@E+14	;commands
	*** 000429	89 86 6e ff 		mov	WORD PTR [bp-146],ax
;|***   data[48] = commands.ds_dmgx;
; Line 608
	*** 00042d	26 a1 1c 00 		mov	ax,WORD PTR es:?commands@@3UCOMMANDS@@E+28	;commands
	*** 000431	89 86 70 ff 		mov	WORD PTR [bp-144],ax
;|***   data[49] = commands.ds_dmgy;
; Line 609
	*** 000435	26 a1 1e 00 		mov	ax,WORD PTR es:?commands@@3UCOMMANDS@@E+30	;commands
	*** 000439	89 86 72 ff 		mov	WORD PTR [bp-142],ax
;|***   data[50] = commands.ds_dmgz;
; Line 610
	*** 00043d	26 a1 20 00 		mov	ax,WORD PTR es:?commands@@3UCOMMANDS@@E+32	;commands
	*** 000441	89 86 74 ff 		mov	WORD PTR [bp-140],ax
;|***   data[51] = commands.spare1;
; Line 611
	*** 000445	26 a1 22 00 		mov	ax,WORD PTR es:?commands@@3UCOMMANDS@@E+34	;commands
	*** 000449	89 86 76 ff 		mov	WORD PTR [bp-138],ax
;|***   memcpy(&data[52],&adcp.data[154],2); // y_vel_btm;
; Line 612
	*** 00044d	6a 02 			push	2
	*** 00044f	68 00 00 		push	SEG ?adcp@@3UADCP@@E	;adcp
	*** 000452	68 a6 00 		push	OFFSET ?adcp@@3UADCP@@E+166	;adcp
	*** 000455	8d 86 78 ff 		lea	ax,WORD PTR [bp-136]
	*** 000459	16 			push	ss
	*** 00045a	50 			push	ax
	*** 00045b	9a 00 00 00 00 		call	FAR PTR _memcpy
	*** 000460	83 c4 0a 		add	sp,10	;000aH
;|***   memcpy(&data[53],&adcp.data[158],2); // z_vel_btm;
; Line 613
	*** 000463	6a 02 			push	2
	*** 000465	68 00 00 		push	SEG ?adcp@@3UADCP@@E	;adcp
	*** 000468	68 aa 00 		push	OFFSET ?adcp@@3UADCP@@E+170	;adcp
	*** 00046b	8d 86 7a ff 		lea	ax,WORD PTR [bp-134]
	*** 00046f	16 			push	ss
	*** 000470	50 			push	ax
	*** 000471	9a 00 00 00 00 		call	FAR PTR _memcpy
	*** 000476	83 c4 0a 		add	sp,10	;000aH
;|***   memcpy(&data[54],&adcp.data[156],2); // x_vel_btm;
; Line 614
	*** 000479	6a 02 			push	2
	*** 00047b	68 00 00 		push	SEG ?adcp@@3UADCP@@E	;adcp
	*** 00047e	68 a8 00 		push	OFFSET ?adcp@@3UADCP@@E+168	;adcp
	*** 000481	8d 86 7c ff 		lea	ax,WORD PTR [bp-132]
	*** 000485	16 			push	ss
	*** 000486	50 			push	ax
	*** 000487	9a 00 00 00 00 		call	FAR PTR _memcpy
	*** 00048c	83 c4 0a 		add	sp,10	;000aH
;|***   memcpy(&data[55],&adcp.data[146],2); // bm1_rng_to_btm;
; Line 615
	*** 00048f	6a 02 			push	2
	*** 000491	68 00 00 		push	SEG ?adcp@@3UADCP@@E	;adcp
	*** 000494	68 9e 00 		push	OFFSET ?adcp@@3UADCP@@E+158	;adcp
	*** 000497	8d 86 7e ff 		lea	ax,WORD PTR [bp-130]
	*** 00049b	16 			push	ss
	*** 00049c	50 			push	ax
	*** 00049d	9a 00 00 00 00 		call	FAR PTR _memcpy
	*** 0004a2	83 c4 0a 		add	sp,10	;000aH
;|***   memcpy(&data[56],&adcp.data[148],2); // bm2_rng_to_btm;
; Line 616
	*** 0004a5	6a 02 			push	2
	*** 0004a7	68 00 00 		push	SEG ?adcp@@3UADCP@@E	;adcp
	*** 0004aa	68 a0 00 		push	OFFSET ?adcp@@3UADCP@@E+160	;adcp
	*** 0004ad	8d 46 80 		lea	ax,WORD PTR [bp-128]
	*** 0004b0	16 			push	ss
	*** 0004b1	50 			push	ax
	*** 0004b2	9a 00 00 00 00 		call	FAR PTR _memcpy
	*** 0004b7	83 c4 0a 		add	sp,10	;000aH
;|***   memcpy(&data[57],&adcp.data[150],2); // bm3_rng_to_btm;
; Line 617
	*** 0004ba	6a 02 			push	2
	*** 0004bc	68 00 00 		push	SEG ?adcp@@3UADCP@@E	;adcp
	*** 0004bf	68 a2 00 		push	OFFSET ?adcp@@3UADCP@@E+162	;adcp
	*** 0004c2	8d 46 82 		lea	ax,WORD PTR [bp-126]
	*** 0004c5	16 			push	ss
	*** 0004c6	50 			push	ax
	*** 0004c7	9a 00 00 00 00 		call	FAR PTR _memcpy
	*** 0004cc	83 c4 0a 		add	sp,10	;000aH
;|***   memcpy(&data[58],&adcp.data[152],2); // bm4_rng_to_btm;
; Line 618
	*** 0004cf	6a 02 			push	2
	*** 0004d1	68 00 00 		push	SEG ?adcp@@3UADCP@@E	;adcp
	*** 0004d4	68 a4 00 		push	OFFSET ?adcp@@3UADCP@@E+164	;adcp
	*** 0004d7	8d 46 84 		lea	ax,WORD PTR [bp-124]
	*** 0004da	16 			push	ss
	*** 0004db	50 			push	ax
	*** 0004dc	9a 00 00 00 00 		call	FAR PTR _memcpy
	*** 0004e1	83 c4 0a 		add	sp,10	;000aH
;|***   data[59] = 0;
; Line 619
	*** 0004e4	c7 46 86 00 00 		mov	WORD PTR [bp-122],0
;|***   _fmemcpy(&data[60],&dyno.data,2*60);
; Line 620
	*** 0004e9	6a 78 			push	120	;0078H
	*** 0004eb	68 00 00 		push	SEG ?dyno@@3UDYNO@@E	;dyno
	*** 0004ee	68 0c 00 		push	OFFSET ?dyno@@3UDYNO@@E+12	;dyno
	*** 0004f1	8d 46 88 		lea	ax,WORD PTR [bp-120]
	*** 0004f4	16 			push	ss
	*** 0004f5	50 			push	ax
	*** 0004f6	9a 00 00 00 00 		call	FAR PTR __fmemcpy
	*** 0004fb	83 c4 0a 		add	sp,10	;000aH
;|***   _fmemcpy(&pcm,&data,sizeof(pcm));
; Line 621
	*** 0004fe	68 f0 00 		push	240	;00f0H
	*** 000501	8d 86 10 ff 		lea	ax,WORD PTR [bp-240]	;data
	*** 000505	16 			push	ss
	*** 000506	50 			push	ax
	*** 000507	1e 			push	ds
	*** 000508	68 00 00 		push	OFFSET DGROUP:?pcm@@3QEDE	;pcm
	*** 00050b	9a 00 00 00 00 		call	FAR PTR __fmemcpy
	*** 000510	83 c4 0a 		add	sp,10	;000aH
;|***   }  
; Line 622
	*** 000513	e9 00 00 		jmp	$EX3684
					$EX3684:
	*** 000516	5e 			pop	si
	*** 000517	5f 			pop	di
	*** 000518	c9 			leave	
	*** 000519	cb 			ret	

?pack_pcm@@ZAXXZ	ENDP
	PUBLIC	?get_frame_time@@ZAXXZ	; get_frame_time
?get_frame_time@@ZAXXZ	PROC FAR	; get_frame_time
;|*** 
;|*** 
;|*** void get_frame_time(void)
;|***   {
; Line 626
	*** 00051a	c8 00 00 00 		enter	0,0
	*** 00051e	57 			push	di
	*** 00051f	56 			push	si
;|***   _disable();
; Line 627
	*** 000520	9a 00 00 00 00 		call	FAR PTR __disable
;|***   time_stamp(&frame_time);
; Line 628
	*** 000525	68 00 00 		push	SEG ?frame_time@@3UTIMER@@E	;frame_time
	*** 000528	68 00 00 		push	OFFSET ?frame_time@@3UTIMER@@E	;frame_time
	*** 00052b	9a 00 00 00 00 		call	FAR PTR ?time_stamp@@ZAXPEUTIMER@@@Z	; time_stamp
	*** 000530	83 c4 04 		add	sp,4
;|***   _enable();
; Line 629
	*** 000533	9a 00 00 00 00 		call	FAR PTR __enable
;|***   }
; Line 630
	*** 000538	e9 00 00 		jmp	$EX3688
					$EX3688:
	*** 00053b	5e 			pop	si
	*** 00053c	5f 			pop	di
	*** 00053d	c9 			leave	
	*** 00053e	cb 			ret	

?get_frame_time@@ZAXXZ	ENDP
	PUBLIC	?send_data_packet@@ZAXXZ	; send_data_packet
?send_data_packet@@ZAXXZ	PROC FAR	; send_data_packet
;|***   
;|***   
;|*** void send_data_packet(void)
;|***   {
; Line 634
	*** 00053f	c8 04 00 00 		enter	4,0
	*** 000543	57 			push	di
	*** 000544	56 			push	si
;	lsb = -2
;	msb = -4
;|***   unsigned int lsb = 0;
; Line 635
	*** 000545	c7 46 fe 00 00 		mov	WORD PTR [bp-2],0	;lsb
;|***   unsigned int msb = 0;
; Line 636
	*** 00054a	c7 46 fc 00 00 		mov	WORD PTR [bp-4],0	;msb
;|***   
;|***   build_packet();
; Line 638
	*** 00054f	9a 00 00 00 00 		call	FAR PTR ?build_packet@@ZAXXZ	; build_packet
;|***   send_pkt(data_pkt, 1514);  // 1514 bytes in enet packet w/o checksum
; Line 639
	*** 000554	68 ea 05 		push	1514	;05eaH
	*** 000557	1e 			push	ds
	*** 000558	68 00 00 		push	OFFSET DGROUP:?data_pkt@@3QEEE	;data_pkt
	*** 00055b	9a 00 00 00 00 		call	FAR PTR ?send_pkt@@ZAHPEEI@Z	; send_pkt
	*** 000560	83 c4 06 		add	sp,6
;|***   }
; Line 640
	*** 000563	e9 00 00 		jmp	$EX3690
					$EX3690:
	*** 000566	5e 			pop	si
	*** 000567	5f 			pop	di
	*** 000568	c9 			leave	
	*** 000569	cb 			ret	

?send_data_packet@@ZAXXZ	ENDP
	PUBLIC	?apply_commands@@ZAXXZ	; apply_commands
?apply_commands@@ZAXXZ	PROC FAR	; apply_commands
;|***   
;|***   
;|*** void apply_commands(void)
;|***   {
; Line 644
	*** 00056a	c8 04 00 00 		enter	4,0
	*** 00056e	57 			push	di
	*** 00056f	56 			push	si
;	lsb = -2
;	msb = -4
;|***   unsigned int lsb = 0;
; Line 645
	*** 000570	c7 46 fe 00 00 		mov	WORD PTR [bp-2],0	;lsb
;|***   unsigned int msb = 0;
; Line 646
	*** 000575	c7 46 fc 00 00 		mov	WORD PTR [bp-4],0	;msb
;|*** 
;|***   // get commands from buffered udp packet
;|***   _disable();
; Line 649
	*** 00057a	9a 00 00 00 00 		call	FAR PTR __disable
;|***   _fmemcpy(&commands, &cmd_buffer[42], sizeof(commands));
; Line 650
	*** 00057f	6a 24 			push	36	;0024H
	*** 000581	68 00 00 		push	SEG ?cmd_buffer@@3QEEE	;cmd_buffer
	*** 000584	68 2a 00 		push	OFFSET ?cmd_buffer@@3QEEE+42	;cmd_buffer
	*** 000587	68 00 00 		push	SEG ?commands@@3UCOMMANDS@@E	;commands
	*** 00058a	68 00 00 		push	OFFSET ?commands@@3UCOMMANDS@@E	;commands
	*** 00058d	9a 00 00 00 00 		call	FAR PTR __fmemcpy
	*** 000592	83 c4 0a 		add	sp,10	;000aH
;|***   _enable();
; Line 651
	*** 000595	9a 00 00 00 00 		call	FAR PTR __enable
;|***   
;|***   // zero out the commands if no response from control for 1 second
;|***   if(++time_since_last_command > 100)  
; Line 654
	*** 00059a	ff 06 00 00 		inc	WORD PTR ?time_since_last_command@@3HE	;time_since_last_command
	*** 00059e	83 3e 00 00 64 		cmp	WORD PTR ?time_since_last_command@@3HE,100	;0064H	;time_since_last_command
	*** 0005a3	7f 03 			jg	$JCC1443
	*** 0005a5	e9 27 00 		jmp	$I3697
					$JCC1443:
;|***     {                                
; Line 655
;|***     commands.rpm = 0;
; Line 656
	*** 0005a8	8e 06 00 00 		mov	es,WORD PTR $T4071
	*** 0005ac	26 c7 06 04 00 00 00 	mov	WORD PTR es:?commands@@3UCOMMANDS@@E+4,0	;commands
;|***     commands.rudder    = 0x800;
; Line 657
	*** 0005b3	26 c7 06 06 00 00 08 	mov	WORD PTR es:?commands@@3UCOMMANDS@@E+6,2048	;0800H	;commands
;|***     commands.stern1    = 0x800;
; Line 658
	*** 0005ba	26 c7 06 08 00 00 08 	mov	WORD PTR es:?commands@@3UCOMMANDS@@E+8,2048	;0800H	;commands
;|***     commands.stern2    = 0x800;
; Line 659
	*** 0005c1	26 c7 06 0a 00 00 08 	mov	WORD PTR es:?commands@@3UCOMMANDS@@E+10,2048	;0800H	;commands
;|***     commands.fore      = 0x800;
; Line 660
	*** 0005c8	26 c7 06 0c 00 00 08 	mov	WORD PTR es:?commands@@3UCOMMANDS@@E+12,2048	;0800H	;commands
;|*** //    commands.actuator5 = 0x800;  // May 2007 jtm
;|***     }
; Line 662
;|*** 
;|*** /*  
;|***   //  blow the ERS if no response from control for 2 minutes
;|***   if(time_since_last_command > 12000)
;|***     {                                
;|***     commands.ballast = commands.ballast | ERS_BLOW;
;|***     time_since_last_command = 12000;
;|***     }
;|*** */
;|*** 
;|*** //  8/30/2007 jtm rem'ed out for sam
;|***   //  blow the ERS if no response from control for 5 seconds
;|***   if(packets_rcvd > 100 && time_since_last_command > 500)
; Line 675
					$I3697:
	*** 0005cf	83 3e 02 00 00 		cmp	WORD PTR ?packets_rcvd@@3KE+2,0	;packets_rcvd
	*** 0005d4	76 03 			jbe	$JCC1492
	*** 0005d6	e9 0a 00 		jmp	$L4072
					$JCC1492:
	*** 0005d9	83 3e 00 00 64 		cmp	WORD PTR ?packets_rcvd@@3KE,100	;0064H	;packets_rcvd
	*** 0005de	77 03 			ja	$JCC1502
	*** 0005e0	e9 1c 00 		jmp	$I3698
					$JCC1502:
					$L4072:
	*** 0005e3	81 3e 00 00 f4 01 	cmp	WORD PTR ?time_since_last_command@@3HE,500	;01f4H	;time_since_last_command
	*** 0005e9	7f 03 			jg	$JCC1513
	*** 0005eb	e9 11 00 		jmp	$I3698
					$JCC1513:
;|***     {                                
; Line 676
;|***     commands.ballast = commands.ballast | ERS_BLOW;
; Line 677
	*** 0005ee	8e 06 00 00 		mov	es,WORD PTR $T4071
	*** 0005f2	26 81 0e 0e 00 00 04 	or	WORD PTR es:?commands@@3UCOMMANDS@@E+14,1024	;0400H	;commands
;|***     time_since_last_command = 500;
; Line 678
	*** 0005f9	c7 06 00 00 f4 01 	mov	WORD PTR ?time_since_last_command@@3HE,500	;01f4H	;time_since_last_command
;|***     }
; Line 679
;|***     
;|***   // apply the commands
;|***   // stern1
;|***   sprintf(s, "Stern1:    %04x", commands.stern1);
; Line 683
					$I3698:
	*** 0005ff	8e 06 00 00 		mov	es,WORD PTR $T4071
	*** 000603	26 ff 36 08 00 		push	WORD PTR es:?commands@@3UCOMMANDS@@E+8	;commands
	*** 000608	1e 			push	ds
	*** 000609	68 00 00 		push	OFFSET DGROUP:$SG3699
	*** 00060c	1e 			push	ds
	*** 00060d	68 00 00 		push	OFFSET DGROUP:?s@@3QEDE	;s
	*** 000610	9a 00 00 00 00 		call	FAR PTR _sprintf
	*** 000615	83 c4 0a 		add	sp,10	;000aH
;|***   PC_DispStr(20,16, (unsigned char *)s, DISP_FGND_BLACK + DISP_BGND_RED);
; Line 684
	*** 000618	6a 40 			push	64	;0040H
	*** 00061a	1e 			push	ds
	*** 00061b	68 00 00 		push	OFFSET DGROUP:?s@@3QEDE	;s
	*** 00061e	6a 10 			push	16	;0010H
	*** 000620	6a 14 			push	20	;0014H
	*** 000622	9a 00 00 00 00 		call	FAR PTR ?PC_DispStr@@ZAXEEPEEE@Z	; PC_DispStr
	*** 000627	83 c4 0a 		add	sp,10	;000aH
;|***   while(_inp(OBS_BASE+DACLSB) & 0x80);
; Line 685
					$FC3702:
	*** 00062a	68 44 03 		push	836	;0344H
	*** 00062d	9a 00 00 00 00 		call	FAR PTR __inp
	*** 000632	83 c4 02 		add	sp,2
	*** 000635	a8 80 			test	al,128	;0080H
	*** 000637	75 03 			jne	$JCC1591
	*** 000639	e9 03 00 		jmp	$FB3703
					$JCC1591:
	*** 00063c	e9 eb ff 		jmp	$FC3702
					$FB3703:
;|***   _outp(OBS_BASE+DACLSB, commands.stern1 & 0xff);
; Line 686
	*** 00063f	8e 06 00 00 		mov	es,WORD PTR $T4071
	*** 000643	26 a0 08 00 		mov	al,BYTE PTR es:?commands@@3UCOMMANDS@@E+8	;commands
	*** 000647	2a e4 			sub	ah,ah
	*** 000649	50 			push	ax
	*** 00064a	68 44 03 		push	836	;0344H
	*** 00064d	9a 00 00 00 00 		call	FAR PTR __outp
	*** 000652	83 c4 04 		add	sp,4
;|***   _outp(OBS_BASE+DACMSB, (commands.stern1>>8) & 0x0f | STERN1_CHAN);
; Line 687
	*** 000655	8e 06 00 00 		mov	es,WORD PTR $T4071
	*** 000659	26 a0 09 00 		mov	al,BYTE PTR es:?commands@@3UCOMMANDS@@E+9	;commands
	*** 00065d	25 0f 00 		and	ax,15	;000fH
	*** 000660	50 			push	ax
	*** 000661	68 45 03 		push	837	;0345H
	*** 000664	9a 00 00 00 00 		call	FAR PTR __outp
	*** 000669	83 c4 04 		add	sp,4
;|***   while(_inp(OBS_BASE+DACLSB) & 0x80);
; Line 688
					$FC3705:
	*** 00066c	68 44 03 		push	836	;0344H
	*** 00066f	9a 00 00 00 00 		call	FAR PTR __inp
	*** 000674	83 c4 02 		add	sp,2
	*** 000677	a8 80 			test	al,128	;0080H
	*** 000679	75 03 			jne	$JCC1657
	*** 00067b	e9 03 00 		jmp	$FB3706
					$JCC1657:
	*** 00067e	e9 eb ff 		jmp	$FC3705
					$FB3706:
;|***   _inp( OBS_BASE+DACMSB);
; Line 689
	*** 000681	68 45 03 		push	837	;0345H
	*** 000684	9a 00 00 00 00 		call	FAR PTR __inp
	*** 000689	83 c4 02 		add	sp,2
;|*** 
;|***   // stern2
;|***   sprintf(s, "Stern2:    %04x", commands.stern2);
; Line 692
	*** 00068c	8e 06 00 00 		mov	es,WORD PTR $T4071
	*** 000690	26 ff 36 0a 00 		push	WORD PTR es:?commands@@3UCOMMANDS@@E+10	;commands
	*** 000695	1e 			push	ds
	*** 000696	68 00 00 		push	OFFSET DGROUP:$SG3707
	*** 000699	1e 			push	ds
	*** 00069a	68 00 00 		push	OFFSET DGROUP:?s@@3QEDE	;s
	*** 00069d	9a 00 00 00 00 		call	FAR PTR _sprintf
	*** 0006a2	83 c4 0a 		add	sp,10	;000aH
;|***   PC_DispStr(20,17, (unsigned char *)s, DISP_FGND_BLACK + DISP_BGND_RED);
; Line 693
	*** 0006a5	6a 40 			push	64	;0040H
	*** 0006a7	1e 			push	ds
	*** 0006a8	68 00 00 		push	OFFSET DGROUP:?s@@3QEDE	;s
	*** 0006ab	6a 11 			push	17	;0011H
	*** 0006ad	6a 14 			push	20	;0014H
	*** 0006af	9a 00 00 00 00 		call	FAR PTR ?PC_DispStr@@ZAXEEPEEE@Z	; PC_DispStr
	*** 0006b4	83 c4 0a 		add	sp,10	;000aH
;|***   while(_inp(OBS_BASE+DACLSB) & 0x80);
; Line 694
					$FC3710:
	*** 0006b7	68 44 03 		push	836	;0344H
	*** 0006ba	9a 00 00 00 00 		call	FAR PTR __inp
	*** 0006bf	83 c4 02 		add	sp,2
	*** 0006c2	a8 80 			test	al,128	;0080H
	*** 0006c4	75 03 			jne	$JCC1732
	*** 0006c6	e9 03 00 		jmp	$FB3711
					$JCC1732:
	*** 0006c9	e9 eb ff 		jmp	$FC3710
					$FB3711:
;|***   _outp(OBS_BASE+DACLSB, commands.stern2 & 0xff);
; Line 695
	*** 0006cc	8e 06 00 00 		mov	es,WORD PTR $T4071
	*** 0006d0	26 a0 0a 00 		mov	al,BYTE PTR es:?commands@@3UCOMMANDS@@E+10	;commands
	*** 0006d4	2a e4 			sub	ah,ah
	*** 0006d6	50 			push	ax
	*** 0006d7	68 44 03 		push	836	;0344H
	*** 0006da	9a 00 00 00 00 		call	FAR PTR __outp
	*** 0006df	83 c4 04 		add	sp,4
;|***   _outp(OBS_BASE+DACMSB, (commands.stern2>>8) & 0x0f | STERN2_CHAN);
; Line 696
	*** 0006e2	8e 06 00 00 		mov	es,WORD PTR $T4071
	*** 0006e6	26 a0 0b 00 		mov	al,BYTE PTR es:?commands@@3UCOMMANDS@@E+11	;commands
	*** 0006ea	25 0f 00 		and	ax,15	;000fH
	*** 0006ed	0c 40 			or	al,64	;0040H
	*** 0006ef	50 			push	ax
	*** 0006f0	68 45 03 		push	837	;0345H
	*** 0006f3	9a 00 00 00 00 		call	FAR PTR __outp
	*** 0006f8	83 c4 04 		add	sp,4
;|***   while(_inp(OBS_BASE+DACLSB) & 0x80);
; Line 697
					$FC3713:
	*** 0006fb	68 44 03 		push	836	;0344H
	*** 0006fe	9a 00 00 00 00 		call	FAR PTR __inp
	*** 000703	83 c4 02 		add	sp,2
	*** 000706	a8 80 			test	al,128	;0080H
	*** 000708	75 03 			jne	$JCC1800
	*** 00070a	e9 03 00 		jmp	$FB3714
					$JCC1800:
	*** 00070d	e9 eb ff 		jmp	$FC3713
					$FB3714:
;|***   _inp( OBS_BASE+DACMSB);
; Line 698
	*** 000710	68 45 03 		push	837	;0345H
	*** 000713	9a 00 00 00 00 		call	FAR PTR __inp
	*** 000718	83 c4 02 		add	sp,2
;|***   
;|***   // forward
;|***   while(_inp(OBS_BASE+DACLSB) & 0x80);
; Line 701
					$FC3716:
	*** 00071b	68 44 03 		push	836	;0344H
	*** 00071e	9a 00 00 00 00 		call	FAR PTR __inp
	*** 000723	83 c4 02 		add	sp,2
	*** 000726	a8 80 			test	al,128	;0080H
	*** 000728	75 03 			jne	$JCC1832
	*** 00072a	e9 03 00 		jmp	$FB3717
					$JCC1832:
	*** 00072d	e9 eb ff 		jmp	$FC3716
					$FB3717:
;|***   _outp(OBS_BASE+DACLSB, commands.fore & 0xff);
; Line 702
	*** 000730	8e 06 00 00 		mov	es,WORD PTR $T4071
	*** 000734	26 a0 0c 00 		mov	al,BYTE PTR es:?commands@@3UCOMMANDS@@E+12	;commands
	*** 000738	2a e4 			sub	ah,ah
	*** 00073a	50 			push	ax
	*** 00073b	68 44 03 		push	836	;0344H
	*** 00073e	9a 00 00 00 00 		call	FAR PTR __outp
	*** 000743	83 c4 04 		add	sp,4
;|***   _outp(OBS_BASE+DACMSB, (commands.fore>>8) & 0x0f | FORE_CHAN);
; Line 703
	*** 000746	8e 06 00 00 		mov	es,WORD PTR $T4071
	*** 00074a	26 8a 26 0d 00 		mov	ah,BYTE PTR es:?commands@@3UCOMMANDS@@E+13	;commands
	*** 00074f	25 00 0f 		and	ax,3840	;0f00H
	*** 000752	0d ff c0 		or	ax,-16129	;c0ffH
	*** 000755	c1 e8 08 		shr	ax,8
	*** 000758	50 			push	ax
	*** 000759	68 45 03 		push	837	;0345H
	*** 00075c	9a 00 00 00 00 		call	FAR PTR __outp
	*** 000761	83 c4 04 		add	sp,4
;|***   while(_inp(OBS_BASE+DACLSB) & 0x80);
; Line 704
					$FC3719:
	*** 000764	68 44 03 		push	836	;0344H
	*** 000767	9a 00 00 00 00 		call	FAR PTR __inp
	*** 00076c	83 c4 02 		add	sp,2
	*** 00076f	a8 80 			test	al,128	;0080H
	*** 000771	75 03 			jne	$JCC1905
	*** 000773	e9 03 00 		jmp	$FB3720
					$JCC1905:
	*** 000776	e9 eb ff 		jmp	$FC3719
					$FB3720:
;|***   _inp( OBS_BASE+DACMSB);
; Line 705
	*** 000779	68 45 03 		push	837	;0345H
	*** 00077c	9a 00 00 00 00 		call	FAR PTR __inp
	*** 000781	83 c4 02 		add	sp,2
;|***   
;|***   // rudder
;|***   sprintf(s, "Rudder:    %04x", commands.rudder);
; Line 708
	*** 000784	8e 06 00 00 		mov	es,WORD PTR $T4071
	*** 000788	26 ff 36 06 00 		push	WORD PTR es:?commands@@3UCOMMANDS@@E+6	;commands
	*** 00078d	1e 			push	ds
	*** 00078e	68 00 00 		push	OFFSET DGROUP:$SG3721
	*** 000791	1e 			push	ds
	*** 000792	68 00 00 		push	OFFSET DGROUP:?s@@3QEDE	;s
	*** 000795	9a 00 00 00 00 		call	FAR PTR _sprintf
	*** 00079a	83 c4 0a 		add	sp,10	;000aH
;|***   PC_DispStr(20,19, (unsigned char *)s, DISP_FGND_BLACK + DISP_BGND_RED);
; Line 709
	*** 00079d	6a 40 			push	64	;0040H
	*** 00079f	1e 			push	ds
	*** 0007a0	68 00 00 		push	OFFSET DGROUP:?s@@3QEDE	;s
	*** 0007a3	6a 13 			push	19	;0013H
	*** 0007a5	6a 14 			push	20	;0014H
	*** 0007a7	9a 00 00 00 00 		call	FAR PTR ?PC_DispStr@@ZAXEEPEEE@Z	; PC_DispStr
	*** 0007ac	83 c4 0a 		add	sp,10	;000aH
;|***   while(_inp(OBS_BASE+DACLSB) & 0x80);
; Line 710
					$FC3724:
	*** 0007af	68 44 03 		push	836	;0344H
	*** 0007b2	9a 00 00 00 00 		call	FAR PTR __inp
	*** 0007b7	83 c4 02 		add	sp,2
	*** 0007ba	a8 80 			test	al,128	;0080H
	*** 0007bc	75 03 			jne	$JCC1980
	*** 0007be	e9 03 00 		jmp	$FB3725
					$JCC1980:
	*** 0007c1	e9 eb ff 		jmp	$FC3724
					$FB3725:
;|***   _outp(OBS_BASE+DACLSB, commands.rudder & 0xff);
; Line 711
	*** 0007c4	8e 06 00 00 		mov	es,WORD PTR $T4071
	*** 0007c8	26 a0 06 00 		mov	al,BYTE PTR es:?commands@@3UCOMMANDS@@E+6	;commands
	*** 0007cc	2a e4 			sub	ah,ah
	*** 0007ce	50 			push	ax
	*** 0007cf	68 44 03 		push	836	;0344H
	*** 0007d2	9a 00 00 00 00 		call	FAR PTR __outp
	*** 0007d7	83 c4 04 		add	sp,4
;|***   _outp(OBS_BASE+DACMSB, (commands.rudder>>8) & 0x0f | RUDDER_CHAN);
; Line 712
	*** 0007da	8e 06 00 00 		mov	es,WORD PTR $T4071
	*** 0007de	26 8a 26 07 00 		mov	ah,BYTE PTR es:?commands@@3UCOMMANDS@@E+7	;commands
	*** 0007e3	25 00 0f 		and	ax,3840	;0f00H
	*** 0007e6	0d ff 80 		or	ax,-32513	;80ffH
	*** 0007e9	c1 e8 08 		shr	ax,8
	*** 0007ec	50 			push	ax
	*** 0007ed	68 45 03 		push	837	;0345H
	*** 0007f0	9a 00 00 00 00 		call	FAR PTR __outp
	*** 0007f5	83 c4 04 		add	sp,4
;|***   while(_inp(OBS_BASE+DACLSB) & 0x80);
; Line 713
					$FC3727:
	*** 0007f8	68 44 03 		push	836	;0344H
	*** 0007fb	9a 00 00 00 00 		call	FAR PTR __inp
	*** 000800	83 c4 02 		add	sp,2
	*** 000803	a8 80 			test	al,128	;0080H
	*** 000805	75 03 			jne	$JCC2053
	*** 000807	e9 03 00 		jmp	$FB3728
					$JCC2053:
	*** 00080a	e9 eb ff 		jmp	$FC3727
					$FB3728:
;|***   _inp( OBS_BASE+DACMSB);
; Line 714
	*** 00080d	68 45 03 		push	837	;0345H
	*** 000810	9a 00 00 00 00 		call	FAR PTR __inp
	*** 000815	83 c4 02 		add	sp,2
;|*** 
;|*** // actuator5
;|*** /*  while(_inp(DYNO_BASE+DACLSB) & 0x80);
;|***   _outp(DYNO_BASE+DACLSB, commands.actuator5 & 0xff);
;|***   _outp(DYNO_BASE+DACMSB, (commands.actuator5>>8) & 0x0f | 0x00);
;|***   while(_inp(DYNO_BASE+DACLSB) & 0x80);
;|***   _inp(DYNO_BASE+DACMSB);
;|*** */    
;|***   // prop
;|***   sprintf(s, "Prop:      %04x", commands.rpm);
; Line 724
	*** 000818	8e 06 00 00 		mov	es,WORD PTR $T4071
	*** 00081c	26 ff 36 04 00 		push	WORD PTR es:?commands@@3UCOMMANDS@@E+4	;commands
	*** 000821	1e 			push	ds
	*** 000822	68 00 00 		push	OFFSET DGROUP:$SG3729
	*** 000825	1e 			push	ds
	*** 000826	68 00 00 		push	OFFSET DGROUP:?s@@3QEDE	;s
	*** 000829	9a 00 00 00 00 		call	FAR PTR _sprintf
	*** 00082e	83 c4 0a 		add	sp,10	;000aH
;|***   PC_DispStr(20,18, (unsigned char *)s, DISP_FGND_BLACK + DISP_BGND_RED);
; Line 725
	*** 000831	6a 40 			push	64	;0040H
	*** 000833	1e 			push	ds
	*** 000834	68 00 00 		push	OFFSET DGROUP:?s@@3QEDE	;s
	*** 000837	6a 12 			push	18	;0012H
	*** 000839	6a 14 			push	20	;0014H
	*** 00083b	9a 00 00 00 00 		call	FAR PTR ?PC_DispStr@@ZAXEEPEEE@Z	; PC_DispStr
	*** 000840	83 c4 0a 		add	sp,10	;000aH
;|***   te5650SetMotor(commands.rpm);
; Line 726
	*** 000843	8e 06 00 00 		mov	es,WORD PTR $T4071
	*** 000847	26 ff 36 04 00 		push	WORD PTR es:?commands@@3UCOMMANDS@@E+4	;commands
	*** 00084c	9a 00 00 00 00 		call	FAR PTR _te5650SetMotor
	*** 000851	83 c4 02 		add	sp,2
;|***   te5650Update();
; Line 727
	*** 000854	9a 00 00 00 00 		call	FAR PTR _te5650Update
;|*** 
;|***   // ers blow  
;|***   sprintf(s, "Ballast:   %04x", commands.ballast);
; Line 730
	*** 000859	8e 06 00 00 		mov	es,WORD PTR $T4071
	*** 00085d	26 ff 36 0e 00 		push	WORD PTR es:?commands@@3UCOMMANDS@@E+14	;commands
	*** 000862	1e 			push	ds
	*** 000863	68 00 00 		push	OFFSET DGROUP:$SG3731
	*** 000866	1e 			push	ds
	*** 000867	68 00 00 		push	OFFSET DGROUP:?s@@3QEDE	;s
	*** 00086a	9a 00 00 00 00 		call	FAR PTR _sprintf
	*** 00086f	83 c4 0a 		add	sp,10	;000aH
;|***   PC_DispStr(20,20, (unsigned char *)s, DISP_FGND_BLACK + DISP_BGND_RED);
; Line 731
	*** 000872	6a 40 			push	64	;0040H
	*** 000874	1e 			push	ds
	*** 000875	68 00 00 		push	OFFSET DGROUP:?s@@3QEDE	;s
	*** 000878	6a 14 			push	20	;0014H
	*** 00087a	6a 14 			push	20	;0014H
	*** 00087c	9a 00 00 00 00 		call	FAR PTR ?PC_DispStr@@ZAXEEPEEE@Z	; PC_DispStr
	*** 000881	83 c4 0a 		add	sp,10	;000aH
;|***   if(commands.ballast & ERS_BLOW)
; Line 732
	*** 000884	8e 06 00 00 		mov	es,WORD PTR $T4071
	*** 000888	26 f6 06 0f 00 04 	test	BYTE PTR es:?commands@@3UCOMMANDS@@E+15,4	;commands
	*** 00088e	75 03 			jne	$JCC2190
	*** 000890	e9 60 00 		jmp	$I3733
					$JCC2190:
;|***     {
; Line 733
;|***     write_bit(PUMP,   PUMPOFF);
; Line 734
	*** 000893	6a 01 			push	1
	*** 000895	6a 10 			push	16	;0010H
	*** 000897	9a 00 00 00 00 		call	FAR PTR ?write_bit@@ZAXHH@Z	; write_bit
	*** 00089c	83 c4 04 		add	sp,4
;|***     write_bit(VALVE1, VALVEOFF);
; Line 735
	*** 00089f	6a 01 			push	1
	*** 0008a1	6a 0a 			push	10	;000aH
	*** 0008a3	9a 00 00 00 00 		call	FAR PTR ?write_bit@@ZAXHH@Z	; write_bit
	*** 0008a8	83 c4 04 		add	sp,4
;|***     write_bit(VALVE2, VALVEOFF);
; Line 736
	*** 0008ab	6a 01 			push	1
	*** 0008ad	6a 0b 			push	11	;000bH
	*** 0008af	9a 00 00 00 00 		call	FAR PTR ?write_bit@@ZAXHH@Z	; write_bit
	*** 0008b4	83 c4 04 		add	sp,4
;|***     write_bit(VALVE3, VALVEOFF);
; Line 737
	*** 0008b7	6a 01 			push	1
	*** 0008b9	6a 0c 			push	12	;000cH
	*** 0008bb	9a 00 00 00 00 		call	FAR PTR ?write_bit@@ZAXHH@Z	; write_bit
	*** 0008c0	83 c4 04 		add	sp,4
;|***     write_bit(VALVE4, VALVEOFF);
; Line 738
	*** 0008c3	6a 01 			push	1
	*** 0008c5	6a 0d 			push	13	;000dH
	*** 0008c7	9a 00 00 00 00 		call	FAR PTR ?write_bit@@ZAXHH@Z	; write_bit
	*** 0008cc	83 c4 04 		add	sp,4
;|***     write_bit(VALVE5, VALVEOFF);
; Line 739
	*** 0008cf	6a 01 			push	1
	*** 0008d1	6a 0e 			push	14	;000eH
	*** 0008d3	9a 00 00 00 00 		call	FAR PTR ?write_bit@@ZAXHH@Z	; write_bit
	*** 0008d8	83 c4 04 		add	sp,4
;|***     write_bit(VALVE6, VALVEOFF);
; Line 740
	*** 0008db	6a 01 			push	1
	*** 0008dd	6a 0f 			push	15	;000fH
	*** 0008df	9a 00 00 00 00 		call	FAR PTR ?write_bit@@ZAXHH@Z	; write_bit
	*** 0008e4	83 c4 04 		add	sp,4
;|***     write_bit(ERS,    ERSBLOW);
; Line 741
	*** 0008e7	6a 00 			push	0
	*** 0008e9	6a 12 			push	18	;0012H
	*** 0008eb	9a 00 00 00 00 		call	FAR PTR ?write_bit@@ZAXHH@Z	; write_bit
	*** 0008f0	83 c4 04 		add	sp,4
;|***     }
; Line 742
;|***   
;|***   // pfs blow
;|***   if(commands.ballast & PFS_BLOW)
; Line 745
					$I3733:
	*** 0008f3	8e 06 00 00 		mov	es,WORD PTR $T4071
	*** 0008f7	26 f6 06 0f 00 01 	test	BYTE PTR es:?commands@@3UCOMMANDS@@E+15,1	;commands
	*** 0008fd	75 03 			jne	$JCC2301
	*** 0008ff	e9 0c 00 		jmp	$I3734
					$JCC2301:
;|***     {
; Line 746
;|***     write_bit(PFSVENTBLOW, PFSBLOW);
; Line 747
	*** 000902	6a 00 			push	0
	*** 000904	6a 09 			push	9
	*** 000906	9a 00 00 00 00 		call	FAR PTR ?write_bit@@ZAXHH@Z	; write_bit
	*** 00090b	83 c4 04 		add	sp,4
;|***     }
; Line 748
;|***   
;|***   // pfs flood
;|***   if(commands.ballast & PFS_FLOOD)
; Line 751
					$I3734:
	*** 00090e	8e 06 00 00 		mov	es,WORD PTR $T4071
	*** 000912	26 f6 06 0f 00 02 	test	BYTE PTR es:?commands@@3UCOMMANDS@@E+15,2	;commands
	*** 000918	75 03 			jne	$JCC2328
	*** 00091a	e9 0c 00 		jmp	$I3735
					$JCC2328:
;|***     {
; Line 752
;|***     write_bit(PFSVENTBLOW, PFSVENT);    
; Line 753
	*** 00091d	6a 01 			push	1
	*** 00091f	6a 09 			push	9
	*** 000921	9a 00 00 00 00 		call	FAR PTR ?write_bit@@ZAXHH@Z	; write_bit
	*** 000926	83 c4 04 		add	sp,4
;|***     }
; Line 754
;|***   
;|***   // turn pump and valves off if no blow/flood command
;|***   if(!(commands.ballast & 0x00ff))
; Line 757
					$I3735:
	*** 000929	8e 06 00 00 		mov	es,WORD PTR $T4071
	*** 00092d	26 f6 06 0e 00 ff 	test	BYTE PTR es:?commands@@3UCOMMANDS@@E+14,255	;00ffH	;commands
	*** 000933	74 03 			je	$JCC2355
	*** 000935	e9 54 00 		jmp	$I3736
					$JCC2355:
;|***     {
; Line 758
;|***     write_bit(PUMP,   PUMPOFF);
; Line 759
	*** 000938	6a 01 			push	1
	*** 00093a	6a 10 			push	16	;0010H
	*** 00093c	9a 00 00 00 00 		call	FAR PTR ?write_bit@@ZAXHH@Z	; write_bit
	*** 000941	83 c4 04 		add	sp,4
;|***     write_bit(VALVE1, VALVEOFF);
; Line 760
	*** 000944	6a 01 			push	1
	*** 000946	6a 0a 			push	10	;000aH
	*** 000948	9a 00 00 00 00 		call	FAR PTR ?write_bit@@ZAXHH@Z	; write_bit
	*** 00094d	83 c4 04 		add	sp,4
;|***     write_bit(VALVE2, VALVEOFF);
; Line 761
	*** 000950	6a 01 			push	1
	*** 000952	6a 0b 			push	11	;000bH
	*** 000954	9a 00 00 00 00 		call	FAR PTR ?write_bit@@ZAXHH@Z	; write_bit
	*** 000959	83 c4 04 		add	sp,4
;|***     write_bit(VALVE3, VALVEOFF);
; Line 762
	*** 00095c	6a 01 			push	1
	*** 00095e	6a 0c 			push	12	;000cH
	*** 000960	9a 00 00 00 00 		call	FAR PTR ?write_bit@@ZAXHH@Z	; write_bit
	*** 000965	83 c4 04 		add	sp,4
;|***     write_bit(VALVE4, VALVEOFF);
; Line 763
	*** 000968	6a 01 			push	1
	*** 00096a	6a 0d 			push	13	;000dH
	*** 00096c	9a 00 00 00 00 		call	FAR PTR ?write_bit@@ZAXHH@Z	; write_bit
	*** 000971	83 c4 04 		add	sp,4
;|***     write_bit(VALVE5, VALVEOFF);
; Line 764
	*** 000974	6a 01 			push	1
	*** 000976	6a 0e 			push	14	;000eH
	*** 000978	9a 00 00 00 00 		call	FAR PTR ?write_bit@@ZAXHH@Z	; write_bit
	*** 00097d	83 c4 04 		add	sp,4
;|***     write_bit(VALVE6, VALVEOFF);
; Line 765
	*** 000980	6a 01 			push	1
	*** 000982	6a 0f 			push	15	;000fH
	*** 000984	9a 00 00 00 00 		call	FAR PTR ?write_bit@@ZAXHH@Z	; write_bit
	*** 000989	83 c4 04 		add	sp,4
;|***     }
; Line 766
;|*** 
;|***   // ballast blow
;|***   if(commands.ballast & ALL_BLOW)
; Line 769
					$I3736:
	*** 00098c	8e 06 00 00 		mov	es,WORD PTR $T4071
	*** 000990	26 f6 06 0e 00 01 	test	BYTE PTR es:?commands@@3UCOMMANDS@@E+14,1	;commands
	*** 000996	75 03 			jne	$JCC2454
	*** 000998	e9 54 00 		jmp	$I3737
					$JCC2454:
;|***     {
; Line 770
;|***     write_bit(PUMP,   PUMPON);
; Line 771
	*** 00099b	6a 00 			push	0
	*** 00099d	6a 10 			push	16	;0010H
	*** 00099f	9a 00 00 00 00 		call	FAR PTR ?write_bit@@ZAXHH@Z	; write_bit
	*** 0009a4	83 c4 04 		add	sp,4
;|***     write_bit(VALVE1, VALVEON);
; Line 772
	*** 0009a7	6a 00 			push	0
	*** 0009a9	6a 0a 			push	10	;000aH
	*** 0009ab	9a 00 00 00 00 		call	FAR PTR ?write_bit@@ZAXHH@Z	; write_bit
	*** 0009b0	83 c4 04 		add	sp,4
;|***     write_bit(VALVE2, VALVEOFF);
; Line 773
	*** 0009b3	6a 01 			push	1
	*** 0009b5	6a 0b 			push	11	;000bH
	*** 0009b7	9a 00 00 00 00 		call	FAR PTR ?write_bit@@ZAXHH@Z	; write_bit
	*** 0009bc	83 c4 04 		add	sp,4
;|***     write_bit(VALVE3, VALVEOFF);
; Line 774
	*** 0009bf	6a 01 			push	1
	*** 0009c1	6a 0c 			push	12	;000cH
	*** 0009c3	9a 00 00 00 00 		call	FAR PTR ?write_bit@@ZAXHH@Z	; write_bit
	*** 0009c8	83 c4 04 		add	sp,4
;|***     write_bit(VALVE4, VALVEON);
; Line 775
	*** 0009cb	6a 00 			push	0
	*** 0009cd	6a 0d 			push	13	;000dH
	*** 0009cf	9a 00 00 00 00 		call	FAR PTR ?write_bit@@ZAXHH@Z	; write_bit
	*** 0009d4	83 c4 04 		add	sp,4
;|***     write_bit(VALVE5, VALVEON);
; Line 776
	*** 0009d7	6a 00 			push	0
	*** 0009d9	6a 0e 			push	14	;000eH
	*** 0009db	9a 00 00 00 00 		call	FAR PTR ?write_bit@@ZAXHH@Z	; write_bit
	*** 0009e0	83 c4 04 		add	sp,4
;|***     write_bit(VALVE6, VALVEOFF);
; Line 777
	*** 0009e3	6a 01 			push	1
	*** 0009e5	6a 0f 			push	15	;000fH
	*** 0009e7	9a 00 00 00 00 		call	FAR PTR ?write_bit@@ZAXHH@Z	; write_bit
	*** 0009ec	83 c4 04 		add	sp,4
;|***     }
; Line 778
;|*** 
;|***   // ballast flood
;|***   if(commands.ballast & ALL_FLOOD)
; Line 781
					$I3737:
	*** 0009ef	8e 06 00 00 		mov	es,WORD PTR $T4071
	*** 0009f3	26 f6 06 0e 00 02 	test	BYTE PTR es:?commands@@3UCOMMANDS@@E+14,2	;commands
	*** 0009f9	75 03 			jne	$JCC2553
	*** 0009fb	e9 54 00 		jmp	$I3738
					$JCC2553:
;|***     {
; Line 782
;|***     write_bit(PUMP,   PUMPON);
; Line 783
	*** 0009fe	6a 00 			push	0
	*** 000a00	6a 10 			push	16	;0010H
	*** 000a02	9a 00 00 00 00 		call	FAR PTR ?write_bit@@ZAXHH@Z	; write_bit
	*** 000a07	83 c4 04 		add	sp,4
;|***     write_bit(VALVE1, VALVEOFF);
; Line 784
	*** 000a0a	6a 01 			push	1
	*** 000a0c	6a 0a 			push	10	;000aH
	*** 000a0e	9a 00 00 00 00 		call	FAR PTR ?write_bit@@ZAXHH@Z	; write_bit
	*** 000a13	83 c4 04 		add	sp,4
;|***     write_bit(VALVE2, VALVEON);
; Line 785
	*** 000a16	6a 00 			push	0
	*** 000a18	6a 0b 			push	11	;000bH
	*** 000a1a	9a 00 00 00 00 		call	FAR PTR ?write_bit@@ZAXHH@Z	; write_bit
	*** 000a1f	83 c4 04 		add	sp,4
;|***     write_bit(VALVE3, VALVEON);
; Line 786
	*** 000a22	6a 00 			push	0
	*** 000a24	6a 0c 			push	12	;000cH
	*** 000a26	9a 00 00 00 00 		call	FAR PTR ?write_bit@@ZAXHH@Z	; write_bit
	*** 000a2b	83 c4 04 		add	sp,4
;|***     write_bit(VALVE4, VALVEOFF);
; Line 787
	*** 000a2e	6a 01 			push	1
	*** 000a30	6a 0d 			push	13	;000dH
	*** 000a32	9a 00 00 00 00 		call	FAR PTR ?write_bit@@ZAXHH@Z	; write_bit
	*** 000a37	83 c4 04 		add	sp,4
;|***     write_bit(VALVE5, VALVEOFF);
; Line 788
	*** 000a3a	6a 01 			push	1
	*** 000a3c	6a 0e 			push	14	;000eH
	*** 000a3e	9a 00 00 00 00 		call	FAR PTR ?write_bit@@ZAXHH@Z	; write_bit
	*** 000a43	83 c4 04 		add	sp,4
;|***     write_bit(VALVE6, VALVEON);
; Line 789
	*** 000a46	6a 00 			push	0
	*** 000a48	6a 0f 			push	15	;000fH
	*** 000a4a	9a 00 00 00 00 		call	FAR PTR ?write_bit@@ZAXHH@Z	; write_bit
	*** 000a4f	83 c4 04 		add	sp,4
;|***     }
; Line 790
;|***     
;|***   // trim forward
;|***   if(commands.ballast & TRIM_FORWARD)
; Line 793
					$I3738:
	*** 000a52	8e 06 00 00 		mov	es,WORD PTR $T4071
	*** 000a56	26 f6 06 0e 00 04 	test	BYTE PTR es:?commands@@3UCOMMANDS@@E+14,4	;commands
	*** 000a5c	75 03 			jne	$JCC2652
	*** 000a5e	e9 54 00 		jmp	$I3739
					$JCC2652:
;|***     {
; Line 794
;|***     write_bit(PUMP,   PUMPON);
; Line 795
	*** 000a61	6a 00 			push	0
	*** 000a63	6a 10 			push	16	;0010H
	*** 000a65	9a 00 00 00 00 		call	FAR PTR ?write_bit@@ZAXHH@Z	; write_bit
	*** 000a6a	83 c4 04 		add	sp,4
;|***     write_bit(VALVE1, VALVEOFF);
; Line 796
	*** 000a6d	6a 01 			push	1
	*** 000a6f	6a 0a 			push	10	;000aH
	*** 000a71	9a 00 00 00 00 		call	FAR PTR ?write_bit@@ZAXHH@Z	; write_bit
	*** 000a76	83 c4 04 		add	sp,4
;|***     write_bit(VALVE2, VALVEON);
; Line 797
	*** 000a79	6a 00 			push	0
	*** 000a7b	6a 0b 			push	11	;000bH
	*** 000a7d	9a 00 00 00 00 		call	FAR PTR ?write_bit@@ZAXHH@Z	; write_bit
	*** 000a82	83 c4 04 		add	sp,4
;|***     write_bit(VALVE3, VALVEOFF);
; Line 798
	*** 000a85	6a 01 			push	1
	*** 000a87	6a 0c 			push	12	;000cH
	*** 000a89	9a 00 00 00 00 		call	FAR PTR ?write_bit@@ZAXHH@Z	; write_bit
	*** 000a8e	83 c4 04 		add	sp,4
;|***     write_bit(VALVE4, VALVEOFF);
; Line 799
	*** 000a91	6a 01 			push	1
	*** 000a93	6a 0d 			push	13	;000dH
	*** 000a95	9a 00 00 00 00 		call	FAR PTR ?write_bit@@ZAXHH@Z	; write_bit
	*** 000a9a	83 c4 04 		add	sp,4
;|***     write_bit(VALVE5, VALVEON);
; Line 800
	*** 000a9d	6a 00 			push	0
	*** 000a9f	6a 0e 			push	14	;000eH
	*** 000aa1	9a 00 00 00 00 		call	FAR PTR ?write_bit@@ZAXHH@Z	; write_bit
	*** 000aa6	83 c4 04 		add	sp,4
;|***     write_bit(VALVE6, VALVEOFF);
; Line 801
	*** 000aa9	6a 01 			push	1
	*** 000aab	6a 0f 			push	15	;000fH
	*** 000aad	9a 00 00 00 00 		call	FAR PTR ?write_bit@@ZAXHH@Z	; write_bit
	*** 000ab2	83 c4 04 		add	sp,4
;|***     }
; Line 802
;|***     
;|***   // trim aft
;|***   if(commands.ballast & TRIM_AFT)
; Line 805
					$I3739:
	*** 000ab5	8e 06 00 00 		mov	es,WORD PTR $T4071
	*** 000ab9	26 f6 06 0e 00 08 	test	BYTE PTR es:?commands@@3UCOMMANDS@@E+14,8	;commands
	*** 000abf	75 03 			jne	$JCC2751
	*** 000ac1	e9 54 00 		jmp	$I3740
					$JCC2751:
;|***     {
; Line 806
;|***     write_bit(PUMP,   PUMPON);
; Line 807
	*** 000ac4	6a 00 			push	0
	*** 000ac6	6a 10 			push	16	;0010H
	*** 000ac8	9a 00 00 00 00 		call	FAR PTR ?write_bit@@ZAXHH@Z	; write_bit
	*** 000acd	83 c4 04 		add	sp,4
;|***     write_bit(VALVE1, VALVEOFF);
; Line 808
	*** 000ad0	6a 01 			push	1
	*** 000ad2	6a 0a 			push	10	;000aH
	*** 000ad4	9a 00 00 00 00 		call	FAR PTR ?write_bit@@ZAXHH@Z	; write_bit
	*** 000ad9	83 c4 04 		add	sp,4
;|***     write_bit(VALVE2, VALVEOFF);
; Line 809
	*** 000adc	6a 01 			push	1
	*** 000ade	6a 0b 			push	11	;000bH
	*** 000ae0	9a 00 00 00 00 		call	FAR PTR ?write_bit@@ZAXHH@Z	; write_bit
	*** 000ae5	83 c4 04 		add	sp,4
;|***     write_bit(VALVE3, VALVEON);
; Line 810
	*** 000ae8	6a 00 			push	0
	*** 000aea	6a 0c 			push	12	;000cH
	*** 000aec	9a 00 00 00 00 		call	FAR PTR ?write_bit@@ZAXHH@Z	; write_bit
	*** 000af1	83 c4 04 		add	sp,4
;|***     write_bit(VALVE4, VALVEON);
; Line 811
	*** 000af4	6a 00 			push	0
	*** 000af6	6a 0d 			push	13	;000dH
	*** 000af8	9a 00 00 00 00 		call	FAR PTR ?write_bit@@ZAXHH@Z	; write_bit
	*** 000afd	83 c4 04 		add	sp,4
;|***     write_bit(VALVE5, VALVEOFF);
; Line 812
	*** 000b00	6a 01 			push	1
	*** 000b02	6a 0e 			push	14	;000eH
	*** 000b04	9a 00 00 00 00 		call	FAR PTR ?write_bit@@ZAXHH@Z	; write_bit
	*** 000b09	83 c4 04 		add	sp,4
;|***     write_bit(VALVE6, VALVEOFF);
; Line 813
	*** 000b0c	6a 01 			push	1
	*** 000b0e	6a 0f 			push	15	;000fH
	*** 000b10	9a 00 00 00 00 		call	FAR PTR ?write_bit@@ZAXHH@Z	; write_bit
	*** 000b15	83 c4 04 		add	sp,4
;|***     }
; Line 814
;|***   
;|***   // templates for future ballast features when implemened
;|***   // forward blow
;|***   if(commands.ballast & FORWARD_BLOW)
; Line 818
					$I3740:
	*** 000b18	8e 06 00 00 		mov	es,WORD PTR $T4071
	*** 000b1c	26 f6 06 0e 00 10 	test	BYTE PTR es:?commands@@3UCOMMANDS@@E+14,16	;0010H	;commands
	*** 000b22	75 03 			jne	$JCC2850
	*** 000b24	e9 00 00 		jmp	$I3741
					$JCC2850:
;|***     {
; Line 819
;|***     }
; Line 820
;|***   
;|***   // forward flood
;|***   if(commands.ballast & FORWARD_FLOOD)
; Line 823
					$I3741:
	*** 000b27	8e 06 00 00 		mov	es,WORD PTR $T4071
	*** 000b2b	26 f6 06 0e 00 20 	test	BYTE PTR es:?commands@@3UCOMMANDS@@E+14,32	;0020H	;commands
	*** 000b31	75 03 			jne	$JCC2865
	*** 000b33	e9 00 00 		jmp	$I3742
					$JCC2865:
;|***     {
; Line 824
;|***     }
; Line 825
;|***   
;|***   // aft blow
;|***   if(commands.ballast & AFT_BLOW)
; Line 828
					$I3742:
	*** 000b36	8e 06 00 00 		mov	es,WORD PTR $T4071
	*** 000b3a	26 f6 06 0e 00 40 	test	BYTE PTR es:?commands@@3UCOMMANDS@@E+14,64	;0040H	;commands
	*** 000b40	75 03 			jne	$JCC2880
	*** 000b42	e9 00 00 		jmp	$I3743
					$JCC2880:
;|***     {
; Line 829
;|***     }
; Line 830
;|***     
;|***   // aft flood
;|***   if(commands.ballast & AFT_FLOOD)
; Line 833
					$I3743:
	*** 000b45	8e 06 00 00 		mov	es,WORD PTR $T4071
	*** 000b49	26 f6 06 0e 00 80 	test	BYTE PTR es:?commands@@3UCOMMANDS@@E+14,128	;0080H	;commands
	*** 000b4f	75 03 			jne	$JCC2895
	*** 000b51	e9 00 00 		jmp	$I3744
					$JCC2895:
;|***     {
; Line 834
;|***     }
; Line 835
;|***  
;|***   if(commands.ds_send_message != 0)
; Line 837
					$I3744:
	*** 000b54	8e 06 00 00 		mov	es,WORD PTR $T4071
	*** 000b58	26 83 3e 1a 00 00 	cmp	WORD PTR es:?commands@@3UCOMMANDS@@E+26,0	;commands
	*** 000b5e	75 03 			jne	$JCC2910
	*** 000b60	e9 06 00 		jmp	$I3745
					$JCC2910:
;|***     {     
; Line 838
;|***       send_message = 0;
; Line 839
	*** 000b63	c7 06 00 00 00 00 	mov	WORD PTR ?send_message@@3HE,0	;send_message
;|***     //sjc send_message = 1;
;|*** //    _fmemcpy(&acoustic_message, &commands.ds_dmgx1, sizeof(acoustic_message));
;|***     }
; Line 842
;|***   }
; Line 843
					$I3745:
	*** 000b69	e9 00 00 		jmp	$EX3694
					$EX3694:
	*** 000b6c	5e 			pop	si
	*** 000b6d	5f 			pop	di
	*** 000b6e	c9 			leave	
	*** 000b6f	cb 			ret	

?apply_commands@@ZAXXZ	ENDP
DMMTEST_TEXT      ENDS
CONST      SEGMENT
$T4073	DD	045dc32adr   ;	7046.3345
CONST      ENDS
DMMTEST_TEXT      SEGMENT
	ASSUME	CS: DMMTEST_TEXT
	PUBLIC	?configure_obc@@ZAXXZ	; configure_obc
?configure_obc@@ZAXXZ	PROC FAR	; configure_obc
;|***         
;|***   
;|*** void configure_obc(void)
;|***   {
; Line 847
	*** 000b70	c8 00 00 00 		enter	0,0
	*** 000b74	57 			push	di
	*** 000b75	56 			push	si
;|***   //for(unsigned i=0; i<88; i++) adcp_test[i] = (unsigned char) i;
;|***   
;|***   rpm_sf = 60.0f * 1000000.0f / 0.838097f / 10160.0f;
; Line 850
	*** 000b76	a1 00 00 		mov	ax,WORD PTR $T4073
	*** 000b79	8b 16 02 00 		mov	dx,WORD PTR $T4073+2
	*** 000b7d	a3 00 00 		mov	WORD PTR ?rpm_sf@@3ME,ax	;rpm_sf
	*** 000b80	89 16 02 00 		mov	WORD PTR ?rpm_sf@@3ME+2,dx	;rpm_sf
;|***   
;|***   sys_timer.high = 0;
; Line 852
	*** 000b84	8e 06 00 00 		mov	es,WORD PTR $T4071
	*** 000b88	2b c0 			sub	ax,ax
	*** 000b8a	26 a3 02 00 		mov	WORD PTR es:?sys_timer@@3UTIMER@@E+2,ax	;sys_timer
	*** 000b8e	26 a3 00 00 		mov	WORD PTR es:?sys_timer@@3UTIMER@@E,ax	;sys_timer
;|***   sys_timer.low = 0;
; Line 853
	*** 000b92	26 c7 06 04 00 00 00 	mov	WORD PTR es:?sys_timer@@3UTIMER@@E+4,0	;sys_timer
;|***   
;|***   frame = 0;
; Line 855
	*** 000b99	2b c0 			sub	ax,ax
	*** 000b9b	a3 02 00 		mov	WORD PTR ?frame@@3KE+2,ax	;frame
	*** 000b9e	a3 00 00 		mov	WORD PTR ?frame@@3KE,ax	;frame
;|***   next_frame = frame;
; Line 856
	*** 000ba1	a1 00 00 		mov	ax,WORD PTR ?frame@@3KE	;frame
	*** 000ba4	8b 16 02 00 		mov	dx,WORD PTR ?frame@@3KE+2	;frame
	*** 000ba8	a3 00 00 		mov	WORD PTR ?next_frame@@3KE,ax	;next_frame
	*** 000bab	89 16 02 00 		mov	WORD PTR ?next_frame@@3KE+2,dx	;next_frame
;|***   
;|***   sys.packet_type = 0xf0c1;   // obc data packet identifier
; Line 858
	*** 000baf	8e 06 00 00 		mov	es,WORD PTR $T4071
	*** 000bb3	26 c7 06 00 00 c1 f0 	mov	WORD PTR es:?sys@@3USYS@@E,-3903	;f0c1H	;sys
;|***   sys.packet_number = 0xfffe;
; Line 859
	*** 000bba	26 c7 06 02 00 fe ff 	mov	WORD PTR es:?sys@@3USYS@@E+2,-2	;fffeH	;sys
;|***   sys.fs_status = 0;
; Line 860
	*** 000bc1	26 c7 06 08 00 00 00 	mov	WORD PTR es:?sys@@3USYS@@E+8,0	;sys
;|***   sys.op_status = 0;
; Line 861
	*** 000bc8	26 c7 06 0a 00 00 00 	mov	WORD PTR es:?sys@@3USYS@@E+10,0	;sys
;|***   
;|***   obs.new_data = 0;
; Line 863
	*** 000bcf	8e 06 00 00 		mov	es,WORD PTR $T4071
	*** 000bd3	26 c7 06 00 00 00 00 	mov	WORD PTR es:?obs@@3UOBS@@E,0	;obs
;|***   obs.frame = frame;
; Line 864
	*** 000bda	a1 00 00 		mov	ax,WORD PTR ?frame@@3KE	;frame
	*** 000bdd	8b 16 02 00 		mov	dx,WORD PTR ?frame@@3KE+2	;frame
	*** 000be1	26 a3 02 00 		mov	WORD PTR es:?obs@@3UOBS@@E+2,ax	;obs
	*** 000be5	26 89 16 04 00 		mov	WORD PTR es:?obs@@3UOBS@@E+4,dx	;obs
;|***   
;|***   dyno.new_data = 0;
; Line 866
	*** 000bea	8e 06 00 00 		mov	es,WORD PTR $T4071
	*** 000bee	26 c7 06 00 00 00 00 	mov	WORD PTR es:?dyno@@3UDYNO@@E,0	;dyno
;|***   obs.frame = frame;
; Line 867
	*** 000bf5	a1 00 00 		mov	ax,WORD PTR ?frame@@3KE	;frame
	*** 000bf8	8b 16 02 00 		mov	dx,WORD PTR ?frame@@3KE+2	;frame
	*** 000bfc	8e 06 00 00 		mov	es,WORD PTR $T4071
	*** 000c00	26 a3 02 00 		mov	WORD PTR es:?obs@@3UOBS@@E+2,ax	;obs
	*** 000c04	26 89 16 04 00 		mov	WORD PTR es:?obs@@3UOBS@@E+4,dx	;obs
;|***   
;|***   prop.new_data = 0;
; Line 869
	*** 000c09	8e 06 00 00 		mov	es,WORD PTR $T4071
	*** 000c0d	26 c7 06 00 00 00 00 	mov	WORD PTR es:?prop@@3UPROP@@E,0	;prop
;|***   prop.frame = frame;
; Line 870
	*** 000c14	a1 00 00 		mov	ax,WORD PTR ?frame@@3KE	;frame
	*** 000c17	8b 16 02 00 		mov	dx,WORD PTR ?frame@@3KE+2	;frame
	*** 000c1b	26 a3 02 00 		mov	WORD PTR es:?prop@@3UPROP@@E+2,ax	;prop
	*** 000c1f	26 89 16 04 00 		mov	WORD PTR es:?prop@@3UPROP@@E+4,dx	;prop
;|***   
;|***   ln200.new_data = 0;
; Line 872
	*** 000c24	8e 06 00 00 		mov	es,WORD PTR $T4071
	*** 000c28	26 c7 06 00 00 00 00 	mov	WORD PTR es:?ln200@@3ULN200@@E,0	;ln200
;|***   ln200.frame = frame;
; Line 873
	*** 000c2f	a1 00 00 		mov	ax,WORD PTR ?frame@@3KE	;frame
	*** 000c32	8b 16 02 00 		mov	dx,WORD PTR ?frame@@3KE+2	;frame
	*** 000c36	26 a3 02 00 		mov	WORD PTR es:?ln200@@3ULN200@@E+2,ax	;ln200
	*** 000c3a	26 89 16 04 00 		mov	WORD PTR es:?ln200@@3ULN200@@E+4,dx	;ln200
;|***   
;|***   echo.new_data = 0;
; Line 875
	*** 000c3f	8e 06 00 00 		mov	es,WORD PTR $T4071
	*** 000c43	26 c7 06 00 00 00 00 	mov	WORD PTR es:?echo@@3UECHO@@E,0	;echo
;|***   echo.frame = frame;
; Line 876
	*** 000c4a	a1 00 00 		mov	ax,WORD PTR ?frame@@3KE	;frame
	*** 000c4d	8b 16 02 00 		mov	dx,WORD PTR ?frame@@3KE+2	;frame
	*** 000c51	26 a3 02 00 		mov	WORD PTR es:?echo@@3UECHO@@E+2,ax	;echo
	*** 000c55	26 89 16 04 00 		mov	WORD PTR es:?echo@@3UECHO@@E+4,dx	;echo
;|***   
;|***   ds.new_data = 0;
; Line 878
	*** 000c5a	8e 06 00 00 		mov	es,WORD PTR $T4071
	*** 000c5e	26 c7 06 00 00 00 00 	mov	WORD PTR es:?ds@@3UDS@@E,0	;ds
;|***   ds.frame = frame;
; Line 879
	*** 000c65	a1 00 00 		mov	ax,WORD PTR ?frame@@3KE	;frame
	*** 000c68	8b 16 02 00 		mov	dx,WORD PTR ?frame@@3KE+2	;frame
	*** 000c6c	26 a3 02 00 		mov	WORD PTR es:?ds@@3UDS@@E+2,ax	;ds
	*** 000c70	26 89 16 04 00 		mov	WORD PTR es:?ds@@3UDS@@E+4,dx	;ds
;|***   
;|***   adcp.new_data = 0;
; Line 881
	*** 000c75	8e 06 00 00 		mov	es,WORD PTR $T4071
	*** 000c79	26 c7 06 00 00 00 00 	mov	WORD PTR es:?adcp@@3UADCP@@E,0	;adcp
;|***   adcp.frame = frame;
; Line 882
	*** 000c80	a1 00 00 		mov	ax,WORD PTR ?frame@@3KE	;frame
	*** 000c83	8b 16 02 00 		mov	dx,WORD PTR ?frame@@3KE+2	;frame
	*** 000c87	26 a3 02 00 		mov	WORD PTR es:?adcp@@3UADCP@@E+2,ax	;adcp
	*** 000c8b	26 89 16 04 00 		mov	WORD PTR es:?adcp@@3UADCP@@E+4,dx	;adcp
;|***   
;|***   init_io(UIO48BASE);
; Line 884
	*** 000c90	68 20 01 		push	288	;0120H
	*** 000c93	9a 00 00 00 00 		call	FAR PTR ?init_io@@ZAXI@Z	; init_io
	*** 000c98	83 c4 02 		add	sp,2
;|***   write_bit(PUMP,   PUMPOFF);
; Line 885
	*** 000c9b	6a 01 			push	1
	*** 000c9d	6a 10 			push	16	;0010H
	*** 000c9f	9a 00 00 00 00 		call	FAR PTR ?write_bit@@ZAXHH@Z	; write_bit
	*** 000ca4	83 c4 04 		add	sp,4
;|***   write_bit(VALVE1, VALVEOFF);
; Line 886
	*** 000ca7	6a 01 			push	1
	*** 000ca9	6a 0a 			push	10	;000aH
	*** 000cab	9a 00 00 00 00 		call	FAR PTR ?write_bit@@ZAXHH@Z	; write_bit
	*** 000cb0	83 c4 04 		add	sp,4
;|***   write_bit(VALVE2, VALVEOFF);
; Line 887
	*** 000cb3	6a 01 			push	1
	*** 000cb5	6a 0b 			push	11	;000bH
	*** 000cb7	9a 00 00 00 00 		call	FAR PTR ?write_bit@@ZAXHH@Z	; write_bit
	*** 000cbc	83 c4 04 		add	sp,4
;|***   write_bit(VALVE3, VALVEOFF);
; Line 888
	*** 000cbf	6a 01 			push	1
	*** 000cc1	6a 0c 			push	12	;000cH
	*** 000cc3	9a 00 00 00 00 		call	FAR PTR ?write_bit@@ZAXHH@Z	; write_bit
	*** 000cc8	83 c4 04 		add	sp,4
;|***   write_bit(VALVE4, VALVEOFF);
; Line 889
	*** 000ccb	6a 01 			push	1
	*** 000ccd	6a 0d 			push	13	;000dH
	*** 000ccf	9a 00 00 00 00 		call	FAR PTR ?write_bit@@ZAXHH@Z	; write_bit
	*** 000cd4	83 c4 04 		add	sp,4
;|***   write_bit(VALVE5, VALVEOFF);
; Line 890
	*** 000cd7	6a 01 			push	1
	*** 000cd9	6a 0e 			push	14	;000eH
	*** 000cdb	9a 00 00 00 00 		call	FAR PTR ?write_bit@@ZAXHH@Z	; write_bit
	*** 000ce0	83 c4 04 		add	sp,4
;|***   write_bit(VALVE6, VALVEOFF);
; Line 891
	*** 000ce3	6a 01 			push	1
	*** 000ce5	6a 0f 			push	15	;000fH
	*** 000ce7	9a 00 00 00 00 		call	FAR PTR ?write_bit@@ZAXHH@Z	; write_bit
	*** 000cec	83 c4 04 		add	sp,4
;|***   write_bit(ERS,    ERSNOBLOW);
; Line 892
	*** 000cef	6a 01 			push	1
	*** 000cf1	6a 12 			push	18	;0012H
	*** 000cf3	9a 00 00 00 00 		call	FAR PTR ?write_bit@@ZAXHH@Z	; write_bit
	*** 000cf8	83 c4 04 		add	sp,4
;|***   write_bit(PFSVENTBLOW, PFSBLOW);
; Line 893
	*** 000cfb	6a 00 			push	0
	*** 000cfd	6a 09 			push	9
	*** 000cff	9a 00 00 00 00 		call	FAR PTR ?write_bit@@ZAXHH@Z	; write_bit
	*** 000d04	83 c4 04 		add	sp,4
;|*** 
;|***   configure_escc();
; Line 895
	*** 000d07	9a 00 00 00 00 		call	FAR PTR ?configure_escc@@ZAXXZ	; configure_escc
;|***   //while(!kbhit());  getch();
;|***   init_tech80();
; Line 897
	*** 000d0c	9a 00 00 00 00 		call	FAR PTR ?init_tech80@@ZAXXZ	; init_tech80
;|***   //while(!kbhit());  getch();
;|***   //init_sys_timer();
;|***   init_com1();
; Line 900
	*** 000d11	9a 00 00 00 00 		call	FAR PTR ?init_com1@@ZAXXZ	; init_com1
;|***   //while(!kbhit());  getch();
;|***   init_com2();
; Line 902
	*** 000d16	9a 00 00 00 00 		call	FAR PTR ?init_com2@@ZAXXZ	; init_com2
;|***   //while(!kbhit());  getch();
;|***   init_com4();
; Line 904
	*** 000d1b	9a 00 00 00 00 		call	FAR PTR ?init_com4@@ZAXXZ	; init_com4
;|***   //while(!kbhit());  getch();
;|***   configure_enet();
; Line 906
	*** 000d20	9a 00 00 00 00 		call	FAR PTR ?configure_enet@@ZAXXZ	; configure_enet
;|***   //while(!kbhit());  getch();
;|***   configure_dmm32a(); // onboard sensor adc
; Line 908
	*** 000d25	9a 00 00 00 00 		call	FAR PTR ?configure_dmm32a@@ZAXXZ	; configure_dmm32a
;|***   //while(!kbhit());  getch();
;|***   configure_dmm32b(); // dyno adc
; Line 910
	*** 000d2a	9a 00 00 00 00 		call	FAR PTR ?configure_dmm32b@@ZAXXZ	; configure_dmm32b
;|***   //while(!kbhit());  getch();
;|***   init_screen();
; Line 912
	*** 000d2f	9a 00 00 00 00 		call	FAR PTR ?init_screen@@ZAXXZ	; init_screen
;|***   }
; Line 913
	*** 000d34	e9 00 00 		jmp	$EX3747
					$EX3747:
	*** 000d37	5e 			pop	si
	*** 000d38	5f 			pop	di
	*** 000d39	c9 			leave	
	*** 000d3a	cb 			ret	

?configure_obc@@ZAXXZ	ENDP
	PUBLIC	?init_tech80@@ZAXXZ	; init_tech80
?init_tech80@@ZAXXZ	PROC FAR	; init_tech80
;|*** 
;|*** 
;|*** void init_tech80(void)
;|***   {
; Line 917
	*** 000d3b	c8 00 00 00 		enter	0,0
	*** 000d3f	57 			push	di
	*** 000d40	56 			push	si
;|***   cout << "te5650InitSw:    " << hex << te5650InitSw() << dec << endl;
; Line 918
	*** 000d41	68 00 00 		push	SEG ?endl@@ZAAEVostream@@AEV1@@Z	;endl
	*** 000d44	68 00 00 		push	OFFSET ?endl@@ZAAEVostream@@AEV1@@Z	;endl
	*** 000d47	68 00 00 		push	SEG ?dec@@ZAAEVios@@AEV1@@Z	;dec
	*** 000d4a	68 00 00 		push	OFFSET ?dec@@ZAAEVios@@AEV1@@Z	;dec
	*** 000d4d	9a 00 00 00 00 		call	FAR PTR _te5650InitSw
	*** 000d52	50 			push	ax
	*** 000d53	68 00 00 		push	SEG ?hex@@ZAAEVios@@AEV1@@Z	;hex
	*** 000d56	68 00 00 		push	OFFSET ?hex@@ZAAEVios@@AEV1@@Z	;hex
	*** 000d59	1e 			push	ds
	*** 000d5a	68 00 00 		push	OFFSET DGROUP:$SG3750
	*** 000d5d	68 00 00 		push	SEG ?cout@@3Vostream_withassign@@E	;cout
	*** 000d60	68 00 00 		push	OFFSET ?cout@@3Vostream_withassign@@E	;cout
	*** 000d63	9a 00 00 00 00 		call	FAR PTR ??6ostream@@RECAEV0@PFD@Z	; ostream::operator<<
	*** 000d68	52 			push	dx
	*** 000d69	50 			push	ax
	*** 000d6a	9a 00 00 00 00 		call	FAR PTR ??6ostream@@RECAEV0@P7AAEVios@@AEV1@@Z@Z	; ostream::operator<<
	*** 000d6f	52 			push	dx
	*** 000d70	50 			push	ax
	*** 000d71	9a 00 00 00 00 		call	FAR PTR ??6ostream@@RECAEV0@F@Z	; ostream::operator<<
	*** 000d76	52 			push	dx
	*** 000d77	50 			push	ax
	*** 000d78	9a 00 00 00 00 		call	FAR PTR ??6ostream@@RECAEV0@P7AAEVios@@AEV1@@Z@Z	; ostream::operator<<
	*** 000d7d	52 			push	dx
	*** 000d7e	50 			push	ax
	*** 000d7f	9a 00 00 00 00 		call	FAR PTR ??6ostream@@RECAEV0@P7AAEV0@AEV0@@Z@Z	; ostream::operator<<
;|***   cout << "te5650InitServo: " << te5650InitServo(0x400, TE5650TYPE_DAC16) << endl;
; Line 919
	*** 000d84	68 00 00 		push	SEG ?endl@@ZAAEVostream@@AEV1@@Z	;endl
	*** 000d87	68 00 00 		push	OFFSET ?endl@@ZAAEVostream@@AEV1@@Z	;endl
	*** 000d8a	6a 00 			push	0
	*** 000d8c	68 00 04 		push	1024	;0400H
	*** 000d8f	9a 00 00 00 00 		call	FAR PTR _te5650InitServo
	*** 000d94	83 c4 04 		add	sp,4
	*** 000d97	50 			push	ax
	*** 000d98	1e 			push	ds
	*** 000d99	68 00 00 		push	OFFSET DGROUP:$SG3751
	*** 000d9c	68 00 00 		push	SEG ?cout@@3Vostream_withassign@@E	;cout
	*** 000d9f	68 00 00 		push	OFFSET ?cout@@3Vostream_withassign@@E	;cout
	*** 000da2	9a 00 00 00 00 		call	FAR PTR ??6ostream@@RECAEV0@PFD@Z	; ostream::operator<<
	*** 000da7	52 			push	dx
	*** 000da8	50 			push	ax
	*** 000da9	9a 00 00 00 00 		call	FAR PTR ??6ostream@@RECAEV0@F@Z	; ostream::operator<<
	*** 000dae	52 			push	dx
	*** 000daf	50 			push	ax
	*** 000db0	9a 00 00 00 00 		call	FAR PTR ??6ostream@@RECAEV0@P7AAEV0@AEV0@@Z@Z	; ostream::operator<<
;|***   cout << "te5650SetAxis:   " << te5650SetAxis(1,1) << endl;
; Line 920
	*** 000db5	68 00 00 		push	SEG ?endl@@ZAAEVostream@@AEV1@@Z	;endl
	*** 000db8	68 00 00 		push	OFFSET ?endl@@ZAAEVostream@@AEV1@@Z	;endl
	*** 000dbb	6a 01 			push	1
	*** 000dbd	6a 01 			push	1
	*** 000dbf	9a 00 00 00 00 		call	FAR PTR _te5650SetAxis
	*** 000dc4	83 c4 04 		add	sp,4
	*** 000dc7	50 			push	ax
	*** 000dc8	1e 			push	ds
	*** 000dc9	68 00 00 		push	OFFSET DGROUP:$SG3752
	*** 000dcc	68 00 00 		push	SEG ?cout@@3Vostream_withassign@@E	;cout
	*** 000dcf	68 00 00 		push	OFFSET ?cout@@3Vostream_withassign@@E	;cout
	*** 000dd2	9a 00 00 00 00 		call	FAR PTR ??6ostream@@RECAEV0@PFD@Z	; ostream::operator<<
	*** 000dd7	52 			push	dx
	*** 000dd8	50 			push	ax
	*** 000dd9	9a 00 00 00 00 		call	FAR PTR ??6ostream@@RECAEV0@F@Z	; ostream::operator<<
	*** 000dde	52 			push	dx
	*** 000ddf	50 			push	ax
	*** 000de0	9a 00 00 00 00 		call	FAR PTR ??6ostream@@RECAEV0@P7AAEV0@AEV0@@Z@Z	; ostream::operator<<
;|***   te5650PhasesPolarity(1,1,1);  // prop encoder A,B,I phase polarity
; Line 921
	*** 000de5	6a 01 			push	1
	*** 000de7	6a 01 			push	1
	*** 000de9	6a 01 			push	1
	*** 000deb	9a 00 00 00 00 		call	FAR PTR _te5650PhasesPolarity
	*** 000df0	83 c4 06 		add	sp,6
;|***   te5650Update();
; Line 922
	*** 000df3	9a 00 00 00 00 		call	FAR PTR _te5650Update
;|***   te5650CaptureIndex();  
; Line 923
	*** 000df8	9a 00 00 00 00 		call	FAR PTR _te5650CaptureIndex
;|***   te5650Update();
; Line 924
	*** 000dfd	9a 00 00 00 00 		call	FAR PTR _te5650Update
;|***   te5650ResetCapture();
; Line 925
	*** 000e02	9a 00 00 00 00 		call	FAR PTR _te5650ResetCapture
;|***   te5650Update();
; Line 926
	*** 000e07	9a 00 00 00 00 		call	FAR PTR _te5650Update
;|***   te5650MotorOff();
; Line 927
	*** 000e0c	9a 00 00 00 00 		call	FAR PTR _te5650MotorOff
;|***   te5650Update();
; Line 928
	*** 000e11	9a 00 00 00 00 		call	FAR PTR _te5650Update
;|***   te5650SetMotor(0);
; Line 929
	*** 000e16	6a 00 			push	0
	*** 000e18	9a 00 00 00 00 		call	FAR PTR _te5650SetMotor
	*** 000e1d	83 c4 02 		add	sp,2
;|***   te5650Update();
; Line 930
	*** 000e20	9a 00 00 00 00 		call	FAR PTR _te5650Update
;|***   cout << "Tech80 5650 Installed." << endl;
; Line 931
	*** 000e25	68 00 00 		push	SEG ?endl@@ZAAEVostream@@AEV1@@Z	;endl
	*** 000e28	68 00 00 		push	OFFSET ?endl@@ZAAEVostream@@AEV1@@Z	;endl
	*** 000e2b	1e 			push	ds
	*** 000e2c	68 00 00 		push	OFFSET DGROUP:$SG3753
	*** 000e2f	68 00 00 		push	SEG ?cout@@3Vostream_withassign@@E	;cout
	*** 000e32	68 00 00 		push	OFFSET ?cout@@3Vostream_withassign@@E	;cout
	*** 000e35	9a 00 00 00 00 		call	FAR PTR ??6ostream@@RECAEV0@PFD@Z	; ostream::operator<<
	*** 000e3a	52 			push	dx
	*** 000e3b	50 			push	ax
	*** 000e3c	9a 00 00 00 00 		call	FAR PTR ??6ostream@@RECAEV0@P7AAEV0@AEV0@@Z@Z	; ostream::operator<<
;|***   }
; Line 932
	*** 000e41	e9 00 00 		jmp	$EX3749
					$EX3749:
	*** 000e44	5e 			pop	si
	*** 000e45	5f 			pop	di
	*** 000e46	c9 			leave	
	*** 000e47	cb 			ret	

?init_tech80@@ZAXXZ	ENDP
	PUBLIC	?init_sys_timer@@ZAXXZ	; init_sys_timer
?init_sys_timer@@ZAXXZ	PROC FAR	; init_sys_timer
;|***   
;|***   
;|*** void init_sys_timer(void)
;|***   {
; Line 936
	*** 000e48	c8 00 00 00 		enter	0,0
	*** 000e4c	57 			push	di
	*** 000e4d	56 			push	si
;|***   rtc_vect = _dos_getvect(0x08);               // save the pc's default rtc isr vector
; Line 937
	*** 000e4e	6a 08 			push	8
	*** 000e50	9a 00 00 00 00 		call	FAR PTR __dos_getvect
	*** 000e55	83 c4 02 		add	sp,2
	*** 000e58	a3 00 00 		mov	WORD PTR ?rtc_vect@@3P7AXXZE,ax	;rtc_vect
	*** 000e5b	89 16 02 00 		mov	WORD PTR ?rtc_vect@@3P7AXXZE+2,dx	;rtc_vect
;|***   _disable();                                  // so we can chain into it later
; Line 938
	*** 000e5f	9a 00 00 00 00 		call	FAR PTR __disable
;|***   _dos_setvect(0x08, sys_timer_isr);           // hook our system timer isr
; Line 939
	*** 000e64	68 00 00 		push	SEG ?sys_timer_isr@@ZAXXZ	;sys_timer_isr
	*** 000e67	68 00 00 		push	OFFSET ?sys_timer_isr@@ZAXXZ	;sys_timer_isr
	*** 000e6a	6a 08 			push	8
	*** 000e6c	9a 00 00 00 00 		call	FAR PTR __dos_setvect
	*** 000e71	83 c4 06 		add	sp,6
;|***   _outp(0x43, CTC0 | LSBMSB | MODE2 | BINARY); // change the pc's 8254 to mode2 operation
; Line 940
	*** 000e74	6a 34 			push	52	;0034H
	*** 000e76	6a 43 			push	67	;0043H
	*** 000e78	9a 00 00 00 00 		call	FAR PTR __outp
	*** 000e7d	83 c4 04 		add	sp,4
;|***   _outp(0x40, 0xff);                           // load timer divisor LSB, then MSB
; Line 941
	*** 000e80	68 ff 00 		push	255	;00ffH
	*** 000e83	6a 40 			push	64	;0040H
	*** 000e85	9a 00 00 00 00 		call	FAR PTR __outp
	*** 000e8a	83 c4 04 		add	sp,4
;|***   _outp(0x40, 0xff);
; Line 942
	*** 000e8d	68 ff 00 		push	255	;00ffH
	*** 000e90	6a 40 			push	64	;0040H
	*** 000e92	9a 00 00 00 00 		call	FAR PTR __outp
	*** 000e97	83 c4 04 		add	sp,4
;|***   _enable();
; Line 943
	*** 000e9a	9a 00 00 00 00 		call	FAR PTR __enable
;|***   }
; Line 944
	*** 000e9f	e9 00 00 		jmp	$EX3755
					$EX3755:
	*** 000ea2	5e 			pop	si
	*** 000ea3	5f 			pop	di
	*** 000ea4	c9 			leave	
	*** 000ea5	cb 			ret	

?init_sys_timer@@ZAXXZ	ENDP
	PUBLIC	?configure_enet@@ZAXXZ	; configure_enet
?configure_enet@@ZAXXZ	PROC FAR	; configure_enet
;|*** 
;|*** 
;|*** void configure_enet(void)
;|***   { 
; Line 948
	*** 000ea6	c8 06 00 00 		enter	6,0
	*** 000eaa	57 			push	di
	*** 000eab	56 			push	si
;	packet_type = -2
;	ptype = -6
;|***   cout << "Initializing packet driver." << endl;
; Line 949
	*** 000eac	68 00 00 		push	SEG ?endl@@ZAAEVostream@@AEV1@@Z	;endl
	*** 000eaf	68 00 00 		push	OFFSET ?endl@@ZAAEVostream@@AEV1@@Z	;endl
	*** 000eb2	1e 			push	ds
	*** 000eb3	68 00 00 		push	OFFSET DGROUP:$SG3758
	*** 000eb6	68 00 00 		push	SEG ?cout@@3Vostream_withassign@@E	;cout
	*** 000eb9	68 00 00 		push	OFFSET ?cout@@3Vostream_withassign@@E	;cout
	*** 000ebc	9a 00 00 00 00 		call	FAR PTR ??6ostream@@RECAEV0@PFD@Z	; ostream::operator<<
	*** 000ec1	52 			push	dx
	*** 000ec2	50 			push	ax
	*** 000ec3	9a 00 00 00 00 		call	FAR PTR ??6ostream@@RECAEV0@P7AAEV0@AEV0@@Z@Z	; ostream::operator<<
;|***   char packet_type[2] = {0x08, 0x00};
; Line 950
	*** 000ec8	c6 46 fe 08 		mov	BYTE PTR [bp-2],8	;packet_type
	*** 000ecc	c6 46 ff 00 		mov	BYTE PTR [bp-1],0
;|***   char far *ptype = packet_type;
; Line 951
	*** 000ed0	8d 46 fe 		lea	ax,WORD PTR [bp-2]	;packet_type
	*** 000ed3	89 46 fa 		mov	WORD PTR [bp-6],ax	;ptype
	*** 000ed6	8c 56 fc 		mov	WORD PTR [bp-4],ss
;|*** 
;|*** /*
;|***   // use at/lantic packet driver
;|***   system("c:\\ne2000\\pktdrv\\atdrive -i 0x7e -b 0x300 -q 10");
;|***   cout << "Access_type() error: " << access_type(1, 52, 0, ptype, 2, receiver) << endl;
;|***   cout << "Handle: " << handle << endl;
;|***   cout << "Set_rcv_mode() error: " << set_rcv_mode(handle, 6) << endl;
;|*** */  
;|***   
;|***   // use ne2000 packet driver
;|***   system("c:\\packet\\pktdrv\\ne2000 0x7e 10 0x300");
; Line 962
	*** 000ed9	1e 			push	ds
	*** 000eda	68 00 00 		push	OFFSET DGROUP:$SG3761
	*** 000edd	9a 00 00 00 00 		call	FAR PTR _system
	*** 000ee2	83 c4 04 		add	sp,4
;|***   cout << "Access_type() error: " << access_type(1, 52, 0, NULL, 0, receiver) << endl;
; Line 963
	*** 000ee5	68 00 00 		push	SEG ?endl@@ZAAEVostream@@AEV1@@Z	;endl
	*** 000ee8	68 00 00 		push	OFFSET ?endl@@ZAAEVostream@@AEV1@@Z	;endl
	*** 000eeb	68 00 00 		push	SEG ?receiver@@ZAXIIIIIIIIIIIII@Z	;receiver
	*** 000eee	68 00 00 		push	OFFSET ?receiver@@ZAXIIIIIIIIIIIII@Z	;receiver
	*** 000ef1	6a 00 			push	0
	*** 000ef3	6a 00 			push	0
	*** 000ef5	6a 00 			push	0
	*** 000ef7	6a 00 			push	0
	*** 000ef9	6a 34 			push	52	;0034H
	*** 000efb	6a 01 			push	1
	*** 000efd	9a 00 00 00 00 		call	FAR PTR ?access_type@@ZAHHHHPEDIP7AXIIIIIIIIIIIII@Z@Z	; access_type
	*** 000f02	83 c4 10 		add	sp,16	;0010H
	*** 000f05	50 			push	ax
	*** 000f06	1e 			push	ds
	*** 000f07	68 00 00 		push	OFFSET DGROUP:$SG3762
	*** 000f0a	68 00 00 		push	SEG ?cout@@3Vostream_withassign@@E	;cout
	*** 000f0d	68 00 00 		push	OFFSET ?cout@@3Vostream_withassign@@E	;cout
	*** 000f10	9a 00 00 00 00 		call	FAR PTR ??6ostream@@RECAEV0@PFD@Z	; ostream::operator<<
	*** 000f15	52 			push	dx
	*** 000f16	50 			push	ax
	*** 000f17	9a 00 00 00 00 		call	FAR PTR ??6ostream@@RECAEV0@H@Z	; ostream::operator<<
	*** 000f1c	52 			push	dx
	*** 000f1d	50 			push	ax
	*** 000f1e	9a 00 00 00 00 		call	FAR PTR ??6ostream@@RECAEV0@P7AAEV0@AEV0@@Z@Z	; ostream::operator<<
;|***   cout << "Handle: " << handle << endl;
; Line 964
	*** 000f23	68 00 00 		push	SEG ?endl@@ZAAEVostream@@AEV1@@Z	;endl
	*** 000f26	68 00 00 		push	OFFSET ?endl@@ZAAEVostream@@AEV1@@Z	;endl
	*** 000f29	ff 36 00 00 		push	WORD PTR ?handle@@3HE	;handle
	*** 000f2d	1e 			push	ds
	*** 000f2e	68 00 00 		push	OFFSET DGROUP:$SG3763
	*** 000f31	68 00 00 		push	SEG ?cout@@3Vostream_withassign@@E	;cout
	*** 000f34	68 00 00 		push	OFFSET ?cout@@3Vostream_withassign@@E	;cout
	*** 000f37	9a 00 00 00 00 		call	FAR PTR ??6ostream@@RECAEV0@PFD@Z	; ostream::operator<<
	*** 000f3c	52 			push	dx
	*** 000f3d	50 			push	ax
	*** 000f3e	9a 00 00 00 00 		call	FAR PTR ??6ostream@@RECAEV0@H@Z	; ostream::operator<<
	*** 000f43	52 			push	dx
	*** 000f44	50 			push	ax
	*** 000f45	9a 00 00 00 00 		call	FAR PTR ??6ostream@@RECAEV0@P7AAEV0@AEV0@@Z@Z	; ostream::operator<<
;|***   cout << "Driver_info() error: " << driver_info(handle) << endl;
; Line 965
	*** 000f4a	68 00 00 		push	SEG ?endl@@ZAAEVostream@@AEV1@@Z	;endl
	*** 000f4d	68 00 00 		push	OFFSET ?endl@@ZAAEVostream@@AEV1@@Z	;endl
	*** 000f50	ff 36 00 00 		push	WORD PTR ?handle@@3HE	;handle
	*** 000f54	9a 00 00 00 00 		call	FAR PTR ?driver_info@@ZAHI@Z	; driver_info
	*** 000f59	83 c4 02 		add	sp,2
	*** 000f5c	50 			push	ax
	*** 000f5d	1e 			push	ds
	*** 000f5e	68 00 00 		push	OFFSET DGROUP:$SG3764
	*** 000f61	68 00 00 		push	SEG ?cout@@3Vostream_withassign@@E	;cout
	*** 000f64	68 00 00 		push	OFFSET ?cout@@3Vostream_withassign@@E	;cout
	*** 000f67	9a 00 00 00 00 		call	FAR PTR ??6ostream@@RECAEV0@PFD@Z	; ostream::operator<<
	*** 000f6c	52 			push	dx
	*** 000f6d	50 			push	ax
	*** 000f6e	9a 00 00 00 00 		call	FAR PTR ??6ostream@@RECAEV0@H@Z	; ostream::operator<<
	*** 000f73	52 			push	dx
	*** 000f74	50 			push	ax
	*** 000f75	9a 00 00 00 00 		call	FAR PTR ??6ostream@@RECAEV0@P7AAEV0@AEV0@@Z@Z	; ostream::operator<<
;|***   cout << "Rpm_sf: " << rpm_sf << endl;
; Line 966
	*** 000f7a	68 00 00 		push	SEG ?endl@@ZAAEVostream@@AEV1@@Z	;endl
	*** 000f7d	68 00 00 		push	OFFSET ?endl@@ZAAEVostream@@AEV1@@Z	;endl
	*** 000f80	ff 36 02 00 		push	WORD PTR ?rpm_sf@@3ME+2	;rpm_sf
	*** 000f84	ff 36 00 00 		push	WORD PTR ?rpm_sf@@3ME	;rpm_sf
	*** 000f88	1e 			push	ds
	*** 000f89	68 00 00 		push	OFFSET DGROUP:$SG3765
	*** 000f8c	68 00 00 		push	SEG ?cout@@3Vostream_withassign@@E	;cout
	*** 000f8f	68 00 00 		push	OFFSET ?cout@@3Vostream_withassign@@E	;cout
	*** 000f92	9a 00 00 00 00 		call	FAR PTR ??6ostream@@RECAEV0@PFD@Z	; ostream::operator<<
	*** 000f97	52 			push	dx
	*** 000f98	50 			push	ax
	*** 000f99	9a 00 00 00 00 		call	FAR PTR ??6ostream@@RECAEV0@M@Z	; ostream::operator<<
	*** 000f9e	52 			push	dx
	*** 000f9f	50 			push	ax
	*** 000fa0	9a 00 00 00 00 		call	FAR PTR ??6ostream@@RECAEV0@P7AAEV0@AEV0@@Z@Z	; ostream::operator<<
;|***   cout << "Packet driver initialized." << endl;
; Line 967
	*** 000fa5	68 00 00 		push	SEG ?endl@@ZAAEVostream@@AEV1@@Z	;endl
	*** 000fa8	68 00 00 		push	OFFSET ?endl@@ZAAEVostream@@AEV1@@Z	;endl
	*** 000fab	1e 			push	ds
	*** 000fac	68 00 00 		push	OFFSET DGROUP:$SG3766
	*** 000faf	68 00 00 		push	SEG ?cout@@3Vostream_withassign@@E	;cout
	*** 000fb2	68 00 00 		push	OFFSET ?cout@@3Vostream_withassign@@E	;cout
	*** 000fb5	9a 00 00 00 00 		call	FAR PTR ??6ostream@@RECAEV0@PFD@Z	; ostream::operator<<
	*** 000fba	52 			push	dx
	*** 000fbb	50 			push	ax
	*** 000fbc	9a 00 00 00 00 		call	FAR PTR ??6ostream@@RECAEV0@P7AAEV0@AEV0@@Z@Z	; ostream::operator<<
;|***   }
; Line 968
	*** 000fc1	e9 00 00 		jmp	$EX3757
					$EX3757:
	*** 000fc4	5e 			pop	si
	*** 000fc5	5f 			pop	di
	*** 000fc6	c9 			leave	
	*** 000fc7	cb 			ret	

?configure_enet@@ZAXXZ	ENDP
	PUBLIC	?configure_escc@@ZAXXZ	; configure_escc
?configure_escc@@ZAXXZ	PROC FAR	; configure_escc
;|*** 
;|***   
;|*** void configure_escc(void)
;|***   {
; Line 972
	*** 000fc8	c8 02 00 00 		enter	2,0
	*** 000fcc	57 			push	di
	*** 000fcd	56 			push	si
;	i = -2
;|***   cout << "Initializing ESCC." << endl;
; Line 973
	*** 000fce	68 00 00 		push	SEG ?endl@@ZAAEVostream@@AEV1@@Z	;endl
	*** 000fd1	68 00 00 		push	OFFSET ?endl@@ZAAEVostream@@AEV1@@Z	;endl
	*** 000fd4	1e 			push	ds
	*** 000fd5	68 00 00 		push	OFFSET DGROUP:$SG3769
	*** 000fd8	68 00 00 		push	SEG ?cout@@3Vostream_withassign@@E	;cout
	*** 000fdb	68 00 00 		push	OFFSET ?cout@@3Vostream_withassign@@E	;cout
	*** 000fde	9a 00 00 00 00 		call	FAR PTR ??6ostream@@RECAEV0@PFD@Z	; ostream::operator<<
	*** 000fe3	52 			push	dx
	*** 000fe4	50 			push	ax
	*** 000fe5	9a 00 00 00 00 		call	FAR PTR ??6ostream@@RECAEV0@P7AAEV0@AEV0@@Z@Z	; ostream::operator<<
;|***   for(int i=0;i<96;i++) pcm[i] = 'a';
; Line 974
	*** 000fea	c7 46 fe 00 00 		mov	WORD PTR [bp-2],0	;i
	*** 000fef	e9 03 00 		jmp	$F3771
					$FC3772:
	*** 000ff2	ff 46 fe 		inc	WORD PTR [bp-2]	;i
					$F3771:
	*** 000ff5	83 7e fe 60 		cmp	WORD PTR [bp-2],96	;0060H	;i
	*** 000ff9	7c 03 			jl	$JCC4089
	*** 000ffb	e9 0b 00 		jmp	$FB3773
					$JCC4089:
	*** 000ffe	8b 5e fe 		mov	bx,WORD PTR [bp-2]	;i
	*** 001001	c6 87 00 00 61 		mov	BYTE PTR ?pcm@@3QEDE[bx],97	;0061H	;pcm
	*** 001006	e9 e9 ff 		jmp	$FC3772
					$FB3773:
;|***   
;|***   // open the two escc communications ports using add_port() function
;|***   // parameters: (base address of escc board,
;|***   //              escc channel 0 or 1,
;|***   //              IRQ setting,   
;|***   //              dma channel for receive,  
;|***   //              dma channel for transmit)
;|*** 
;|***   // channel A to communicate with the LN200                  
;|***   channela = escc1.add_port(0x240,0,5,0,0);  //1st channel, IRQ 5, no dma
; Line 984
	*** 001009	68 40 02 		push	576	;0240H
	*** 00100c	6a 00 			push	0
	*** 00100e	6a 05 			push	5
	*** 001010	6a 00 			push	0
	*** 001012	6a 00 			push	0
	*** 001014	68 00 00 		push	SEG ?escc1@@3VCescc@@E	;escc1
	*** 001017	68 00 00 		push	OFFSET ?escc1@@3VCescc@@E	;escc1
	*** 00101a	9a 00 00 00 00 		call	FAR PTR ?add_port@Cescc@@RECIIIIII@Z	; Cescc::add_port
	*** 00101f	a3 00 00 		mov	WORD PTR ?channela@@3IE,ax	;channela
;|***   cout << "Channel A = " << channela << endl;
; Line 985
	*** 001022	68 00 00 		push	SEG ?endl@@ZAAEVostream@@AEV1@@Z	;endl
	*** 001025	68 00 00 		push	OFFSET ?endl@@ZAAEVostream@@AEV1@@Z	;endl
	*** 001028	ff 36 00 00 		push	WORD PTR ?channela@@3IE	;channela
	*** 00102c	1e 			push	ds
	*** 00102d	68 00 00 		push	OFFSET DGROUP:$SG3774
	*** 001030	68 00 00 		push	SEG ?cout@@3Vostream_withassign@@E	;cout
	*** 001033	68 00 00 		push	OFFSET ?cout@@3Vostream_withassign@@E	;cout
	*** 001036	9a 00 00 00 00 		call	FAR PTR ??6ostream@@RECAEV0@PFD@Z	; ostream::operator<<
	*** 00103b	52 			push	dx
	*** 00103c	50 			push	ax
	*** 00103d	9a 00 00 00 00 		call	FAR PTR ??6ostream@@RECAEV0@I@Z	; ostream::operator<<
	*** 001042	52 			push	dx
	*** 001043	50 			push	ax
	*** 001044	9a 00 00 00 00 		call	FAR PTR ??6ostream@@RECAEV0@P7AAEV0@AEV0@@Z@Z	; ostream::operator<<
;|***   
;|***   // channel B to transmit the pcm telemetry
;|***   channelb = escc1.add_port(0x240,1,5,1,5);  //2nd channel IRQ 5, Rx=DMA Ch1, Tx=DMA Ch5
; Line 988
	*** 001049	68 40 02 		push	576	;0240H
	*** 00104c	6a 01 			push	1
	*** 00104e	6a 05 			push	5
	*** 001050	6a 01 			push	1
	*** 001052	6a 05 			push	5
	*** 001054	68 00 00 		push	SEG ?escc1@@3VCescc@@E	;escc1
	*** 001057	68 00 00 		push	OFFSET ?escc1@@3VCescc@@E	;escc1
	*** 00105a	9a 00 00 00 00 		call	FAR PTR ?add_port@Cescc@@RECIIIIII@Z	; Cescc::add_port
	*** 00105f	a3 00 00 		mov	WORD PTR ?channelb@@3IE,ax	;channelb
;|***   cout << "Channel B = " << channelb  << endl;
; Line 989
	*** 001062	68 00 00 		push	SEG ?endl@@ZAAEVostream@@AEV1@@Z	;endl
	*** 001065	68 00 00 		push	OFFSET ?endl@@ZAAEVostream@@AEV1@@Z	;endl
	*** 001068	ff 36 00 00 		push	WORD PTR ?channelb@@3IE	;channelb
	*** 00106c	1e 			push	ds
	*** 00106d	68 00 00 		push	OFFSET DGROUP:$SG3775
	*** 001070	68 00 00 		push	SEG ?cout@@3Vostream_withassign@@E	;cout
	*** 001073	68 00 00 		push	OFFSET ?cout@@3Vostream_withassign@@E	;cout
	*** 001076	9a 00 00 00 00 		call	FAR PTR ??6ostream@@RECAEV0@PFD@Z	; ostream::operator<<
	*** 00107b	52 			push	dx
	*** 00107c	50 			push	ax
	*** 00107d	9a 00 00 00 00 		call	FAR PTR ??6ostream@@RECAEV0@I@Z	; ostream::operator<<
	*** 001082	52 			push	dx
	*** 001083	50 			push	ax
	*** 001084	9a 00 00 00 00 		call	FAR PTR ??6ostream@@RECAEV0@P7AAEV0@AEV0@@Z@Z	; ostream::operator<<
;|***   
;|***   // assemble configuration data for channel_a for LN200 SDLC operation.
;|***   // see Siemens SAB 82532 ESCC User's Manual page 110.
;|***   settings.mode = 0x88;   // transparent 0 frames, receiver active
; Line 993
	*** 001089	8e 06 00 00 		mov	es,WORD PTR $T4071
	*** 00108d	26 c7 06 02 00 88 00 	mov	WORD PTR es:?settings@@3Uescc_regs@@E+2,136	;0088H	;settings
;|***   settings.timr = 0x1f;   // for cb98
; Line 994
	*** 001094	26 c7 06 04 00 1f 00 	mov	WORD PTR es:?settings@@3Uescc_regs@@E+4,31	;001fH	;settings
;|***   settings.xbcl = 0x00;   // n/a for interrupt mode
; Line 995
	*** 00109b	26 c7 06 06 00 00 00 	mov	WORD PTR es:?settings@@3Uescc_regs@@E+6,0	;settings
;|***   settings.xbch = 0x00;   // interrupt mode (no dma)
; Line 996
	*** 0010a2	26 c7 06 08 00 00 00 	mov	WORD PTR es:?settings@@3Uescc_regs@@E+8,0	;settings
;|***   settings.ccr0 = 0xc0;   // power up, master clock enabled
; Line 997
	*** 0010a9	26 c7 06 0a 00 c0 00 	mov	WORD PTR es:?settings@@3Uescc_regs@@E+10,192	;00c0H	;settings
;|***   settings.ccr1 = 0x10;   // txd push-pull, one's insertion, clk mode 0 (use LN200 clock)
; Line 998
	*** 0010b0	26 c7 06 0c 00 10 00 	mov	WORD PTR es:?settings@@3Uescc_regs@@E+12,16	;0010H	;settings
;|***   settings.ccr2 = 0x00;   // normal txd/rxd, ssel=0 (clk mode 0a), crc-ccitt, no inversion 
; Line 999
	*** 0010b7	26 c7 06 0e 00 00 00 	mov	WORD PTR es:?settings@@3Uescc_regs@@E+14,0	;settings
;|***   settings.ccr3 = 0x00;   // no preamble, rx crc off, tx crc generated internally
; Line 1000
	*** 0010be	26 c7 06 10 00 00 00 	mov	WORD PTR es:?settings@@3Uescc_regs@@E+16,0	;settings
;|***   settings.ccr4 = 0x00;   
; Line 1001
	*** 0010c5	26 c7 06 12 00 00 00 	mov	WORD PTR es:?settings@@3Uescc_regs@@E+18,0	;settings
;|***   settings.bgr  = 0x00;    
; Line 1002
	*** 0010cc	26 c7 06 14 00 00 00 	mov	WORD PTR es:?settings@@3Uescc_regs@@E+20,0	;settings
;|***   settings.iva  = 0x00;    
; Line 1003
	*** 0010d3	26 c7 06 16 00 00 00 	mov	WORD PTR es:?settings@@3Uescc_regs@@E+22,0	;settings
;|***   settings.ipc  = 0x03;   // masked interrupts NOT visible, pin INT = push/pull active high
; Line 1004
	*** 0010da	26 c7 06 18 00 03 00 	mov	WORD PTR es:?settings@@3Uescc_regs@@E+24,3	;settings
;|***   settings.imr0 = 0x04;   // cdsc disabled
; Line 1005
	*** 0010e1	26 c7 06 1a 00 04 00 	mov	WORD PTR es:?settings@@3Uescc_regs@@E+26,4	;settings
;|***   settings.imr1 = 0x00;   // all interrupts enabled 
; Line 1006
	*** 0010e8	26 c7 06 1c 00 00 00 	mov	WORD PTR es:?settings@@3Uescc_regs@@E+28,0	;settings
;|***   settings.pvr  = 0x00;   
; Line 1007
	*** 0010ef	26 c7 06 1e 00 00 00 	mov	WORD PTR es:?settings@@3Uescc_regs@@E+30,0	;settings
;|***   settings.pim  = 0xff;
; Line 1008
	*** 0010f6	26 c7 06 20 00 ff 00 	mov	WORD PTR es:?settings@@3Uescc_regs@@E+32,255	;00ffH	;settings
;|***   settings.pcr  = 0xe0;
; Line 1009
	*** 0010fd	26 c7 06 22 00 e0 00 	mov	WORD PTR es:?settings@@3Uescc_regs@@E+34,224	;00e0H	;settings
;|***   settings.xad1 = 0xff;
; Line 1010
	*** 001104	26 c7 06 24 00 ff 00 	mov	WORD PTR es:?settings@@3Uescc_regs@@E+36,255	;00ffH	;settings
;|***   settings.xad2 = 0xff;
; Line 1011
	*** 00110b	26 c7 06 26 00 ff 00 	mov	WORD PTR es:?settings@@3Uescc_regs@@E+38,255	;00ffH	;settings
;|***   settings.rah1 = 0xff;
; Line 1012
	*** 001112	26 c7 06 28 00 ff 00 	mov	WORD PTR es:?settings@@3Uescc_regs@@E+40,255	;00ffH	;settings
;|***   settings.rah2 = 0xff;
; Line 1013
	*** 001119	26 c7 06 2a 00 ff 00 	mov	WORD PTR es:?settings@@3Uescc_regs@@E+42,255	;00ffH	;settings
;|***   settings.ral1 = 0xff;
; Line 1014
	*** 001120	26 c7 06 2c 00 ff 00 	mov	WORD PTR es:?settings@@3Uescc_regs@@E+44,255	;00ffH	;settings
;|***   settings.ral2 = 0xff;
; Line 1015
	*** 001127	26 c7 06 2e 00 ff 00 	mov	WORD PTR es:?settings@@3Uescc_regs@@E+46,255	;00ffH	;settings
;|***   settings.rlcr = 0x00;
; Line 1016
	*** 00112e	26 c7 06 30 00 00 00 	mov	WORD PTR es:?settings@@3Uescc_regs@@E+48,0	;settings
;|***   settings.pre  = 0x00;
; Line 1017
	*** 001135	26 c7 06 32 00 00 00 	mov	WORD PTR es:?settings@@3Uescc_regs@@E+50,0	;settings
;|***     
;|***   // write configuration data to escc channel a registers
;|***   // parameters:(port to intialize,
;|***   //             operating mode,
;|***   //             settings defined above,
;|***   //             number of receive buffers,
;|***   //             number of transmit buffers)
;|***   cout << "initializing channel A" << endl;
; Line 1025
	*** 00113c	68 00 00 		push	SEG ?endl@@ZAAEVostream@@AEV1@@Z	;endl
	*** 00113f	68 00 00 		push	OFFSET ?endl@@ZAAEVostream@@AEV1@@Z	;endl
	*** 001142	1e 			push	ds
	*** 001143	68 00 00 		push	OFFSET DGROUP:$SG3776
	*** 001146	68 00 00 		push	SEG ?cout@@3Vostream_withassign@@E	;cout
	*** 001149	68 00 00 		push	OFFSET ?cout@@3Vostream_withassign@@E	;cout
	*** 00114c	9a 00 00 00 00 		call	FAR PTR ??6ostream@@RECAEV0@PFD@Z	; ostream::operator<<
	*** 001151	52 			push	dx
	*** 001152	50 			push	ax
	*** 001153	9a 00 00 00 00 		call	FAR PTR ??6ostream@@RECAEV0@P7AAEV0@AEV0@@Z@Z	; ostream::operator<<
;|***   if(escc1.init_port(channela,OPMODE_HDLC,&settings,2,2)==TRUE)
; Line 1026
	*** 001158	ff 36 00 00 		push	WORD PTR ?channela@@3IE	;channela
	*** 00115c	6a 00 			push	0
	*** 00115e	68 00 00 		push	SEG ?settings@@3Uescc_regs@@E	;settings
	*** 001161	68 00 00 		push	OFFSET ?settings@@3Uescc_regs@@E	;settings
	*** 001164	6a 02 			push	2
	*** 001166	6a 02 			push	2
	*** 001168	68 00 00 		push	SEG ?escc1@@3VCescc@@E	;escc1
	*** 00116b	68 00 00 		push	OFFSET ?escc1@@3VCescc@@E	;escc1
	*** 00116e	9a 00 00 00 00 		call	FAR PTR ?init_port@Cescc@@RECIIIPEUescc_regs@@II@Z	; Cescc::init_port
	*** 001173	3d 00 00 		cmp	ax,0
	*** 001176	74 03 			je	$JCC4470
	*** 001178	e9 1f 00 		jmp	$I3777
					$JCC4470:
;|***     cout << "Intialize Channel A OK." << endl;
; Line 1027
	*** 00117b	68 00 00 		push	SEG ?endl@@ZAAEVostream@@AEV1@@Z	;endl
	*** 00117e	68 00 00 		push	OFFSET ?endl@@ZAAEVostream@@AEV1@@Z	;endl
	*** 001181	1e 			push	ds
	*** 001182	68 00 00 		push	OFFSET DGROUP:$SG3778
	*** 001185	68 00 00 		push	SEG ?cout@@3Vostream_withassign@@E	;cout
	*** 001188	68 00 00 		push	OFFSET ?cout@@3Vostream_withassign@@E	;cout
	*** 00118b	9a 00 00 00 00 		call	FAR PTR ??6ostream@@RECAEV0@PFD@Z	; ostream::operator<<
	*** 001190	52 			push	dx
	*** 001191	50 			push	ax
	*** 001192	9a 00 00 00 00 		call	FAR PTR ??6ostream@@RECAEV0@P7AAEV0@AEV0@@Z@Z	; ostream::operator<<
;|***   else
; Line 1028
	*** 001197	e9 21 00 		jmp	$I3779
					$I3777:
;|***     {
; Line 1029
;|***     cout << "Initialize Channel A FAILED!" << endl;
; Line 1030
	*** 00119a	68 00 00 		push	SEG ?endl@@ZAAEVostream@@AEV1@@Z	;endl
	*** 00119d	68 00 00 		push	OFFSET ?endl@@ZAAEVostream@@AEV1@@Z	;endl
	*** 0011a0	1e 			push	ds
	*** 0011a1	68 00 00 		push	OFFSET DGROUP:$SG3780
	*** 0011a4	68 00 00 		push	SEG ?cout@@3Vostream_withassign@@E	;cout
	*** 0011a7	68 00 00 		push	OFFSET ?cout@@3Vostream_withassign@@E	;cout
	*** 0011aa	9a 00 00 00 00 		call	FAR PTR ??6ostream@@RECAEV0@PFD@Z	; ostream::operator<<
	*** 0011af	52 			push	dx
	*** 0011b0	50 			push	ax
	*** 0011b1	9a 00 00 00 00 		call	FAR PTR ??6ostream@@RECAEV0@P7AAEV0@AEV0@@Z@Z	; ostream::operator<<
;|***     terminate();
; Line 1031
	*** 0011b6	9a 00 00 00 00 		call	FAR PTR ?terminate@@ZAXXZ	; terminate
;|***     //exit(0);
;|***     }
; Line 1033
					$I3779:
;|***   
;|***   // test channel a to make sure it opened
;|***   if(escc1.clear_rx_buffer(channela)==TRUE)
; Line 1036
	*** 0011bb	ff 36 00 00 		push	WORD PTR ?channela@@3IE	;channela
	*** 0011bf	68 00 00 		push	SEG ?escc1@@3VCescc@@E	;escc1
	*** 0011c2	68 00 00 		push	OFFSET ?escc1@@3VCescc@@E	;escc1
	*** 0011c5	9a 00 00 00 00 		call	FAR PTR ?clear_rx_buffer@Cescc@@RECII@Z	; Cescc::clear_rx_buffer
	*** 0011ca	3d 00 00 		cmp	ax,0
	*** 0011cd	74 03 			je	$JCC4557
	*** 0011cf	e9 1f 00 		jmp	$I3781
					$JCC4557:
;|***     cout << "Channel A rx buffer cleared OK.  " << endl;
; Line 1037
	*** 0011d2	68 00 00 		push	SEG ?endl@@ZAAEVostream@@AEV1@@Z	;endl
	*** 0011d5	68 00 00 		push	OFFSET ?endl@@ZAAEVostream@@AEV1@@Z	;endl
	*** 0011d8	1e 			push	ds
	*** 0011d9	68 00 00 		push	OFFSET DGROUP:$SG3782
	*** 0011dc	68 00 00 		push	SEG ?cout@@3Vostream_withassign@@E	;cout
	*** 0011df	68 00 00 		push	OFFSET ?cout@@3Vostream_withassign@@E	;cout
	*** 0011e2	9a 00 00 00 00 		call	FAR PTR ??6ostream@@RECAEV0@PFD@Z	; ostream::operator<<
	*** 0011e7	52 			push	dx
	*** 0011e8	50 			push	ax
	*** 0011e9	9a 00 00 00 00 		call	FAR PTR ??6ostream@@RECAEV0@P7AAEV0@AEV0@@Z@Z	; ostream::operator<<
;|***   else
; Line 1038
	*** 0011ee	e9 21 00 		jmp	$I3783
					$I3781:
;|***     {
; Line 1039
;|***     cout << "Channel A rx buffer clear FAILED!" << endl;
; Line 1040
	*** 0011f1	68 00 00 		push	SEG ?endl@@ZAAEVostream@@AEV1@@Z	;endl
	*** 0011f4	68 00 00 		push	OFFSET ?endl@@ZAAEVostream@@AEV1@@Z	;endl
	*** 0011f7	1e 			push	ds
	*** 0011f8	68 00 00 		push	OFFSET DGROUP:$SG3784
	*** 0011fb	68 00 00 		push	SEG ?cout@@3Vostream_withassign@@E	;cout
	*** 0011fe	68 00 00 		push	OFFSET ?cout@@3Vostream_withassign@@E	;cout
	*** 001201	9a 00 00 00 00 		call	FAR PTR ??6ostream@@RECAEV0@PFD@Z	; ostream::operator<<
	*** 001206	52 			push	dx
	*** 001207	50 			push	ax
	*** 001208	9a 00 00 00 00 		call	FAR PTR ??6ostream@@RECAEV0@P7AAEV0@AEV0@@Z@Z	; ostream::operator<<
;|***     terminate();
; Line 1041
	*** 00120d	9a 00 00 00 00 		call	FAR PTR ?terminate@@ZAXXZ	; terminate
;|***     //exit(0);
;|***     }
; Line 1043
					$I3783:
;|*** 
;|***   if(escc1.clear_tx_buffer(channela)==TRUE)
; Line 1045
	*** 001212	ff 36 00 00 		push	WORD PTR ?channela@@3IE	;channela
	*** 001216	68 00 00 		push	SEG ?escc1@@3VCescc@@E	;escc1
	*** 001219	68 00 00 		push	OFFSET ?escc1@@3VCescc@@E	;escc1
	*** 00121c	9a 00 00 00 00 		call	FAR PTR ?clear_tx_buffer@Cescc@@RECII@Z	; Cescc::clear_tx_buffer
	*** 001221	3d 00 00 		cmp	ax,0
	*** 001224	74 03 			je	$JCC4644
	*** 001226	e9 1f 00 		jmp	$I3785
					$JCC4644:
;|***     cout << "Channel A tx buffer cleared OK." << endl;
; Line 1046
	*** 001229	68 00 00 		push	SEG ?endl@@ZAAEVostream@@AEV1@@Z	;endl
	*** 00122c	68 00 00 		push	OFFSET ?endl@@ZAAEVostream@@AEV1@@Z	;endl
	*** 00122f	1e 			push	ds
	*** 001230	68 00 00 		push	OFFSET DGROUP:$SG3786
	*** 001233	68 00 00 		push	SEG ?cout@@3Vostream_withassign@@E	;cout
	*** 001236	68 00 00 		push	OFFSET ?cout@@3Vostream_withassign@@E	;cout
	*** 001239	9a 00 00 00 00 		call	FAR PTR ??6ostream@@RECAEV0@PFD@Z	; ostream::operator<<
	*** 00123e	52 			push	dx
	*** 00123f	50 			push	ax
	*** 001240	9a 00 00 00 00 		call	FAR PTR ??6ostream@@RECAEV0@P7AAEV0@AEV0@@Z@Z	; ostream::operator<<
;|***   else
; Line 1047
	*** 001245	e9 21 00 		jmp	$I3787
					$I3785:
;|***     {
; Line 1048
;|***     cout << "Channel A tx buffer clear FAILED!" << endl;
; Line 1049
	*** 001248	68 00 00 		push	SEG ?endl@@ZAAEVostream@@AEV1@@Z	;endl
	*** 00124b	68 00 00 		push	OFFSET ?endl@@ZAAEVostream@@AEV1@@Z	;endl
	*** 00124e	1e 			push	ds
	*** 00124f	68 00 00 		push	OFFSET DGROUP:$SG3788
	*** 001252	68 00 00 		push	SEG ?cout@@3Vostream_withassign@@E	;cout
	*** 001255	68 00 00 		push	OFFSET ?cout@@3Vostream_withassign@@E	;cout
	*** 001258	9a 00 00 00 00 		call	FAR PTR ??6ostream@@RECAEV0@PFD@Z	; ostream::operator<<
	*** 00125d	52 			push	dx
	*** 00125e	50 			push	ax
	*** 00125f	9a 00 00 00 00 		call	FAR PTR ??6ostream@@RECAEV0@P7AAEV0@AEV0@@Z@Z	; ostream::operator<<
;|***     terminate();
; Line 1050
	*** 001264	9a 00 00 00 00 		call	FAR PTR ?terminate@@ZAXXZ	; terminate
;|***     }
; Line 1051
					$I3787:
;|***   
;|***   // set channel a frame transmission type
;|***   if(escc1.set_tx_type(channela, TRANSPARENT_MODE)==TRUE)
; Line 1054
	*** 001269	ff 36 00 00 		push	WORD PTR ?channela@@3IE	;channela
	*** 00126d	6a 01 			push	1
	*** 00126f	68 00 00 		push	SEG ?escc1@@3VCescc@@E	;escc1
	*** 001272	68 00 00 		push	OFFSET ?escc1@@3VCescc@@E	;escc1
	*** 001275	9a 00 00 00 00 		call	FAR PTR ?set_tx_type@Cescc@@RECIII@Z	; Cescc::set_tx_type
	*** 00127a	3d 00 00 		cmp	ax,0
	*** 00127d	74 03 			je	$JCC4733
	*** 00127f	e9 1f 00 		jmp	$I3789
					$JCC4733:
;|***     cout << "Channel A set to Transparent Mode.  " << endl;
; Line 1055
	*** 001282	68 00 00 		push	SEG ?endl@@ZAAEVostream@@AEV1@@Z	;endl
	*** 001285	68 00 00 		push	OFFSET ?endl@@ZAAEVostream@@AEV1@@Z	;endl
	*** 001288	1e 			push	ds
	*** 001289	68 00 00 		push	OFFSET DGROUP:$SG3790
	*** 00128c	68 00 00 		push	SEG ?cout@@3Vostream_withassign@@E	;cout
	*** 00128f	68 00 00 		push	OFFSET ?cout@@3Vostream_withassign@@E	;cout
	*** 001292	9a 00 00 00 00 		call	FAR PTR ??6ostream@@RECAEV0@PFD@Z	; ostream::operator<<
	*** 001297	52 			push	dx
	*** 001298	50 			push	ax
	*** 001299	9a 00 00 00 00 		call	FAR PTR ??6ostream@@RECAEV0@P7AAEV0@AEV0@@Z@Z	; ostream::operator<<
;|***   else
; Line 1056
	*** 00129e	e9 21 00 		jmp	$I3791
					$I3789:
;|***     {
; Line 1057
;|***     cout << "Channel A Transparent Mode not set!  Channel not open!" << endl;
; Line 1058
	*** 0012a1	68 00 00 		push	SEG ?endl@@ZAAEVostream@@AEV1@@Z	;endl
	*** 0012a4	68 00 00 		push	OFFSET ?endl@@ZAAEVostream@@AEV1@@Z	;endl
	*** 0012a7	1e 			push	ds
	*** 0012a8	68 00 00 		push	OFFSET DGROUP:$SG3792
	*** 0012ab	68 00 00 		push	SEG ?cout@@3Vostream_withassign@@E	;cout
	*** 0012ae	68 00 00 		push	OFFSET ?cout@@3Vostream_withassign@@E	;cout
	*** 0012b1	9a 00 00 00 00 		call	FAR PTR ??6ostream@@RECAEV0@PFD@Z	; ostream::operator<<
	*** 0012b6	52 			push	dx
	*** 0012b7	50 			push	ax
	*** 0012b8	9a 00 00 00 00 		call	FAR PTR ??6ostream@@RECAEV0@P7AAEV0@AEV0@@Z@Z	; ostream::operator<<
;|***     terminate();
; Line 1059
	*** 0012bd	9a 00 00 00 00 		call	FAR PTR ?terminate@@ZAXXZ	; terminate
;|***     }
; Line 1060
					$I3791:
;|*** 
;|***   // Channel b runs off the escc internal oscillator.
;|***   // Configure the escc frequency generator to produce a 9.8304 MHz clock signal
;|***   // from the onboard 18.432 MHz TTL oscillator.  The 9.8304 MHz clock is 
;|***   // then divided by 128 and used as the master clock for the 76.8 KHz pcm data stream
;|***   
;|***   // See escc.cpp, Cypress ICD2053B clock-generator datasheet and BitCalc software
;|***   // available at the Cypress Web site to calculate the clock scaling factor.
;|***   
;|***   // void Cescc::set_clock_generator(unsigned port,     //either channel A or B will work
;|***   //                                 unsigned long hval,//stuffed hex value from BitCalc
;|***   //                                 unsigned nmbits)   //number of bits in stuffed value
;|***   
;|***   //escc1.set_clock_generator(channela, 0x5d31c0L, 0x18);
;|***   
;|***   // new 2.4576 MHz clock for 19.2 KHz PCM bit rate 12/19/2007 jtm
;|***   escc1.set_clock_generator(channela, 0x5d51c0L, 24);
; Line 1077
	*** 0012c2	ff 36 00 00 		push	WORD PTR ?channela@@3IE	;channela
	*** 0012c6	6a 5d 			push	93	;005dH
	*** 0012c8	68 c0 51 		push	20928	;51c0H
	*** 0012cb	6a 18 			push	24	;0018H
	*** 0012cd	68 00 00 		push	SEG ?escc1@@3VCescc@@E	;escc1
	*** 0012d0	68 00 00 		push	OFFSET ?escc1@@3VCescc@@E	;escc1
	*** 0012d3	9a 00 00 00 00 		call	FAR PTR ?set_clock_generator@Cescc@@RECXIKI@Z	; Cescc::set_clock_generator
;|*** 
;|*** 
;|***   // Configure channel_b for biphase-m operation for pcm data telemetry.
;|***   // see Siemens SAB 82532 ESCC User's Manual page 110 for register descriptions.
;|***   settings.mode = 0xC8;  // extended transparent mode 0, rcvr active, extern timer k=32768
; Line 1082
	*** 0012d8	8e 06 00 00 		mov	es,WORD PTR $T4071
	*** 0012dc	26 c7 06 02 00 c8 00 	mov	WORD PTR es:?settings@@3Uescc_regs@@E+2,200	;00c8H	;settings
;|***   settings.timr = 0xe2;  // cnt=7, value=2, continuous 100 Hz interrupts when tcp=1/9.8304MHz
; Line 1083
	*** 0012e3	26 c7 06 04 00 e2 00 	mov	WORD PTR es:?settings@@3Uescc_regs@@E+4,226	;00e2H	;settings
;|***   settings.xbcl = 0x00;  // set up by setupdmat() when transmission is started
; Line 1084
	*** 0012ea	26 c7 06 06 00 00 00 	mov	WORD PTR es:?settings@@3Uescc_regs@@E+6,0	;settings
;|***   settings.xbch = 0x80;  // dma data transfer mode
; Line 1085
	*** 0012f1	26 c7 06 08 00 80 00 	mov	WORD PTR es:?settings@@3Uescc_regs@@E+8,128	;0080H	;settings
;|***   // Note:  ESCC User's manual p 92/129 has switched FM0 & FM1?  Actually FM0=101, FM1=100 ?
;|***   settings.ccr0 = 0xD0;  // power-up, master clk=xtal, FM1(biphase-m), hdlc/sdlc
; Line 1087
	*** 0012f8	26 c7 06 0a 00 d0 00 	mov	WORD PTR es:?settings@@3Uescc_regs@@E+10,208	;00d0H	;settings
;|***   settings.ccr1 = 0x17;  // set txd push-pull, set clk mode 7b
; Line 1088
	*** 0012ff	26 c7 06 0c 00 17 00 	mov	WORD PTR es:?settings@@3Uescc_regs@@E+12,23	;0017H	;settings
;|***   settings.ccr2 = 0x38;  // br9&8=0, bdf=1, ssel=1, toe=1, rwx=0, crc-ccitt, no inversion
; Line 1089
	*** 001306	26 c7 06 0e 00 38 00 	mov	WORD PTR es:?settings@@3Uescc_regs@@E+14,56	;0038H	;settings
;|***   settings.ccr3 = 0x02;  // no preamble, radd=0, crl=0, rcrc=off, xcrc=off, psd=na
; Line 1090
	*** 00130d	26 c7 06 10 00 02 00 	mov	WORD PTR es:?settings@@3Uescc_regs@@E+16,2	;settings
;|***   settings.ccr4 = 0x00;  // added to implement MCK4 and EBRG, but not used
; Line 1091
	*** 001314	26 c7 06 12 00 00 00 	mov	WORD PTR es:?settings@@3Uescc_regs@@E+18,0	;settings
;|***   settings.bgr  = 0x3f;  // brg divisor=63 (0x3F), 76.8 KHz = 9.8304 MHz /((63+1)*2)
; Line 1092
	*** 00131b	26 c7 06 14 00 3f 00 	mov	WORD PTR es:?settings@@3Uescc_regs@@E+20,63	;003fH	;settings
;|***   settings.iva  = 0x00;  // not set here
; Line 1093
	*** 001322	26 c7 06 16 00 00 00 	mov	WORD PTR es:?settings@@3Uescc_regs@@E+22,0	;settings
;|***   settings.ipc  = 0x03;  // masked interrupts not visible, pin INT = push/pull active high
; Line 1094
	*** 001329	26 c7 06 18 00 03 00 	mov	WORD PTR es:?settings@@3Uescc_regs@@E+24,3	;settings
;|***   settings.imr0 = 0x00;  // all interrupts enabled
; Line 1095
	*** 001330	26 c7 06 1a 00 00 00 	mov	WORD PTR es:?settings@@3Uescc_regs@@E+26,0	;settings
;|***   settings.imr1 = 0x00;  // all interrupts enabled
; Line 1096
	*** 001337	26 c7 06 1c 00 00 00 	mov	WORD PTR es:?settings@@3Uescc_regs@@E+28,0	;settings
;|***   settings.pvr  = 0x00;  
; Line 1097
	*** 00133e	26 c7 06 1e 00 00 00 	mov	WORD PTR es:?settings@@3Uescc_regs@@E+30,0	;settings
;|***   settings.pim  = 0xff;
; Line 1098
	*** 001345	26 c7 06 20 00 ff 00 	mov	WORD PTR es:?settings@@3Uescc_regs@@E+32,255	;00ffH	;settings
;|***   settings.pcr  = 0xe0;
; Line 1099
	*** 00134c	26 c7 06 22 00 e0 00 	mov	WORD PTR es:?settings@@3Uescc_regs@@E+34,224	;00e0H	;settings
;|***   settings.xad1 = 0xff;
; Line 1100
	*** 001353	26 c7 06 24 00 ff 00 	mov	WORD PTR es:?settings@@3Uescc_regs@@E+36,255	;00ffH	;settings
;|***   settings.xad2 = 0xff;
; Line 1101
	*** 00135a	26 c7 06 26 00 ff 00 	mov	WORD PTR es:?settings@@3Uescc_regs@@E+38,255	;00ffH	;settings
;|***   settings.rah1 = 0xff;
; Line 1102
	*** 001361	26 c7 06 28 00 ff 00 	mov	WORD PTR es:?settings@@3Uescc_regs@@E+40,255	;00ffH	;settings
;|***   settings.rah2 = 0xff;
; Line 1103
	*** 001368	26 c7 06 2a 00 ff 00 	mov	WORD PTR es:?settings@@3Uescc_regs@@E+42,255	;00ffH	;settings
;|***   settings.ral1 = 0xff;
; Line 1104
	*** 00136f	26 c7 06 2c 00 ff 00 	mov	WORD PTR es:?settings@@3Uescc_regs@@E+44,255	;00ffH	;settings
;|***   settings.ral2 = 0xff;
; Line 1105
	*** 001376	26 c7 06 2e 00 ff 00 	mov	WORD PTR es:?settings@@3Uescc_regs@@E+46,255	;00ffH	;settings
;|***   settings.rlcr = 0x00;
; Line 1106
	*** 00137d	26 c7 06 30 00 00 00 	mov	WORD PTR es:?settings@@3Uescc_regs@@E+48,0	;settings
;|***   settings.pre  = 0x00;
; Line 1107
	*** 001384	26 c7 06 32 00 00 00 	mov	WORD PTR es:?settings@@3Uescc_regs@@E+50,0	;settings
;|***   
;|***   //Write configuration to channelb registers
;|***   //Parameters: (port to intialize,
;|***   //             operating mode,
;|***   //             settings defined above,
;|***   //             number of receive buffers,
;|***   //             number of transmit buffers)
;|***   if(escc1.init_port(channelb,OPMODE_HDLC,&settings,MAX_RBUFS,MAX_TBUFS)==TRUE)
; Line 1115
	*** 00138b	ff 36 00 00 		push	WORD PTR ?channelb@@3IE	;channelb
	*** 00138f	6a 00 			push	0
	*** 001391	06 			push	es
	*** 001392	68 00 00 		push	OFFSET ?settings@@3Uescc_regs@@E	;settings
	*** 001395	6a 10 			push	16	;0010H
	*** 001397	6a 10 			push	16	;0010H
	*** 001399	68 00 00 		push	SEG ?escc1@@3VCescc@@E	;escc1
	*** 00139c	68 00 00 		push	OFFSET ?escc1@@3VCescc@@E	;escc1
	*** 00139f	9a 00 00 00 00 		call	FAR PTR ?init_port@Cescc@@RECIIIPEUescc_regs@@II@Z	; Cescc::init_port
	*** 0013a4	3d 00 00 		cmp	ax,0
	*** 0013a7	74 03 			je	$JCC5031
	*** 0013a9	e9 1f 00 		jmp	$I3793
					$JCC5031:
;|***     cout << "Intialize Channel B OK." << endl;
; Line 1116
	*** 0013ac	68 00 00 		push	SEG ?endl@@ZAAEVostream@@AEV1@@Z	;endl
	*** 0013af	68 00 00 		push	OFFSET ?endl@@ZAAEVostream@@AEV1@@Z	;endl
	*** 0013b2	1e 			push	ds
	*** 0013b3	68 00 00 		push	OFFSET DGROUP:$SG3794
	*** 0013b6	68 00 00 		push	SEG ?cout@@3Vostream_withassign@@E	;cout
	*** 0013b9	68 00 00 		push	OFFSET ?cout@@3Vostream_withassign@@E	;cout
	*** 0013bc	9a 00 00 00 00 		call	FAR PTR ??6ostream@@RECAEV0@PFD@Z	; ostream::operator<<
	*** 0013c1	52 			push	dx
	*** 0013c2	50 			push	ax
	*** 0013c3	9a 00 00 00 00 		call	FAR PTR ??6ostream@@RECAEV0@P7AAEV0@AEV0@@Z@Z	; ostream::operator<<
;|***   else
; Line 1117
	*** 0013c8	e9 21 00 		jmp	$I3795
					$I3793:
;|***     {
; Line 1118
;|***     cout << "Initialize Channel B FAILED!" << endl;
; Line 1119
	*** 0013cb	68 00 00 		push	SEG ?endl@@ZAAEVostream@@AEV1@@Z	;endl
	*** 0013ce	68 00 00 		push	OFFSET ?endl@@ZAAEVostream@@AEV1@@Z	;endl
	*** 0013d1	1e 			push	ds
	*** 0013d2	68 00 00 		push	OFFSET DGROUP:$SG3796
	*** 0013d5	68 00 00 		push	SEG ?cout@@3Vostream_withassign@@E	;cout
	*** 0013d8	68 00 00 		push	OFFSET ?cout@@3Vostream_withassign@@E	;cout
	*** 0013db	9a 00 00 00 00 		call	FAR PTR ??6ostream@@RECAEV0@PFD@Z	; ostream::operator<<
	*** 0013e0	52 			push	dx
	*** 0013e1	50 			push	ax
	*** 0013e2	9a 00 00 00 00 		call	FAR PTR ??6ostream@@RECAEV0@P7AAEV0@AEV0@@Z@Z	; ostream::operator<<
;|***     terminate();
; Line 1120
	*** 0013e7	9a 00 00 00 00 		call	FAR PTR ?terminate@@ZAXXZ	; terminate
;|***     }
; Line 1121
					$I3795:
;|***   
;|***   // test channelb to make sure it opened
;|***   if(escc1.clear_rx_buffer(channelb)==TRUE)
; Line 1124
	*** 0013ec	ff 36 00 00 		push	WORD PTR ?channelb@@3IE	;channelb
	*** 0013f0	68 00 00 		push	SEG ?escc1@@3VCescc@@E	;escc1
	*** 0013f3	68 00 00 		push	OFFSET ?escc1@@3VCescc@@E	;escc1
	*** 0013f6	9a 00 00 00 00 		call	FAR PTR ?clear_rx_buffer@Cescc@@RECII@Z	; Cescc::clear_rx_buffer
	*** 0013fb	3d 00 00 		cmp	ax,0
	*** 0013fe	74 03 			je	$JCC5118
	*** 001400	e9 1f 00 		jmp	$I3797
					$JCC5118:
;|***     cout << "Channel B rx buffer cleared OK.  " << endl;
; Line 1125
	*** 001403	68 00 00 		push	SEG ?endl@@ZAAEVostream@@AEV1@@Z	;endl
	*** 001406	68 00 00 		push	OFFSET ?endl@@ZAAEVostream@@AEV1@@Z	;endl
	*** 001409	1e 			push	ds
	*** 00140a	68 00 00 		push	OFFSET DGROUP:$SG3798
	*** 00140d	68 00 00 		push	SEG ?cout@@3Vostream_withassign@@E	;cout
	*** 001410	68 00 00 		push	OFFSET ?cout@@3Vostream_withassign@@E	;cout
	*** 001413	9a 00 00 00 00 		call	FAR PTR ??6ostream@@RECAEV0@PFD@Z	; ostream::operator<<
	*** 001418	52 			push	dx
	*** 001419	50 			push	ax
	*** 00141a	9a 00 00 00 00 		call	FAR PTR ??6ostream@@RECAEV0@P7AAEV0@AEV0@@Z@Z	; ostream::operator<<
;|***   else
; Line 1126
	*** 00141f	e9 21 00 		jmp	$I3799
					$I3797:
;|***     {
; Line 1127
;|***     cout << "Channel B rx buffer clear FAILED!" << endl;
; Line 1128
	*** 001422	68 00 00 		push	SEG ?endl@@ZAAEVostream@@AEV1@@Z	;endl
	*** 001425	68 00 00 		push	OFFSET ?endl@@ZAAEVostream@@AEV1@@Z	;endl
	*** 001428	1e 			push	ds
	*** 001429	68 00 00 		push	OFFSET DGROUP:$SG3800
	*** 00142c	68 00 00 		push	SEG ?cout@@3Vostream_withassign@@E	;cout
	*** 00142f	68 00 00 		push	OFFSET ?cout@@3Vostream_withassign@@E	;cout
	*** 001432	9a 00 00 00 00 		call	FAR PTR ??6ostream@@RECAEV0@PFD@Z	; ostream::operator<<
	*** 001437	52 			push	dx
	*** 001438	50 			push	ax
	*** 001439	9a 00 00 00 00 		call	FAR PTR ??6ostream@@RECAEV0@P7AAEV0@AEV0@@Z@Z	; ostream::operator<<
;|***     terminate();
; Line 1129
	*** 00143e	9a 00 00 00 00 		call	FAR PTR ?terminate@@ZAXXZ	; terminate
;|***     }
; Line 1130
					$I3799:
;|***   
;|***   if(escc1.clear_tx_buffer(channelb)==TRUE)
; Line 1132
	*** 001443	ff 36 00 00 		push	WORD PTR ?channelb@@3IE	;channelb
	*** 001447	68 00 00 		push	SEG ?escc1@@3VCescc@@E	;escc1
	*** 00144a	68 00 00 		push	OFFSET ?escc1@@3VCescc@@E	;escc1
	*** 00144d	9a 00 00 00 00 		call	FAR PTR ?clear_tx_buffer@Cescc@@RECII@Z	; Cescc::clear_tx_buffer
	*** 001452	3d 00 00 		cmp	ax,0
	*** 001455	74 03 			je	$JCC5205
	*** 001457	e9 1f 00 		jmp	$I3801
					$JCC5205:
;|***     cout << "Channel B tx buffer cleared OK." << endl;
; Line 1133
	*** 00145a	68 00 00 		push	SEG ?endl@@ZAAEVostream@@AEV1@@Z	;endl
	*** 00145d	68 00 00 		push	OFFSET ?endl@@ZAAEVostream@@AEV1@@Z	;endl
	*** 001460	1e 			push	ds
	*** 001461	68 00 00 		push	OFFSET DGROUP:$SG3802
	*** 001464	68 00 00 		push	SEG ?cout@@3Vostream_withassign@@E	;cout
	*** 001467	68 00 00 		push	OFFSET ?cout@@3Vostream_withassign@@E	;cout
	*** 00146a	9a 00 00 00 00 		call	FAR PTR ??6ostream@@RECAEV0@PFD@Z	; ostream::operator<<
	*** 00146f	52 			push	dx
	*** 001470	50 			push	ax
	*** 001471	9a 00 00 00 00 		call	FAR PTR ??6ostream@@RECAEV0@P7AAEV0@AEV0@@Z@Z	; ostream::operator<<
;|***   else
; Line 1134
	*** 001476	e9 21 00 		jmp	$I3803
					$I3801:
;|***     {
; Line 1135
;|***     cout << "Channel B tx buffer clear FAILED!" << endl;
; Line 1136
	*** 001479	68 00 00 		push	SEG ?endl@@ZAAEVostream@@AEV1@@Z	;endl
	*** 00147c	68 00 00 		push	OFFSET ?endl@@ZAAEVostream@@AEV1@@Z	;endl
	*** 00147f	1e 			push	ds
	*** 001480	68 00 00 		push	OFFSET DGROUP:$SG3804
	*** 001483	68 00 00 		push	SEG ?cout@@3Vostream_withassign@@E	;cout
	*** 001486	68 00 00 		push	OFFSET ?cout@@3Vostream_withassign@@E	;cout
	*** 001489	9a 00 00 00 00 		call	FAR PTR ??6ostream@@RECAEV0@PFD@Z	; ostream::operator<<
	*** 00148e	52 			push	dx
	*** 00148f	50 			push	ax
	*** 001490	9a 00 00 00 00 		call	FAR PTR ??6ostream@@RECAEV0@P7AAEV0@AEV0@@Z@Z	; ostream::operator<<
;|***     terminate();
; Line 1137
	*** 001495	9a 00 00 00 00 		call	FAR PTR ?terminate@@ZAXXZ	; terminate
;|***     }
; Line 1138
					$I3803:
;|***   
;|***   //set channelb frame transmission type
;|***   if(escc1.set_tx_type(channelb, TRANSPARENT_MODE)==TRUE)
; Line 1141
	*** 00149a	ff 36 00 00 		push	WORD PTR ?channelb@@3IE	;channelb
	*** 00149e	6a 01 			push	1
	*** 0014a0	68 00 00 		push	SEG ?escc1@@3VCescc@@E	;escc1
	*** 0014a3	68 00 00 		push	OFFSET ?escc1@@3VCescc@@E	;escc1
	*** 0014a6	9a 00 00 00 00 		call	FAR PTR ?set_tx_type@Cescc@@RECIII@Z	; Cescc::set_tx_type
	*** 0014ab	3d 00 00 		cmp	ax,0
	*** 0014ae	74 03 			je	$JCC5294
	*** 0014b0	e9 1f 00 		jmp	$I3805
					$JCC5294:
;|***     cout << "Channel B set to Transparent Mode.  " << endl;
; Line 1142
	*** 0014b3	68 00 00 		push	SEG ?endl@@ZAAEVostream@@AEV1@@Z	;endl
	*** 0014b6	68 00 00 		push	OFFSET ?endl@@ZAAEVostream@@AEV1@@Z	;endl
	*** 0014b9	1e 			push	ds
	*** 0014ba	68 00 00 		push	OFFSET DGROUP:$SG3806
	*** 0014bd	68 00 00 		push	SEG ?cout@@3Vostream_withassign@@E	;cout
	*** 0014c0	68 00 00 		push	OFFSET ?cout@@3Vostream_withassign@@E	;cout
	*** 0014c3	9a 00 00 00 00 		call	FAR PTR ??6ostream@@RECAEV0@PFD@Z	; ostream::operator<<
	*** 0014c8	52 			push	dx
	*** 0014c9	50 			push	ax
	*** 0014ca	9a 00 00 00 00 		call	FAR PTR ??6ostream@@RECAEV0@P7AAEV0@AEV0@@Z@Z	; ostream::operator<<
;|***   else
; Line 1143
	*** 0014cf	e9 21 00 		jmp	$I3807
					$I3805:
;|***     {
; Line 1144
;|***     cout << "Channel B Transparent Mode not set!  Channel not open!" << endl;
; Line 1145
	*** 0014d2	68 00 00 		push	SEG ?endl@@ZAAEVostream@@AEV1@@Z	;endl
	*** 0014d5	68 00 00 		push	OFFSET ?endl@@ZAAEVostream@@AEV1@@Z	;endl
	*** 0014d8	1e 			push	ds
	*** 0014d9	68 00 00 		push	OFFSET DGROUP:$SG3808
	*** 0014dc	68 00 00 		push	SEG ?cout@@3Vostream_withassign@@E	;cout
	*** 0014df	68 00 00 		push	OFFSET ?cout@@3Vostream_withassign@@E	;cout
	*** 0014e2	9a 00 00 00 00 		call	FAR PTR ??6ostream@@RECAEV0@PFD@Z	; ostream::operator<<
	*** 0014e7	52 			push	dx
	*** 0014e8	50 			push	ax
	*** 0014e9	9a 00 00 00 00 		call	FAR PTR ??6ostream@@RECAEV0@P7AAEV0@AEV0@@Z@Z	; ostream::operator<<
;|***     terminate();
; Line 1146
	*** 0014ee	9a 00 00 00 00 		call	FAR PTR ?terminate@@ZAXXZ	; terminate
;|***     }
; Line 1147
					$I3807:
;|***   cout << "ESCC initialized." << endl;
; Line 1148
	*** 0014f3	68 00 00 		push	SEG ?endl@@ZAAEVostream@@AEV1@@Z	;endl
	*** 0014f6	68 00 00 		push	OFFSET ?endl@@ZAAEVostream@@AEV1@@Z	;endl
	*** 0014f9	1e 			push	ds
	*** 0014fa	68 00 00 		push	OFFSET DGROUP:$SG3809
	*** 0014fd	68 00 00 		push	SEG ?cout@@3Vostream_withassign@@E	;cout
	*** 001500	68 00 00 		push	OFFSET ?cout@@3Vostream_withassign@@E	;cout
	*** 001503	9a 00 00 00 00 		call	FAR PTR ??6ostream@@RECAEV0@PFD@Z	; ostream::operator<<
	*** 001508	52 			push	dx
	*** 001509	50 			push	ax
	*** 00150a	9a 00 00 00 00 		call	FAR PTR ??6ostream@@RECAEV0@P7AAEV0@AEV0@@Z@Z	; ostream::operator<<
;|***   }
; Line 1149
	*** 00150f	e9 00 00 		jmp	$EX3768
					$EX3768:
	*** 001512	5e 			pop	si
	*** 001513	5f 			pop	di
	*** 001514	c9 			leave	
	*** 001515	cb 			ret	

?configure_escc@@ZAXXZ	ENDP
	PUBLIC	?wait_for_time_tick@@ZAXXZ	; wait_for_time_tick
?wait_for_time_tick@@ZAXXZ	PROC FAR	; wait_for_time_tick
;|*** 
;|***   
;|*** void wait_for_time_tick(void)            
;|***   {
; Line 1153
	*** 001516	c8 02 00 00 		enter	2,0
	*** 00151a	57 			push	di
	*** 00151b	56 			push	si
;	pcm_lockup = -2
;|***   /*
;|***     Generates the 100 Hz frame rate,
;|***     sends the pcm data frame,
;|***     queries the LN200,
;|***     writes data to screen.
;|***   */
;|***   static unsigned toggle = 0;
;|***   unsigned pcm_lockup = 1;
; Line 1161
	*** 00151c	c7 46 fe 01 00 		mov	WORD PTR [bp-2],1	;pcm_lockup
;|***   
;|***   pcm_sent = 0;
; Line 1163
	*** 001521	c7 06 00 00 00 00 	mov	WORD PTR ?pcm_sent@@3IE,0	;pcm_sent
;|***   
;|***   while(frame < next_frame)              // idle loop waits until beginning of next frame
; Line 1165
					$FC3816:
	*** 001527	a1 00 00 		mov	ax,WORD PTR ?frame@@3KE	;frame
	*** 00152a	8b 16 02 00 		mov	dx,WORD PTR ?frame@@3KE+2	;frame
	*** 00152e	39 16 02 00 		cmp	WORD PTR ?next_frame@@3KE+2,dx	;next_frame
	*** 001532	73 03 			jae	$JCC5426
	*** 001534	e9 4b 00 		jmp	$FB3817
					$JCC5426:
	*** 001537	76 03 			jbe	$JCC5431
	*** 001539	e9 09 00 		jmp	$L4074
					$JCC5431:
	*** 00153c	39 06 00 00 		cmp	WORD PTR ?next_frame@@3KE,ax	;next_frame
	*** 001540	77 03 			ja	$JCC5440
	*** 001542	e9 3d 00 		jmp	$FB3817
					$JCC5440:
					$L4074:
;|***     {                                    // frame is incremented in dmm32a isr by 100 Hz timer
; Line 1166
;|***     if(data_ready)
; Line 1167
	*** 001545	83 3e 00 00 00 		cmp	WORD PTR ?data_ready@@3IE,0	;data_ready
	*** 00154a	75 03 			jne	$JCC5450
	*** 00154c	e9 0b 00 		jmp	$I3818
					$JCC5450:
;|***       {                                  // wait until adc's are done before querying the ln200
; Line 1168
;|***       data_ready = 0;
; Line 1169
	*** 00154f	c7 06 00 00 00 00 	mov	WORD PTR ?data_ready@@3IE,0	;data_ready
;|***       query_ln200();
; Line 1170
	*** 001555	9a 00 00 00 00 		call	FAR PTR ?query_ln200@@ZAXXZ	; query_ln200
;|***       }
; Line 1171
;|***     if(escc1.istxing[channelb]==0)
; Line 1172
					$I3818:
	*** 00155a	8e 06 00 00 		mov	es,WORD PTR $T4071
	*** 00155e	8b 1e 00 00 		mov	bx,WORD PTR ?channelb@@3IE	;channelb
	*** 001562	d1 e3 			shl	bx,1
	*** 001564	26 83 bf 92 01 00 	cmp	WORD PTR es:?escc1@@3VCescc@@E[bx+402],0	;escc1
	*** 00156a	74 03 			je	$JCC5482
	*** 00156c	e9 10 00 		jmp	$I3819
					$JCC5482:
;|***       {
; Line 1173
;|***       pcm_sent = 0;
; Line 1174
	*** 00156f	c7 06 00 00 00 00 	mov	WORD PTR ?pcm_sent@@3IE,0	;pcm_sent
;|***       send_pcm();
; Line 1175
	*** 001575	9a 00 00 00 00 		call	FAR PTR ?send_pcm@@ZAXXZ	; send_pcm
;|***       pcm_lockup = 0;
; Line 1176
	*** 00157a	c7 46 fe 00 00 		mov	WORD PTR [bp-2],0	;pcm_lockup
;|***       }  
; Line 1177
;|***     }
; Line 1178
					$I3819:
	*** 00157f	e9 a5 ff 		jmp	$FC3816
DMMTEST_TEXT      ENDS
CONST      SEGMENT
$T4075	DQ	03f768003999a2d0er    ;	5.493177473577816E-03
CONST      ENDS
DMMTEST_TEXT      SEGMENT
	ASSUME	CS: DMMTEST_TEXT
					$FB3817:
;|***   
;|***   //if(pcm_lockup) escc1.clear_tx_buffer(channelb);
;|***     
;|***   sprintf(s, "Pitch:   %04x  %10.2f deg", ln200.data[9], (ln200.data[9] / 182.044));   // Pitch
; Line 1182
	*** 001582	8e 06 00 00 		mov	es,WORD PTR $T4071
	*** 001586	bb 1e 00 		mov	bx,OFFSET ?ln200@@3ULN200@@E+30	;ln200
	*** 001589	9a 00 00 00 00 		call	FAR PTR __aFeldw
	*** 00158e	9a 00 00 00 00 		call	FAR PTR __aFdcvt
	*** 001593	bb 00 00 		mov	bx,OFFSET DGROUP:$T4075
	*** 001596	9a 00 00 00 00 		call	FAR PTR __aFfmuld
	*** 00159b	83 ec 08 		sub	sp,8
	*** 00159e	8b dc 			mov	bx,sp
	*** 0015a0	9a 00 00 00 00 		call	FAR PTR __aFfstdp
	*** 0015a5	8e 06 00 00 		mov	es,WORD PTR $T4071
	*** 0015a9	26 ff 36 1e 00 		push	WORD PTR es:?ln200@@3ULN200@@E+30	;ln200
	*** 0015ae	1e 			push	ds
	*** 0015af	68 00 00 		push	OFFSET DGROUP:$SG3820
	*** 0015b2	1e 			push	ds
	*** 0015b3	68 00 00 		push	OFFSET DGROUP:?s@@3QEDE	;s
	*** 0015b6	9a 00 00 00 00 		call	FAR PTR _sprintf
	*** 0015bb	83 c4 12 		add	sp,18	;0012H
;|***   PC_DispStr(0,6, (unsigned char *)s, DISP_FGND_BLACK + DISP_BGND_RED);
; Line 1183
	*** 0015be	6a 40 			push	64	;0040H
	*** 0015c0	1e 			push	ds
	*** 0015c1	68 00 00 		push	OFFSET DGROUP:?s@@3QEDE	;s
	*** 0015c4	6a 06 			push	6
	*** 0015c6	6a 00 			push	0
	*** 0015c8	9a 00 00 00 00 		call	FAR PTR ?PC_DispStr@@ZAXEEPEEE@Z	; PC_DispStr
	*** 0015cd	83 c4 0a 		add	sp,10	;000aH
;|***   sprintf(s, "Roll:    %04x  %10.2f deg", ln200.data[10], (ln200.data[10] / 182.044));  // Roll
; Line 1184
	*** 0015d0	8e 06 00 00 		mov	es,WORD PTR $T4071
	*** 0015d4	bb 20 00 		mov	bx,OFFSET ?ln200@@3ULN200@@E+32	;ln200
	*** 0015d7	9a 00 00 00 00 		call	FAR PTR __aFeldw
	*** 0015dc	9a 00 00 00 00 		call	FAR PTR __aFdcvt
	*** 0015e1	bb 00 00 		mov	bx,OFFSET DGROUP:$T4075
	*** 0015e4	9a 00 00 00 00 		call	FAR PTR __aFfmuld
	*** 0015e9	83 ec 08 		sub	sp,8
	*** 0015ec	8b dc 			mov	bx,sp
	*** 0015ee	9a 00 00 00 00 		call	FAR PTR __aFfstdp
	*** 0015f3	8e 06 00 00 		mov	es,WORD PTR $T4071
	*** 0015f7	26 ff 36 20 00 		push	WORD PTR es:?ln200@@3ULN200@@E+32	;ln200
	*** 0015fc	1e 			push	ds
	*** 0015fd	68 00 00 		push	OFFSET DGROUP:$SG3822
	*** 001600	1e 			push	ds
	*** 001601	68 00 00 		push	OFFSET DGROUP:?s@@3QEDE	;s
	*** 001604	9a 00 00 00 00 		call	FAR PTR _sprintf
	*** 001609	83 c4 12 		add	sp,18	;0012H
;|***   PC_DispStr(0,7, (unsigned char *)s, DISP_FGND_BLACK + DISP_BGND_RED);
; Line 1185
	*** 00160c	6a 40 			push	64	;0040H
	*** 00160e	1e 			push	ds
	*** 00160f	68 00 00 		push	OFFSET DGROUP:?s@@3QEDE	;s
	*** 001612	6a 07 			push	7
	*** 001614	6a 00 			push	0
	*** 001616	9a 00 00 00 00 		call	FAR PTR ?PC_DispStr@@ZAXEEPEEE@Z	; PC_DispStr
	*** 00161b	83 c4 0a 		add	sp,10	;000aH
;|***   sprintf(s, "Heading: %04x  %10.2f deg", ln200.data[11], (ln200.data[11] / 182.044));  // Heading
; Line 1186
	*** 00161e	8e 06 00 00 		mov	es,WORD PTR $T4071
	*** 001622	bb 22 00 		mov	bx,OFFSET ?ln200@@3ULN200@@E+34	;ln200
	*** 001625	9a 00 00 00 00 		call	FAR PTR __aFeldw
	*** 00162a	9a 00 00 00 00 		call	FAR PTR __aFdcvt
	*** 00162f	bb 00 00 		mov	bx,OFFSET DGROUP:$T4075
	*** 001632	9a 00 00 00 00 		call	FAR PTR __aFfmuld
	*** 001637	83 ec 08 		sub	sp,8
	*** 00163a	8b dc 			mov	bx,sp
	*** 00163c	9a 00 00 00 00 		call	FAR PTR __aFfstdp
	*** 001641	8e 06 00 00 		mov	es,WORD PTR $T4071
	*** 001645	26 ff 36 22 00 		push	WORD PTR es:?ln200@@3ULN200@@E+34	;ln200
	*** 00164a	1e 			push	ds
	*** 00164b	68 00 00 		push	OFFSET DGROUP:$SG3824
	*** 00164e	1e 			push	ds
	*** 00164f	68 00 00 		push	OFFSET DGROUP:?s@@3QEDE	;s
	*** 001652	9a 00 00 00 00 		call	FAR PTR _sprintf
	*** 001657	83 c4 12 		add	sp,18	;0012H
;|***   PC_DispStr(0,8, (unsigned char *)s, DISP_FGND_BLACK + DISP_BGND_RED);
; Line 1187
	*** 00165a	6a 40 			push	64	;0040H
	*** 00165c	1e 			push	ds
	*** 00165d	68 00 00 		push	OFFSET DGROUP:?s@@3QEDE	;s
	*** 001660	6a 08 			push	8
	*** 001662	6a 00 			push	0
	*** 001664	9a 00 00 00 00 		call	FAR PTR ?PC_DispStr@@ZAXEEPEEE@Z	; PC_DispStr
	*** 001669	83 c4 0a 		add	sp,10	;000aH
;|***   
;|***   sprintf(s, "Stern 1: %04x", echo.data[4]);
; Line 1189
	*** 00166c	8e 06 00 00 		mov	es,WORD PTR $T4071
	*** 001670	26 a0 10 00 		mov	al,BYTE PTR es:?echo@@3UECHO@@E+16	;echo
	*** 001674	2a e4 			sub	ah,ah
	*** 001676	50 			push	ax
	*** 001677	1e 			push	ds
	*** 001678	68 00 00 		push	OFFSET DGROUP:$SG3826
	*** 00167b	1e 			push	ds
	*** 00167c	68 00 00 		push	OFFSET DGROUP:?s@@3QEDE	;s
	*** 00167f	9a 00 00 00 00 		call	FAR PTR _sprintf
	*** 001684	83 c4 0a 		add	sp,10	;000aH
;|***   PC_DispStr(0,9, (unsigned char *)s, DISP_FGND_BLACK + DISP_BGND_RED);     // Stern 1
; Line 1190
	*** 001687	6a 40 			push	64	;0040H
	*** 001689	1e 			push	ds
	*** 00168a	68 00 00 		push	OFFSET DGROUP:?s@@3QEDE	;s
	*** 00168d	6a 09 			push	9
	*** 00168f	6a 00 			push	0
	*** 001691	9a 00 00 00 00 		call	FAR PTR ?PC_DispStr@@ZAXEEPEEE@Z	; PC_DispStr
	*** 001696	83 c4 0a 		add	sp,10	;000aH
;|***   sprintf(s, "Stern 2: %04x", echo.data[5]);
; Line 1191
	*** 001699	8e 06 00 00 		mov	es,WORD PTR $T4071
	*** 00169d	26 a0 11 00 		mov	al,BYTE PTR es:?echo@@3UECHO@@E+17	;echo
	*** 0016a1	2a e4 			sub	ah,ah
	*** 0016a3	50 			push	ax
	*** 0016a4	1e 			push	ds
	*** 0016a5	68 00 00 		push	OFFSET DGROUP:$SG3828
	*** 0016a8	1e 			push	ds
	*** 0016a9	68 00 00 		push	OFFSET DGROUP:?s@@3QEDE	;s
	*** 0016ac	9a 00 00 00 00 		call	FAR PTR _sprintf
	*** 0016b1	83 c4 0a 		add	sp,10	;000aH
;|***   PC_DispStr(0,10, (unsigned char *)s, DISP_FGND_BLACK + DISP_BGND_RED);     // Stern 2
; Line 1192
	*** 0016b4	6a 40 			push	64	;0040H
	*** 0016b6	1e 			push	ds
	*** 0016b7	68 00 00 		push	OFFSET DGROUP:?s@@3QEDE	;s
	*** 0016ba	6a 0a 			push	10	;000aH
	*** 0016bc	6a 00 			push	0
	*** 0016be	9a 00 00 00 00 		call	FAR PTR ?PC_DispStr@@ZAXEEPEEE@Z	; PC_DispStr
	*** 0016c3	83 c4 0a 		add	sp,10	;000aH
;|***   sprintf(s, "Rudder:  %04x", echo.data[3]);
; Line 1193
	*** 0016c6	8e 06 00 00 		mov	es,WORD PTR $T4071
	*** 0016ca	26 a0 0f 00 		mov	al,BYTE PTR es:?echo@@3UECHO@@E+15	;echo
	*** 0016ce	2a e4 			sub	ah,ah
	*** 0016d0	50 			push	ax
	*** 0016d1	1e 			push	ds
	*** 0016d2	68 00 00 		push	OFFSET DGROUP:$SG3830
	*** 0016d5	1e 			push	ds
	*** 0016d6	68 00 00 		push	OFFSET DGROUP:?s@@3QEDE	;s
	*** 0016d9	9a 00 00 00 00 		call	FAR PTR _sprintf
	*** 0016de	83 c4 0a 		add	sp,10	;000aH
;|***   PC_DispStr(0,11, (unsigned char *)s, DISP_FGND_BLACK + DISP_BGND_RED);     // Rudder
; Line 1194
	*** 0016e1	6a 40 			push	64	;0040H
	*** 0016e3	1e 			push	ds
	*** 0016e4	68 00 00 		push	OFFSET DGROUP:?s@@3QEDE	;s
	*** 0016e7	6a 0b 			push	11	;000bH
	*** 0016e9	6a 00 			push	0
	*** 0016eb	9a 00 00 00 00 		call	FAR PTR ?PC_DispStr@@ZAXEEPEEE@Z	; PC_DispStr
	*** 0016f0	83 c4 0a 		add	sp,10	;000aH
;|***   sprintf(s, "Fore:    %04x", echo.data[6]);
; Line 1195
	*** 0016f3	8e 06 00 00 		mov	es,WORD PTR $T4071
	*** 0016f7	26 a0 12 00 		mov	al,BYTE PTR es:?echo@@3UECHO@@E+18	;echo
	*** 0016fb	2a e4 			sub	ah,ah
	*** 0016fd	50 			push	ax
	*** 0016fe	1e 			push	ds
	*** 0016ff	68 00 00 		push	OFFSET DGROUP:$SG3832
	*** 001702	1e 			push	ds
	*** 001703	68 00 00 		push	OFFSET DGROUP:?s@@3QEDE	;s
	*** 001706	9a 00 00 00 00 		call	FAR PTR _sprintf
	*** 00170b	83 c4 0a 		add	sp,10	;000aH
;|***   PC_DispStr(0,12, (unsigned char *)s, DISP_FGND_BLACK + DISP_BGND_RED);     // Fore
; Line 1196
	*** 00170e	6a 40 			push	64	;0040H
	*** 001710	1e 			push	ds
	*** 001711	68 00 00 		push	OFFSET DGROUP:?s@@3QEDE	;s
	*** 001714	6a 0c 			push	12	;000cH
	*** 001716	6a 00 			push	0
	*** 001718	9a 00 00 00 00 		call	FAR PTR ?PC_DispStr@@ZAXEEPEEE@Z	; PC_DispStr
	*** 00171d	83 c4 0a 		add	sp,10	;000aH
;|***   
;|***   sprintf(s, "RawPos:    %08ld", prop_report);
; Line 1198
	*** 001720	ff 36 02 00 		push	WORD PTR ?prop_report@@3JE+2	;prop_report
	*** 001724	ff 36 00 00 		push	WORD PTR ?prop_report@@3JE	;prop_report
	*** 001728	1e 			push	ds
	*** 001729	68 00 00 		push	OFFSET DGROUP:$SG3834
	*** 00172c	1e 			push	ds
	*** 00172d	68 00 00 		push	OFFSET DGROUP:?s@@3QEDE	;s
	*** 001730	9a 00 00 00 00 		call	FAR PTR _sprintf
	*** 001735	83 c4 0c 		add	sp,12	;000cH
;|***   PC_DispStr(0,13, (unsigned char *)s, DISP_FGND_BLACK + DISP_BGND_RED);     // Prop position
; Line 1199
	*** 001738	6a 40 			push	64	;0040H
	*** 00173a	1e 			push	ds
	*** 00173b	68 00 00 		push	OFFSET DGROUP:?s@@3QEDE	;s
	*** 00173e	6a 0d 			push	13	;000dH
	*** 001740	6a 00 			push	0
	*** 001742	9a 00 00 00 00 		call	FAR PTR ?PC_DispStr@@ZAXEEPEEE@Z	; PC_DispStr
	*** 001747	83 c4 0a 		add	sp,10	;000aH
;|***   
;|***   sprintf(s, "RawIndex:    %08ld", index_report);
; Line 1201
	*** 00174a	ff 36 02 00 		push	WORD PTR ?index_report@@3JE+2	;index_report
	*** 00174e	ff 36 00 00 		push	WORD PTR ?index_report@@3JE	;index_report
	*** 001752	1e 			push	ds
	*** 001753	68 00 00 		push	OFFSET DGROUP:$SG3836
	*** 001756	1e 			push	ds
	*** 001757	68 00 00 		push	OFFSET DGROUP:?s@@3QEDE	;s
	*** 00175a	9a 00 00 00 00 		call	FAR PTR _sprintf
	*** 00175f	83 c4 0c 		add	sp,12	;000cH
;|***   PC_DispStr(0,14, (unsigned char *)s, DISP_FGND_BLACK + DISP_BGND_RED);     // Prop position
; Line 1202
	*** 001762	6a 40 			push	64	;0040H
	*** 001764	1e 			push	ds
	*** 001765	68 00 00 		push	OFFSET DGROUP:?s@@3QEDE	;s
	*** 001768	6a 0e 			push	14	;000eH
	*** 00176a	6a 00 			push	0
	*** 00176c	9a 00 00 00 00 		call	FAR PTR ?PC_DispStr@@ZAXEEPEEE@Z	; PC_DispStr
	*** 001771	83 c4 0a 		add	sp,10	;000aH
;|***   
;|***   sprintf(s, "PPos:    %08d", prop.position);
; Line 1204
	*** 001774	8e 06 00 00 		mov	es,WORD PTR $T4071
	*** 001778	26 ff 36 1c 00 		push	WORD PTR es:?prop@@3UPROP@@E+28	;prop
	*** 00177d	26 ff 36 1a 00 		push	WORD PTR es:?prop@@3UPROP@@E+26	;prop
	*** 001782	1e 			push	ds
	*** 001783	68 00 00 		push	OFFSET DGROUP:$SG3838
	*** 001786	1e 			push	ds
	*** 001787	68 00 00 		push	OFFSET DGROUP:?s@@3QEDE	;s
	*** 00178a	9a 00 00 00 00 		call	FAR PTR _sprintf
	*** 00178f	83 c4 0c 		add	sp,12	;000cH
;|***   PC_DispStr(0,15, (unsigned char *)s, DISP_FGND_BLACK + DISP_BGND_RED);     // Prop position
; Line 1205
	*** 001792	6a 40 			push	64	;0040H
	*** 001794	1e 			push	ds
	*** 001795	68 00 00 		push	OFFSET DGROUP:?s@@3QEDE	;s
	*** 001798	6a 0f 			push	15	;000fH
	*** 00179a	6a 00 			push	0
	*** 00179c	9a 00 00 00 00 		call	FAR PTR ?PC_DispStr@@ZAXEEPEEE@Z	; PC_DispStr
	*** 0017a1	83 c4 0a 		add	sp,10	;000aH
;|***     
;|***   next_frame = frame + 1;                
; Line 1207
	*** 0017a4	a1 00 00 		mov	ax,WORD PTR ?frame@@3KE	;frame
	*** 0017a7	8b 16 02 00 		mov	dx,WORD PTR ?frame@@3KE+2	;frame
	*** 0017ab	05 01 00 		add	ax,1
	*** 0017ae	83 d2 00 		adc	dx,0
	*** 0017b1	a3 00 00 		mov	WORD PTR ?next_frame@@3KE,ax	;next_frame
	*** 0017b4	89 16 02 00 		mov	WORD PTR ?next_frame@@3KE+2,dx	;next_frame
;|***   }
; Line 1208
	*** 0017b8	e9 00 00 		jmp	$EX3811
					$EX3811:
	*** 0017bb	5e 			pop	si
	*** 0017bc	5f 			pop	di
	*** 0017bd	c9 			leave	
	*** 0017be	cb 			ret	

?wait_for_time_tick@@ZAXXZ	ENDP
	PUBLIC	?start_data_collection@@ZAXXZ	; start_data_collection
?start_data_collection@@ZAXXZ	PROC FAR	; start_data_collection
;|*** 
;|***   
;|*** void start_data_collection(void)  
;|***   {
; Line 1212
	*** 0017bf	c8 00 00 00 		enter	0,0
	*** 0017c3	57 			push	di
	*** 0017c4	56 			push	si
;|***   trigger_dmm32a();
; Line 1213
	*** 0017c5	9a 00 00 00 00 		call	FAR PTR ?trigger_dmm32a@@ZAXXZ	; trigger_dmm32a
;|***   trigger_dmm32b();
; Line 1214
	*** 0017ca	9a 00 00 00 00 		call	FAR PTR ?trigger_dmm32b@@ZAXXZ	; trigger_dmm32b
;|***   }
; Line 1215
	*** 0017cf	e9 00 00 		jmp	$EX3841
					$EX3841:
	*** 0017d2	5e 			pop	si
	*** 0017d3	5f 			pop	di
	*** 0017d4	c9 			leave	
	*** 0017d5	cb 			ret	

?start_data_collection@@ZAXXZ	ENDP
	PUBLIC	?query_ln200@@ZAXXZ	; query_ln200
?query_ln200@@ZAXXZ	PROC FAR	; query_ln200
;|*** 
;|*** 
;|*** void query_ln200(void)
;|***   {
; Line 1219
	*** 0017d6	c8 00 00 00 		enter	0,0
	*** 0017da	57 			push	di
	*** 0017db	56 			push	si
;|***   prep_ln200_command();                        // build the ln200 initialization command
; Line 1220
	*** 0017dc	9a 00 00 00 00 		call	FAR PTR ?prep_ln200_command@@ZAXXZ	; prep_ln200_command
;|***   escc1.tx_port(channela, ln200_command, 14);  // and send it to the ln200
; Line 1221
	*** 0017e1	ff 36 00 00 		push	WORD PTR ?channela@@3IE	;channela
	*** 0017e5	1e 			push	ds
	*** 0017e6	68 00 00 		push	OFFSET DGROUP:?ln200_command@@3QEDE	;ln200_command
	*** 0017e9	6a 0e 			push	14	;000eH
	*** 0017eb	68 00 00 		push	SEG ?escc1@@3VCescc@@E	;escc1
	*** 0017ee	68 00 00 		push	OFFSET ?escc1@@3VCescc@@E	;escc1
	*** 0017f1	9a 00 00 00 00 		call	FAR PTR ?tx_port@Cescc@@RECIIPEDI@Z	; Cescc::tx_port
;|***   }
; Line 1222
	*** 0017f6	e9 00 00 		jmp	$EX3843
					$EX3843:
	*** 0017f9	5e 			pop	si
	*** 0017fa	5f 			pop	di
	*** 0017fb	c9 			leave	
	*** 0017fc	cb 			ret	

?query_ln200@@ZAXXZ	ENDP
	PUBLIC	?configure_dmm32a@@ZAXXZ	; configure_dmm32a
?configure_dmm32a@@ZAXXZ	PROC FAR	; configure_dmm32a
;|***   
;|*** 
;|*** void configure_dmm32a(void)
;|***   {
; Line 1226
	*** 0017fd	c8 00 00 00 		enter	0,0
	*** 001801	57 			push	di
	*** 001802	56 			push	si
;|***   cout << "Initializing DMM32a." << endl;
; Line 1227
	*** 001803	68 00 00 		push	SEG ?endl@@ZAAEVostream@@AEV1@@Z	;endl
	*** 001806	68 00 00 		push	OFFSET ?endl@@ZAAEVostream@@AEV1@@Z	;endl
	*** 001809	1e 			push	ds
	*** 00180a	68 00 00 		push	OFFSET DGROUP:$SG3846
	*** 00180d	68 00 00 		push	SEG ?cout@@3Vostream_withassign@@E	;cout
	*** 001810	68 00 00 		push	OFFSET ?cout@@3Vostream_withassign@@E	;cout
	*** 001813	9a 00 00 00 00 		call	FAR PTR ??6ostream@@RECAEV0@PFD@Z	; ostream::operator<<
	*** 001818	52 			push	dx
	*** 001819	50 			push	ax
	*** 00181a	9a 00 00 00 00 		call	FAR PTR ??6ostream@@RECAEV0@P7AAEV0@AEV0@@Z@Z	; ostream::operator<<
;|***    //io = 0x340, irq=11, bottom board, reads the two banks of 5B modules
;|***   _disable();
; Line 1229
	*** 00181f	9a 00 00 00 00 		call	FAR PTR __disable
;|***   _outp(OBS_BASE+FCR, FIFORST);                   // reset the fifo
; Line 1230
	*** 001824	6a 02 			push	2
	*** 001826	68 47 03 		push	839	;0347H
	*** 001829	9a 00 00 00 00 		call	FAR PTR __outp
	*** 00182e	83 c4 04 		add	sp,4
;|*** 
;|***   _outp(OBS_BASE+MCR, PAGE1);                     // set dio ports for outputs, mode0
; Line 1232
	*** 001831	6a 01 			push	1
	*** 001833	68 48 03 		push	840	;0348H
	*** 001836	9a 00 00 00 00 		call	FAR PTR __outp
	*** 00183b	83 c4 04 		add	sp,4
;|***   _outp(OBS_BASE+15,  0x80);
; Line 1233
	*** 00183e	68 80 00 		push	128	;0080H
	*** 001841	68 4f 03 		push	847	;034fH
	*** 001844	9a 00 00 00 00 		call	FAR PTR __outp
	*** 001849	83 c4 04 		add	sp,4
;|***   _outp(OBS_BASE+MCR, PAGE0);
; Line 1234
	*** 00184c	6a 00 			push	0
	*** 00184e	68 48 03 		push	840	;0348H
	*** 001851	9a 00 00 00 00 		call	FAR PTR __outp
	*** 001856	83 c4 04 		add	sp,4
;|*** 
;|***   _outp(OBS_BASE+LCR,  0);                         // set the range of channels to scan
; Line 1236
	*** 001859	6a 00 			push	0
	*** 00185b	68 42 03 		push	834	;0342H
	*** 00185e	9a 00 00 00 00 		call	FAR PTR __outp
	*** 001863	83 c4 04 		add	sp,4
;|***   _outp(OBS_BASE+HCR,  31);                        // all channels for the 2 5B module backplanes
; Line 1237
	*** 001866	6a 1f 			push	31	;001fH
	*** 001868	68 43 03 		push	835	;0343H
	*** 00186b	9a 00 00 00 00 		call	FAR PTR __outp
	*** 001870	83 c4 04 		add	sp,4
;|***   _outp(OBS_BASE+FCR, SCANEN);                     // enable scan interrupts
; Line 1238
	*** 001873	6a 04 			push	4
	*** 001875	68 47 03 		push	839	;0347H
	*** 001878	9a 00 00 00 00 		call	FAR PTR __outp
	*** 00187d	83 c4 04 		add	sp,4
;|***   _outp(OBS_BASE+ACR, KHZ200 | BIPOLAR5 | GAIN1);  // 200KHz scans, +-5Volt inputs
; Line 1239
	*** 001880	6a 30 			push	48	;0030H
	*** 001882	68 4b 03 		push	843	;034bH
	*** 001885	9a 00 00 00 00 		call	FAR PTR __outp
	*** 00188a	83 c4 04 		add	sp,4
;|***   while(_inp(OBS_BASE+ARR) & WAIT);                // wait for the adc circuits to settle
; Line 1240
					$FC3848:
	*** 00188d	68 4b 03 		push	843	;034bH
	*** 001890	9a 00 00 00 00 		call	FAR PTR __inp
	*** 001895	83 c4 02 		add	sp,2
	*** 001898	a8 80 			test	al,128	;0080H
	*** 00189a	75 03 			jne	$JCC6298
	*** 00189c	e9 03 00 		jmp	$FB3849
					$JCC6298:
	*** 00189f	e9 eb ff 		jmp	$FC3848
					$FB3849:
;|*** 
;|***   _outp(OBS_BASE+MCR, PAGE2);                      // configure ctc0 for falling edge trigger
; Line 1242
	*** 0018a2	6a 02 			push	2
	*** 0018a4	68 48 03 		push	840	;0348H
	*** 0018a7	9a 00 00 00 00 		call	FAR PTR __outp
	*** 0018ac	83 c4 04 		add	sp,4
;|***   _outp(OBS_BASE+15 , 1);
; Line 1243
	*** 0018af	6a 01 			push	1
	*** 0018b1	68 4f 03 		push	847	;034fH
	*** 0018b4	9a 00 00 00 00 		call	FAR PTR __outp
	*** 0018b9	83 c4 04 		add	sp,4
;|***   _outp(OBS_BASE+MCR, PAGE0);
; Line 1244
	*** 0018bc	6a 00 			push	0
	*** 0018be	68 48 03 		push	840	;0348H
	*** 0018c1	9a 00 00 00 00 		call	FAR PTR __outp
	*** 0018c6	83 c4 04 		add	sp,4
;|***   _outp(OBS_BASE+CTCCR, 0x42);                     // set CTC0 to 10 KHz input
; Line 1245
	*** 0018c9	6a 42 			push	66	;0042H
	*** 0018cb	68 4a 03 		push	842	;034aH
	*** 0018ce	9a 00 00 00 00 		call	FAR PTR __outp
	*** 0018d3	83 c4 04 		add	sp,4
;|***   _outp(OBS_BASE+MCR, PAGE0);                      // access the 82C54's registers
; Line 1246
	*** 0018d6	6a 00 			push	0
	*** 0018d8	68 48 03 		push	840	;0348H
	*** 0018db	9a 00 00 00 00 		call	FAR PTR __outp
	*** 0018e0	83 c4 04 		add	sp,4
;|***   _outp(OBS_BASE+15, CTC0 | LSBMSB | MODE2 | BINARY);// program the 82C54's mode
; Line 1247
	*** 0018e3	6a 34 			push	52	;0034H
	*** 0018e5	68 4f 03 		push	847	;034fH
	*** 0018e8	9a 00 00 00 00 		call	FAR PTR __outp
	*** 0018ed	83 c4 04 		add	sp,4
;|***   _outp(OBS_BASE+12, 0x64);                        // load divisor LSB (100 or 0x0064)
; Line 1248
	*** 0018f0	6a 64 			push	100	;0064H
	*** 0018f2	68 4c 03 		push	844	;034cH
	*** 0018f5	9a 00 00 00 00 		call	FAR PTR __outp
	*** 0018fa	83 c4 04 		add	sp,4
;|***   _outp(OBS_BASE+12, 0x00);                        // load divisor MSB
; Line 1249
	*** 0018fd	6a 00 			push	0
	*** 0018ff	68 4c 03 		push	844	;034cH
	*** 001902	9a 00 00 00 00 		call	FAR PTR __outp
	*** 001907	83 c4 04 		add	sp,4
;|***                                                    // 10 KHz / 100 = 100 Hz frame rate
;|***   old_dmm32a_vect = _dos_getvect(11-8+0x70);       // save old irq11 vector
; Line 1251
	*** 00190a	6a 73 			push	115	;0073H
	*** 00190c	9a 00 00 00 00 		call	FAR PTR __dos_getvect
	*** 001911	83 c4 02 		add	sp,2
	*** 001914	a3 00 00 		mov	WORD PTR ?old_dmm32a_vect@@3P7AXXZE,ax	;old_dmm32a_vect
	*** 001917	89 16 02 00 		mov	WORD PTR ?old_dmm32a_vect@@3P7AXXZE+2,dx	;old_dmm32a_vect
;|***   _dos_setvect(11-8+0x70, isr_dmm32a);             // install dmm32a isr vector
; Line 1252
	*** 00191b	68 00 00 		push	SEG ?isr_dmm32a@@ZAXXZ	;isr_dmm32a
	*** 00191e	68 00 00 		push	OFFSET ?isr_dmm32a@@ZAXXZ	;isr_dmm32a
	*** 001921	6a 73 			push	115	;0073H
	*** 001923	9a 00 00 00 00 		call	FAR PTR __dos_setvect
	*** 001928	83 c4 06 		add	sp,6
;|***   _outp(0xa1, _inp(0xa1) & 0xf7);                  // unmask irq11 at pic
; Line 1253
	*** 00192b	68 a1 00 		push	161	;00a1H
	*** 00192e	9a 00 00 00 00 		call	FAR PTR __inp
	*** 001933	83 c4 02 		add	sp,2
	*** 001936	25 f7 00 		and	ax,247	;00f7H
	*** 001939	50 			push	ax
	*** 00193a	68 a1 00 		push	161	;00a1H
	*** 00193d	9a 00 00 00 00 		call	FAR PTR __outp
	*** 001942	83 c4 04 		add	sp,4
;|*** 
;|***   _outp(OBS_BASE+ICR, ADINTE | TINTE);             // enable adc and timer interrupts
; Line 1255
	*** 001945	68 a0 00 		push	160	;00a0H
	*** 001948	68 49 03 		push	841	;0349H
	*** 00194b	9a 00 00 00 00 		call	FAR PTR __outp
	*** 001950	83 c4 04 		add	sp,4
;|***   _enable();
; Line 1256
	*** 001953	9a 00 00 00 00 		call	FAR PTR __enable
;|***   cout << "DMM32a initialized." << endl;
; Line 1257
	*** 001958	68 00 00 		push	SEG ?endl@@ZAAEVostream@@AEV1@@Z	;endl
	*** 00195b	68 00 00 		push	OFFSET ?endl@@ZAAEVostream@@AEV1@@Z	;endl
	*** 00195e	1e 			push	ds
	*** 00195f	68 00 00 		push	OFFSET DGROUP:$SG3850
	*** 001962	68 00 00 		push	SEG ?cout@@3Vostream_withassign@@E	;cout
	*** 001965	68 00 00 		push	OFFSET ?cout@@3Vostream_withassign@@E	;cout
	*** 001968	9a 00 00 00 00 		call	FAR PTR ??6ostream@@RECAEV0@PFD@Z	; ostream::operator<<
	*** 00196d	52 			push	dx
	*** 00196e	50 			push	ax
	*** 00196f	9a 00 00 00 00 		call	FAR PTR ??6ostream@@RECAEV0@P7AAEV0@AEV0@@Z@Z	; ostream::operator<<
;|***   }
; Line 1258
	*** 001974	e9 00 00 		jmp	$EX3845
					$EX3845:
	*** 001977	5e 			pop	si
	*** 001978	5f 			pop	di
	*** 001979	c9 			leave	
	*** 00197a	cb 			ret	

?configure_dmm32a@@ZAXXZ	ENDP
	PUBLIC	?trigger_dmm32a@@ZAXXZ	; trigger_dmm32a
?trigger_dmm32a@@ZAXXZ	PROC FAR	; trigger_dmm32a
;|***   
;|*** 
;|*** void trigger_dmm32a(void)  
;|***   {
; Line 1262
	*** 00197b	c8 00 00 00 		enter	0,0
	*** 00197f	57 			push	di
	*** 001980	56 			push	si
;|***   while(_inp(OBS_BASE+ARR) & WAIT);        // wait for the adc inputs to settle
; Line 1263
					$FC3854:
	*** 001981	68 4b 03 		push	843	;034bH
	*** 001984	9a 00 00 00 00 		call	FAR PTR __inp
	*** 001989	83 c4 02 		add	sp,2
	*** 00198c	a8 80 			test	al,128	;0080H
	*** 00198e	75 03 			jne	$JCC6542
	*** 001990	e9 03 00 		jmp	$FB3855
					$JCC6542:
	*** 001993	e9 eb ff 		jmp	$FC3854
					$FB3855:
;|***   _outp(OBS_BASE, 0);                      // start the scan of the onboard sensors
; Line 1264
	*** 001996	6a 00 			push	0
	*** 001998	68 40 03 		push	832	;0340H
	*** 00199b	9a 00 00 00 00 		call	FAR PTR __outp
	*** 0019a0	83 c4 04 		add	sp,4
;|***   }
; Line 1265
	*** 0019a3	e9 00 00 		jmp	$EX3852
					$EX3852:
	*** 0019a6	5e 			pop	si
	*** 0019a7	5f 			pop	di
	*** 0019a8	c9 			leave	
	*** 0019a9	cb 			ret	

?trigger_dmm32a@@ZAXXZ	ENDP
	PUBLIC	?isr_dmm32a@@ZAXXZ	; isr_dmm32a
?isr_dmm32a@@ZAXXZ	PROC FAR	; isr_dmm32a
;|***   
;|***   
;|*** void interrupt isr_dmm32a(void)
;|***   {
; Line 1269
	*** 0019aa	60 			pusha
	*** 0019ab	1e 			push	ds
	*** 0019ac	06 			push	es
	*** 0019ad	8b ec 			mov	bp,sp
	*** 0019af	81 ec 06 00 		sub	sp,6
	*** 0019b3	1e 			push	ds
	*** 0019b4	b8 00 00 		mov	ax,DGROUP
	*** 0019b7	8e d8 			mov	ds,ax
	ASSUME DS: DGROUP
	*** 0019b9	fc 			cld	
;	i = -2
;	lsb = -4
;	msb = -6
;|***   // the dmm32 A board generates two types of interrupts:
;|***   // 1) 82C54 ctc0 timeouts, TINT, the 100 Hz frame timer
;|***   // 2) adc scan complete, ADINT, when onboard sensor data is ready
;|***   
;|***   unsigned i;
;|***   unsigned lsb = 0;
; Line 1275
	*** 0019ba	c7 46 fc 00 00 		mov	WORD PTR [bp-4],0	;lsb
;|***   unsigned msb = 0;
; Line 1276
	*** 0019bf	c7 46 fa 00 00 		mov	WORD PTR [bp-6],0	;msb
;|*** 
;|***   // section 1, a TINT has occurred, the 100 Hz ctc0 signals the beginning of a new frame
;|***   if(_inp(OBS_BASE+ISR) & TINT)
; Line 1279
	*** 0019c4	68 49 03 		push	841	;0349H
	*** 0019c7	9a 00 00 00 00 		call	FAR PTR __inp
	*** 0019cc	83 c4 02 		add	sp,2
	*** 0019cf	a8 20 			test	al,32	;0020H
	*** 0019d1	75 03 			jne	$JCC6609
	*** 0019d3	e9 0a 00 		jmp	$I3861
					$JCC6609:
;|***     {
; Line 1280
;|***     frame++;                                       // update the frame counter
; Line 1281
	*** 0019d6	83 06 00 00 01 		add	WORD PTR ?frame@@3KE,1	;frame
	*** 0019db	83 16 02 00 00 		adc	WORD PTR ?frame@@3KE+2,0	;frame
;|***     }
; Line 1282
;|***   
;|***   // section 2, an ADINT has occurred, the onboard sensor data is ready
;|***   if(_inp(OBS_BASE+ISR) & ADINT)
; Line 1285
					$I3861:
	*** 0019e0	68 49 03 		push	841	;0349H
	*** 0019e3	9a 00 00 00 00 		call	FAR PTR __inp
	*** 0019e8	83 c4 02 		add	sp,2
	*** 0019eb	a8 80 			test	al,128	;0080H
	*** 0019ed	75 03 			jne	$JCC6637
	*** 0019ef	e9 5f 00 		jmp	$I3862
					$JCC6637:
;|***     {
; Line 1286
;|***     time_stamp(&obs_time);
; Line 1287
	*** 0019f2	68 00 00 		push	SEG ?obs_time@@3UTIMER@@E	;obs_time
	*** 0019f5	68 00 00 		push	OFFSET ?obs_time@@3UTIMER@@E	;obs_time
	*** 0019f8	9a 00 00 00 00 		call	FAR PTR ?time_stamp@@ZAXPEUTIMER@@@Z	; time_stamp
	*** 0019fd	83 c4 04 		add	sp,4
;|***     for(i=0; i<32; i++) obs_array[i] = _inpw(OBS_BASE);  // read the data from the dmm32a fifo
; Line 1288
	*** 001a00	c7 46 fe 00 00 		mov	WORD PTR [bp-2],0	;i
	*** 001a05	e9 03 00 		jmp	$F3863
					$FC3864:
	*** 001a08	ff 46 fe 		inc	WORD PTR [bp-2]	;i
					$F3863:
	*** 001a0b	83 7e fe 20 		cmp	WORD PTR [bp-2],32	;0020H	;i
	*** 001a0f	72 03 			jb	$JCC6671
	*** 001a11	e9 17 00 		jmp	$FB3865
					$JCC6671:
	*** 001a14	68 40 03 		push	832	;0340H
	*** 001a17	9a 00 00 00 00 		call	FAR PTR __inpw
	*** 001a1c	83 c4 02 		add	sp,2
	*** 001a1f	8b 5e fe 		mov	bx,WORD PTR [bp-2]	;i
	*** 001a22	d1 e3 			shl	bx,1
	*** 001a24	89 87 00 00 		mov	WORD PTR ?obs_array@@3QEIE[bx],ax	;obs_array
	*** 001a28	e9 dd ff 		jmp	$FC3864
					$FB3865:
;|***     _fmemcpy(obs_buffer, obs_array, sizeof(obs_array));  // buffer the data
; Line 1289
	*** 001a2b	6a 40 			push	64	;0040H
	*** 001a2d	1e 			push	ds
	*** 001a2e	68 00 00 		push	OFFSET DGROUP:?obs_array@@3QEIE	;obs_array
	*** 001a31	1e 			push	ds
	*** 001a32	68 00 00 		push	OFFSET DGROUP:?obs_buffer@@3QEEE	;obs_buffer
	*** 001a35	9a 00 00 00 00 		call	FAR PTR __fmemcpy
	*** 001a3a	83 c4 0a 		add	sp,10	;000aH
;|***     obs_new_data = 1;                                    // flag the system new data available
; Line 1290
	*** 001a3d	c7 06 00 00 01 00 	mov	WORD PTR ?obs_new_data@@3IE,1	;obs_new_data
;|***     obs_data_frame = frame;                              // record the frame number
; Line 1291
	*** 001a43	a1 00 00 		mov	ax,WORD PTR ?frame@@3KE	;frame
	*** 001a46	8b 16 02 00 		mov	dx,WORD PTR ?frame@@3KE+2	;frame
	*** 001a4a	a3 00 00 		mov	WORD PTR ?obs_data_frame@@3KE,ax	;obs_data_frame
	*** 001a4d	89 16 02 00 		mov	WORD PTR ?obs_data_frame@@3KE+2,dx	;obs_data_frame
;|***     }
; Line 1292
;|***   _outp(OBS_BASE+MCR, INTRST);                           // reset the dmm32's interrupt circuit    
; Line 1293
					$I3862:
	*** 001a51	6a 08 			push	8
	*** 001a53	68 48 03 		push	840	;0348H
	*** 001a56	9a 00 00 00 00 		call	FAR PTR __outp
	*** 001a5b	83 c4 04 		add	sp,4
;|***   _outp(OBS_BASE+FCR, FIFORST);                          // reset the fifo
; Line 1294
	*** 001a5e	6a 02 			push	2
	*** 001a60	68 47 03 		push	839	;0347H
	*** 001a63	9a 00 00 00 00 		call	FAR PTR __outp
	*** 001a68	83 c4 04 		add	sp,4
;|***   _outp(OBS_BASE+LCR,  0);                               // reset the range of channels to scan
; Line 1295
	*** 001a6b	6a 00 			push	0
	*** 001a6d	68 42 03 		push	834	;0342H
	*** 001a70	9a 00 00 00 00 		call	FAR PTR __outp
	*** 001a75	83 c4 04 		add	sp,4
;|***   _outp(OBS_BASE+HCR,  31);
; Line 1296
	*** 001a78	6a 1f 			push	31	;001fH
	*** 001a7a	68 43 03 		push	835	;0343H
	*** 001a7d	9a 00 00 00 00 		call	FAR PTR __outp
	*** 001a82	83 c4 04 		add	sp,4
;|***   _outp(OBS_BASE+FCR, SCANEN);                           // enable scan interrupts
; Line 1297
	*** 001a85	6a 04 			push	4
	*** 001a87	68 47 03 		push	839	;0347H
	*** 001a8a	9a 00 00 00 00 		call	FAR PTR __outp
	*** 001a8f	83 c4 04 		add	sp,4
;|*** 
;|***   _outp(0xa0, 0x20);                                     // slave EOI
; Line 1299
	*** 001a92	6a 20 			push	32	;0020H
	*** 001a94	68 a0 00 		push	160	;00a0H
	*** 001a97	9a 00 00 00 00 		call	FAR PTR __outp
	*** 001a9c	83 c4 04 		add	sp,4
;|***   _outp(0x20, 0x20);                                     // master EOI  
; Line 1300
	*** 001a9f	6a 20 			push	32	;0020H
	*** 001aa1	6a 20 			push	32	;0020H
	*** 001aa3	9a 00 00 00 00 		call	FAR PTR __outp
	*** 001aa8	83 c4 04 		add	sp,4
;|***   }
; Line 1301
	*** 001aab	e9 00 00 		jmp	$EX3857
					$EX3857:
	*** 001aae	8b e5 			mov	sp,bp
	*** 001ab0	07 			pop	es
	*** 001ab1	1f 			pop	ds
	ASSUME DS: DGROUP
	*** 001ab2	61 			popa
	*** 001ab3	cf 			iret	

?isr_dmm32a@@ZAXXZ	ENDP
	PUBLIC	?configure_dmm32b@@ZAXXZ	; configure_dmm32b
?configure_dmm32b@@ZAXXZ	PROC FAR	; configure_dmm32b
;|***   
;|*** 
;|*** void configure_dmm32b(void)
;|***   {
; Line 1305
	*** 001ab4	c8 00 00 00 		enter	0,0
	*** 001ab8	57 			push	di
	*** 001ab9	56 			push	si
;|***   cout << "Initializing DMM32b." << endl;
; Line 1306
	*** 001aba	68 00 00 		push	SEG ?endl@@ZAAEVostream@@AEV1@@Z	;endl
	*** 001abd	68 00 00 		push	OFFSET ?endl@@ZAAEVostream@@AEV1@@Z	;endl
	*** 001ac0	1e 			push	ds
	*** 001ac1	68 00 00 		push	OFFSET DGROUP:$SG3868
	*** 001ac4	68 00 00 		push	SEG ?cout@@3Vostream_withassign@@E	;cout
	*** 001ac7	68 00 00 		push	OFFSET ?cout@@3Vostream_withassign@@E	;cout
	*** 001aca	9a 00 00 00 00 		call	FAR PTR ??6ostream@@RECAEV0@PFD@Z	; ostream::operator<<
	*** 001acf	52 			push	dx
	*** 001ad0	50 			push	ax
	*** 001ad1	9a 00 00 00 00 		call	FAR PTR ??6ostream@@RECAEV0@P7AAEV0@AEV0@@Z@Z	; ostream::operator<<
;|***   //io = 0x380, irq=12, top board, reads the mux boxes and the prop dynos
;|***   _disable();
; Line 1308
	*** 001ad6	9a 00 00 00 00 		call	FAR PTR __disable
;|*** 
;|***   _outp(DYNO_BASE+FCR, FIFORST);                         // reset the adc fifo
; Line 1310
	*** 001adb	6a 02 			push	2
	*** 001add	68 87 03 		push	903	;0387H
	*** 001ae0	9a 00 00 00 00 		call	FAR PTR __outp
	*** 001ae5	83 c4 04 		add	sp,4
;|***   _outp(DYNO_BASE+LCR,  0);                              // set the range of channels to scan
; Line 1311
	*** 001ae8	6a 00 			push	0
	*** 001aea	68 82 03 		push	898	;0382H
	*** 001aed	9a 00 00 00 00 		call	FAR PTR __outp
	*** 001af2	83 c4 04 		add	sp,4
;|***   _outp(DYNO_BASE+HCR,  7);                              // initially set for 8 channels for mux boxes
; Line 1312
	*** 001af5	6a 07 			push	7
	*** 001af7	68 83 03 		push	899	;0383H
	*** 001afa	9a 00 00 00 00 		call	FAR PTR __outp
	*** 001aff	83 c4 04 		add	sp,4
;|***   _outp(DYNO_BASE+FCR, SCANEN);                          // enable adc scan interrupts
; Line 1313
	*** 001b02	6a 04 			push	4
	*** 001b04	68 87 03 		push	903	;0387H
	*** 001b07	9a 00 00 00 00 		call	FAR PTR __outp
	*** 001b0c	83 c4 04 		add	sp,4
;|***   _outp(DYNO_BASE+ACR, KHZ200 | BIPOLAR5 | GAIN1);       // 200KHz scans, +-5Volt inputs
; Line 1314
	*** 001b0f	6a 30 			push	48	;0030H
	*** 001b11	68 8b 03 		push	907	;038bH
	*** 001b14	9a 00 00 00 00 		call	FAR PTR __outp
	*** 001b19	83 c4 04 		add	sp,4
;|***   while(_inp(DYNO_BASE+ARR) & WAIT);                     // wait for adc inputs to settle
; Line 1315
					$FC3870:
	*** 001b1c	68 8b 03 		push	907	;038bH
	*** 001b1f	9a 00 00 00 00 		call	FAR PTR __inp
	*** 001b24	83 c4 02 		add	sp,2
	*** 001b27	a8 80 			test	al,128	;0080H
	*** 001b29	75 03 			jne	$JCC6953
	*** 001b2b	e9 03 00 		jmp	$FB3871
					$JCC6953:
	*** 001b2e	e9 eb ff 		jmp	$FC3870
					$FB3871:
;|*** 
;|***   _outp(DYNO_BASE+MCR, PAGE1);                           // set the 8255 dio ports for outputs, mode0
; Line 1317
	*** 001b31	6a 01 			push	1
	*** 001b33	68 88 03 		push	904	;0388H
	*** 001b36	9a 00 00 00 00 		call	FAR PTR __outp
	*** 001b3b	83 c4 04 		add	sp,4
;|***   _outp(DYNO_BASE+15,  0x80);
; Line 1318
	*** 001b3e	68 80 00 		push	128	;0080H
	*** 001b41	68 8f 03 		push	911	;038fH
	*** 001b44	9a 00 00 00 00 		call	FAR PTR __outp
	*** 001b49	83 c4 04 		add	sp,4
;|***   _outp(DYNO_BASE+MCR, PAGE0);
; Line 1319
	*** 001b4c	6a 00 			push	0
	*** 001b4e	68 88 03 		push	904	;0388H
	*** 001b51	9a 00 00 00 00 		call	FAR PTR __outp
	*** 001b56	83 c4 04 		add	sp,4
;|*** 
;|***   old_dmm32b_vect = _dos_getvect(12-8+0x70);             // save old irq12 isr vector
; Line 1321
	*** 001b59	6a 74 			push	116	;0074H
	*** 001b5b	9a 00 00 00 00 		call	FAR PTR __dos_getvect
	*** 001b60	83 c4 02 		add	sp,2
	*** 001b63	a3 00 00 		mov	WORD PTR ?old_dmm32b_vect@@3P7AXXZE,ax	;old_dmm32b_vect
	*** 001b66	89 16 02 00 		mov	WORD PTR ?old_dmm32b_vect@@3P7AXXZE+2,dx	;old_dmm32b_vect
;|***   _dos_setvect(12-8+0x70, isr_dmm32b);                   // install new isr_dmm32b vector
; Line 1322
	*** 001b6a	68 00 00 		push	SEG ?isr_dmm32b@@ZAXXZ	;isr_dmm32b
	*** 001b6d	68 00 00 		push	OFFSET ?isr_dmm32b@@ZAXXZ	;isr_dmm32b
	*** 001b70	6a 74 			push	116	;0074H
	*** 001b72	9a 00 00 00 00 		call	FAR PTR __dos_setvect
	*** 001b77	83 c4 06 		add	sp,6
;|***   _outp(0xa1, _inp(0xa1) & 0xef);                        // unmask irq12 at pic
; Line 1323
	*** 001b7a	68 a1 00 		push	161	;00a1H
	*** 001b7d	9a 00 00 00 00 		call	FAR PTR __inp
	*** 001b82	83 c4 02 		add	sp,2
	*** 001b85	25 ef 00 		and	ax,239	;00efH
	*** 001b88	50 			push	ax
	*** 001b89	68 a1 00 		push	161	;00a1H
	*** 001b8c	9a 00 00 00 00 		call	FAR PTR __outp
	*** 001b91	83 c4 04 		add	sp,4
;|*** 
;|***   _outp(DYNO_BASE+CTCCR, _inp(DYNO_BASE+CTCCR) | 0x02);  // set 8254 ctc0 for 10 MHz input
; Line 1325
	*** 001b94	68 8a 03 		push	906	;038aH
	*** 001b97	9a 00 00 00 00 		call	FAR PTR __inp
	*** 001b9c	83 c4 02 		add	sp,2
	*** 001b9f	0d 02 00 		or	ax,2
	*** 001ba2	50 			push	ax
	*** 001ba3	68 8a 03 		push	906	;038aH
	*** 001ba6	9a 00 00 00 00 		call	FAR PTR __outp
	*** 001bab	83 c4 04 		add	sp,4
;|***   _outp(DYNO_BASE+MCR, PAGE2);                           // set ctc0 for falling edge trigger
; Line 1326
	*** 001bae	6a 02 			push	2
	*** 001bb0	68 88 03 		push	904	;0388H
	*** 001bb3	9a 00 00 00 00 		call	FAR PTR __outp
	*** 001bb8	83 c4 04 		add	sp,4
;|***   _outp(DYNO_BASE+15 , 1);
; Line 1327
	*** 001bbb	6a 01 			push	1
	*** 001bbd	68 8f 03 		push	911	;038fH
	*** 001bc0	9a 00 00 00 00 		call	FAR PTR __outp
	*** 001bc5	83 c4 04 		add	sp,4
;|***   _outp(DYNO_BASE+MCR, PAGE0);
; Line 1328
	*** 001bc8	6a 00 			push	0
	*** 001bca	68 88 03 		push	904	;0388H
	*** 001bcd	9a 00 00 00 00 		call	FAR PTR __outp
	*** 001bd2	83 c4 04 		add	sp,4
;|***   _outp(DYNO_BASE+ICR, ADINTE | TINTE);                  // enable adc & ctc0 timer interrupts
; Line 1329
	*** 001bd5	68 a0 00 		push	160	;00a0H
	*** 001bd8	68 89 03 		push	905	;0389H
	*** 001bdb	9a 00 00 00 00 		call	FAR PTR __outp
	*** 001be0	83 c4 04 		add	sp,4
;|*** 
;|***   _enable();
; Line 1331
	*** 001be3	9a 00 00 00 00 		call	FAR PTR __enable
;|***   cout << "DMM32b initialized." << endl;
; Line 1332
	*** 001be8	68 00 00 		push	SEG ?endl@@ZAAEVostream@@AEV1@@Z	;endl
	*** 001beb	68 00 00 		push	OFFSET ?endl@@ZAAEVostream@@AEV1@@Z	;endl
	*** 001bee	1e 			push	ds
	*** 001bef	68 00 00 		push	OFFSET DGROUP:$SG3872
	*** 001bf2	68 00 00 		push	SEG ?cout@@3Vostream_withassign@@E	;cout
	*** 001bf5	68 00 00 		push	OFFSET ?cout@@3Vostream_withassign@@E	;cout
	*** 001bf8	9a 00 00 00 00 		call	FAR PTR ??6ostream@@RECAEV0@PFD@Z	; ostream::operator<<
	*** 001bfd	52 			push	dx
	*** 001bfe	50 			push	ax
	*** 001bff	9a 00 00 00 00 		call	FAR PTR ??6ostream@@RECAEV0@P7AAEV0@AEV0@@Z@Z	; ostream::operator<<
;|***   }
; Line 1333
	*** 001c04	e9 00 00 		jmp	$EX3867
					$EX3867:
	*** 001c07	5e 			pop	si
	*** 001c08	5f 			pop	di
	*** 001c09	c9 			leave	
	*** 001c0a	cb 			ret	

?configure_dmm32b@@ZAXXZ	ENDP
	PUBLIC	?trigger_dmm32b@@ZAXXZ	; trigger_dmm32b
?trigger_dmm32b@@ZAXXZ	PROC FAR	; trigger_dmm32b
;|*** 
;|*** 
;|*** void trigger_dmm32b(void)  
;|***   {                                  // start dmm32b for the entire mux/scan/read routine
; Line 1337
	*** 001c0b	c8 00 00 00 		enter	0,0
	*** 001c0f	57 			push	di
	*** 001c10	56 			push	si
;|***   reading_prop = 0;                  // start with mux box scans, not prop scans
; Line 1338
	*** 001c11	c7 06 00 00 00 00 	mov	WORD PTR ?reading_prop@@3IE,0	;reading_prop
;|***   mux_addr = 0;
; Line 1339
	*** 001c17	c7 06 00 00 00 00 	mov	WORD PTR ?mux_addr@@3IE,0	;mux_addr
;|*** 
;|***   _disable();
; Line 1341
	*** 001c1d	9a 00 00 00 00 		call	FAR PTR __disable
;|***   
;|***   // initialize the mux address and put it on the wires
;|***   _outp(DYNO_BASE+MCR, PAGE1);
; Line 1344
	*** 001c22	6a 01 			push	1
	*** 001c24	68 88 03 		push	904	;0388H
	*** 001c27	9a 00 00 00 00 		call	FAR PTR __outp
	*** 001c2c	83 c4 04 		add	sp,4
;|***   _outp(DYNO_BASE+PORTA , mux_addr);
; Line 1345
	*** 001c2f	ff 36 00 00 		push	WORD PTR ?mux_addr@@3IE	;mux_addr
	*** 001c33	68 8c 03 		push	908	;038cH
	*** 001c36	9a 00 00 00 00 		call	FAR PTR __outp
	*** 001c3b	83 c4 04 		add	sp,4
;|***   _outp(DYNO_BASE+MCR, PAGE0);
; Line 1346
	*** 001c3e	6a 00 			push	0
	*** 001c40	68 88 03 		push	904	;0388H
	*** 001c43	9a 00 00 00 00 		call	FAR PTR __outp
	*** 001c48	83 c4 04 		add	sp,4
;|*** 
;|***   // start a 200 usec settling period for the mux box data 
;|***   // with a 10MHz input to ctc0 and desired delay of 200 usec the divisor = 2000 = 0x07d0
;|***   _outp(DYNO_BASE+15, CTC0 | LSBMSB | MODE0 | BINARY);   // program ctc0
; Line 1350
	*** 001c4b	6a 30 			push	48	;0030H
	*** 001c4d	68 8f 03 		push	911	;038fH
	*** 001c50	9a 00 00 00 00 		call	FAR PTR __outp
	*** 001c55	83 c4 04 		add	sp,4
;|***   _outp(DYNO_BASE+12, 0xd0);                             // load divisor LSB
; Line 1351
	*** 001c58	68 d0 00 		push	208	;00d0H
	*** 001c5b	68 8c 03 		push	908	;038cH
	*** 001c5e	9a 00 00 00 00 		call	FAR PTR __outp
	*** 001c63	83 c4 04 		add	sp,4
;|***   _outp(DYNO_BASE+12, 0x07);                             // load divisor MSB
; Line 1352
	*** 001c66	6a 07 			push	7
	*** 001c68	68 8c 03 		push	908	;038cH
	*** 001c6b	9a 00 00 00 00 		call	FAR PTR __outp
	*** 001c70	83 c4 04 		add	sp,4
;|***   _outp(DYNO_BASE+ICR, ADINTE | TINTE);                  // enable adc and timer interrupts
; Line 1353
	*** 001c73	68 a0 00 		push	160	;00a0H
	*** 001c76	68 89 03 		push	905	;0389H
	*** 001c79	9a 00 00 00 00 		call	FAR PTR __outp
	*** 001c7e	83 c4 04 		add	sp,4
;|***   _enable();
; Line 1354
	*** 001c81	9a 00 00 00 00 		call	FAR PTR __enable
;|***   
;|***   // ctc0 will generate a TINT interrupt 200usec from now
;|***   // we will trigger a scan of the mux boards in the dmm32b isr when the TINT interrupt occurs
;|***   // and read the data in the dmm32b isr when a ADINT interrupt occurs
;|***   }
; Line 1359
	*** 001c86	e9 00 00 		jmp	$EX3874
					$EX3874:
	*** 001c89	5e 			pop	si
	*** 001c8a	5f 			pop	di
	*** 001c8b	c9 			leave	
	*** 001c8c	cb 			ret	

?trigger_dmm32b@@ZAXXZ	ENDP
	PUBLIC	?isr_dmm32b@@ZAXXZ	; isr_dmm32b
?isr_dmm32b@@ZAXXZ	PROC FAR	; isr_dmm32b
;|***     
;|*** 
;|*** void interrupt isr_dmm32b(void)
;|***   {
; Line 1363
	*** 001c8d	60 			pusha
	*** 001c8e	1e 			push	ds
	*** 001c8f	06 			push	es
	*** 001c90	8b ec 			mov	bp,sp
	*** 001c92	81 ec 0a 00 		sub	sp,10	;000aH
	*** 001c96	1e 			push	ds
	*** 001c97	b8 00 00 		mov	ax,DGROUP
	*** 001c9a	8e d8 			mov	ds,ax
	ASSUME DS: DGROUP
	*** 001c9c	fc 			cld	
;	i = -2
;	lsb = -4
;	msb = -6
;	prop_pos = -10
;|***   // two modes of operation
;|***   // 1) reading the prop dynos      (no multiplexing)
;|***   // 2) reading the mux boxes dynos (with multiplexing)
;|***   
;|***   // for each mode there are two types of interrupts
;|***   // a) settling time complete (TINT, 82C54 ctc0 timeouts)
;|***   // b) adc scan complete (ADINT)
;|***   
;|***   unsigned int i;
;|***   unsigned int lsb      = 0;
; Line 1373
	*** 001c9d	c7 46 fc 00 00 		mov	WORD PTR [bp-4],0	;lsb
;|***   unsigned int msb      = 0;
; Line 1374
	*** 001ca2	c7 46 fa 00 00 		mov	WORD PTR [bp-6],0	;msb
;|***   long int     prop_pos = 0;
; Line 1375
	*** 001ca7	2b c0 			sub	ax,ax
	*** 001ca9	89 46 f8 		mov	WORD PTR [bp-8],ax
	*** 001cac	89 46 f6 		mov	WORD PTR [bp-10],ax	;prop_pos
;|***   
;|***   // mode 1, reading prop dynos
;|***   if(reading_prop)
; Line 1378
	*** 001caf	83 3e 00 00 00 		cmp	WORD PTR ?reading_prop@@3IE,0	;reading_prop
	*** 001cb4	75 03 			jne	$JCC7348
	*** 001cb6	e9 96 01 		jmp	$I3881
					$JCC7348:
;|***     {
; Line 1379
;|***     if(_inp(DYNO_BASE+ISR) & TINT)                        // 200 usec settling time is complete
; Line 1380
	*** 001cb9	68 89 03 		push	905	;0389H
	*** 001cbc	9a 00 00 00 00 		call	FAR PTR __inp
	*** 001cc1	83 c4 02 		add	sp,2
	*** 001cc4	a8 20 			test	al,32	;0020H
	*** 001cc6	75 03 			jne	$JCC7366
	*** 001cc8	e9 4d 00 		jmp	$I3882
					$JCC7366:
;|***       {                                                   // trigger a scan of the prop dynos
; Line 1381
;|***       _outp(DYNO_BASE+ICR, ADINTE & ~TINTE);              // disable further timer interrupts
; Line 1382
	*** 001ccb	68 80 00 		push	128	;0080H
	*** 001cce	68 89 03 		push	905	;0389H
	*** 001cd1	9a 00 00 00 00 		call	FAR PTR __outp
	*** 001cd6	83 c4 04 		add	sp,4
;|***       _outp(DYNO_BASE+FCR, _inp(DYNO_BASE+FCR) | FIFORST);// reset the fifo
; Line 1383
	*** 001cd9	68 87 03 		push	903	;0387H
	*** 001cdc	9a 00 00 00 00 		call	FAR PTR __inp
	*** 001ce1	83 c4 02 		add	sp,2
	*** 001ce4	0d 02 00 		or	ax,2
	*** 001ce7	50 			push	ax
	*** 001ce8	68 87 03 		push	903	;0387H
	*** 001ceb	9a 00 00 00 00 		call	FAR PTR __outp
	*** 001cf0	83 c4 04 		add	sp,4
;|***       while(_inp(DYNO_BASE+ARR) & WAIT);                  // ensure the adc is ready and then
; Line 1384
					$FC3884:
	*** 001cf3	68 8b 03 		push	907	;038bH
	*** 001cf6	9a 00 00 00 00 		call	FAR PTR __inp
	*** 001cfb	83 c4 02 		add	sp,2
	*** 001cfe	a8 80 			test	al,128	;0080H
	*** 001d00	75 03 			jne	$JCC7424
	*** 001d02	e9 03 00 		jmp	$FB3885
					$JCC7424:
	*** 001d05	e9 eb ff 		jmp	$FC3884
					$FB3885:
;|***       _outp(DYNO_BASE, 0);                                // trigger the scan
; Line 1385
	*** 001d08	6a 00 			push	0
	*** 001d0a	68 80 03 		push	896	;0380H
	*** 001d0d	9a 00 00 00 00 		call	FAR PTR __outp
	*** 001d12	83 c4 04 		add	sp,4
;|***       // we will read the prop dyno adc's when an ADINT interrupt occurs about 30 usec from now
;|***       }
; Line 1387
;|***     else                                                  // not a TINT, must be an ADINT
; Line 1388
	*** 001d15	e9 34 01 		jmp	$I3886
					$I3882:
;|***       {                                                   
; Line 1389
;|***       if(_inp(DYNO_BASE+ISR) & ADINT)                     // ADINT occurred so it is 
; Line 1390
	*** 001d18	68 89 03 		push	905	;0389H
	*** 001d1b	9a 00 00 00 00 		call	FAR PTR __inp
	*** 001d20	83 c4 02 		add	sp,2
	*** 001d23	a8 80 			test	al,128	;0080H
	*** 001d25	75 03 			jne	$JCC7461
	*** 001d27	e9 22 01 		jmp	$I3887
					$JCC7461:
;|***         {                                                 // time to read the prop data
; Line 1391
;|***         time_stamp(&prop_adc_time);
; Line 1392
	*** 001d2a	68 00 00 		push	SEG ?prop_adc_time@@3UTIMER@@E	;prop_adc_time
	*** 001d2d	68 00 00 		push	OFFSET ?prop_adc_time@@3UTIMER@@E	;prop_adc_time
	*** 001d30	9a 00 00 00 00 		call	FAR PTR ?time_stamp@@ZAXPEUTIMER@@@Z	; time_stamp
	*** 001d35	83 c4 04 		add	sp,4
;|***         if(te5650IsCapture()==1)
; Line 1393
	*** 001d38	9a 00 00 00 00 		call	FAR PTR _te5650IsCapture
	*** 001d3d	48 			dec	ax
	*** 001d3e	74 03 			je	$JCC7486
	*** 001d40	e9 0c 00 		jmp	$I3888
					$JCC7486:
;|***           {
; Line 1394
;|***           te5650CapturePos(&prop_index);                  // get prop index
; Line 1395
	*** 001d43	1e 			push	ds
	*** 001d44	68 00 00 		push	OFFSET DGROUP:?prop_index@@3JE	;prop_index
	*** 001d47	9a 00 00 00 00 		call	FAR PTR _te5650CapturePos
	*** 001d4c	83 c4 04 		add	sp,4
;|***           }
; Line 1396
;|***         te5650ActPos(&prop_pos);                          // get prop position
; Line 1397
					$I3888:
	*** 001d4f	8d 46 f6 		lea	ax,WORD PTR [bp-10]	;prop_pos
	*** 001d52	16 			push	ss
	*** 001d53	50 			push	ax
	*** 001d54	9a 00 00 00 00 		call	FAR PTR _te5650ActPos
	*** 001d59	83 c4 04 		add	sp,4
;|***         prop_report = prop_pos;
; Line 1398
	*** 001d5c	8b 46 f6 		mov	ax,WORD PTR [bp-10]	;prop_pos
	*** 001d5f	8b 56 f8 		mov	dx,WORD PTR [bp-8]
	*** 001d62	a3 00 00 		mov	WORD PTR ?prop_report@@3JE,ax	;prop_report
	*** 001d65	89 16 02 00 		mov	WORD PTR ?prop_report@@3JE+2,dx	;prop_report
;|***         index_report = prop_index;
; Line 1399
	*** 001d69	a1 00 00 		mov	ax,WORD PTR ?prop_index@@3JE	;prop_index
	*** 001d6c	8b 16 02 00 		mov	dx,WORD PTR ?prop_index@@3JE+2	;prop_index
	*** 001d70	a3 00 00 		mov	WORD PTR ?index_report@@3JE,ax	;index_report
	*** 001d73	89 16 02 00 		mov	WORD PTR ?index_report@@3JE+2,dx	;index_report
;|***         time_stamp(&prop_position_time);
; Line 1400
	*** 001d77	68 00 00 		push	SEG ?prop_position_time@@3UTIMER@@E	;prop_position_time
	*** 001d7a	68 00 00 		push	OFFSET ?prop_position_time@@3UTIMER@@E	;prop_position_time
	*** 001d7d	9a 00 00 00 00 		call	FAR PTR ?time_stamp@@ZAXPEUTIMER@@@Z	; time_stamp
	*** 001d82	83 c4 04 		add	sp,4
;|***         time_stamp(&prop_rpm_time);
; Line 1401
	*** 001d85	68 00 00 		push	SEG ?prop_rpm_time@@3UTIMER@@E	;prop_rpm_time
	*** 001d88	68 00 00 		push	OFFSET ?prop_rpm_time@@3UTIMER@@E	;prop_rpm_time
	*** 001d8b	9a 00 00 00 00 		call	FAR PTR ?time_stamp@@ZAXPEUTIMER@@@Z	; time_stamp
	*** 001d90	83 c4 04 		add	sp,4
;|***         prop_position_absolute_current = prop_pos;
; Line 1402
	*** 001d93	8b 46 f6 		mov	ax,WORD PTR [bp-10]	;prop_pos
	*** 001d96	8b 56 f8 		mov	dx,WORD PTR [bp-8]
	*** 001d99	a3 00 00 		mov	WORD PTR ?prop_position_absolute_current@@3JE,ax	;prop_position_absolute_current
	*** 001d9c	89 16 02 00 		mov	WORD PTR ?prop_position_absolute_current@@3JE+2,dx	;prop_position_absolute_current
;|***         prop_position = (prop_pos - prop_index) - 19409;  // 4/25/2006 jtm prop zero
; Line 1403
	*** 001da0	8b 46 f6 		mov	ax,WORD PTR [bp-10]	;prop_pos
	*** 001da3	8b 56 f8 		mov	dx,WORD PTR [bp-8]
	*** 001da6	2b 06 00 00 		sub	ax,WORD PTR ?prop_index@@3JE	;prop_index
	*** 001daa	1b 16 02 00 		sbb	dx,WORD PTR ?prop_index@@3JE+2	;prop_index
	*** 001dae	2d d1 4b 		sub	ax,19409	;4bd1H
	*** 001db1	83 da 00 		sbb	dx,0
	*** 001db4	a3 00 00 		mov	WORD PTR ?prop_position@@3JE,ax	;prop_position
	*** 001db7	89 16 02 00 		mov	WORD PTR ?prop_position@@3JE+2,dx	;prop_position
;|***         
;|***         for(i=0; i<6; i++)                                // read and buffer the dyno data  
; Line 1405
	*** 001dbb	c7 46 fe 00 00 		mov	WORD PTR [bp-2],0	;i
	*** 001dc0	e9 03 00 		jmp	$F3889
					$FC3890:
	*** 001dc3	ff 46 fe 		inc	WORD PTR [bp-2]	;i
					$F3889:
	*** 001dc6	83 7e fe 06 		cmp	WORD PTR [bp-2],6	;i
	*** 001dca	72 03 			jb	$JCC7626
	*** 001dcc	e9 17 00 		jmp	$FB3891
					$JCC7626:
;|***           {
; Line 1406
;|***           prop_array[i] = _inpw(DYNO_BASE);
; Line 1407
	*** 001dcf	68 80 03 		push	896	;0380H
	*** 001dd2	9a 00 00 00 00 		call	FAR PTR __inpw
	*** 001dd7	83 c4 02 		add	sp,2
	*** 001dda	8b 5e fe 		mov	bx,WORD PTR [bp-2]	;i
	*** 001ddd	d1 e3 			shl	bx,1
	*** 001ddf	89 87 00 00 		mov	WORD PTR ?prop_array@@3QEIE[bx],ax	;prop_array
;|***           }
; Line 1408
	*** 001de3	e9 dd ff 		jmp	$FC3890
					$FB3891:
;|***         _fmemcpy(prop_buffer, prop_array, sizeof(prop_array));
; Line 1409
	*** 001de6	6a 0c 			push	12	;000cH
	*** 001de8	1e 			push	ds
	*** 001de9	68 00 00 		push	OFFSET DGROUP:?prop_array@@3QEIE	;prop_array
	*** 001dec	1e 			push	ds
	*** 001ded	68 00 00 		push	OFFSET DGROUP:?prop_buffer@@3QEEE	;prop_buffer
	*** 001df0	9a 00 00 00 00 		call	FAR PTR __fmemcpy
	*** 001df5	83 c4 0a 		add	sp,10	;000aH
;|***                                                                                                 
;|***         prop_new_data = 1;                            // flag new data is available
; Line 1411
	*** 001df8	c7 06 00 00 01 00 	mov	WORD PTR ?prop_new_data@@3IE,1	;prop_new_data
;|***         prop_data_frame = frame;                      // record the frame number      
; Line 1412
	*** 001dfe	a1 00 00 		mov	ax,WORD PTR ?frame@@3KE	;frame
	*** 001e01	8b 16 02 00 		mov	dx,WORD PTR ?frame@@3KE+2	;frame
	*** 001e05	a3 00 00 		mov	WORD PTR ?prop_data_frame@@3KE,ax	;prop_data_frame
	*** 001e08	89 16 02 00 		mov	WORD PTR ?prop_data_frame@@3KE+2,dx	;prop_data_frame
;|***         
;|***         reading_prop = 0;                             // reset flag so we scan the mux boxes next
; Line 1414
	*** 001e0c	c7 06 00 00 00 00 	mov	WORD PTR ?reading_prop@@3IE,0	;reading_prop
;|***         _outp(DYNO_BASE+FCR, _inp(DYNO_BASE+FCR) | FIFORST); // reset the fifo
; Line 1415
	*** 001e12	68 87 03 		push	903	;0387H
	*** 001e15	9a 00 00 00 00 		call	FAR PTR __inp
	*** 001e1a	83 c4 02 		add	sp,2
	*** 001e1d	0d 02 00 		or	ax,2
	*** 001e20	50 			push	ax
	*** 001e21	68 87 03 		push	903	;0387H
	*** 001e24	9a 00 00 00 00 		call	FAR PTR __outp
	*** 001e29	83 c4 04 		add	sp,4
;|***         _outp(DYNO_BASE+LCR,  0);                     // set the range of channels to scan
; Line 1416
	*** 001e2c	6a 00 			push	0
	*** 001e2e	68 82 03 		push	898	;0382H
	*** 001e31	9a 00 00 00 00 		call	FAR PTR __outp
	*** 001e36	83 c4 04 		add	sp,4
;|***         _outp(DYNO_BASE+HCR,  7);
; Line 1417
	*** 001e39	6a 07 			push	7
	*** 001e3b	68 83 03 		push	899	;0383H
	*** 001e3e	9a 00 00 00 00 		call	FAR PTR __outp
	*** 001e43	83 c4 04 		add	sp,4
;|***         
;|***         data_ready = 1;
; Line 1419
	*** 001e46	c7 06 00 00 01 00 	mov	WORD PTR ?data_ready@@3IE,1	;data_ready
;|***         }
; Line 1420
;|***       }
; Line 1421
					$I3887:
					$I3886:
;|***     } // end of the prop section
; Line 1422
;|***   
;|***   
;|***   // mode 2, reading mux boxes 
;|***   else
; Line 1426
	*** 001e4c	e9 da 01 		jmp	$I3892
					$I3881:
;|***     {
; Line 1427
;|***     if(_inp(DYNO_BASE+ISR) & TINT)                      // the 200 usec settling time is complete
; Line 1428
	*** 001e4f	68 89 03 		push	905	;0389H
	*** 001e52	9a 00 00 00 00 		call	FAR PTR __inp
	*** 001e57	83 c4 02 		add	sp,2
	*** 001e5a	a8 20 			test	al,32	;0020H
	*** 001e5c	75 03 			jne	$JCC7772
	*** 001e5e	e9 33 00 		jmp	$I3893
					$JCC7772:
;|***       {                                                 // so start a mux box scan
; Line 1429
;|***       _outp(DYNO_BASE+ICR, ADINTE & ~TINTE);            // disable further TINT interrupts
; Line 1430
	*** 001e61	68 80 00 		push	128	;0080H
	*** 001e64	68 89 03 		push	905	;0389H
	*** 001e67	9a 00 00 00 00 		call	FAR PTR __outp
	*** 001e6c	83 c4 04 		add	sp,4
;|***       while(_inp(DYNO_BASE+ARR) & WAIT);                // wait for converters to get ready
; Line 1431
					$FC3895:
	*** 001e6f	68 8b 03 		push	907	;038bH
	*** 001e72	9a 00 00 00 00 		call	FAR PTR __inp
	*** 001e77	83 c4 02 		add	sp,2
	*** 001e7a	a8 80 			test	al,128	;0080H
	*** 001e7c	75 03 			jne	$JCC7804
	*** 001e7e	e9 03 00 		jmp	$FB3896
					$JCC7804:
	*** 001e81	e9 eb ff 		jmp	$FC3895
					$FB3896:
;|***       _outp(DYNO_BASE, 0);                              // trigger the scan
; Line 1432
	*** 001e84	6a 00 			push	0
	*** 001e86	68 80 03 		push	896	;0380H
	*** 001e89	9a 00 00 00 00 		call	FAR PTR __outp
	*** 001e8e	83 c4 04 		add	sp,4
;|***       // we will read the mux box scan about 40 usec from now when an ADINT irq occurs
;|***       }
; Line 1434
;|***       
;|***     else                                                  
; Line 1436
	*** 001e91	e9 95 01 		jmp	$I3897
					$I3893:
;|***       {
; Line 1437
;|***       if(_inp(DYNO_BASE+ISR) & ADINT)                     // the mux box adc data is ready
; Line 1438
	*** 001e94	68 89 03 		push	905	;0389H
	*** 001e97	9a 00 00 00 00 		call	FAR PTR __inp
	*** 001e9c	83 c4 02 		add	sp,2
	*** 001e9f	a8 80 			test	al,128	;0080H
	*** 001ea1	75 03 			jne	$JCC7841
	*** 001ea3	e9 83 01 		jmp	$I3898
					$JCC7841:
;|***         {
; Line 1439
;|***         for(i=0; i<8; i++)                                // read the data  
; Line 1440
	*** 001ea6	c7 46 fe 00 00 		mov	WORD PTR [bp-2],0	;i
	*** 001eab	e9 03 00 		jmp	$F3899
					$FC3900:
	*** 001eae	ff 46 fe 		inc	WORD PTR [bp-2]	;i
					$F3899:
	*** 001eb1	83 7e fe 08 		cmp	WORD PTR [bp-2],8	;i
	*** 001eb5	72 03 			jb	$JCC7861
	*** 001eb7	e9 1e 00 		jmp	$FB3901
					$JCC7861:
;|***           {
; Line 1441
;|***           dyno_array[i + (mux_addr*8)] = _inpw(DYNO_BASE);
; Line 1442
	*** 001eba	68 80 03 		push	896	;0380H
	*** 001ebd	9a 00 00 00 00 		call	FAR PTR __inpw
	*** 001ec2	83 c4 02 		add	sp,2
	*** 001ec5	8b 1e 00 00 		mov	bx,WORD PTR ?mux_addr@@3IE	;mux_addr
	*** 001ec9	c1 e3 03 		shl	bx,3
	*** 001ecc	03 5e fe 		add	bx,WORD PTR [bp-2]	;i
	*** 001ecf	d1 e3 			shl	bx,1
	*** 001ed1	89 87 00 00 		mov	WORD PTR ?dyno_array@@3QEIE[bx],ax	;dyno_array
;|***           }
; Line 1443
	*** 001ed5	e9 d6 ff 		jmp	$FC3900
					$FB3901:
;|***         
;|***         mux_addr++;                                       // set mux address for the next scan
; Line 1445
	*** 001ed8	ff 06 00 00 		inc	WORD PTR ?mux_addr@@3IE	;mux_addr
;|***         
;|***         if(mux_addr < 16)                                 // not done scanning all 16 addresses
; Line 1447
	*** 001edc	83 3e 00 00 10 		cmp	WORD PTR ?mux_addr@@3IE,16	;0010H	;mux_addr
	*** 001ee1	72 03 			jb	$JCC7905
	*** 001ee3	e9 62 00 		jmp	$I3902
					$JCC7905:
;|***           {
; Line 1448
;|***           _outp(DYNO_BASE+MCR, PAGE1);                    // put address on the dio port
; Line 1449
	*** 001ee6	6a 01 			push	1
	*** 001ee8	68 88 03 		push	904	;0388H
	*** 001eeb	9a 00 00 00 00 		call	FAR PTR __outp
	*** 001ef0	83 c4 04 		add	sp,4
;|***           _outp(DYNO_BASE+PORTA , mux_addr);
; Line 1450
	*** 001ef3	ff 36 00 00 		push	WORD PTR ?mux_addr@@3IE	;mux_addr
	*** 001ef7	68 8c 03 		push	908	;038cH
	*** 001efa	9a 00 00 00 00 		call	FAR PTR __outp
	*** 001eff	83 c4 04 		add	sp,4
;|***           
;|***           // start another 200 usec settling period
;|***           _outp(DYNO_BASE+MCR, PAGE0);                         // access the 82C54 timer
; Line 1453
	*** 001f02	6a 00 			push	0
	*** 001f04	68 88 03 		push	904	;0388H
	*** 001f07	9a 00 00 00 00 		call	FAR PTR __outp
	*** 001f0c	83 c4 04 		add	sp,4
;|***           _outp(DYNO_BASE+15, CTC0 | LSBMSB | MODE0 | BINARY); // set up ctc0
; Line 1454
	*** 001f0f	6a 30 			push	48	;0030H
	*** 001f11	68 8f 03 		push	911	;038fH
	*** 001f14	9a 00 00 00 00 		call	FAR PTR __outp
	*** 001f19	83 c4 04 		add	sp,4
;|***           _outp(DYNO_BASE+12, 0xd0);                           // divisor LSB (2000 or 0x07d0)
; Line 1455
	*** 001f1c	68 d0 00 		push	208	;00d0H
	*** 001f1f	68 8c 03 		push	908	;038cH
	*** 001f22	9a 00 00 00 00 		call	FAR PTR __outp
	*** 001f27	83 c4 04 		add	sp,4
;|***           _outp(DYNO_BASE+12, 0x07);                           // divisor MSB 
; Line 1456
	*** 001f2a	6a 07 			push	7
	*** 001f2c	68 8c 03 		push	908	;038cH
	*** 001f2f	9a 00 00 00 00 		call	FAR PTR __outp
	*** 001f34	83 c4 04 		add	sp,4
;|***           _outp(DYNO_BASE+ICR, ADINTE | TINTE);                // enable adc & timer interrupts
; Line 1457
	*** 001f37	68 a0 00 		push	160	;00a0H
	*** 001f3a	68 89 03 		push	905	;0389H
	*** 001f3d	9a 00 00 00 00 		call	FAR PTR __outp
	*** 001f42	83 c4 04 		add	sp,4
;|***           // we will scan the mux data again when ctc0 generates a TINT irq 200 usec from now
;|***           }
; Line 1459
;|***           
;|***         else                                            // all 16 mux addresses have been scanned
; Line 1461
	*** 001f45	e9 e1 00 		jmp	$I3903
					$I3902:
;|***           {
; Line 1462
;|***           time_stamp(&dyno_time);
; Line 1463
	*** 001f48	68 00 00 		push	SEG ?dyno_time@@3UTIMER@@E	;dyno_time
	*** 001f4b	68 00 00 		push	OFFSET ?dyno_time@@3UTIMER@@E	;dyno_time
	*** 001f4e	9a 00 00 00 00 		call	FAR PTR ?time_stamp@@ZAXPEUTIMER@@@Z	; time_stamp
	*** 001f53	83 c4 04 		add	sp,4
;|***           
;|***           _fmemcpy(dyno_buffer, dyno_array, sizeof(dyno_array));// buffer the data
; Line 1465
	*** 001f56	68 00 01 		push	256	;0100H
	*** 001f59	1e 			push	ds
	*** 001f5a	68 00 00 		push	OFFSET DGROUP:?dyno_array@@3QEIE	;dyno_array
	*** 001f5d	1e 			push	ds
	*** 001f5e	68 00 00 		push	OFFSET DGROUP:?dyno_buffer@@3QEEE	;dyno_buffer
	*** 001f61	9a 00 00 00 00 		call	FAR PTR __fmemcpy
	*** 001f66	83 c4 0a 		add	sp,10	;000aH
;|***           dyno_data_frame = frame;                              // set system flags
; Line 1466
	*** 001f69	a1 00 00 		mov	ax,WORD PTR ?frame@@3KE	;frame
	*** 001f6c	8b 16 02 00 		mov	dx,WORD PTR ?frame@@3KE+2	;frame
	*** 001f70	a3 00 00 		mov	WORD PTR ?dyno_data_frame@@3KE,ax	;dyno_data_frame
	*** 001f73	89 16 02 00 		mov	WORD PTR ?dyno_data_frame@@3KE+2,dx	;dyno_data_frame
;|***           dyno_new_data = 1;
; Line 1467
	*** 001f77	c7 06 00 00 01 00 	mov	WORD PTR ?dyno_new_data@@3IE,1	;dyno_new_data
;|***           
;|***           mux_addr = 0;                                   // reset the mux addess for next frame 
; Line 1469
	*** 001f7d	c7 06 00 00 00 00 	mov	WORD PTR ?mux_addr@@3IE,0	;mux_addr
;|***           _outp(DYNO_BASE+MCR, PAGE1);
; Line 1470
	*** 001f83	6a 01 			push	1
	*** 001f85	68 88 03 		push	904	;0388H
	*** 001f88	9a 00 00 00 00 		call	FAR PTR __outp
	*** 001f8d	83 c4 04 		add	sp,4
;|***           _outp(DYNO_BASE+PORTA, mux_addr);
; Line 1471
	*** 001f90	ff 36 00 00 		push	WORD PTR ?mux_addr@@3IE	;mux_addr
	*** 001f94	68 8c 03 		push	908	;038cH
	*** 001f97	9a 00 00 00 00 		call	FAR PTR __outp
	*** 001f9c	83 c4 04 		add	sp,4
;|***           _outp(DYNO_BASE+MCR, PAGE0);
; Line 1472
	*** 001f9f	6a 00 			push	0
	*** 001fa1	68 88 03 		push	904	;0388H
	*** 001fa4	9a 00 00 00 00 		call	FAR PTR __outp
	*** 001fa9	83 c4 04 		add	sp,4
;|***           
;|***           reading_prop = 1;                                   // set flag to do a prop scan next
; Line 1474
	*** 001fac	c7 06 00 00 01 00 	mov	WORD PTR ?reading_prop@@3IE,1	;reading_prop
;|***           _outp(DYNO_BASE+FCR, _inp(DYNO_BASE+FCR) | FIFORST);// reset the fifo
; Line 1475
	*** 001fb2	68 87 03 		push	903	;0387H
	*** 001fb5	9a 00 00 00 00 		call	FAR PTR __inp
	*** 001fba	83 c4 02 		add	sp,2
	*** 001fbd	0d 02 00 		or	ax,2
	*** 001fc0	50 			push	ax
	*** 001fc1	68 87 03 		push	903	;0387H
	*** 001fc4	9a 00 00 00 00 		call	FAR PTR __outp
	*** 001fc9	83 c4 04 		add	sp,4
;|***           _outp(DYNO_BASE+LCR, 16);                           // set range of prop channels
; Line 1476
	*** 001fcc	6a 10 			push	16	;0010H
	*** 001fce	68 82 03 		push	898	;0382H
	*** 001fd1	9a 00 00 00 00 		call	FAR PTR __outp
	*** 001fd6	83 c4 04 		add	sp,4
;|***           _outp(DYNO_BASE+HCR, 21);
; Line 1477
	*** 001fd9	6a 15 			push	21	;0015H
	*** 001fdb	68 83 03 		push	899	;0383H
	*** 001fde	9a 00 00 00 00 		call	FAR PTR __outp
	*** 001fe3	83 c4 04 		add	sp,4
;|*** 
;|***           // start another 200 usec settling period
;|***           _outp(DYNO_BASE+MCR, PAGE0);                        // access the 82C54's registers
; Line 1480
	*** 001fe6	6a 00 			push	0
	*** 001fe8	68 88 03 		push	904	;0388H
	*** 001feb	9a 00 00 00 00 		call	FAR PTR __outp
	*** 001ff0	83 c4 04 		add	sp,4
;|***           _outp(DYNO_BASE+15, CTC0 | LSBMSB | MODE0 | BINARY);// set up ctc0
; Line 1481
	*** 001ff3	6a 30 			push	48	;0030H
	*** 001ff5	68 8f 03 		push	911	;038fH
	*** 001ff8	9a 00 00 00 00 		call	FAR PTR __outp
	*** 001ffd	83 c4 04 		add	sp,4
;|***           _outp(DYNO_BASE+12, 0xd0);                          // load divisor LSB (2000 or 0x07d0)
; Line 1482
	*** 002000	68 d0 00 		push	208	;00d0H
	*** 002003	68 8c 03 		push	908	;038cH
	*** 002006	9a 00 00 00 00 		call	FAR PTR __outp
	*** 00200b	83 c4 04 		add	sp,4
;|***           _outp(DYNO_BASE+12, 0x07);                          // load divisor MSB
; Line 1483
	*** 00200e	6a 07 			push	7
	*** 002010	68 8c 03 		push	908	;038cH
	*** 002013	9a 00 00 00 00 		call	FAR PTR __outp
	*** 002018	83 c4 04 		add	sp,4
;|***           _outp(DYNO_BASE+ICR, ADINTE | TINTE);               // enable adc & timer interrupts
; Line 1484
	*** 00201b	68 a0 00 		push	160	;00a0H
	*** 00201e	68 89 03 		push	905	;0389H
	*** 002021	9a 00 00 00 00 		call	FAR PTR __outp
	*** 002026	83 c4 04 		add	sp,4
;|***           // we will scan the prop dynos when ctc0 generates a TINT irq 200 usec from now
;|***           }
; Line 1486
					$I3903:
;|***         }
; Line 1487
;|***       }
; Line 1488
					$I3898:
					$I3897:
;|***     } // end mux box section
; Line 1489
					$I3892:
;|*** 
;|***   _outp(DYNO_BASE+MCR, INTRST); // reset the dmm32's interrupt circuit    
; Line 1491
	*** 002029	6a 08 			push	8
	*** 00202b	68 88 03 		push	904	;0388H
	*** 00202e	9a 00 00 00 00 		call	FAR PTR __outp
	*** 002033	83 c4 04 		add	sp,4
;|***   _outp(0xa0, 0x20);            // slave  EOI
; Line 1492
	*** 002036	6a 20 			push	32	;0020H
	*** 002038	68 a0 00 		push	160	;00a0H
	*** 00203b	9a 00 00 00 00 		call	FAR PTR __outp
	*** 002040	83 c4 04 		add	sp,4
;|***   _outp(0x20, 0x20);            // master EOI  
; Line 1493
	*** 002043	6a 20 			push	32	;0020H
	*** 002045	6a 20 			push	32	;0020H
	*** 002047	9a 00 00 00 00 		call	FAR PTR __outp
	*** 00204c	83 c4 04 		add	sp,4
;|***   // end dmm32b isr
;|***   }
; Line 1495
	*** 00204f	e9 00 00 		jmp	$EX3876
					$EX3876:
	*** 002052	8b e5 			mov	sp,bp
	*** 002054	07 			pop	es
	*** 002055	1f 			pop	ds
	ASSUME DS: DGROUP
	*** 002056	61 			popa
	*** 002057	cf 			iret	

?isr_dmm32b@@ZAXXZ	ENDP
	PUBLIC	?sys_timer_isr@@ZAXXZ	; sys_timer_isr
?sys_timer_isr@@ZAXXZ	PROC FAR	; sys_timer_isr
;|***   
;|*** 
;|*** void interrupt sys_timer_isr(void) 
;|***   {                                // every pc timer tick (approx 55 msec)
; Line 1499
	*** 002058	60 			pusha
	*** 002059	1e 			push	ds
	*** 00205a	06 			push	es
	*** 00205b	8b ec 			mov	bp,sp
	*** 00205d	81 ec 00 00 		sub	sp,0
	*** 002061	1e 			push	ds
	*** 002062	b8 00 00 		mov	ax,DGROUP
	*** 002065	8e d8 			mov	ds,ax
	ASSUME DS: DGROUP
	*** 002067	fc 			cld	
;|***   sys_timer.high++;                // increment the high long word of the obc system timer
; Line 1500
	*** 002068	8e 06 00 00 		mov	es,WORD PTR $T4071
	*** 00206c	26 83 06 00 00 01 	add	WORD PTR es:?sys_timer@@3UTIMER@@E,1	;sys_timer
	*** 002072	26 83 16 02 00 00 	adc	WORD PTR es:?sys_timer@@3UTIMER@@E+2,0	;sys_timer
;|***   _chain_intr(rtc_vect);           // chain back into the pc's original rtc isr
; Line 1501
	*** 002078	ff 36 02 00 		push	WORD PTR ?rtc_vect@@3P7AXXZE+2	;rtc_vect
	*** 00207c	ff 36 00 00 		push	WORD PTR ?rtc_vect@@3P7AXXZE	;rtc_vect
	*** 002080	9a 00 00 00 00 		call	FAR PTR __chain_intr
	*** 002085	83 c4 04 		add	sp,4
;|***   }
; Line 1502
	*** 002088	e9 00 00 		jmp	$EX3905
					$EX3905:
	*** 00208b	8b e5 			mov	sp,bp
	*** 00208d	07 			pop	es
	*** 00208e	1f 			pop	ds
	ASSUME DS: DGROUP
	*** 00208f	61 			popa
	*** 002090	cf 			iret	

?sys_timer_isr@@ZAXXZ	ENDP
	PUBLIC	?terminate@@ZAXXZ	; terminate
?terminate@@ZAXXZ	PROC FAR	; terminate
;|***   
;|*** 
;|*** void terminate(void)
;|***   {
; Line 1506
	*** 002091	c8 52 00 00 		enter	82,0
	*** 002095	57 			push	di
	*** 002096	56 			push	si
;	s = -82
;|***   char s[81];
;|***   
;|***   _getch();
; Line 1509
	*** 002097	9a 00 00 00 00 		call	FAR PTR __getch
;|***   _disable();
; Line 1510
	*** 00209c	9a 00 00 00 00 		call	FAR PTR __disable
;|***   shutdown_tech80();
; Line 1511
	*** 0020a1	9a 00 00 00 00 		call	FAR PTR ?shutdown_tech80@@ZAXXZ	; shutdown_tech80
;|***   shutdown_enet();
; Line 1512
	*** 0020a6	9a 00 00 00 00 		call	FAR PTR ?shutdown_enet@@ZAXXZ	; shutdown_enet
;|***   shutdown_com1();
; Line 1513
	*** 0020ab	9a 00 00 00 00 		call	FAR PTR ?shutdown_com1@@ZAXXZ	; shutdown_com1
;|***   shutdown_com2();
; Line 1514
	*** 0020b0	9a 00 00 00 00 		call	FAR PTR ?shutdown_com2@@ZAXXZ	; shutdown_com2
;|***   shutdown_com4();
; Line 1515
	*** 0020b5	9a 00 00 00 00 		call	FAR PTR ?shutdown_com4@@ZAXXZ	; shutdown_com4
;|***   shutdown_dmm32a();
; Line 1516
	*** 0020ba	9a 00 00 00 00 		call	FAR PTR ?shutdown_dmm32a@@ZAXXZ	; shutdown_dmm32a
;|***   shutdown_dmm32b();
; Line 1517
	*** 0020bf	9a 00 00 00 00 		call	FAR PTR ?shutdown_dmm32b@@ZAXXZ	; shutdown_dmm32b
;|***   shutdown_escc();
; Line 1518
	*** 0020c4	9a 00 00 00 00 		call	FAR PTR ?shutdown_escc@@ZAXXZ	; shutdown_escc
;|*** //  shutdown_sys_timer();
;|***   shutdown_uio48();
; Line 1520
	*** 0020c9	9a 00 00 00 00 		call	FAR PTR ?shutdown_uio48@@ZAXXZ	; shutdown_uio48
;|***   _enable();
; Line 1521
	*** 0020ce	9a 00 00 00 00 		call	FAR PTR __enable
;|***   
;|***   // put final data on screen
;|***         sprintf(s, "%s%8lu %5u%s%8lu", "Frame start:   ",
;|***           frame_time.high, frame_time.low, "    Frame # ", frame);
; Line 1525
	*** 0020d3	ff 36 02 00 		push	WORD PTR ?frame@@3KE+2	;frame
	*** 0020d7	ff 36 00 00 		push	WORD PTR ?frame@@3KE	;frame
	*** 0020db	1e 			push	ds
	*** 0020dc	68 00 00 		push	OFFSET DGROUP:$SG3909
	*** 0020df	8e 06 00 00 		mov	es,WORD PTR $T4071
	*** 0020e3	26 ff 36 04 00 		push	WORD PTR es:?frame_time@@3UTIMER@@E+4	;frame_time
	*** 0020e8	26 ff 36 02 00 		push	WORD PTR es:?frame_time@@3UTIMER@@E+2	;frame_time
	*** 0020ed	26 ff 36 00 00 		push	WORD PTR es:?frame_time@@3UTIMER@@E	;frame_time
	*** 0020f2	1e 			push	ds
	*** 0020f3	68 00 00 		push	OFFSET DGROUP:$SG3910
	*** 0020f6	1e 			push	ds
	*** 0020f7	68 00 00 		push	OFFSET DGROUP:$SG3911
	*** 0020fa	8d 46 ae 		lea	ax,WORD PTR [bp-82]	;s
	*** 0020fd	16 			push	ss
	*** 0020fe	50 			push	ax
	*** 0020ff	9a 00 00 00 00 		call	FAR PTR _sprintf
	*** 002104	83 c4 1a 		add	sp,26	;001aH
;|***         PC_DispStr(0,6, (unsigned char *)s, DISP_FGND_BLACK + DISP_BGND_LIGHT_GRAY);  
; Line 1526
	*** 002107	6a 70 			push	112	;0070H
	*** 002109	8d 46 ae 		lea	ax,WORD PTR [bp-82]	;s
	*** 00210c	16 			push	ss
	*** 00210d	50 			push	ax
	*** 00210e	6a 06 			push	6
	*** 002110	6a 00 			push	0
	*** 002112	9a 00 00 00 00 		call	FAR PTR ?PC_DispStr@@ZAXEEPEEE@Z	; PC_DispStr
	*** 002117	83 c4 0a 		add	sp,10	;000aH
;|*** 
;|***         sprintf(s, "%s%8lu %5u", "OBS data:      ",
;|***           obs_time.high, obs_time.low);
; Line 1529
	*** 00211a	8e 06 00 00 		mov	es,WORD PTR $T4071
	*** 00211e	26 ff 36 04 00 		push	WORD PTR es:?obs_time@@3UTIMER@@E+4	;obs_time
	*** 002123	26 ff 36 02 00 		push	WORD PTR es:?obs_time@@3UTIMER@@E+2	;obs_time
	*** 002128	26 ff 36 00 00 		push	WORD PTR es:?obs_time@@3UTIMER@@E	;obs_time
	*** 00212d	1e 			push	ds
	*** 00212e	68 00 00 		push	OFFSET DGROUP:$SG3913
	*** 002131	1e 			push	ds
	*** 002132	68 00 00 		push	OFFSET DGROUP:$SG3914
	*** 002135	8d 46 ae 		lea	ax,WORD PTR [bp-82]	;s
	*** 002138	16 			push	ss
	*** 002139	50 			push	ax
	*** 00213a	9a 00 00 00 00 		call	FAR PTR _sprintf
	*** 00213f	83 c4 12 		add	sp,18	;0012H
;|***         PC_DispStr(0,7, (unsigned char *)s, DISP_FGND_BLACK + DISP_BGND_LIGHT_GRAY);
; Line 1530
	*** 002142	6a 70 			push	112	;0070H
	*** 002144	8d 46 ae 		lea	ax,WORD PTR [bp-82]	;s
	*** 002147	16 			push	ss
	*** 002148	50 			push	ax
	*** 002149	6a 07 			push	7
	*** 00214b	6a 00 			push	0
	*** 00214d	9a 00 00 00 00 		call	FAR PTR ?PC_DispStr@@ZAXEEPEEE@Z	; PC_DispStr
	*** 002152	83 c4 0a 		add	sp,10	;000aH
;|*** 
;|***         sprintf(s, "%s%8lu %5u", "Dyno data:     ",
;|***           dyno_time.high, dyno_time.low);
; Line 1533
	*** 002155	8e 06 00 00 		mov	es,WORD PTR $T4071
	*** 002159	26 ff 36 04 00 		push	WORD PTR es:?dyno_time@@3UTIMER@@E+4	;dyno_time
	*** 00215e	26 ff 36 02 00 		push	WORD PTR es:?dyno_time@@3UTIMER@@E+2	;dyno_time
	*** 002163	26 ff 36 00 00 		push	WORD PTR es:?dyno_time@@3UTIMER@@E	;dyno_time
	*** 002168	1e 			push	ds
	*** 002169	68 00 00 		push	OFFSET DGROUP:$SG3916
	*** 00216c	1e 			push	ds
	*** 00216d	68 00 00 		push	OFFSET DGROUP:$SG3917
	*** 002170	8d 46 ae 		lea	ax,WORD PTR [bp-82]	;s
	*** 002173	16 			push	ss
	*** 002174	50 			push	ax
	*** 002175	9a 00 00 00 00 		call	FAR PTR _sprintf
	*** 00217a	83 c4 12 		add	sp,18	;0012H
;|***         PC_DispStr(0,8, (unsigned char *)s, DISP_FGND_BLACK + DISP_BGND_LIGHT_GRAY);
; Line 1534
	*** 00217d	6a 70 			push	112	;0070H
	*** 00217f	8d 46 ae 		lea	ax,WORD PTR [bp-82]	;s
	*** 002182	16 			push	ss
	*** 002183	50 			push	ax
	*** 002184	6a 08 			push	8
	*** 002186	6a 00 			push	0
	*** 002188	9a 00 00 00 00 		call	FAR PTR ?PC_DispStr@@ZAXEEPEEE@Z	; PC_DispStr
	*** 00218d	83 c4 0a 		add	sp,10	;000aH
;|*** 
;|***         sprintf(s, "%s%8lu %5u", "Prop adc:      ",
;|***           prop_adc_time.high, prop_adc_time.low);
; Line 1537
	*** 002190	8e 06 00 00 		mov	es,WORD PTR $T4071
	*** 002194	26 ff 36 04 00 		push	WORD PTR es:?prop_adc_time@@3UTIMER@@E+4	;prop_adc_time
	*** 002199	26 ff 36 02 00 		push	WORD PTR es:?prop_adc_time@@3UTIMER@@E+2	;prop_adc_time
	*** 00219e	26 ff 36 00 00 		push	WORD PTR es:?prop_adc_time@@3UTIMER@@E	;prop_adc_time
	*** 0021a3	1e 			push	ds
	*** 0021a4	68 00 00 		push	OFFSET DGROUP:$SG3919
	*** 0021a7	1e 			push	ds
	*** 0021a8	68 00 00 		push	OFFSET DGROUP:$SG3920
	*** 0021ab	8d 46 ae 		lea	ax,WORD PTR [bp-82]	;s
	*** 0021ae	16 			push	ss
	*** 0021af	50 			push	ax
	*** 0021b0	9a 00 00 00 00 		call	FAR PTR _sprintf
	*** 0021b5	83 c4 12 		add	sp,18	;0012H
;|***         PC_DispStr(0,9, (unsigned char *)s, DISP_FGND_BLACK + DISP_BGND_LIGHT_GRAY);
; Line 1538
	*** 0021b8	6a 70 			push	112	;0070H
	*** 0021ba	8d 46 ae 		lea	ax,WORD PTR [bp-82]	;s
	*** 0021bd	16 			push	ss
	*** 0021be	50 			push	ax
	*** 0021bf	6a 09 			push	9
	*** 0021c1	6a 00 			push	0
	*** 0021c3	9a 00 00 00 00 		call	FAR PTR ?PC_DispStr@@ZAXEEPEEE@Z	; PC_DispStr
	*** 0021c8	83 c4 0a 		add	sp,10	;000aH
;|*** 
;|***         sprintf(s, "%s%8lu %5u", "Prop position: ",
;|***           prop_position_time.high, prop_position_time.low);
; Line 1541
	*** 0021cb	8e 06 00 00 		mov	es,WORD PTR $T4071
	*** 0021cf	26 ff 36 04 00 		push	WORD PTR es:?prop_position_time@@3UTIMER@@E+4	;prop_position_time
	*** 0021d4	26 ff 36 02 00 		push	WORD PTR es:?prop_position_time@@3UTIMER@@E+2	;prop_position_time
	*** 0021d9	26 ff 36 00 00 		push	WORD PTR es:?prop_position_time@@3UTIMER@@E	;prop_position_time
	*** 0021de	1e 			push	ds
	*** 0021df	68 00 00 		push	OFFSET DGROUP:$SG3922
	*** 0021e2	1e 			push	ds
	*** 0021e3	68 00 00 		push	OFFSET DGROUP:$SG3923
	*** 0021e6	8d 46 ae 		lea	ax,WORD PTR [bp-82]	;s
	*** 0021e9	16 			push	ss
	*** 0021ea	50 			push	ax
	*** 0021eb	9a 00 00 00 00 		call	FAR PTR _sprintf
	*** 0021f0	83 c4 12 		add	sp,18	;0012H
;|***         PC_DispStr(0,10, (unsigned char *)s, DISP_FGND_BLACK + DISP_BGND_LIGHT_GRAY);
; Line 1542
	*** 0021f3	6a 70 			push	112	;0070H
	*** 0021f5	8d 46 ae 		lea	ax,WORD PTR [bp-82]	;s
	*** 0021f8	16 			push	ss
	*** 0021f9	50 			push	ax
	*** 0021fa	6a 0a 			push	10	;000aH
	*** 0021fc	6a 00 			push	0
	*** 0021fe	9a 00 00 00 00 		call	FAR PTR ?PC_DispStr@@ZAXEEPEEE@Z	; PC_DispStr
	*** 002203	83 c4 0a 		add	sp,10	;000aH
;|*** 
;|***         sprintf(s, "%s%8lu %5u", "Commands rcvd: ",
;|***           cmds_time.high, cmds_time.low);
; Line 1545
	*** 002206	8e 06 00 00 		mov	es,WORD PTR $T4071
	*** 00220a	26 ff 36 04 00 		push	WORD PTR es:?cmds_time@@3UTIMER@@E+4	;cmds_time
	*** 00220f	26 ff 36 02 00 		push	WORD PTR es:?cmds_time@@3UTIMER@@E+2	;cmds_time
	*** 002214	26 ff 36 00 00 		push	WORD PTR es:?cmds_time@@3UTIMER@@E	;cmds_time
	*** 002219	1e 			push	ds
	*** 00221a	68 00 00 		push	OFFSET DGROUP:$SG3925
	*** 00221d	1e 			push	ds
	*** 00221e	68 00 00 		push	OFFSET DGROUP:$SG3926
	*** 002221	8d 46 ae 		lea	ax,WORD PTR [bp-82]	;s
	*** 002224	16 			push	ss
	*** 002225	50 			push	ax
	*** 002226	9a 00 00 00 00 		call	FAR PTR _sprintf
	*** 00222b	83 c4 12 		add	sp,18	;0012H
;|***         PC_DispStr(0,11, (unsigned char *)s, DISP_FGND_BLACK + DISP_BGND_LIGHT_GRAY);
; Line 1546
	*** 00222e	6a 70 			push	112	;0070H
	*** 002230	8d 46 ae 		lea	ax,WORD PTR [bp-82]	;s
	*** 002233	16 			push	ss
	*** 002234	50 			push	ax
	*** 002235	6a 0b 			push	11	;000bH
	*** 002237	6a 00 			push	0
	*** 002239	9a 00 00 00 00 		call	FAR PTR ?PC_DispStr@@ZAXEEPEEE@Z	; PC_DispStr
	*** 00223e	83 c4 0a 		add	sp,10	;000aH
;|*** 
;|***         sprintf(s, "%s%8lu %5u", "ADCP rcvd:     ",
;|***           adcp_time.high, adcp_time.low);
; Line 1549
	*** 002241	8e 06 00 00 		mov	es,WORD PTR $T4071
	*** 002245	26 ff 36 04 00 		push	WORD PTR es:?adcp_time@@3UTIMER@@E+4	;adcp_time
	*** 00224a	26 ff 36 02 00 		push	WORD PTR es:?adcp_time@@3UTIMER@@E+2	;adcp_time
	*** 00224f	26 ff 36 00 00 		push	WORD PTR es:?adcp_time@@3UTIMER@@E	;adcp_time
	*** 002254	1e 			push	ds
	*** 002255	68 00 00 		push	OFFSET DGROUP:$SG3928
	*** 002258	1e 			push	ds
	*** 002259	68 00 00 		push	OFFSET DGROUP:$SG3929
	*** 00225c	8d 46 ae 		lea	ax,WORD PTR [bp-82]	;s
	*** 00225f	16 			push	ss
	*** 002260	50 			push	ax
	*** 002261	9a 00 00 00 00 		call	FAR PTR _sprintf
	*** 002266	83 c4 12 		add	sp,18	;0012H
;|***         PC_DispStr(0,12, (unsigned char *)s, DISP_FGND_BLACK + DISP_BGND_LIGHT_GRAY);
; Line 1550
	*** 002269	6a 70 			push	112	;0070H
	*** 00226b	8d 46 ae 		lea	ax,WORD PTR [bp-82]	;s
	*** 00226e	16 			push	ss
	*** 00226f	50 			push	ax
	*** 002270	6a 0c 			push	12	;000cH
	*** 002272	6a 00 			push	0
	*** 002274	9a 00 00 00 00 		call	FAR PTR ?PC_DispStr@@ZAXEEPEEE@Z	; PC_DispStr
	*** 002279	83 c4 0a 		add	sp,10	;000aH
;|*** 
;|***         sprintf(s, "%s%8lu %5u", "DS rcvd:       ",
;|***           ds_time.high, ds_time.low);
; Line 1553
	*** 00227c	8e 06 00 00 		mov	es,WORD PTR $T4071
	*** 002280	26 ff 36 04 00 		push	WORD PTR es:?ds_time@@3UTIMER@@E+4	;ds_time
	*** 002285	26 ff 36 02 00 		push	WORD PTR es:?ds_time@@3UTIMER@@E+2	;ds_time
	*** 00228a	26 ff 36 00 00 		push	WORD PTR es:?ds_time@@3UTIMER@@E	;ds_time
	*** 00228f	1e 			push	ds
	*** 002290	68 00 00 		push	OFFSET DGROUP:$SG3931
	*** 002293	1e 			push	ds
	*** 002294	68 00 00 		push	OFFSET DGROUP:$SG3932
	*** 002297	8d 46 ae 		lea	ax,WORD PTR [bp-82]	;s
	*** 00229a	16 			push	ss
	*** 00229b	50 			push	ax
	*** 00229c	9a 00 00 00 00 		call	FAR PTR _sprintf
	*** 0022a1	83 c4 12 		add	sp,18	;0012H
;|***         PC_DispStr(0,13, (unsigned char *)s, DISP_FGND_BLACK + DISP_BGND_LIGHT_GRAY);
; Line 1554
	*** 0022a4	6a 70 			push	112	;0070H
	*** 0022a6	8d 46 ae 		lea	ax,WORD PTR [bp-82]	;s
	*** 0022a9	16 			push	ss
	*** 0022aa	50 			push	ax
	*** 0022ab	6a 0d 			push	13	;000dH
	*** 0022ad	6a 00 			push	0
	*** 0022af	9a 00 00 00 00 		call	FAR PTR ?PC_DispStr@@ZAXEEPEEE@Z	; PC_DispStr
	*** 0022b4	83 c4 0a 		add	sp,10	;000aH
;|***         
;|***         sprintf(s, "%s%8lu %5u%s%8lu ", "LN200 rcvd:    ",
;|***           ln200_time.high, ln200_time.low, "    LN200 # ", ln200_rx_num);
; Line 1557
	*** 0022b7	ff 36 02 00 		push	WORD PTR ?ln200_rx_num@@3KE+2	;ln200_rx_num
	*** 0022bb	ff 36 00 00 		push	WORD PTR ?ln200_rx_num@@3KE	;ln200_rx_num
	*** 0022bf	1e 			push	ds
	*** 0022c0	68 00 00 		push	OFFSET DGROUP:$SG3934
	*** 0022c3	8e 06 00 00 		mov	es,WORD PTR $T4071
	*** 0022c7	26 ff 36 04 00 		push	WORD PTR es:?ln200_time@@3UTIMER@@E+4	;ln200_time
	*** 0022cc	26 ff 36 02 00 		push	WORD PTR es:?ln200_time@@3UTIMER@@E+2	;ln200_time
	*** 0022d1	26 ff 36 00 00 		push	WORD PTR es:?ln200_time@@3UTIMER@@E	;ln200_time
	*** 0022d6	1e 			push	ds
	*** 0022d7	68 00 00 		push	OFFSET DGROUP:$SG3935
	*** 0022da	1e 			push	ds
	*** 0022db	68 00 00 		push	OFFSET DGROUP:$SG3936
	*** 0022de	8d 46 ae 		lea	ax,WORD PTR [bp-82]	;s
	*** 0022e1	16 			push	ss
	*** 0022e2	50 			push	ax
	*** 0022e3	9a 00 00 00 00 		call	FAR PTR _sprintf
	*** 0022e8	83 c4 1a 		add	sp,26	;001aH
;|***         PC_DispStr(0,14, (unsigned char *)s, DISP_FGND_BLACK + DISP_BGND_LIGHT_GRAY);
; Line 1558
	*** 0022eb	6a 70 			push	112	;0070H
	*** 0022ed	8d 46 ae 		lea	ax,WORD PTR [bp-82]	;s
	*** 0022f0	16 			push	ss
	*** 0022f1	50 			push	ax
	*** 0022f2	6a 0e 			push	14	;000eH
	*** 0022f4	6a 00 			push	0
	*** 0022f6	9a 00 00 00 00 		call	FAR PTR ?PC_DispStr@@ZAXEEPEEE@Z	; PC_DispStr
	*** 0022fb	83 c4 0a 		add	sp,10	;000aH
;|***         
;|***         sprintf(s, "%s%lu", "Received packets: ", packets_rcvd);          
; Line 1560
	*** 0022fe	ff 36 02 00 		push	WORD PTR ?packets_rcvd@@3KE+2	;packets_rcvd
	*** 002302	ff 36 00 00 		push	WORD PTR ?packets_rcvd@@3KE	;packets_rcvd
	*** 002306	1e 			push	ds
	*** 002307	68 00 00 		push	OFFSET DGROUP:$SG3938
	*** 00230a	1e 			push	ds
	*** 00230b	68 00 00 		push	OFFSET DGROUP:$SG3939
	*** 00230e	8d 46 ae 		lea	ax,WORD PTR [bp-82]	;s
	*** 002311	16 			push	ss
	*** 002312	50 			push	ax
	*** 002313	9a 00 00 00 00 		call	FAR PTR _sprintf
	*** 002318	83 c4 10 		add	sp,16	;0010H
;|***         PC_DispStr(0,15, (unsigned char *)s, DISP_FGND_BLACK + DISP_BGND_LIGHT_GRAY);
; Line 1561
	*** 00231b	6a 70 			push	112	;0070H
	*** 00231d	8d 46 ae 		lea	ax,WORD PTR [bp-82]	;s
	*** 002320	16 			push	ss
	*** 002321	50 			push	ax
	*** 002322	6a 0f 			push	15	;000fH
	*** 002324	6a 00 			push	0
	*** 002326	9a 00 00 00 00 		call	FAR PTR ?PC_DispStr@@ZAXEEPEEE@Z	; PC_DispStr
	*** 00232b	83 c4 0a 		add	sp,10	;000aH
;|*** 
;|***         sprintf(s, "%s%lu", "Ax0 count:        ", ax0_counter);          
; Line 1563
	*** 00232e	ff 36 02 00 		push	WORD PTR ?ax0_counter@@3KE+2	;ax0_counter
	*** 002332	ff 36 00 00 		push	WORD PTR ?ax0_counter@@3KE	;ax0_counter
	*** 002336	1e 			push	ds
	*** 002337	68 00 00 		push	OFFSET DGROUP:$SG3941
	*** 00233a	1e 			push	ds
	*** 00233b	68 00 00 		push	OFFSET DGROUP:$SG3942
	*** 00233e	8d 46 ae 		lea	ax,WORD PTR [bp-82]	;s
	*** 002341	16 			push	ss
	*** 002342	50 			push	ax
	*** 002343	9a 00 00 00 00 		call	FAR PTR _sprintf
	*** 002348	83 c4 10 		add	sp,16	;0010H
;|***         PC_DispStr(0,16, (unsigned char *)s, DISP_FGND_BLACK + DISP_BGND_LIGHT_GRAY);
; Line 1564
	*** 00234b	6a 70 			push	112	;0070H
	*** 00234d	8d 46 ae 		lea	ax,WORD PTR [bp-82]	;s
	*** 002350	16 			push	ss
	*** 002351	50 			push	ax
	*** 002352	6a 10 			push	16	;0010H
	*** 002354	6a 00 			push	0
	*** 002356	9a 00 00 00 00 		call	FAR PTR ?PC_DispStr@@ZAXEEPEEE@Z	; PC_DispStr
	*** 00235b	83 c4 0a 		add	sp,10	;000aH
;|***         
;|***         sprintf(s, "%s%lu", "Ax1 count:        ", ax1_counter);          
; Line 1566
	*** 00235e	ff 36 02 00 		push	WORD PTR ?ax1_counter@@3KE+2	;ax1_counter
	*** 002362	ff 36 00 00 		push	WORD PTR ?ax1_counter@@3KE	;ax1_counter
	*** 002366	1e 			push	ds
	*** 002367	68 00 00 		push	OFFSET DGROUP:$SG3944
	*** 00236a	1e 			push	ds
	*** 00236b	68 00 00 		push	OFFSET DGROUP:$SG3945
	*** 00236e	8d 46 ae 		lea	ax,WORD PTR [bp-82]	;s
	*** 002371	16 			push	ss
	*** 002372	50 			push	ax
	*** 002373	9a 00 00 00 00 		call	FAR PTR _sprintf
	*** 002378	83 c4 10 		add	sp,16	;0010H
;|***         PC_DispStr(0,17, (unsigned char *)s, DISP_FGND_BLACK + DISP_BGND_LIGHT_GRAY);
; Line 1567
	*** 00237b	6a 70 			push	112	;0070H
	*** 00237d	8d 46 ae 		lea	ax,WORD PTR [bp-82]	;s
	*** 002380	16 			push	ss
	*** 002381	50 			push	ax
	*** 002382	6a 11 			push	17	;0011H
	*** 002384	6a 00 			push	0
	*** 002386	9a 00 00 00 00 		call	FAR PTR ?PC_DispStr@@ZAXEEPEEE@Z	; PC_DispStr
	*** 00238b	83 c4 0a 		add	sp,10	;000aH
;|***         
;|***         sprintf(s, "%s%lu", "Discards:         ", discards);          
; Line 1569
	*** 00238e	ff 36 02 00 		push	WORD PTR ?discards@@3KE+2	;discards
	*** 002392	ff 36 00 00 		push	WORD PTR ?discards@@3KE	;discards
	*** 002396	1e 			push	ds
	*** 002397	68 00 00 		push	OFFSET DGROUP:$SG3947
	*** 00239a	1e 			push	ds
	*** 00239b	68 00 00 		push	OFFSET DGROUP:$SG3948
	*** 00239e	8d 46 ae 		lea	ax,WORD PTR [bp-82]	;s
	*** 0023a1	16 			push	ss
	*** 0023a2	50 			push	ax
	*** 0023a3	9a 00 00 00 00 		call	FAR PTR _sprintf
	*** 0023a8	83 c4 10 		add	sp,16	;0010H
;|***         PC_DispStr(0,18, (unsigned char *)s, DISP_FGND_BLACK + DISP_BGND_LIGHT_GRAY);
; Line 1570
	*** 0023ab	6a 70 			push	112	;0070H
	*** 0023ad	8d 46 ae 		lea	ax,WORD PTR [bp-82]	;s
	*** 0023b0	16 			push	ss
	*** 0023b1	50 			push	ax
	*** 0023b2	6a 12 			push	18	;0012H
	*** 0023b4	6a 00 			push	0
	*** 0023b6	9a 00 00 00 00 		call	FAR PTR ?PC_DispStr@@ZAXEEPEEE@Z	; PC_DispStr
	*** 0023bb	83 c4 0a 		add	sp,10	;000aH
;|*** 
;|***         sprintf(s, "%s%lu", "Receiver calls:   ", receiver_calls);          
; Line 1572
	*** 0023be	ff 36 02 00 		push	WORD PTR ?receiver_calls@@3KE+2	;receiver_calls
	*** 0023c2	ff 36 00 00 		push	WORD PTR ?receiver_calls@@3KE	;receiver_calls
	*** 0023c6	1e 			push	ds
	*** 0023c7	68 00 00 		push	OFFSET DGROUP:$SG3950
	*** 0023ca	1e 			push	ds
	*** 0023cb	68 00 00 		push	OFFSET DGROUP:$SG3951
	*** 0023ce	8d 46 ae 		lea	ax,WORD PTR [bp-82]	;s
	*** 0023d1	16 			push	ss
	*** 0023d2	50 			push	ax
	*** 0023d3	9a 00 00 00 00 		call	FAR PTR _sprintf
	*** 0023d8	83 c4 10 		add	sp,16	;0010H
;|***         PC_DispStr(0,19, (unsigned char *)s, DISP_FGND_BLACK + DISP_BGND_LIGHT_GRAY);
; Line 1573
	*** 0023db	6a 70 			push	112	;0070H
	*** 0023dd	8d 46 ae 		lea	ax,WORD PTR [bp-82]	;s
	*** 0023e0	16 			push	ss
	*** 0023e1	50 			push	ax
	*** 0023e2	6a 13 			push	19	;0013H
	*** 0023e4	6a 00 			push	0
	*** 0023e6	9a 00 00 00 00 		call	FAR PTR ?PC_DispStr@@ZAXEEPEEE@Z	; PC_DispStr
	*** 0023eb	83 c4 0a 		add	sp,10	;000aH
;|***   }
; Line 1574
	*** 0023ee	e9 00 00 		jmp	$EX3907
					$EX3907:
	*** 0023f1	5e 			pop	si
	*** 0023f2	5f 			pop	di
	*** 0023f3	c9 			leave	
	*** 0023f4	cb 			ret	

?terminate@@ZAXXZ	ENDP
	PUBLIC	?shutdown_uio48@@ZAXXZ	; shutdown_uio48
?shutdown_uio48@@ZAXXZ	PROC FAR	; shutdown_uio48
;|***   
;|***   
;|*** void shutdown_uio48(void)
;|***   {
; Line 1578
	*** 0023f5	c8 02 00 00 		enter	2,0
	*** 0023f9	57 			push	di
	*** 0023fa	56 			push	si
;	i = -2
;|***   for(int i=1;i<49;i++) set_bit(i);
; Line 1579
	*** 0023fb	c7 46 fe 01 00 		mov	WORD PTR [bp-2],1	;i
	*** 002400	e9 03 00 		jmp	$F3956
					$FC3957:
	*** 002403	ff 46 fe 		inc	WORD PTR [bp-2]	;i
					$F3956:
	*** 002406	83 7e fe 31 		cmp	WORD PTR [bp-2],49	;0031H	;i
	*** 00240a	7c 03 			jl	$JCC9226
	*** 00240c	e9 0e 00 		jmp	$FB3958
					$JCC9226:
	*** 00240f	ff 76 fe 		push	WORD PTR [bp-2]	;i
	*** 002412	9a 00 00 00 00 		call	FAR PTR ?set_bit@@ZAXH@Z	; set_bit
	*** 002417	83 c4 02 		add	sp,2
	*** 00241a	e9 e6 ff 		jmp	$FC3957
					$FB3958:
;|***   }     
; Line 1580
	*** 00241d	e9 00 00 		jmp	$EX3954
					$EX3954:
	*** 002420	5e 			pop	si
	*** 002421	5f 			pop	di
	*** 002422	c9 			leave	
	*** 002423	cb 			ret	

?shutdown_uio48@@ZAXXZ	ENDP
	PUBLIC	?shutdown_sys_timer@@ZAXXZ	; shutdown_sys_timer
?shutdown_sys_timer@@ZAXXZ	PROC FAR	; shutdown_sys_timer
;|*** 
;|*** 
;|*** void shutdown_sys_timer(void)
;|***   {  // restore pc's default system timer isr
; Line 1584
	*** 002424	c8 00 00 00 		enter	0,0
	*** 002428	57 			push	di
	*** 002429	56 			push	si
;|***   _disable();
; Line 1585
	*** 00242a	9a 00 00 00 00 		call	FAR PTR __disable
;|***   _dos_setvect(0x08, rtc_vect);
; Line 1586
	*** 00242f	ff 36 02 00 		push	WORD PTR ?rtc_vect@@3P7AXXZE+2	;rtc_vect
	*** 002433	ff 36 00 00 		push	WORD PTR ?rtc_vect@@3P7AXXZE	;rtc_vect
	*** 002437	6a 08 			push	8
	*** 002439	9a 00 00 00 00 		call	FAR PTR __dos_setvect
	*** 00243e	83 c4 06 		add	sp,6
;|***   _enable();
; Line 1587
	*** 002441	9a 00 00 00 00 		call	FAR PTR __enable
;|***   }
; Line 1588
	*** 002446	e9 00 00 		jmp	$EX3960
					$EX3960:
	*** 002449	5e 			pop	si
	*** 00244a	5f 			pop	di
	*** 00244b	c9 			leave	
	*** 00244c	cb 			ret	

?shutdown_sys_timer@@ZAXXZ	ENDP
	PUBLIC	?shutdown_enet@@ZAXXZ	; shutdown_enet
?shutdown_enet@@ZAXXZ	PROC FAR	; shutdown_enet
;|*** 
;|*** 
;|*** void shutdown_enet(void)
;|***   {
; Line 1592
	*** 00244d	c8 00 00 00 		enter	0,0
	*** 002451	57 			push	di
	*** 002452	56 			push	si
;|***   
;|***   // use with at/lantic packet driver  
;|*** /*  while(handle > 0)
;|***     {
;|***     release_type(handle);
;|***     handle--;
;|***     }
;|*** */
;|*** 
;|***   // use with the ne2000 packet driver    
;|***   terminate(handle);  
; Line 1603
	*** 002453	ff 36 00 00 		push	WORD PTR ?handle@@3HE	;handle
	*** 002457	9a 00 00 00 00 		call	FAR PTR ?terminate@@ZAHH@Z	; terminate
	*** 00245c	83 c4 02 		add	sp,2
;|***   }    
; Line 1604
	*** 00245f	e9 00 00 		jmp	$EX3962
					$EX3962:
	*** 002462	5e 			pop	si
	*** 002463	5f 			pop	di
	*** 002464	c9 			leave	
	*** 002465	cb 			ret	

?shutdown_enet@@ZAXXZ	ENDP
	PUBLIC	?shutdown_tech80@@ZAXXZ	; shutdown_tech80
?shutdown_tech80@@ZAXXZ	PROC FAR	; shutdown_tech80
;|***   
;|***   
;|*** void shutdown_tech80(void)
;|***   {
; Line 1608
	*** 002466	c8 00 00 00 		enter	0,0
	*** 00246a	57 			push	di
	*** 00246b	56 			push	si
;|***   te5650SetMotor(0);
; Line 1609
	*** 00246c	6a 00 			push	0
	*** 00246e	9a 00 00 00 00 		call	FAR PTR _te5650SetMotor
	*** 002473	83 c4 02 		add	sp,2
;|***   }
; Line 1610
	*** 002476	e9 00 00 		jmp	$EX3964
					$EX3964:
	*** 002479	5e 			pop	si
	*** 00247a	5f 			pop	di
	*** 00247b	c9 			leave	
	*** 00247c	cb 			ret	

?shutdown_tech80@@ZAXXZ	ENDP
	PUBLIC	?shutdown_dmm32a@@ZAXXZ	; shutdown_dmm32a
?shutdown_dmm32a@@ZAXXZ	PROC FAR	; shutdown_dmm32a
;|*** 
;|*** 
;|*** void shutdown_dmm32a(void)
;|***   {                                           // onboard sensors, irq 11
; Line 1614
	*** 00247d	c8 00 00 00 		enter	0,0
	*** 002481	57 			push	di
	*** 002482	56 			push	si
;|***   _outp(OBS_BASE+ICR, 0x00);                  // disable interrupts on the dmm32
; Line 1615
	*** 002483	6a 00 			push	0
	*** 002485	68 49 03 		push	841	;0349H
	*** 002488	9a 00 00 00 00 		call	FAR PTR __outp
	*** 00248d	83 c4 04 		add	sp,4
;|***   _disable();
; Line 1616
	*** 002490	9a 00 00 00 00 		call	FAR PTR __disable
;|***   _outp(OBS_BASE+MCR, 0x20);                  // apply dmm32 master reset
; Line 1617
	*** 002495	6a 20 			push	32	;0020H
	*** 002497	68 48 03 		push	840	;0348H
	*** 00249a	9a 00 00 00 00 		call	FAR PTR __outp
	*** 00249f	83 c4 04 		add	sp,4
;|***   _outp(0xa1, _inp(0xa1) | ~0xf7);            // mask off irq 11 at the pic
; Line 1618
	*** 0024a2	68 a1 00 		push	161	;00a1H
	*** 0024a5	9a 00 00 00 00 		call	FAR PTR __inp
	*** 0024aa	83 c4 02 		add	sp,2
	*** 0024ad	0d 08 ff 		or	ax,-248	;ff08H
	*** 0024b0	50 			push	ax
	*** 0024b1	68 a1 00 		push	161	;00a1H
	*** 0024b4	9a 00 00 00 00 		call	FAR PTR __outp
	*** 0024b9	83 c4 04 		add	sp,4
;|***   _dos_setvect(11-8+0x70, old_dmm32a_vect);   // rehook previous irq handler
; Line 1619
	*** 0024bc	ff 36 02 00 		push	WORD PTR ?old_dmm32a_vect@@3P7AXXZE+2	;old_dmm32a_vect
	*** 0024c0	ff 36 00 00 		push	WORD PTR ?old_dmm32a_vect@@3P7AXXZE	;old_dmm32a_vect
	*** 0024c4	6a 73 			push	115	;0073H
	*** 0024c6	9a 00 00 00 00 		call	FAR PTR __dos_setvect
	*** 0024cb	83 c4 06 		add	sp,6
;|***   _enable();
; Line 1620
	*** 0024ce	9a 00 00 00 00 		call	FAR PTR __enable
;|***   }
; Line 1621
	*** 0024d3	e9 00 00 		jmp	$EX3966
					$EX3966:
	*** 0024d6	5e 			pop	si
	*** 0024d7	5f 			pop	di
	*** 0024d8	c9 			leave	
	*** 0024d9	cb 			ret	

?shutdown_dmm32a@@ZAXXZ	ENDP
	PUBLIC	?shutdown_dmm32b@@ZAXXZ	; shutdown_dmm32b
?shutdown_dmm32b@@ZAXXZ	PROC FAR	; shutdown_dmm32b
;|*** 
;|*** 
;|*** void shutdown_dmm32b(void)
;|***   {                                           // dyno, irq 12
; Line 1625
	*** 0024da	c8 00 00 00 		enter	0,0
	*** 0024de	57 			push	di
	*** 0024df	56 			push	si
;|***   _outp(DYNO_BASE+ICR, 0x00);                 // disable interrupts on the dmm32
; Line 1626
	*** 0024e0	6a 00 			push	0
	*** 0024e2	68 89 03 		push	905	;0389H
	*** 0024e5	9a 00 00 00 00 		call	FAR PTR __outp
	*** 0024ea	83 c4 04 		add	sp,4
;|***   _disable();
; Line 1627
	*** 0024ed	9a 00 00 00 00 		call	FAR PTR __disable
;|***   _outp(DYNO_BASE+MCR, 0x20);                 // apply dmm32 master reset
; Line 1628
	*** 0024f2	6a 20 			push	32	;0020H
	*** 0024f4	68 88 03 		push	904	;0388H
	*** 0024f7	9a 00 00 00 00 		call	FAR PTR __outp
	*** 0024fc	83 c4 04 		add	sp,4
;|***   _outp(0xa1, _inp(0xa1) | ~0xef);            // mask off irq 12 at the pic
; Line 1629
	*** 0024ff	68 a1 00 		push	161	;00a1H
	*** 002502	9a 00 00 00 00 		call	FAR PTR __inp
	*** 002507	83 c4 02 		add	sp,2
	*** 00250a	0d 10 ff 		or	ax,-240	;ff10H
	*** 00250d	50 			push	ax
	*** 00250e	68 a1 00 		push	161	;00a1H
	*** 002511	9a 00 00 00 00 		call	FAR PTR __outp
	*** 002516	83 c4 04 		add	sp,4
;|***   _dos_setvect(12-8+0x70, old_dmm32b_vect);   // rehook previous irq handler
; Line 1630
	*** 002519	ff 36 02 00 		push	WORD PTR ?old_dmm32b_vect@@3P7AXXZE+2	;old_dmm32b_vect
	*** 00251d	ff 36 00 00 		push	WORD PTR ?old_dmm32b_vect@@3P7AXXZE	;old_dmm32b_vect
	*** 002521	6a 74 			push	116	;0074H
	*** 002523	9a 00 00 00 00 		call	FAR PTR __dos_setvect
	*** 002528	83 c4 06 		add	sp,6
;|***   _enable();
; Line 1631
	*** 00252b	9a 00 00 00 00 		call	FAR PTR __enable
;|***   }
; Line 1632
	*** 002530	e9 00 00 		jmp	$EX3968
					$EX3968:
	*** 002533	5e 			pop	si
	*** 002534	5f 			pop	di
	*** 002535	c9 			leave	
	*** 002536	cb 			ret	

?shutdown_dmm32b@@ZAXXZ	ENDP
	PUBLIC	?shutdown_escc@@ZAXXZ	; shutdown_escc
?shutdown_escc@@ZAXXZ	PROC FAR	; shutdown_escc
;|*** 
;|*** 
;|*** void shutdown_escc(void)
;|***   {
; Line 1636
	*** 002537	c8 00 00 00 		enter	0,0
	*** 00253b	57 			push	di
	*** 00253c	56 			push	si
;|***   escc1.kill_port(channela);
; Line 1637
	*** 00253d	ff 36 00 00 		push	WORD PTR ?channela@@3IE	;channela
	*** 002541	68 00 00 		push	SEG ?escc1@@3VCescc@@E	;escc1
	*** 002544	68 00 00 		push	OFFSET ?escc1@@3VCescc@@E	;escc1
	*** 002547	9a 00 00 00 00 		call	FAR PTR ?kill_port@Cescc@@RECII@Z	; Cescc::kill_port
;|***   escc1.kill_port(channelb);
; Line 1638
	*** 00254c	ff 36 00 00 		push	WORD PTR ?channelb@@3IE	;channelb
	*** 002550	68 00 00 		push	SEG ?escc1@@3VCescc@@E	;escc1
	*** 002553	68 00 00 		push	OFFSET ?escc1@@3VCescc@@E	;escc1
	*** 002556	9a 00 00 00 00 		call	FAR PTR ?kill_port@Cescc@@RECII@Z	; Cescc::kill_port
;|***   }
; Line 1639
	*** 00255b	e9 00 00 		jmp	$EX3970
					$EX3970:
	*** 00255e	5e 			pop	si
	*** 00255f	5f 			pop	di
	*** 002560	c9 			leave	
	*** 002561	cb 			ret	

?shutdown_escc@@ZAXXZ	ENDP
	PUBLIC	?build_packet@@ZAXXZ	; build_packet
?build_packet@@ZAXXZ	PROC FAR	; build_packet
;|*** 
;|*** 
;|*** void build_packet(void)
;|***   {
; Line 1643
	*** 002562	c8 30 00 00 		enter	48,0
	*** 002566	57 			push	di
	*** 002567	56 			push	si
;	i = -2
;	j = -4
;	value = -6
;	checksum16 = -8
;	checksum32 = -12
;	udp_pseudo = -32
;	prop_delta_position = -36
;	prop_delta_time_high = -40
;	prop_delta_time_low = -44
;	prop_delta_time = -48
;|***   unsigned i,j,value;
;|***   unsigned checksum16 = 0;
; Line 1645
	*** 002568	c7 46 f8 00 00 		mov	WORD PTR [bp-8],0	;checksum16
;|***   unsigned long checksum32 = 0;
; Line 1646
	*** 00256d	2b c0 			sub	ax,ax
	*** 00256f	89 46 f6 		mov	WORD PTR [bp-10],ax
	*** 002572	89 46 f4 		mov	WORD PTR [bp-12],ax	;checksum32
;|***   unsigned char udp_pseudo[20];
;|***   long prop_delta_position = 0;
; Line 1648
	*** 002575	2b c0 			sub	ax,ax
	*** 002577	89 46 de 		mov	WORD PTR [bp-34],ax
	*** 00257a	89 46 dc 		mov	WORD PTR [bp-36],ax	;prop_delta_position
;|***   //unsigned long prop_delta_time_high = 0;
;|***   long prop_delta_time_high = 0;
; Line 1650
	*** 00257d	2b c0 			sub	ax,ax
	*** 00257f	89 46 da 		mov	WORD PTR [bp-38],ax
	*** 002582	89 46 d8 		mov	WORD PTR [bp-40],ax	;prop_delta_time_high
;|***   //unsigned long prop_delta_time_low = 0;
;|***   long prop_delta_time_low = 0;
; Line 1652
	*** 002585	2b c0 			sub	ax,ax
	*** 002587	89 46 d6 		mov	WORD PTR [bp-42],ax
	*** 00258a	89 46 d4 		mov	WORD PTR [bp-44],ax	;prop_delta_time_low
;|***   unsigned long prop_delta_time = 0;
; Line 1653
	*** 00258d	2b c0 			sub	ax,ax
	*** 00258f	89 46 d2 		mov	WORD PTR [bp-46],ax
	*** 002592	89 46 d0 		mov	WORD PTR [bp-48],ax	;prop_delta_time
;|*** 
;|*** /*
;|***   for(j=0;j<1514;j++)
;|***     {
;|***     data_pkt[j]=0;
;|***     }
;|*** */    
;|***     
;|***   _fmemset(data_pkt, 0, sizeof(data_pkt));
; Line 1662
	*** 002595	68 ea 05 		push	1514	;05eaH
	*** 002598	6a 00 			push	0
	*** 00259a	1e 			push	ds
	*** 00259b	68 00 00 		push	OFFSET DGROUP:?data_pkt@@3QEEE	;data_pkt
	*** 00259e	9a 00 00 00 00 		call	FAR PTR __fmemset
	*** 0025a3	83 c4 08 		add	sp,8
;|***   
;|***   _disable();             // turn off other services while we copy data
; Line 1664
	*** 0025a6	9a 00 00 00 00 		call	FAR PTR __disable
;|***   
;|***   sys.packet_number++;
; Line 1666
	*** 0025ab	8e 06 00 00 		mov	es,WORD PTR $T4071
	*** 0025af	26 ff 06 02 00 		inc	WORD PTR es:?sys@@3USYS@@E+2	;sys
;|***   sys.frame = frame - 1;  // data is from last frame--not this one
; Line 1667
	*** 0025b4	a1 00 00 		mov	ax,WORD PTR ?frame@@3KE	;frame
	*** 0025b7	8b 16 02 00 		mov	dx,WORD PTR ?frame@@3KE+2	;frame
	*** 0025bb	2d 01 00 		sub	ax,1
	*** 0025be	83 da 00 		sbb	dx,0
	*** 0025c1	26 a3 04 00 		mov	WORD PTR es:?sys@@3USYS@@E+4,ax	;sys
	*** 0025c5	26 89 16 06 00 		mov	WORD PTR es:?sys@@3USYS@@E+6,dx	;sys
;|***   sys.fs_status = 0;
; Line 1668
	*** 0025ca	26 c7 06 08 00 00 00 	mov	WORD PTR es:?sys@@3USYS@@E+8,0	;sys
;|***   sys.fs_status = (read_port(FSHIGH) << 8) | read_port(FSLOW);
; Line 1669
	*** 0025d1	6a 03 			push	3
	*** 0025d3	9a 00 00 00 00 		call	FAR PTR ?read_port@@ZAIH@Z	; read_port
	*** 0025d8	83 c4 02 		add	sp,2
	*** 0025db	6a 00 			push	0
	*** 0025dd	8b f0 			mov	si,ax
	*** 0025df	9a 00 00 00 00 		call	FAR PTR ?read_port@@ZAIH@Z	; read_port
	*** 0025e4	83 c4 02 		add	sp,2
	*** 0025e7	8b ce 			mov	cx,si
	*** 0025e9	8a e9 			mov	ch,cl
	*** 0025eb	2a c9 			sub	cl,cl
	*** 0025ed	0b c1 			or	ax,cx
	*** 0025ef	8e 06 00 00 		mov	es,WORD PTR $T4071
	*** 0025f3	26 a3 08 00 		mov	WORD PTR es:?sys@@3USYS@@E+8,ax	;sys
;|***   sys.op_status = read_port(FSHIGH2);
; Line 1670
	*** 0025f7	6a 04 			push	4
	*** 0025f9	9a 00 00 00 00 		call	FAR PTR ?read_port@@ZAIH@Z	; read_port
	*** 0025fe	83 c4 02 		add	sp,2
	*** 002601	8e 06 00 00 		mov	es,WORD PTR $T4071
	*** 002605	26 a3 0a 00 		mov	WORD PTR es:?sys@@3USYS@@E+10,ax	;sys
;|***   sys.time_high = frame_time.high;
; Line 1671
	*** 002609	8e 06 00 00 		mov	es,WORD PTR $T4071
	*** 00260d	26 a1 00 00 		mov	ax,WORD PTR es:?frame_time@@3UTIMER@@E	;frame_time
	*** 002611	26 8b 16 02 00 		mov	dx,WORD PTR es:?frame_time@@3UTIMER@@E+2	;frame_time
	*** 002616	8e 06 00 00 		mov	es,WORD PTR $T4071
	*** 00261a	26 a3 0c 00 		mov	WORD PTR es:?sys@@3USYS@@E+12,ax	;sys
	*** 00261e	26 89 16 0e 00 		mov	WORD PTR es:?sys@@3USYS@@E+14,dx	;sys
;|***   sys.time_low  = frame_time.low;
; Line 1672
	*** 002623	8e 06 00 00 		mov	es,WORD PTR $T4071
	*** 002627	26 a1 04 00 		mov	ax,WORD PTR es:?frame_time@@3UTIMER@@E+4	;frame_time
	*** 00262b	8e 06 00 00 		mov	es,WORD PTR $T4071
	*** 00262f	26 a3 10 00 		mov	WORD PTR es:?sys@@3USYS@@E+16,ax	;sys
;|***   
;|***   obs.new_data = obs_new_data;
; Line 1674
	*** 002633	a1 00 00 		mov	ax,WORD PTR ?obs_new_data@@3IE	;obs_new_data
	*** 002636	8e 06 00 00 		mov	es,WORD PTR $T4071
	*** 00263a	26 a3 00 00 		mov	WORD PTR es:?obs@@3UOBS@@E,ax	;obs
;|***   obs_new_data = 0;
; Line 1675
	*** 00263e	c7 06 00 00 00 00 	mov	WORD PTR ?obs_new_data@@3IE,0	;obs_new_data
;|***   obs.frame = obs_data_frame;
; Line 1676
	*** 002644	a1 00 00 		mov	ax,WORD PTR ?obs_data_frame@@3KE	;obs_data_frame
	*** 002647	8b 16 02 00 		mov	dx,WORD PTR ?obs_data_frame@@3KE+2	;obs_data_frame
	*** 00264b	26 a3 02 00 		mov	WORD PTR es:?obs@@3UOBS@@E+2,ax	;obs
	*** 00264f	26 89 16 04 00 		mov	WORD PTR es:?obs@@3UOBS@@E+4,dx	;obs
;|***   obs.time_high = obs_time.high;
; Line 1677
	*** 002654	8e 06 00 00 		mov	es,WORD PTR $T4071
	*** 002658	26 a1 00 00 		mov	ax,WORD PTR es:?obs_time@@3UTIMER@@E	;obs_time
	*** 00265c	26 8b 16 02 00 		mov	dx,WORD PTR es:?obs_time@@3UTIMER@@E+2	;obs_time
	*** 002661	8e 06 00 00 		mov	es,WORD PTR $T4071
	*** 002665	26 a3 06 00 		mov	WORD PTR es:?obs@@3UOBS@@E+6,ax	;obs
	*** 002669	26 89 16 08 00 		mov	WORD PTR es:?obs@@3UOBS@@E+8,dx	;obs
;|***   obs.time_low  = obs_time.low;
; Line 1678
	*** 00266e	8e 06 00 00 		mov	es,WORD PTR $T4071
	*** 002672	26 a1 04 00 		mov	ax,WORD PTR es:?obs_time@@3UTIMER@@E+4	;obs_time
	*** 002676	8e 06 00 00 		mov	es,WORD PTR $T4071
	*** 00267a	26 a3 0a 00 		mov	WORD PTR es:?obs@@3UOBS@@E+10,ax	;obs
;|***   _fmemcpy(&obs.data, &obs_buffer, sizeof(obs.data));  
; Line 1679
	*** 00267e	6a 40 			push	64	;0040H
	*** 002680	1e 			push	ds
	*** 002681	68 00 00 		push	OFFSET DGROUP:?obs_buffer@@3QEEE	;obs_buffer
	*** 002684	06 			push	es
	*** 002685	68 0c 00 		push	OFFSET ?obs@@3UOBS@@E+12	;obs
	*** 002688	9a 00 00 00 00 		call	FAR PTR __fmemcpy
	*** 00268d	83 c4 0a 		add	sp,10	;000aH
;|***   
;|***   dyno.new_data = dyno_new_data;
; Line 1681
	*** 002690	a1 00 00 		mov	ax,WORD PTR ?dyno_new_data@@3IE	;dyno_new_data
	*** 002693	8e 06 00 00 		mov	es,WORD PTR $T4071
	*** 002697	26 a3 00 00 		mov	WORD PTR es:?dyno@@3UDYNO@@E,ax	;dyno
;|***   dyno_new_data = 0;
; Line 1682
	*** 00269b	c7 06 00 00 00 00 	mov	WORD PTR ?dyno_new_data@@3IE,0	;dyno_new_data
;|***   dyno.frame = dyno_data_frame;
; Line 1683
	*** 0026a1	a1 00 00 		mov	ax,WORD PTR ?dyno_data_frame@@3KE	;dyno_data_frame
	*** 0026a4	8b 16 02 00 		mov	dx,WORD PTR ?dyno_data_frame@@3KE+2	;dyno_data_frame
	*** 0026a8	26 a3 02 00 		mov	WORD PTR es:?dyno@@3UDYNO@@E+2,ax	;dyno
	*** 0026ac	26 89 16 04 00 		mov	WORD PTR es:?dyno@@3UDYNO@@E+4,dx	;dyno
;|***   dyno.time_high = dyno_time.high;
; Line 1684
	*** 0026b1	8e 06 00 00 		mov	es,WORD PTR $T4071
	*** 0026b5	26 a1 00 00 		mov	ax,WORD PTR es:?dyno_time@@3UTIMER@@E	;dyno_time
	*** 0026b9	26 8b 16 02 00 		mov	dx,WORD PTR es:?dyno_time@@3UTIMER@@E+2	;dyno_time
	*** 0026be	8e 06 00 00 		mov	es,WORD PTR $T4071
	*** 0026c2	26 a3 06 00 		mov	WORD PTR es:?dyno@@3UDYNO@@E+6,ax	;dyno
	*** 0026c6	26 89 16 08 00 		mov	WORD PTR es:?dyno@@3UDYNO@@E+8,dx	;dyno
;|***   dyno.time_low  = dyno_time.low;
; Line 1685
	*** 0026cb	8e 06 00 00 		mov	es,WORD PTR $T4071
	*** 0026cf	26 a1 04 00 		mov	ax,WORD PTR es:?dyno_time@@3UTIMER@@E+4	;dyno_time
	*** 0026d3	8e 06 00 00 		mov	es,WORD PTR $T4071
	*** 0026d7	26 a3 0a 00 		mov	WORD PTR es:?dyno@@3UDYNO@@E+10,ax	;dyno
;|***   _fmemcpy(&dyno.data, &dyno_buffer, sizeof(dyno.data));  
; Line 1686
	*** 0026db	68 00 01 		push	256	;0100H
	*** 0026de	1e 			push	ds
	*** 0026df	68 00 00 		push	OFFSET DGROUP:?dyno_buffer@@3QEEE	;dyno_buffer
	*** 0026e2	06 			push	es
	*** 0026e3	68 0c 00 		push	OFFSET ?dyno@@3UDYNO@@E+12	;dyno
	*** 0026e6	9a 00 00 00 00 		call	FAR PTR __fmemcpy
	*** 0026eb	83 c4 0a 		add	sp,10	;000aH
;|***   
;|***   prop.new_data = prop_new_data;
; Line 1688
	*** 0026ee	a1 00 00 		mov	ax,WORD PTR ?prop_new_data@@3IE	;prop_new_data
	*** 0026f1	8e 06 00 00 		mov	es,WORD PTR $T4071
	*** 0026f5	26 a3 00 00 		mov	WORD PTR es:?prop@@3UPROP@@E,ax	;prop
;|***   prop_new_data = 0;
; Line 1689
	*** 0026f9	c7 06 00 00 00 00 	mov	WORD PTR ?prop_new_data@@3IE,0	;prop_new_data
;|***   prop.frame = prop_data_frame;
; Line 1690
	*** 0026ff	a1 00 00 		mov	ax,WORD PTR ?prop_data_frame@@3KE	;prop_data_frame
	*** 002702	8b 16 02 00 		mov	dx,WORD PTR ?prop_data_frame@@3KE+2	;prop_data_frame
	*** 002706	26 a3 02 00 		mov	WORD PTR es:?prop@@3UPROP@@E+2,ax	;prop
	*** 00270a	26 89 16 04 00 		mov	WORD PTR es:?prop@@3UPROP@@E+4,dx	;prop
;|***   prop.rpm_time_high = prop_rpm_time.high;
; Line 1691
	*** 00270f	8e 06 00 00 		mov	es,WORD PTR $T4071
	*** 002713	26 a1 00 00 		mov	ax,WORD PTR es:?prop_rpm_time@@3UTIMER@@E	;prop_rpm_time
	*** 002717	26 8b 16 02 00 		mov	dx,WORD PTR es:?prop_rpm_time@@3UTIMER@@E+2	;prop_rpm_time
	*** 00271c	8e 06 00 00 		mov	es,WORD PTR $T4071
	*** 002720	26 a3 06 00 		mov	WORD PTR es:?prop@@3UPROP@@E+6,ax	;prop
	*** 002724	26 89 16 08 00 		mov	WORD PTR es:?prop@@3UPROP@@E+8,dx	;prop
;|***   prop.rpm_time_low  = prop_rpm_time.low;
; Line 1692
	*** 002729	8e 06 00 00 		mov	es,WORD PTR $T4071
	*** 00272d	26 a1 04 00 		mov	ax,WORD PTR es:?prop_rpm_time@@3UTIMER@@E+4	;prop_rpm_time
	*** 002731	8e 06 00 00 		mov	es,WORD PTR $T4071
	*** 002735	26 a3 0a 00 		mov	WORD PTR es:?prop@@3UPROP@@E+10,ax	;prop
;|***   prop.position_time_high = prop_position_time.high;
; Line 1693
	*** 002739	8e 06 00 00 		mov	es,WORD PTR $T4071
	*** 00273d	26 a1 00 00 		mov	ax,WORD PTR es:?prop_position_time@@3UTIMER@@E	;prop_position_time
	*** 002741	26 8b 16 02 00 		mov	dx,WORD PTR es:?prop_position_time@@3UTIMER@@E+2	;prop_position_time
	*** 002746	8e 06 00 00 		mov	es,WORD PTR $T4071
	*** 00274a	26 a3 0c 00 		mov	WORD PTR es:?prop@@3UPROP@@E+12,ax	;prop
	*** 00274e	26 89 16 0e 00 		mov	WORD PTR es:?prop@@3UPROP@@E+14,dx	;prop
;|***   prop.position_time_low  = prop_position_time.low;
; Line 1694
	*** 002753	8e 06 00 00 		mov	es,WORD PTR $T4071
	*** 002757	26 a1 04 00 		mov	ax,WORD PTR es:?prop_position_time@@3UTIMER@@E+4	;prop_position_time
	*** 00275b	8e 06 00 00 		mov	es,WORD PTR $T4071
	*** 00275f	26 a3 10 00 		mov	WORD PTR es:?prop@@3UPROP@@E+16,ax	;prop
;|*** //  while(prop_position < 0) prop_position += 10160;  // old encoder normalize the prop position
;|***   while(prop_position < 0) prop_position += 20000;    // new encoder normalize the prop position
; Line 1696
					$FC3984:
	*** 002763	83 3e 02 00 00 		cmp	WORD PTR ?prop_position@@3JE+2,0	;prop_position
	*** 002768	7c 03 			jl	$JCC10088
	*** 00276a	e9 0e 00 		jmp	$FB3985
					$JCC10088:
	*** 00276d	81 06 00 00 20 4e 	add	WORD PTR ?prop_position@@3JE,20000	;4e20H	;prop_position
	*** 002773	83 16 02 00 00 		adc	WORD PTR ?prop_position@@3JE+2,0	;prop_position
	*** 002778	e9 e8 ff 		jmp	$FC3984
					$FB3985:
;|*** //  while(prop_position > 10159) prop_position -= 10160; // old encoder
;|***   while(prop_position > 19999) prop_position -= 20000;   // new encoder
; Line 1698
					$FC3987:
	*** 00277b	83 3e 02 00 00 		cmp	WORD PTR ?prop_position@@3JE+2,0	;prop_position
	*** 002780	7d 03 			jge	$JCC10112
	*** 002782	e9 1e 00 		jmp	$FB3988
					$JCC10112:
	*** 002785	7e 03 			jle	$JCC10117
	*** 002787	e9 0b 00 		jmp	$L4080
					$JCC10117:
	*** 00278a	81 3e 00 00 1f 4e 	cmp	WORD PTR ?prop_position@@3JE,19999	;4e1fH	;prop_position
	*** 002790	77 03 			ja	$JCC10128
	*** 002792	e9 0e 00 		jmp	$FB3988
					$JCC10128:
					$L4080:
	*** 002795	81 2e 00 00 20 4e 	sub	WORD PTR ?prop_position@@3JE,20000	;4e20H	;prop_position
	*** 00279b	83 1e 02 00 00 		sbb	WORD PTR ?prop_position@@3JE+2,0	;prop_position
	*** 0027a0	e9 d8 ff 		jmp	$FC3987
DMMTEST_TEXT      ENDS
CONST      SEGMENT
$T4081	DD	03e99999ar   ;	.30000001
CONST      ENDS
DMMTEST_TEXT      SEGMENT
	ASSUME	CS: DMMTEST_TEXT
					$FB3988:
;|***   prop.position = prop_position;
; Line 1699
	*** 0027a3	a1 00 00 		mov	ax,WORD PTR ?prop_position@@3JE	;prop_position
	*** 0027a6	8b 16 02 00 		mov	dx,WORD PTR ?prop_position@@3JE+2	;prop_position
	*** 0027aa	8e 06 00 00 		mov	es,WORD PTR $T4071
	*** 0027ae	26 a3 1a 00 		mov	WORD PTR es:?prop@@3UPROP@@E+26,ax	;prop
	*** 0027b2	26 89 16 1c 00 		mov	WORD PTR es:?prop@@3UPROP@@E+28,dx	;prop
;|***   prop_delta_position = prop_position_absolute_current - prop_position_absolute_previous;
; Line 1700
	*** 0027b7	a1 00 00 		mov	ax,WORD PTR ?prop_position_absolute_current@@3JE	;prop_position_absolute_current
	*** 0027ba	8b 16 02 00 		mov	dx,WORD PTR ?prop_position_absolute_current@@3JE+2	;prop_position_absolute_current
	*** 0027be	2b 06 00 00 		sub	ax,WORD PTR ?prop_position_absolute_previous@@3JE	;prop_position_absolute_previous
	*** 0027c2	1b 16 02 00 		sbb	dx,WORD PTR ?prop_position_absolute_previous@@3JE+2	;prop_position_absolute_previous
	*** 0027c6	89 46 dc 		mov	WORD PTR [bp-36],ax	;prop_delta_position
	*** 0027c9	89 56 de 		mov	WORD PTR [bp-34],dx
;|*** 
;|*** /*
;|***   prop_delta_time_high = prop_position_time.high - prop_position_time_previous.high;
;|***   prop_delta_time_low = prop_position_time.low - prop_position_time_previous.low;
;|***   if(prop_delta_time_low < 0)
;|***     {
;|***     prop_delta_time_high--;
;|***     prop_delta_time_low += 65536;
;|***     }
;|***   prop_delta_time = (65535 * prop_delta_time_high) + prop_delta_time_low;
;|***   
;|***   if(prop_delta_time != 0)
;|***      prop.rpm = (int) (rpm_sf * ((float)prop_delta_position / (float)prop_delta_time));
;|*** */
;|***   // rpm scale factor = 60 sec/min  x  rev/numcounts  x  1/.01 sec
;|***   //prop.rpm = (int) ((float)prop_delta_position * 0.590551f);  // old encoder
;|***   prop.rpm = (int) ((float)prop_delta_position * 0.3f);  // new encoder
; Line 1717
	*** 0027cc	bb 00 00 		mov	bx,OFFSET DGROUP:$T4081
	*** 0027cf	9a 00 00 00 00 		call	FAR PTR __aFflds
	*** 0027d4	8d 5e dc 		lea	bx,WORD PTR [bp-36]	;prop_delta_position
	*** 0027d7	9a 00 00 00 00 		call	FAR PTR __aFfldl
	*** 0027dc	9a 00 00 00 00 		call	FAR PTR __aFfmul
	*** 0027e1	9a 00 00 00 00 		call	FAR PTR __aFdcvt
	*** 0027e6	9a 00 00 00 00 		call	FAR PTR __aFftol
	*** 0027eb	8e 06 00 00 		mov	es,WORD PTR $T4071
	*** 0027ef	26 a3 18 00 		mov	WORD PTR es:?prop@@3UPROP@@E+24,ax	;prop
;|***   
;|***   prop_position_absolute_previous = prop_position_absolute_current;
; Line 1719
	*** 0027f3	a1 00 00 		mov	ax,WORD PTR ?prop_position_absolute_current@@3JE	;prop_position_absolute_current
	*** 0027f6	8b 16 02 00 		mov	dx,WORD PTR ?prop_position_absolute_current@@3JE+2	;prop_position_absolute_current
	*** 0027fa	a3 00 00 		mov	WORD PTR ?prop_position_absolute_previous@@3JE,ax	;prop_position_absolute_previous
	*** 0027fd	89 16 02 00 		mov	WORD PTR ?prop_position_absolute_previous@@3JE+2,dx	;prop_position_absolute_previous
;|***   prop_position_time_previous.high = prop_position_time.high;
; Line 1720
	*** 002801	8e 06 00 00 		mov	es,WORD PTR $T4071
	*** 002805	26 a1 00 00 		mov	ax,WORD PTR es:?prop_position_time@@3UTIMER@@E	;prop_position_time
	*** 002809	26 8b 16 02 00 		mov	dx,WORD PTR es:?prop_position_time@@3UTIMER@@E+2	;prop_position_time
	*** 00280e	8e 06 00 00 		mov	es,WORD PTR $T4071
	*** 002812	26 a3 00 00 		mov	WORD PTR es:?prop_position_time_previous@@3UTIMER@@E,ax	;prop_position_time_previous
	*** 002816	26 89 16 02 00 		mov	WORD PTR es:?prop_position_time_previous@@3UTIMER@@E+2,dx	;prop_position_time_previous
;|***   prop_position_time_previous.low  = prop_position_time.low;
; Line 1721
	*** 00281b	8e 06 00 00 		mov	es,WORD PTR $T4071
	*** 00281f	26 a1 04 00 		mov	ax,WORD PTR es:?prop_position_time@@3UTIMER@@E+4	;prop_position_time
	*** 002823	8e 06 00 00 		mov	es,WORD PTR $T4071
	*** 002827	26 a3 04 00 		mov	WORD PTR es:?prop_position_time_previous@@3UTIMER@@E+4,ax	;prop_position_time_previous
;|*** 
;|***   prop.adc_time_high = prop_adc_time.high;
; Line 1723
	*** 00282b	8e 06 00 00 		mov	es,WORD PTR $T4071
	*** 00282f	26 a1 00 00 		mov	ax,WORD PTR es:?prop_adc_time@@3UTIMER@@E	;prop_adc_time
	*** 002833	26 8b 16 02 00 		mov	dx,WORD PTR es:?prop_adc_time@@3UTIMER@@E+2	;prop_adc_time
	*** 002838	8e 06 00 00 		mov	es,WORD PTR $T4071
	*** 00283c	26 a3 12 00 		mov	WORD PTR es:?prop@@3UPROP@@E+18,ax	;prop
	*** 002840	26 89 16 14 00 		mov	WORD PTR es:?prop@@3UPROP@@E+20,dx	;prop
;|***   prop.adc_time_low  = prop_adc_time.low;
; Line 1724
	*** 002845	8e 06 00 00 		mov	es,WORD PTR $T4071
	*** 002849	26 a1 04 00 		mov	ax,WORD PTR es:?prop_adc_time@@3UTIMER@@E+4	;prop_adc_time
	*** 00284d	8e 06 00 00 		mov	es,WORD PTR $T4071
	*** 002851	26 a3 16 00 		mov	WORD PTR es:?prop@@3UPROP@@E+22,ax	;prop
;|***   _fmemcpy(&prop.data, &prop_buffer, sizeof(prop.data));  
; Line 1725
	*** 002855	6a 0c 			push	12	;000cH
	*** 002857	1e 			push	ds
	*** 002858	68 00 00 		push	OFFSET DGROUP:?prop_buffer@@3QEEE	;prop_buffer
	*** 00285b	06 			push	es
	*** 00285c	68 1e 00 		push	OFFSET ?prop@@3UPROP@@E+30	;prop
	*** 00285f	9a 00 00 00 00 		call	FAR PTR __fmemcpy
	*** 002864	83 c4 0a 		add	sp,10	;000aH
;|***   
;|***   ln200.new_data = ln200_new_data;
; Line 1727
	*** 002867	a1 00 00 		mov	ax,WORD PTR ?ln200_new_data@@3IE	;ln200_new_data
	*** 00286a	8e 06 00 00 		mov	es,WORD PTR $T4071
	*** 00286e	26 a3 00 00 		mov	WORD PTR es:?ln200@@3ULN200@@E,ax	;ln200
;|***   ln200_new_data = 0;
; Line 1728
	*** 002872	c7 06 00 00 00 00 	mov	WORD PTR ?ln200_new_data@@3IE,0	;ln200_new_data
;|***   ln200.frame = ln200_data_frame;
; Line 1729
	*** 002878	a1 00 00 		mov	ax,WORD PTR ?ln200_data_frame@@3KE	;ln200_data_frame
	*** 00287b	8b 16 02 00 		mov	dx,WORD PTR ?ln200_data_frame@@3KE+2	;ln200_data_frame
	*** 00287f	26 a3 02 00 		mov	WORD PTR es:?ln200@@3ULN200@@E+2,ax	;ln200
	*** 002883	26 89 16 04 00 		mov	WORD PTR es:?ln200@@3ULN200@@E+4,dx	;ln200
;|***   ln200.time_high = ln200_time.high;
; Line 1730
	*** 002888	8e 06 00 00 		mov	es,WORD PTR $T4071
	*** 00288c	26 a1 00 00 		mov	ax,WORD PTR es:?ln200_time@@3UTIMER@@E	;ln200_time
	*** 002890	26 8b 16 02 00 		mov	dx,WORD PTR es:?ln200_time@@3UTIMER@@E+2	;ln200_time
	*** 002895	8e 06 00 00 		mov	es,WORD PTR $T4071
	*** 002899	26 a3 06 00 		mov	WORD PTR es:?ln200@@3ULN200@@E+6,ax	;ln200
	*** 00289d	26 89 16 08 00 		mov	WORD PTR es:?ln200@@3ULN200@@E+8,dx	;ln200
;|***   ln200.time_low  = ln200_time.low;
; Line 1731
	*** 0028a2	8e 06 00 00 		mov	es,WORD PTR $T4071
	*** 0028a6	26 a1 04 00 		mov	ax,WORD PTR es:?ln200_time@@3UTIMER@@E+4	;ln200_time
	*** 0028aa	8e 06 00 00 		mov	es,WORD PTR $T4071
	*** 0028ae	26 a3 0a 00 		mov	WORD PTR es:?ln200@@3ULN200@@E+10,ax	;ln200
;|***   _fmemcpy(&ln200.data, &ln200_buffer, sizeof(ln200.data));  
; Line 1732
	*** 0028b2	6a 20 			push	32	;0020H
	*** 0028b4	1e 			push	ds
	*** 0028b5	68 00 00 		push	OFFSET DGROUP:?ln200_buffer@@3QEEE	;ln200_buffer
	*** 0028b8	06 			push	es
	*** 0028b9	68 0c 00 		push	OFFSET ?ln200@@3ULN200@@E+12	;ln200
	*** 0028bc	9a 00 00 00 00 		call	FAR PTR __fmemcpy
	*** 0028c1	83 c4 0a 		add	sp,10	;000aH
;|***                                       
;|***   echo.new_data = echo_new_data;
; Line 1734
	*** 0028c4	a1 00 00 		mov	ax,WORD PTR ?echo_new_data@@3IE	;echo_new_data
	*** 0028c7	8e 06 00 00 		mov	es,WORD PTR $T4071
	*** 0028cb	26 a3 00 00 		mov	WORD PTR es:?echo@@3UECHO@@E,ax	;echo
;|***   echo_new_data = 0;
; Line 1735
	*** 0028cf	c7 06 00 00 00 00 	mov	WORD PTR ?echo_new_data@@3IE,0	;echo_new_data
;|***   echo.frame = echo_data_frame;
; Line 1736
	*** 0028d5	a1 00 00 		mov	ax,WORD PTR ?echo_data_frame@@3KE	;echo_data_frame
	*** 0028d8	8b 16 02 00 		mov	dx,WORD PTR ?echo_data_frame@@3KE+2	;echo_data_frame
	*** 0028dc	26 a3 02 00 		mov	WORD PTR es:?echo@@3UECHO@@E+2,ax	;echo
	*** 0028e0	26 89 16 04 00 		mov	WORD PTR es:?echo@@3UECHO@@E+4,dx	;echo
;|***   echo.time_high = cmds_time.high;
; Line 1737
	*** 0028e5	8e 06 00 00 		mov	es,WORD PTR $T4071
	*** 0028e9	26 a1 00 00 		mov	ax,WORD PTR es:?cmds_time@@3UTIMER@@E	;cmds_time
	*** 0028ed	26 8b 16 02 00 		mov	dx,WORD PTR es:?cmds_time@@3UTIMER@@E+2	;cmds_time
	*** 0028f2	8e 06 00 00 		mov	es,WORD PTR $T4071
	*** 0028f6	26 a3 06 00 		mov	WORD PTR es:?echo@@3UECHO@@E+6,ax	;echo
	*** 0028fa	26 89 16 08 00 		mov	WORD PTR es:?echo@@3UECHO@@E+8,dx	;echo
;|***   echo.time_low  = cmds_time.low;
; Line 1738
	*** 0028ff	8e 06 00 00 		mov	es,WORD PTR $T4071
	*** 002903	26 a1 04 00 		mov	ax,WORD PTR es:?cmds_time@@3UTIMER@@E+4	;cmds_time
	*** 002907	8e 06 00 00 		mov	es,WORD PTR $T4071
	*** 00290b	26 a3 0a 00 		mov	WORD PTR es:?echo@@3UECHO@@E+10,ax	;echo
;|***   _fmemcpy(&echo.data, &commands, sizeof(echo.data));  
; Line 1739
	*** 00290f	6a 24 			push	36	;0024H
	*** 002911	68 00 00 		push	SEG ?commands@@3UCOMMANDS@@E	;commands
	*** 002914	68 00 00 		push	OFFSET ?commands@@3UCOMMANDS@@E	;commands
	*** 002917	06 			push	es
	*** 002918	68 0c 00 		push	OFFSET ?echo@@3UECHO@@E+12	;echo
	*** 00291b	9a 00 00 00 00 		call	FAR PTR __fmemcpy
	*** 002920	83 c4 0a 		add	sp,10	;000aH
;|***   
;|***   ds.new_data = ds_new_data;
; Line 1741
	*** 002923	a1 00 00 		mov	ax,WORD PTR ?ds_new_data@@3IE	;ds_new_data
	*** 002926	8e 06 00 00 		mov	es,WORD PTR $T4071
	*** 00292a	26 a3 00 00 		mov	WORD PTR es:?ds@@3UDS@@E,ax	;ds
;|***   ds_new_data = 0;
; Line 1742
	*** 00292e	c7 06 00 00 00 00 	mov	WORD PTR ?ds_new_data@@3IE,0	;ds_new_data
;|***   ds.frame = ds_data_frame;
; Line 1743
	*** 002934	a1 00 00 		mov	ax,WORD PTR ?ds_data_frame@@3KE	;ds_data_frame
	*** 002937	8b 16 02 00 		mov	dx,WORD PTR ?ds_data_frame@@3KE+2	;ds_data_frame
	*** 00293b	26 a3 02 00 		mov	WORD PTR es:?ds@@3UDS@@E+2,ax	;ds
	*** 00293f	26 89 16 04 00 		mov	WORD PTR es:?ds@@3UDS@@E+4,dx	;ds
;|***   ds.time_high = ds_time.high;
; Line 1744
	*** 002944	8e 06 00 00 		mov	es,WORD PTR $T4071
	*** 002948	26 a1 00 00 		mov	ax,WORD PTR es:?ds_time@@3UTIMER@@E	;ds_time
	*** 00294c	26 8b 16 02 00 		mov	dx,WORD PTR es:?ds_time@@3UTIMER@@E+2	;ds_time
	*** 002951	8e 06 00 00 		mov	es,WORD PTR $T4071
	*** 002955	26 a3 06 00 		mov	WORD PTR es:?ds@@3UDS@@E+6,ax	;ds
	*** 002959	26 89 16 08 00 		mov	WORD PTR es:?ds@@3UDS@@E+8,dx	;ds
;|***   ds.time_low  = ds_time.low;
; Line 1745
	*** 00295e	8e 06 00 00 		mov	es,WORD PTR $T4071
	*** 002962	26 a1 04 00 		mov	ax,WORD PTR es:?ds_time@@3UTIMER@@E+4	;ds_time
	*** 002966	8e 06 00 00 		mov	es,WORD PTR $T4071
	*** 00296a	26 a3 0a 00 		mov	WORD PTR es:?ds@@3UDS@@E+10,ax	;ds
;|***   _fmemcpy(&ds.data, &ds_buffer, sizeof(ds.data));  
; Line 1746
	*** 00296e	6a 50 			push	80	;0050H
	*** 002970	1e 			push	ds
	*** 002971	68 00 00 		push	OFFSET DGROUP:?ds_buffer@@3QEEE	;ds_buffer
	*** 002974	06 			push	es
	*** 002975	68 0c 00 		push	OFFSET ?ds@@3UDS@@E+12	;ds
	*** 002978	9a 00 00 00 00 		call	FAR PTR __fmemcpy
	*** 00297d	83 c4 0a 		add	sp,10	;000aH
;|***   
;|***   adcp.new_data = adcp_new_data;
; Line 1748
	*** 002980	a1 00 00 		mov	ax,WORD PTR ?adcp_new_data@@3IE	;adcp_new_data
	*** 002983	8e 06 00 00 		mov	es,WORD PTR $T4071
	*** 002987	26 a3 00 00 		mov	WORD PTR es:?adcp@@3UADCP@@E,ax	;adcp
;|***   adcp_new_data = 0;
; Line 1749
	*** 00298b	c7 06 00 00 00 00 	mov	WORD PTR ?adcp_new_data@@3IE,0	;adcp_new_data
;|***   adcp.frame = adcp_data_frame;
; Line 1750
	*** 002991	a1 00 00 		mov	ax,WORD PTR ?adcp_data_frame@@3KE	;adcp_data_frame
	*** 002994	8b 16 02 00 		mov	dx,WORD PTR ?adcp_data_frame@@3KE+2	;adcp_data_frame
	*** 002998	26 a3 02 00 		mov	WORD PTR es:?adcp@@3UADCP@@E+2,ax	;adcp
	*** 00299c	26 89 16 04 00 		mov	WORD PTR es:?adcp@@3UADCP@@E+4,dx	;adcp
;|***   adcp.time_high = adcp_time.high;
; Line 1751
	*** 0029a1	8e 06 00 00 		mov	es,WORD PTR $T4071
	*** 0029a5	26 a1 00 00 		mov	ax,WORD PTR es:?adcp_time@@3UTIMER@@E	;adcp_time
	*** 0029a9	26 8b 16 02 00 		mov	dx,WORD PTR es:?adcp_time@@3UTIMER@@E+2	;adcp_time
	*** 0029ae	8e 06 00 00 		mov	es,WORD PTR $T4071
	*** 0029b2	26 a3 06 00 		mov	WORD PTR es:?adcp@@3UADCP@@E+6,ax	;adcp
	*** 0029b6	26 89 16 08 00 		mov	WORD PTR es:?adcp@@3UADCP@@E+8,dx	;adcp
;|***   adcp.time_low  = adcp_time.low;
; Line 1752
	*** 0029bb	8e 06 00 00 		mov	es,WORD PTR $T4071
	*** 0029bf	26 a1 04 00 		mov	ax,WORD PTR es:?adcp_time@@3UTIMER@@E+4	;adcp_time
	*** 0029c3	8e 06 00 00 		mov	es,WORD PTR $T4071
	*** 0029c7	26 a3 0a 00 		mov	WORD PTR es:?adcp@@3UADCP@@E+10,ax	;adcp
;|***   _fmemcpy(&adcp.data, &adcp_buffer, sizeof(adcp.data));  
; Line 1753
	*** 0029cb	68 d5 00 		push	213	;00d5H
	*** 0029ce	1e 			push	ds
	*** 0029cf	68 00 00 		push	OFFSET DGROUP:?adcp_buffer@@3QEEE	;adcp_buffer
	*** 0029d2	06 			push	es
	*** 0029d3	68 0c 00 		push	OFFSET ?adcp@@3UADCP@@E+12	;adcp
	*** 0029d6	9a 00 00 00 00 		call	FAR PTR __fmemcpy
	*** 0029db	83 c4 0a 		add	sp,10	;000aH
;|***   
;|***   gps.new_data = gps_new_data;
; Line 1755
	*** 0029de	a1 00 00 		mov	ax,WORD PTR ?gps_new_data@@3IE	;gps_new_data
	*** 0029e1	8e 06 00 00 		mov	es,WORD PTR $T4071
	*** 0029e5	26 a3 00 00 		mov	WORD PTR es:?gps@@3UGPS@@E,ax	;gps
;|***   gps_new_data = 0;
; Line 1756
	*** 0029e9	c7 06 00 00 00 00 	mov	WORD PTR ?gps_new_data@@3IE,0	;gps_new_data
;|***   gps.frame = gps_data_frame;
; Line 1757
	*** 0029ef	a1 00 00 		mov	ax,WORD PTR ?gps_data_frame@@3KE	;gps_data_frame
	*** 0029f2	8b 16 02 00 		mov	dx,WORD PTR ?gps_data_frame@@3KE+2	;gps_data_frame
	*** 0029f6	26 a3 02 00 		mov	WORD PTR es:?gps@@3UGPS@@E+2,ax	;gps
	*** 0029fa	26 89 16 04 00 		mov	WORD PTR es:?gps@@3UGPS@@E+4,dx	;gps
;|***   gps.time_high = gps_time.high;
; Line 1758
	*** 0029ff	8e 06 00 00 		mov	es,WORD PTR $T4071
	*** 002a03	26 a1 00 00 		mov	ax,WORD PTR es:?gps_time@@3UTIMER@@E	;gps_time
	*** 002a07	26 8b 16 02 00 		mov	dx,WORD PTR es:?gps_time@@3UTIMER@@E+2	;gps_time
	*** 002a0c	8e 06 00 00 		mov	es,WORD PTR $T4071
	*** 002a10	26 a3 06 00 		mov	WORD PTR es:?gps@@3UGPS@@E+6,ax	;gps
	*** 002a14	26 89 16 08 00 		mov	WORD PTR es:?gps@@3UGPS@@E+8,dx	;gps
;|***   gps.time_low  = gps_time.low;
; Line 1759
	*** 002a19	8e 06 00 00 		mov	es,WORD PTR $T4071
	*** 002a1d	26 a1 04 00 		mov	ax,WORD PTR es:?gps_time@@3UTIMER@@E+4	;gps_time
	*** 002a21	8e 06 00 00 		mov	es,WORD PTR $T4071
	*** 002a25	26 a3 0a 00 		mov	WORD PTR es:?gps@@3UGPS@@E+10,ax	;gps
;|***   _fmemcpy(&gps.data, &gps_buffer, sizeof(gps.data));  
; Line 1760
	*** 002a29	6a 50 			push	80	;0050H
	*** 002a2b	1e 			push	ds
	*** 002a2c	68 00 00 		push	OFFSET DGROUP:?gps_buffer@@3QEEE	;gps_buffer
	*** 002a2f	06 			push	es
	*** 002a30	68 0c 00 		push	OFFSET ?gps@@3UGPS@@E+12	;gps
	*** 002a33	9a 00 00 00 00 		call	FAR PTR __fmemcpy
	*** 002a38	83 c4 0a 		add	sp,10	;000aH
;|*** 
;|***   _enable();                               // finished copying data, restore other services
; Line 1762
	*** 002a3b	9a 00 00 00 00 		call	FAR PTR __enable
;|***   
;|***   _fmemcpy(data_pkt, broadcast_mac, 6);    // insert destination mac addr;
; Line 1764
	*** 002a40	6a 06 			push	6
	*** 002a42	1e 			push	ds
	*** 002a43	68 00 00 		push	OFFSET DGROUP:?broadcast_mac@@3QEEE	;broadcast_mac
	*** 002a46	1e 			push	ds
	*** 002a47	68 00 00 		push	OFFSET DGROUP:?data_pkt@@3QEEE	;data_pkt
	*** 002a4a	9a 00 00 00 00 		call	FAR PTR __fmemcpy
	*** 002a4f	83 c4 0a 		add	sp,10	;000aH
;|***   _fmemcpy(data_pkt+6, obc_mac, 6);        // insert source mac addr
; Line 1765
	*** 002a52	6a 06 			push	6
	*** 002a54	1e 			push	ds
	*** 002a55	68 00 00 		push	OFFSET DGROUP:?obc_mac@@3QEEE	;obc_mac
	*** 002a58	1e 			push	ds
	*** 002a59	68 06 00 		push	OFFSET DGROUP:?data_pkt@@3QEEE+6	;data_pkt
	*** 002a5c	9a 00 00 00 00 		call	FAR PTR __fmemcpy
	*** 002a61	83 c4 0a 		add	sp,10	;000aH
;|*** 
;|***   // for DIX insert packet type = 0x0800 (ip packet)
;|***   data_pkt[12] = 0x08;
; Line 1768
	*** 002a64	c6 06 0c 00 08 		mov	BYTE PTR ?data_pkt@@3QEEE+12,8	;data_pkt
;|***   data_pkt[13] = 0x00;
; Line 1769
	*** 002a69	c6 06 0d 00 00 		mov	BYTE PTR ?data_pkt@@3QEEE+13,0	;data_pkt
;|*** 
;|***   // insert ip header
;|***   // insert version (4 bit) and header length (4 bit)
;|***   data_pkt[14] = 0x45; // version = 0, hdr len = 5 (ie: 5 x 32-bit words) 69
; Line 1773
	*** 002a6e	c6 06 0e 00 45 		mov	BYTE PTR ?data_pkt@@3QEEE+14,69	;0045H	;data_pkt
;|*** 
;|***   // insert type of service (TOS) (8 bit)
;|***   data_pkt[15] = 0;
; Line 1776
	*** 002a73	c6 06 0f 00 00 		mov	BYTE PTR ?data_pkt@@3QEEE+15,0	;data_pkt
;|*** 
;|***   // insert total length (16 bit)
;|***   data_pkt[16] = 0x05;  // high byte 1500 bytes to fit in Ethernet data field
; Line 1779
	*** 002a78	c6 06 10 00 05 		mov	BYTE PTR ?data_pkt@@3QEEE+16,5	;data_pkt
;|***   data_pkt[17] = 0xdc;  // low byte  
; Line 1780
	*** 002a7d	c6 06 11 00 dc 		mov	BYTE PTR ?data_pkt@@3QEEE+17,220	;00dcH	;data_pkt
;|*** 
;|***   // insert id (16 bit)
;|***   data_pkt[18] = high_byte(ip_id);     // high byte
; Line 1783
	*** 002a82	ff 36 00 00 		push	WORD PTR ?ip_id@@3IE	;ip_id
	*** 002a86	9a 00 00 00 00 		call	FAR PTR ?high_byte@@ZAEI@Z	; high_byte
	*** 002a8b	83 c4 02 		add	sp,2
	*** 002a8e	a2 12 00 		mov	BYTE PTR ?data_pkt@@3QEEE+18,al	;data_pkt
;|***   data_pkt[19] = low_byte(ip_id);      // low byte
; Line 1784
	*** 002a91	ff 36 00 00 		push	WORD PTR ?ip_id@@3IE	;ip_id
	*** 002a95	9a 00 00 00 00 		call	FAR PTR ?low_byte@@ZAEI@Z	; low_byte
	*** 002a9a	83 c4 02 		add	sp,2
	*** 002a9d	a2 13 00 		mov	BYTE PTR ?data_pkt@@3QEEE+19,al	;data_pkt
;|***   ip_id++;
; Line 1785
	*** 002aa0	ff 06 00 00 		inc	WORD PTR ?ip_id@@3IE	;ip_id
;|*** 
;|***   // insert flags (3 bit) and fragment offset (13 bit)
;|***   data_pkt[20] = 0;
; Line 1788
	*** 002aa4	c6 06 14 00 00 		mov	BYTE PTR ?data_pkt@@3QEEE+20,0	;data_pkt
;|***   data_pkt[21] = 0;
; Line 1789
	*** 002aa9	c6 06 15 00 00 		mov	BYTE PTR ?data_pkt@@3QEEE+21,0	;data_pkt
;|*** 
;|***   // insert time to live (TTL) (8 bit)
;|***   data_pkt[22] = 64;
; Line 1792
	*** 002aae	c6 06 16 00 40 		mov	BYTE PTR ?data_pkt@@3QEEE+22,64	;0040H	;data_pkt
;|*** 
;|***   // insert protocol (8 bit)
;|***   data_pkt[23] = 17;  // UDP protocol = type 17
; Line 1795
	*** 002ab3	c6 06 17 00 11 		mov	BYTE PTR ?data_pkt@@3QEEE+23,17	;0011H	;data_pkt
;|*** 
;|***   // insert dummy ip checksum
;|***   data_pkt[24] = 0;
; Line 1798
	*** 002ab8	c6 06 18 00 00 		mov	BYTE PTR ?data_pkt@@3QEEE+24,0	;data_pkt
;|***   data_pkt[25] = 0;
; Line 1799
	*** 002abd	c6 06 19 00 00 		mov	BYTE PTR ?data_pkt@@3QEEE+25,0	;data_pkt
;|*** 
;|***   // insert source ip address (32 bit)
;|***   data_pkt[26] = 192;
; Line 1802
	*** 002ac2	c6 06 1a 00 c0 		mov	BYTE PTR ?data_pkt@@3QEEE+26,192	;00c0H	;data_pkt
;|***   data_pkt[27] = 168;
; Line 1803
	*** 002ac7	c6 06 1b 00 a8 		mov	BYTE PTR ?data_pkt@@3QEEE+27,168	;00a8H	;data_pkt
;|***   data_pkt[28] = 1;
; Line 1804
	*** 002acc	c6 06 1c 00 01 		mov	BYTE PTR ?data_pkt@@3QEEE+28,1	;data_pkt
;|***   data_pkt[29] = 4;
; Line 1805
	*** 002ad1	c6 06 1d 00 04 		mov	BYTE PTR ?data_pkt@@3QEEE+29,4	;data_pkt
;|*** 
;|*** /*
;|***   // insert destination ip address (32 bit) sam
;|***   data_pkt[30] = 192;
;|***   data_pkt[31] = 168;
;|***   data_pkt[32] = 1;
;|***   data_pkt[33] = 8;
;|*** */
;|*** 
;|*** /*
;|***   // insert destination ip address (32 bit) jim
;|***   data_pkt[30] = 192;
;|***   data_pkt[31] = 168;
;|***   data_pkt[32] = 1;
;|***   data_pkt[33] = 5;
;|*** */
;|*** 
;|*** /*  // insert destination ip address (32 bit) shore
;|***   data_pkt[30] = 192;
;|***   data_pkt[31] = 168;
;|***   data_pkt[32] = 1;
;|***   data_pkt[33] = 30;
;|*** */
;|*** 
;|*** /*
;|***   // insert destination ip address (32 bit) control
;|***   data_pkt[30] = 192;
;|***   data_pkt[31] = 168;
;|***   data_pkt[32] = 1;
;|***   data_pkt[33] = 8;
;|*** */  
;|*** 
;|***   // insert destination ip address (32 bit) broadcast ip
;|***   data_pkt[30] = 192;
; Line 1839
	*** 002ad6	c6 06 1e 00 c0 		mov	BYTE PTR ?data_pkt@@3QEEE+30,192	;00c0H	;data_pkt
;|***   data_pkt[31] = 168;
; Line 1840
	*** 002adb	c6 06 1f 00 a8 		mov	BYTE PTR ?data_pkt@@3QEEE+31,168	;00a8H	;data_pkt
;|***   data_pkt[32] = 1;
; Line 1841
	*** 002ae0	c6 06 20 00 01 		mov	BYTE PTR ?data_pkt@@3QEEE+32,1	;data_pkt
;|***   data_pkt[33] = 255;
; Line 1842
	*** 002ae5	c6 06 21 00 ff 		mov	BYTE PTR ?data_pkt@@3QEEE+33,255	;00ffH	;data_pkt
;|*** 
;|***   // insert true ip header checksum
;|***   // checksum is the 1's complement of the 16-bit 1's complement sum
;|***   // each pair of 8-bit bytes is first converted to a 16-bit word which
;|***   // must be converted from 2's complement to 1's complememt representation
;|***   // use 32-bit integer math to capture the 1's complement carry bit
;|***   checksum32=0;        
; Line 1849
	*** 002aea	2b c0 			sub	ax,ax
	*** 002aec	89 46 f6 		mov	WORD PTR [bp-10],ax
	*** 002aef	89 46 f4 		mov	WORD PTR [bp-12],ax	;checksum32
;|***   for(j=14;j<34;)
; Line 1850
	*** 002af2	c7 46 fc 0e 00 		mov	WORD PTR [bp-4],14	;000eH	;j
					$FC3992:
	*** 002af7	83 7e fc 22 		cmp	WORD PTR [bp-4],34	;0022H	;j
	*** 002afb	72 03 			jb	$JCC11003
	*** 002afd	e9 4c 00 		jmp	$FB3993
					$JCC11003:
;|***     {
; Line 1851
;|***     value = (data_pkt[j] << 8) + data_pkt[j+1];  // form next 16-bit word
; Line 1852
	*** 002b00	8b 5e fc 		mov	bx,WORD PTR [bp-4]	;j
	*** 002b03	8a a7 00 00 		mov	ah,BYTE PTR ?data_pkt@@3QEEE[bx]	;data_pkt
	*** 002b07	2a c0 			sub	al,al
	*** 002b09	8b 5e fc 		mov	bx,WORD PTR [bp-4]	;j
	*** 002b0c	8a 8f 01 00 		mov	cl,BYTE PTR ?data_pkt@@3QEEE[bx+1]	;data_pkt
	*** 002b10	2a ed 			sub	ch,ch
	*** 002b12	03 c1 			add	ax,cx
	*** 002b14	89 46 fa 		mov	WORD PTR [bp-6],ax	;value
;|***     checksum32 += value;                         // add it to the checksum and
; Line 1853
	*** 002b17	8b 46 fa 		mov	ax,WORD PTR [bp-6]	;value
	*** 002b1a	2b d2 			sub	dx,dx
	*** 002b1c	01 46 f4 		add	WORD PTR [bp-12],ax	;checksum32
	*** 002b1f	11 56 f6 		adc	WORD PTR [bp-10],dx
;|***     if(checksum32 > 0x0000ffff)                  // perform end-around carry if required
; Line 1854
	*** 002b22	83 7e f6 00 		cmp	WORD PTR [bp-10],0
	*** 002b26	76 03 			jbe	$JCC11046
	*** 002b28	e9 09 00 		jmp	$L4086
					$JCC11046:
	*** 002b2b	83 7e f4 ff 		cmp	WORD PTR [bp-12],-1	;ffffH	;checksum32
	*** 002b2f	77 03 			ja	$JCC11055
	*** 002b31	e9 11 00 		jmp	$I3994
					$JCC11055:
					$L4086:
;|***       {                                          
; Line 1855
;|***       checksum32 = (checksum32 & 0x0000ffff) + 1;
; Line 1856
	*** 002b34	8b 46 f4 		mov	ax,WORD PTR [bp-12]	;checksum32
	*** 002b37	2b d2 			sub	dx,dx
	*** 002b39	05 01 00 		add	ax,1
	*** 002b3c	83 d2 00 		adc	dx,0
	*** 002b3f	89 46 f4 		mov	WORD PTR [bp-12],ax	;checksum32
	*** 002b42	89 56 f6 		mov	WORD PTR [bp-10],dx
;|***       }
; Line 1857
;|***     j = j+2;
; Line 1858
					$I3994:
	*** 002b45	83 46 fc 02 		add	WORD PTR [bp-4],2	;j
;|***     }
; Line 1859
	*** 002b49	e9 ab ff 		jmp	$FC3992
					$FB3993:
;|***   checksum16 = (unsigned)(checksum32 & 0x0000ffff);// convert back to 16-bit
; Line 1860
	*** 002b4c	8b 46 f4 		mov	ax,WORD PTR [bp-12]	;checksum32
	*** 002b4f	89 46 f8 		mov	WORD PTR [bp-8],ax	;checksum16
;|***   checksum16 = ~checksum16;                        // take the 1's complement
; Line 1861
	*** 002b52	f7 56 f8 		not	WORD PTR [bp-8]	;checksum16
;|***   data_pkt[24] = high_byte(checksum16);            // and insert into header
; Line 1862
	*** 002b55	ff 76 f8 		push	WORD PTR [bp-8]	;checksum16
	*** 002b58	9a 00 00 00 00 		call	FAR PTR ?high_byte@@ZAEI@Z	; high_byte
	*** 002b5d	83 c4 02 		add	sp,2
	*** 002b60	a2 18 00 		mov	BYTE PTR ?data_pkt@@3QEEE+24,al	;data_pkt
;|***   data_pkt[25] = low_byte(checksum16);
; Line 1863
	*** 002b63	ff 76 f8 		push	WORD PTR [bp-8]	;checksum16
	*** 002b66	9a 00 00 00 00 		call	FAR PTR ?low_byte@@ZAEI@Z	; low_byte
	*** 002b6b	83 c4 02 		add	sp,2
	*** 002b6e	a2 19 00 		mov	BYTE PTR ?data_pkt@@3QEEE+25,al	;data_pkt
;|*** 
;|***   // insert udp packet into ip data field (up to 1480 bytes)
;|***   // start with the udp header
;|***   // insert udp source port
;|***   data_pkt[34] = high_byte(UDP_SOURCE_PORT);
; Line 1868
	*** 002b71	68 57 13 		push	4951	;1357H
	*** 002b74	9a 00 00 00 00 		call	FAR PTR ?high_byte@@ZAEI@Z	; high_byte
	*** 002b79	83 c4 02 		add	sp,2
	*** 002b7c	a2 22 00 		mov	BYTE PTR ?data_pkt@@3QEEE+34,al	;data_pkt
;|***   data_pkt[35] = low_byte(UDP_SOURCE_PORT);
; Line 1869
	*** 002b7f	68 57 13 		push	4951	;1357H
	*** 002b82	9a 00 00 00 00 		call	FAR PTR ?low_byte@@ZAEI@Z	; low_byte
	*** 002b87	83 c4 02 		add	sp,2
	*** 002b8a	a2 23 00 		mov	BYTE PTR ?data_pkt@@3QEEE+35,al	;data_pkt
;|*** 
;|***   // insert udp destination port
;|***   data_pkt[36] = high_byte(UDP_DEST_PORT);
; Line 1872
	*** 002b8d	68 56 13 		push	4950	;1356H
	*** 002b90	9a 00 00 00 00 		call	FAR PTR ?high_byte@@ZAEI@Z	; high_byte
	*** 002b95	83 c4 02 		add	sp,2
	*** 002b98	a2 24 00 		mov	BYTE PTR ?data_pkt@@3QEEE+36,al	;data_pkt
;|***   data_pkt[37] = low_byte(UDP_DEST_PORT);
; Line 1873
	*** 002b9b	68 56 13 		push	4950	;1356H
	*** 002b9e	9a 00 00 00 00 		call	FAR PTR ?low_byte@@ZAEI@Z	; low_byte
	*** 002ba3	83 c4 02 		add	sp,2
	*** 002ba6	a2 25 00 		mov	BYTE PTR ?data_pkt@@3QEEE+37,al	;data_pkt
;|*** 
;|***   // insert udp length
;|***   data_pkt[38] = high_byte(UDP_LENGTH);
; Line 1876
	*** 002ba9	68 c8 05 		push	1480	;05c8H
	*** 002bac	9a 00 00 00 00 		call	FAR PTR ?high_byte@@ZAEI@Z	; high_byte
	*** 002bb1	83 c4 02 		add	sp,2
	*** 002bb4	a2 26 00 		mov	BYTE PTR ?data_pkt@@3QEEE+38,al	;data_pkt
;|***   data_pkt[39] = low_byte(UDP_LENGTH);
; Line 1877
	*** 002bb7	68 c8 05 		push	1480	;05c8H
	*** 002bba	9a 00 00 00 00 		call	FAR PTR ?low_byte@@ZAEI@Z	; low_byte
	*** 002bbf	83 c4 02 		add	sp,2
	*** 002bc2	a2 27 00 		mov	BYTE PTR ?data_pkt@@3QEEE+39,al	;data_pkt
;|*** 
;|***   // insert dummy udp checksum
;|***   // must wait until after udp data is loaded to calculate the real udp checksum
;|***   data_pkt[40] = 0;
; Line 1881
	*** 002bc5	c6 06 28 00 00 		mov	BYTE PTR ?data_pkt@@3QEEE+40,0	;data_pkt
;|***   data_pkt[41] = 0;
; Line 1882
	*** 002bca	c6 06 29 00 00 		mov	BYTE PTR ?data_pkt@@3QEEE+41,0	;data_pkt
;|***   
;|***   /*
;|***   // insert dummy udp data for trouble shooting
;|***   for(i=42; i<1514; i++) // insert packet data
;|***     {
;|***     data_pkt[i] = (unsigned char) i & 0xf;
;|***     }
;|***   */
;|***   
;|***   // insert real obc data
;|***   i = 42;
; Line 1893
	*** 002bcf	c7 46 fe 2a 00 		mov	WORD PTR [bp-2],42	;002aH	;i
;|***   
;|***   _fmemcpy(&data_pkt[i], &sys, sizeof(sys));
; Line 1895
	*** 002bd4	6a 12 			push	18	;0012H
	*** 002bd6	68 00 00 		push	SEG ?sys@@3USYS@@E	;sys
	*** 002bd9	68 00 00 		push	OFFSET ?sys@@3USYS@@E	;sys
	*** 002bdc	8b 46 fe 		mov	ax,WORD PTR [bp-2]	;i
	*** 002bdf	05 00 00 		add	ax,OFFSET DGROUP:?data_pkt@@3QEEE	;data_pkt
	*** 002be2	1e 			push	ds
	*** 002be3	50 			push	ax
	*** 002be4	9a 00 00 00 00 		call	FAR PTR __fmemcpy
	*** 002be9	83 c4 0a 		add	sp,10	;000aH
;|***   i += sizeof(sys);
; Line 1896
	*** 002bec	83 46 fe 12 		add	WORD PTR [bp-2],18	;0012H	;i
;|*** 
;|***   _fmemcpy(&data_pkt[i], &obs, sizeof(obs));
; Line 1898
	*** 002bf0	6a 4c 			push	76	;004cH
	*** 002bf2	68 00 00 		push	SEG ?obs@@3UOBS@@E	;obs
	*** 002bf5	68 00 00 		push	OFFSET ?obs@@3UOBS@@E	;obs
	*** 002bf8	8b 46 fe 		mov	ax,WORD PTR [bp-2]	;i
	*** 002bfb	05 00 00 		add	ax,OFFSET DGROUP:?data_pkt@@3QEEE	;data_pkt
	*** 002bfe	1e 			push	ds
	*** 002bff	50 			push	ax
	*** 002c00	9a 00 00 00 00 		call	FAR PTR __fmemcpy
	*** 002c05	83 c4 0a 		add	sp,10	;000aH
;|***   i += sizeof(obs);
; Line 1899
	*** 002c08	83 46 fe 4c 		add	WORD PTR [bp-2],76	;004cH	;i
;|*** 
;|***   _fmemcpy(&data_pkt[i], &dyno, sizeof(dyno));
; Line 1901
	*** 002c0c	68 0c 01 		push	268	;010cH
	*** 002c0f	68 00 00 		push	SEG ?dyno@@3UDYNO@@E	;dyno
	*** 002c12	68 00 00 		push	OFFSET ?dyno@@3UDYNO@@E	;dyno
	*** 002c15	8b 46 fe 		mov	ax,WORD PTR [bp-2]	;i
	*** 002c18	05 00 00 		add	ax,OFFSET DGROUP:?data_pkt@@3QEEE	;data_pkt
	*** 002c1b	1e 			push	ds
	*** 002c1c	50 			push	ax
	*** 002c1d	9a 00 00 00 00 		call	FAR PTR __fmemcpy
	*** 002c22	83 c4 0a 		add	sp,10	;000aH
;|***   i += sizeof(dyno);
; Line 1902
	*** 002c25	81 46 fe 0c 01 		add	WORD PTR [bp-2],268	;010cH	;i
;|***   
;|***   _fmemcpy(&data_pkt[i], &prop, sizeof(prop));
; Line 1904
	*** 002c2a	6a 2a 			push	42	;002aH
	*** 002c2c	68 00 00 		push	SEG ?prop@@3UPROP@@E	;prop
	*** 002c2f	68 00 00 		push	OFFSET ?prop@@3UPROP@@E	;prop
	*** 002c32	8b 46 fe 		mov	ax,WORD PTR [bp-2]	;i
	*** 002c35	05 00 00 		add	ax,OFFSET DGROUP:?data_pkt@@3QEEE	;data_pkt
	*** 002c38	1e 			push	ds
	*** 002c39	50 			push	ax
	*** 002c3a	9a 00 00 00 00 		call	FAR PTR __fmemcpy
	*** 002c3f	83 c4 0a 		add	sp,10	;000aH
;|***   i += sizeof(prop);
; Line 1905
	*** 002c42	83 46 fe 2a 		add	WORD PTR [bp-2],42	;002aH	;i
;|***   
;|***   _fmemcpy(&data_pkt[i], &ln200, sizeof(ln200));
; Line 1907
	*** 002c46	6a 2c 			push	44	;002cH
	*** 002c48	68 00 00 		push	SEG ?ln200@@3ULN200@@E	;ln200
	*** 002c4b	68 00 00 		push	OFFSET ?ln200@@3ULN200@@E	;ln200
	*** 002c4e	8b 46 fe 		mov	ax,WORD PTR [bp-2]	;i
	*** 002c51	05 00 00 		add	ax,OFFSET DGROUP:?data_pkt@@3QEEE	;data_pkt
	*** 002c54	1e 			push	ds
	*** 002c55	50 			push	ax
	*** 002c56	9a 00 00 00 00 		call	FAR PTR __fmemcpy
	*** 002c5b	83 c4 0a 		add	sp,10	;000aH
;|***   i += sizeof(ln200);
; Line 1908
	*** 002c5e	83 46 fe 2c 		add	WORD PTR [bp-2],44	;002cH	;i
;|***   
;|***   _fmemcpy(&data_pkt[i], &echo, sizeof(echo));
; Line 1910
	*** 002c62	6a 30 			push	48	;0030H
	*** 002c64	68 00 00 		push	SEG ?echo@@3UECHO@@E	;echo
	*** 002c67	68 00 00 		push	OFFSET ?echo@@3UECHO@@E	;echo
	*** 002c6a	8b 46 fe 		mov	ax,WORD PTR [bp-2]	;i
	*** 002c6d	05 00 00 		add	ax,OFFSET DGROUP:?data_pkt@@3QEEE	;data_pkt
	*** 002c70	1e 			push	ds
	*** 002c71	50 			push	ax
	*** 002c72	9a 00 00 00 00 		call	FAR PTR __fmemcpy
	*** 002c77	83 c4 0a 		add	sp,10	;000aH
;|***   i += sizeof(echo);
; Line 1911
	*** 002c7a	83 46 fe 30 		add	WORD PTR [bp-2],48	;0030H	;i
;|***   
;|***   _fmemcpy(&data_pkt[i], &ds, sizeof(ds));
; Line 1913
	*** 002c7e	6a 5c 			push	92	;005cH
	*** 002c80	68 00 00 		push	SEG ?ds@@3UDS@@E	;ds
	*** 002c83	68 00 00 		push	OFFSET ?ds@@3UDS@@E	;ds
	*** 002c86	8b 46 fe 		mov	ax,WORD PTR [bp-2]	;i
	*** 002c89	05 00 00 		add	ax,OFFSET DGROUP:?data_pkt@@3QEEE	;data_pkt
	*** 002c8c	1e 			push	ds
	*** 002c8d	50 			push	ax
	*** 002c8e	9a 00 00 00 00 		call	FAR PTR __fmemcpy
	*** 002c93	83 c4 0a 		add	sp,10	;000aH
;|***   i += sizeof(ds);
; Line 1914
	*** 002c96	83 46 fe 5c 		add	WORD PTR [bp-2],92	;005cH	;i
;|***   
;|***   _fmemcpy(&data_pkt[i], &adcp, sizeof(adcp));
; Line 1916
	*** 002c9a	68 e1 00 		push	225	;00e1H
	*** 002c9d	68 00 00 		push	SEG ?adcp@@3UADCP@@E	;adcp
	*** 002ca0	68 00 00 		push	OFFSET ?adcp@@3UADCP@@E	;adcp
	*** 002ca3	8b 46 fe 		mov	ax,WORD PTR [bp-2]	;i
	*** 002ca6	05 00 00 		add	ax,OFFSET DGROUP:?data_pkt@@3QEEE	;data_pkt
	*** 002ca9	1e 			push	ds
	*** 002caa	50 			push	ax
	*** 002cab	9a 00 00 00 00 		call	FAR PTR __fmemcpy
	*** 002cb0	83 c4 0a 		add	sp,10	;000aH
;|***   i += sizeof(adcp);
; Line 1917
	*** 002cb3	81 46 fe e1 00 		add	WORD PTR [bp-2],225	;00e1H	;i
;|***   
;|***   _fmemcpy(&data_pkt[i], &gps, sizeof(gps));
; Line 1919
	*** 002cb8	6a 5c 			push	92	;005cH
	*** 002cba	68 00 00 		push	SEG ?gps@@3UGPS@@E	;gps
	*** 002cbd	68 00 00 		push	OFFSET ?gps@@3UGPS@@E	;gps
	*** 002cc0	8b 46 fe 		mov	ax,WORD PTR [bp-2]	;i
	*** 002cc3	05 00 00 		add	ax,OFFSET DGROUP:?data_pkt@@3QEEE	;data_pkt
	*** 002cc6	1e 			push	ds
	*** 002cc7	50 			push	ax
	*** 002cc8	9a 00 00 00 00 		call	FAR PTR __fmemcpy
	*** 002ccd	83 c4 0a 		add	sp,10	;000aH
;|***   i += sizeof(gps);
; Line 1920
	*** 002cd0	83 46 fe 5c 		add	WORD PTR [bp-2],92	;005cH	;i
;|*** 
;|***   // now calculate and insert the real udp checksum
;|***   // from the udp pseudo-header and true header
;|***   for(j=0;j<8;j++) udp_pseudo[j] = data_pkt[j+26];  // source & dest ip addr
; Line 1924
	*** 002cd4	c7 46 fc 00 00 		mov	WORD PTR [bp-4],0	;j
	*** 002cd9	e9 03 00 		jmp	$F3996
					$FC3997:
	*** 002cdc	ff 46 fc 		inc	WORD PTR [bp-4]	;j
					$F3996:
	*** 002cdf	83 7e fc 08 		cmp	WORD PTR [bp-4],8	;j
	*** 002ce3	72 03 			jb	$JCC11491
	*** 002ce5	e9 10 00 		jmp	$FB3998
					$JCC11491:
	*** 002ce8	8b 5e fc 		mov	bx,WORD PTR [bp-4]	;j
	*** 002ceb	8a 87 1a 00 		mov	al,BYTE PTR ?data_pkt@@3QEEE[bx+26]	;data_pkt
	*** 002cef	8b 76 fc 		mov	si,WORD PTR [bp-4]	;j
	*** 002cf2	88 42 e0 		mov	BYTE PTR [bp-32][si],al
	*** 002cf5	e9 e4 ff 		jmp	$FC3997
					$FB3998:
;|***   udp_pseudo[8] = 0;
; Line 1925
	*** 002cf8	c6 46 e8 00 		mov	BYTE PTR [bp-24],0
;|***   udp_pseudo[9] = data_pkt[23];   // protocol id
; Line 1926
	*** 002cfc	a0 17 00 		mov	al,BYTE PTR ?data_pkt@@3QEEE+23	;data_pkt
	*** 002cff	88 46 e9 		mov	BYTE PTR [bp-23],al
;|***   udp_pseudo[10] = data_pkt[38];  // udp length high byte
; Line 1927
	*** 002d02	a0 26 00 		mov	al,BYTE PTR ?data_pkt@@3QEEE+38	;data_pkt
	*** 002d05	88 46 ea 		mov	BYTE PTR [bp-22],al
;|***   udp_pseudo[11] = data_pkt[39];  // udp length low byte
; Line 1928
	*** 002d08	a0 27 00 		mov	al,BYTE PTR ?data_pkt@@3QEEE+39	;data_pkt
	*** 002d0b	88 46 eb 		mov	BYTE PTR [bp-21],al
;|*** 
;|***   // calculate the 1's complement checksum
;|***   checksum32 = 0;
; Line 1931
	*** 002d0e	2b c0 			sub	ax,ax
	*** 002d10	89 46 f6 		mov	WORD PTR [bp-10],ax
	*** 002d13	89 46 f4 		mov	WORD PTR [bp-12],ax	;checksum32
;|***   for(j=0;j<12;)
; Line 1932
	*** 002d16	c7 46 fc 00 00 		mov	WORD PTR [bp-4],0	;j
					$FC4000:
	*** 002d1b	83 7e fc 0c 		cmp	WORD PTR [bp-4],12	;000cH	;j
	*** 002d1f	72 03 			jb	$JCC11551
	*** 002d21	e9 4a 00 		jmp	$FB4001
					$JCC11551:
;|***     {
; Line 1933
;|***     value = (udp_pseudo[j] << 8) + udp_pseudo[j+1];
; Line 1934
	*** 002d24	8b 76 fc 		mov	si,WORD PTR [bp-4]	;j
	*** 002d27	8a 62 e0 		mov	ah,BYTE PTR [bp-32][si]
	*** 002d2a	2a c0 			sub	al,al
	*** 002d2c	8b 76 fc 		mov	si,WORD PTR [bp-4]	;j
	*** 002d2f	8a 4a e1 		mov	cl,BYTE PTR [bp-31][si]
	*** 002d32	2a ed 			sub	ch,ch
	*** 002d34	03 c1 			add	ax,cx
	*** 002d36	89 46 fa 		mov	WORD PTR [bp-6],ax	;value
;|***     checksum32 += value;                         // add them up
; Line 1935
	*** 002d39	8b 46 fa 		mov	ax,WORD PTR [bp-6]	;value
	*** 002d3c	2b d2 			sub	dx,dx
	*** 002d3e	01 46 f4 		add	WORD PTR [bp-12],ax	;checksum32
	*** 002d41	11 56 f6 		adc	WORD PTR [bp-10],dx
;|***     if(checksum32 > 0x0000ffff)                  // perform end-around carry
; Line 1936
	*** 002d44	83 7e f6 00 		cmp	WORD PTR [bp-10],0
	*** 002d48	76 03 			jbe	$JCC11592
	*** 002d4a	e9 09 00 		jmp	$L4087
					$JCC11592:
	*** 002d4d	83 7e f4 ff 		cmp	WORD PTR [bp-12],-1	;ffffH	;checksum32
	*** 002d51	77 03 			ja	$JCC11601
	*** 002d53	e9 11 00 		jmp	$I4002
					$JCC11601:
					$L4087:
;|***       {
; Line 1937
;|***       checksum32 = (checksum32 & 0x0000ffff) + 1;
; Line 1938
	*** 002d56	8b 46 f4 		mov	ax,WORD PTR [bp-12]	;checksum32
	*** 002d59	2b d2 			sub	dx,dx
	*** 002d5b	05 01 00 		add	ax,1
	*** 002d5e	83 d2 00 		adc	dx,0
	*** 002d61	89 46 f4 		mov	WORD PTR [bp-12],ax	;checksum32
	*** 002d64	89 56 f6 		mov	WORD PTR [bp-10],dx
;|***       }
; Line 1939
;|***     j = j+2;
; Line 1940
					$I4002:
	*** 002d67	83 46 fc 02 		add	WORD PTR [bp-4],2	;j
;|***     }
; Line 1941
	*** 002d6b	e9 ad ff 		jmp	$FC4000
					$FB4001:
;|*** 
;|***   // insert the true udp header and data next
;|***   for(j=34;j<1514;)                              // true udp header and data
; Line 1944
	*** 002d6e	c7 46 fc 22 00 		mov	WORD PTR [bp-4],34	;0022H	;j
					$FC4004:
	*** 002d73	81 7e fc ea 05 		cmp	WORD PTR [bp-4],1514	;05eaH	;j
	*** 002d78	72 03 			jb	$JCC11640
	*** 002d7a	e9 4c 00 		jmp	$FB4005
					$JCC11640:
;|***     {
; Line 1945
;|***     value = (data_pkt[j] << 8) + data_pkt[j+1];
; Line 1946
	*** 002d7d	8b 5e fc 		mov	bx,WORD PTR [bp-4]	;j
	*** 002d80	8a a7 00 00 		mov	ah,BYTE PTR ?data_pkt@@3QEEE[bx]	;data_pkt
	*** 002d84	2a c0 			sub	al,al
	*** 002d86	8b 5e fc 		mov	bx,WORD PTR [bp-4]	;j
	*** 002d89	8a 8f 01 00 		mov	cl,BYTE PTR ?data_pkt@@3QEEE[bx+1]	;data_pkt
	*** 002d8d	2a ed 			sub	ch,ch
	*** 002d8f	03 c1 			add	ax,cx
	*** 002d91	89 46 fa 		mov	WORD PTR [bp-6],ax	;value
;|***     checksum32 += value;                         // add them up
; Line 1947
	*** 002d94	8b 46 fa 		mov	ax,WORD PTR [bp-6]	;value
	*** 002d97	2b d2 			sub	dx,dx
	*** 002d99	01 46 f4 		add	WORD PTR [bp-12],ax	;checksum32
	*** 002d9c	11 56 f6 		adc	WORD PTR [bp-10],dx
;|***     if(checksum32 > 0x0000ffff)                  // perform end-around carry
; Line 1948
	*** 002d9f	83 7e f6 00 		cmp	WORD PTR [bp-10],0
	*** 002da3	76 03 			jbe	$JCC11683
	*** 002da5	e9 09 00 		jmp	$L4088
					$JCC11683:
	*** 002da8	83 7e f4 ff 		cmp	WORD PTR [bp-12],-1	;ffffH	;checksum32
	*** 002dac	77 03 			ja	$JCC11692
	*** 002dae	e9 11 00 		jmp	$I4006
					$JCC11692:
					$L4088:
;|***       {
; Line 1949
;|***       checksum32 = (checksum32 & 0x0000ffff) + 1;
; Line 1950
	*** 002db1	8b 46 f4 		mov	ax,WORD PTR [bp-12]	;checksum32
	*** 002db4	2b d2 			sub	dx,dx
	*** 002db6	05 01 00 		add	ax,1
	*** 002db9	83 d2 00 		adc	dx,0
	*** 002dbc	89 46 f4 		mov	WORD PTR [bp-12],ax	;checksum32
	*** 002dbf	89 56 f6 		mov	WORD PTR [bp-10],dx
;|***       }
; Line 1951
;|***     j = j+2;
; Line 1952
					$I4006:
	*** 002dc2	83 46 fc 02 		add	WORD PTR [bp-4],2	;j
;|***     }
; Line 1953
	*** 002dc6	e9 aa ff 		jmp	$FC4004
					$FB4005:
;|***   checksum16 = (unsigned)(checksum32 & 0x0000ffff);// convert back to 16-bit
; Line 1954
	*** 002dc9	8b 46 f4 		mov	ax,WORD PTR [bp-12]	;checksum32
	*** 002dcc	89 46 f8 		mov	WORD PTR [bp-8],ax	;checksum16
;|***   checksum16 = ~checksum16;                      // take the 1's complement
; Line 1955
	*** 002dcf	f7 56 f8 		not	WORD PTR [bp-8]	;checksum16
;|***   if(checksum16 == 0) checksum16 = 0xffff;       // do this only for udp/tcp packets
; Line 1956
	*** 002dd2	83 7e f8 00 		cmp	WORD PTR [bp-8],0	;checksum16
	*** 002dd6	74 03 			je	$JCC11734
	*** 002dd8	e9 05 00 		jmp	$I4008
					$JCC11734:
	*** 002ddb	c7 46 f8 ff ff 		mov	WORD PTR [bp-8],-1	;ffffH	;checksum16
;|***   data_pkt[40] = high_byte(checksum16);
; Line 1957
					$I4008:
	*** 002de0	ff 76 f8 		push	WORD PTR [bp-8]	;checksum16
	*** 002de3	9a 00 00 00 00 		call	FAR PTR ?high_byte@@ZAEI@Z	; high_byte
	*** 002de8	83 c4 02 		add	sp,2
	*** 002deb	a2 28 00 		mov	BYTE PTR ?data_pkt@@3QEEE+40,al	;data_pkt
;|***   data_pkt[41] = low_byte(checksum16);
; Line 1958
	*** 002dee	ff 76 f8 		push	WORD PTR [bp-8]	;checksum16
	*** 002df1	9a 00 00 00 00 		call	FAR PTR ?low_byte@@ZAEI@Z	; low_byte
	*** 002df6	83 c4 02 		add	sp,2
	*** 002df9	a2 29 00 		mov	BYTE PTR ?data_pkt@@3QEEE+41,al	;data_pkt
;|*** 
;|***   // end build_packet()
;|***   }
; Line 1961
	*** 002dfc	e9 00 00 		jmp	$EX3972
					$EX3972:
	*** 002dff	5e 			pop	si
	*** 002e00	5f 			pop	di
	*** 002e01	c9 			leave	
	*** 002e02	cb 			ret	

?build_packet@@ZAXXZ	ENDP
	PUBLIC	?high_byte@@ZAEI@Z	; high_byte
?high_byte@@ZAEI@Z	PROC FAR	; high_byte
;|*** 
;|*** 
;|*** unsigned char high_byte(unsigned int word)
;|***   {
; Line 1965
	*** 002e03	c8 00 00 00 		enter	0,0
	*** 002e07	57 			push	di
	*** 002e08	56 			push	si
;	word = 6
;|***   return (unsigned char) ((word>>8)&0xff);
; Line 1966
	*** 002e09	8a 46 07 		mov	al,BYTE PTR [bp+7]
	*** 002e0c	e9 00 00 		jmp	$EX4010
;|***   }
; Line 1967
					$EX4010:
	*** 002e0f	5e 			pop	si
	*** 002e10	5f 			pop	di
	*** 002e11	c9 			leave	
	*** 002e12	cb 			ret	

?high_byte@@ZAEI@Z	ENDP
	PUBLIC	?low_byte@@ZAEI@Z	; low_byte
?low_byte@@ZAEI@Z	PROC FAR	; low_byte
;|*** 
;|*** 
;|*** unsigned char low_byte(unsigned int word)
;|***   {
; Line 1971
	*** 002e13	c8 00 00 00 		enter	0,0
	*** 002e17	57 			push	di
	*** 002e18	56 			push	si
;	word = 6
;|***   return (unsigned char) (word&0xff);
; Line 1972
	*** 002e19	8a 46 06 		mov	al,BYTE PTR [bp+6]	;word
	*** 002e1c	e9 00 00 		jmp	$EX4013
;|***   }
; Line 1973
					$EX4013:
	*** 002e1f	5e 			pop	si
	*** 002e20	5f 			pop	di
	*** 002e21	c9 			leave	
	*** 002e22	cb 			ret	

?low_byte@@ZAEI@Z	ENDP
	PUBLIC	?init_screen@@ZAXXZ	; init_screen
?init_screen@@ZAXXZ	PROC FAR	; init_screen
;|***     
;|*** 
;|*** void init_screen(void)
;|*** {
; Line 1977
	*** 002e23	c8 52 00 00 		enter	82,0
	*** 002e27	57 			push	di
	*** 002e28	56 			push	si
;	s = -82
;|***   char s[81];
;|*** 
;|***    PC_DispClrScr(DISP_FGND_LIGHT_GRAY + DISP_BGND_RED);
; Line 1980
	*** 002e29	6a 47 			push	71	;0047H
	*** 002e2b	9a 00 00 00 00 		call	FAR PTR ?PC_DispClrScr@@ZAXE@Z	; PC_DispClrScr
	*** 002e30	83 c4 02 		add	sp,2
;|*** //  PC_DispClrRow(0, DISP_BGND_LIGHT_GRAY);
;|*** //  PC_DispClrRow(1, DISP_BGND_LIGHT_GRAY);
;|***   
;|***   sprintf(s, "%s", 
;|*** "                       Autonomous Model Onboard Computer                        ");
; Line 1985
	*** 002e33	1e 			push	ds
	*** 002e34	68 00 00 		push	OFFSET DGROUP:$SG4018
	*** 002e37	1e 			push	ds
	*** 002e38	68 00 00 		push	OFFSET DGROUP:$SG4019
	*** 002e3b	8d 46 ae 		lea	ax,WORD PTR [bp-82]	;s
	*** 002e3e	16 			push	ss
	*** 002e3f	50 			push	ax
	*** 002e40	9a 00 00 00 00 		call	FAR PTR _sprintf
	*** 002e45	83 c4 0c 		add	sp,12	;000cH
;|***   PC_DispStr(0,0, (unsigned char *)s, DISP_FGND_BLACK + DISP_BGND_LIGHT_GRAY);
; Line 1986
	*** 002e48	6a 70 			push	112	;0070H
	*** 002e4a	8d 46 ae 		lea	ax,WORD PTR [bp-82]	;s
	*** 002e4d	16 			push	ss
	*** 002e4e	50 			push	ax
	*** 002e4f	6a 00 			push	0
	*** 002e51	6a 00 			push	0
	*** 002e53	9a 00 00 00 00 		call	FAR PTR ?PC_DispStr@@ZAXEEPEEE@Z	; PC_DispStr
	*** 002e58	83 c4 0a 		add	sp,10	;000aH
;|*** 
;|***   sprintf(s, "%s", 
;|*** "                               NSWC-CD Code 5600                                ");
; Line 1989
	*** 002e5b	1e 			push	ds
	*** 002e5c	68 00 00 		push	OFFSET DGROUP:$SG4021
	*** 002e5f	1e 			push	ds
	*** 002e60	68 00 00 		push	OFFSET DGROUP:$SG4022
	*** 002e63	8d 46 ae 		lea	ax,WORD PTR [bp-82]	;s
	*** 002e66	16 			push	ss
	*** 002e67	50 			push	ax
	*** 002e68	9a 00 00 00 00 		call	FAR PTR _sprintf
	*** 002e6d	83 c4 0c 		add	sp,12	;000cH
;|***   PC_DispStr(0,1, (unsigned char *)s, DISP_FGND_BLACK + DISP_BGND_LIGHT_GRAY);  
; Line 1990
	*** 002e70	6a 70 			push	112	;0070H
	*** 002e72	8d 46 ae 		lea	ax,WORD PTR [bp-82]	;s
	*** 002e75	16 			push	ss
	*** 002e76	50 			push	ax
	*** 002e77	6a 01 			push	1
	*** 002e79	6a 00 			push	0
	*** 002e7b	9a 00 00 00 00 		call	FAR PTR ?PC_DispStr@@ZAXEEPEEE@Z	; PC_DispStr
	*** 002e80	83 c4 0a 		add	sp,10	;000aH
;|***     
;|***   sprintf(s, "%s",
;|*** "                             March 8, 2004 Rev 0.8                              ");
; Line 1993
	*** 002e83	1e 			push	ds
	*** 002e84	68 00 00 		push	OFFSET DGROUP:$SG4024
	*** 002e87	1e 			push	ds
	*** 002e88	68 00 00 		push	OFFSET DGROUP:$SG4025
	*** 002e8b	8d 46 ae 		lea	ax,WORD PTR [bp-82]	;s
	*** 002e8e	16 			push	ss
	*** 002e8f	50 			push	ax
	*** 002e90	9a 00 00 00 00 		call	FAR PTR _sprintf
	*** 002e95	83 c4 0c 		add	sp,12	;000cH
;|***   PC_DispStr(0,2, (unsigned char *)s, DISP_FGND_BLACK + DISP_BGND_LIGHT_GRAY);
; Line 1994
	*** 002e98	6a 70 			push	112	;0070H
	*** 002e9a	8d 46 ae 		lea	ax,WORD PTR [bp-82]	;s
	*** 002e9d	16 			push	ss
	*** 002e9e	50 			push	ax
	*** 002e9f	6a 02 			push	2
	*** 002ea1	6a 00 			push	0
	*** 002ea3	9a 00 00 00 00 		call	FAR PTR ?PC_DispStr@@ZAXEEPEEE@Z	; PC_DispStr
	*** 002ea8	83 c4 0a 		add	sp,10	;000aH
;|***   
;|*** }
; Line 1996
	*** 002eab	e9 00 00 		jmp	$EX4016
					$EX4016:
	*** 002eae	5e 			pop	si
	*** 002eaf	5f 			pop	di
	*** 002eb0	c9 			leave	
	*** 002eb1	cb 			ret	

?init_screen@@ZAXXZ	ENDP
	PUBLIC	?prep_ln200_command@@ZAXXZ	; prep_ln200_command
?prep_ln200_command@@ZAXXZ	PROC FAR	; prep_ln200_command
;|*** 
;|*** 
;|*** void prep_ln200_command(void)
;|***   {
; Line 2000
	*** 002eb2	c8 24 00 00 		enter	36,0
	*** 002eb6	57 			push	di
	*** 002eb7	56 			push	si
;	boresights_valid = -8
;	heading_valid = -10
;	bit = -12
;	mode = -14
;	latitude = -16
;	x_axis = -18
;	y_axis = -20
;	z_axis = -22
;	icmd = -36
;	i = -2
;	heading = -4
;	latitude_valid = -6
;|***   #define YES 1
;|***   //#define X_AXIS 0.0f
;|***   #define X_AXIS -0.48f
;|***   #define Y_AXIS 0.0f
;|***   #define Z_AXIS 0.0f
;|***   #define LATITUDE 38.7f
;|*** 
;|***   int i;
;|***   int heading;
;|***   unsigned latitude_valid = 0;
; Line 2010
	*** 002eb8	c7 46 fa 00 00 		mov	WORD PTR [bp-6],0	;latitude_valid
;|***   unsigned boresights_valid = 0;
; Line 2011
	*** 002ebd	c7 46 f8 00 00 		mov	WORD PTR [bp-8],0	;boresights_valid
;|***   unsigned heading_valid = 0;
; Line 2012
	*** 002ec2	c7 46 f6 00 00 		mov	WORD PTR [bp-10],0	;heading_valid
;|***   unsigned bit = 0;                               
; Line 2013
	*** 002ec7	c7 46 f4 00 00 		mov	WORD PTR [bp-12],0	;bit
;|***   unsigned mode = 0;
; Line 2014
	*** 002ecc	c7 46 f2 00 00 		mov	WORD PTR [bp-14],0	;mode
;|***   int      latitude;
;|***   int      x_axis;
;|***   int      y_axis;
;|***   int      z_axis;
;|***   
;|***   unsigned icmd[7];
;|***   
;|***   //static unsigned do_once = 1;
;|***   
;|***   //heading = (int) (-52.0 * 182.044);   // along wavemaker?
;|*** //  heading =  (int) (-53.5 * 182.044);    // along wavemaker? 5/21/08
;|*** //  heading =  (int) (26.5 * 182.044);   // Aberdeen Alignment 8/28/06 sjc
;|*** //  latitude = (int) (LATITUDE * 182.044); // operating latitude,+-degrees, see ln200 ICD 5/21/08
;|***   x_axis =   (int) (X_AXIS * 182.044);   // boresight rotations,+-degrees
; Line 2028
	*** 002ed1	c7 46 ee a9 ff 		mov	WORD PTR [bp-18],-87	;ffa9H	;x_axis
;|***   y_axis =   (int) (Y_AXIS * 182.044);
; Line 2029
	*** 002ed6	c7 46 ec 00 00 		mov	WORD PTR [bp-20],0	;y_axis
;|***   z_axis =   (int) (Z_AXIS * 182.044);
; Line 2030
	*** 002edb	c7 46 ea 00 00 		mov	WORD PTR [bp-22],0	;z_axis
;|*** 
;|***     
;|***   //mode = 0;      //LN200 modes are 0 (free inertial) and 1 (fast leveling)
;|***   //mode = 1;
;|***     
;|*** /*  latitude_valid   = YES; // 5/21/08
;|***   heading_valid    = YES;  5/21/08
;|***   boresights_valid = YES;
;|***   bit = NO;
;|*** */  
;|***   //ln200_mode = 0;
;|***   //if (commands.ln200_mode & 0x0010) commands.ln200_mode=0;               
;|*** //commented out 5/21/08
;|*** /*  if(commands.ln200_mode & 0x0010) commands.ln200_mode = commands.ln200_mode | 0x0001;               
;|***   
;|***   if(do_once)   // set heading to presets at model startup only
;|***     {
;|***     do_once = 0;
;|***     commands.ln200_mode = 0x0011;
;|***     }
;|*** */                        
;|*** /*
;|*** if (commands.mode & 0x2000) latitude_valid =1;
;|*** if (commands.mode & 0x4000) heading_valid =1;
;|*** 
;|*** if (commands.ln200_mode & 0x8000)
;|***   {latitude = (int) (command.ln200_init_latitude * 182.044);
;|***    heading = (int) (command.ln200_init_heading * 182.044);
;|***   }
;|*** 
;|*** if (send_once == 1)
;|***   {heading = (int) (+128.0 * 182.044);
;|***    latitude = (int) (LATITUDE * 182.044);
;|***    mode = 1;
;|***    latitude_valid = 1;
;|***    heading_valid = 1;
;|***   }
;|***    
;|*** if (ready == 1)
;|***   {heading = (int) (+128.0 * 182.044);
;|***    heading = (int) (commands.ln200_init_heading * 182.044);
;|***    latitude = (int) (LATITUDE *182.044);
;|***    mode = (commands.ln200_mode & 0x0007);
;|***    latitude_valid = 1;
;|***    heading_valid = 1;
;|***   } 
;|***    
;|***         
;|*** */
;|*** /*  icmd[0]=0x0000;                   // assemble the command word icmd[]
;|***   icmd[0]=icmd[0]|commands.ln200_mode & 0x0007;
;|***   icmd[0]=icmd[0]|(boresights_valid<<3);
;|***   icmd[0]=icmd[0]|(bit<<4);
;|***   icmd[0]=icmd[0]|(latitude_valid<<8);
;|***   icmd[0]=icmd[0]|((commands.ln200_mode & 0x0010) << 5);
;|*** */
;|*** 
;|*** //  icmd[1]=latitude;
;|*** //  icmd[2]=heading;
;|***   icmd[0] = commands.ln200_mode;
; Line 2090
	*** 002ee0	8e 06 00 00 		mov	es,WORD PTR $T4071
	*** 002ee4	26 a1 10 00 		mov	ax,WORD PTR es:?commands@@3UCOMMANDS@@E+16	;commands
	*** 002ee8	89 46 dc 		mov	WORD PTR [bp-36],ax	;icmd
;|***   icmd[1] = commands.ln200_init_latitude; //5/21/08
; Line 2091
	*** 002eeb	26 a1 14 00 		mov	ax,WORD PTR es:?commands@@3UCOMMANDS@@E+20	;commands
	*** 002eef	89 46 de 		mov	WORD PTR [bp-34],ax
;|***   icmd[2] = commands.ln200_init_heading;
; Line 2092
	*** 002ef2	26 a1 12 00 		mov	ax,WORD PTR es:?commands@@3UCOMMANDS@@E+18	;commands
	*** 002ef6	89 46 e0 		mov	WORD PTR [bp-32],ax
;|***   icmd[3] = x_axis;
; Line 2093
	*** 002ef9	8b 46 ee 		mov	ax,WORD PTR [bp-18]	;x_axis
	*** 002efc	89 46 e2 		mov	WORD PTR [bp-30],ax
;|***   icmd[4] = y_axis;
; Line 2094
	*** 002eff	8b 46 ec 		mov	ax,WORD PTR [bp-20]	;y_axis
	*** 002f02	89 46 e4 		mov	WORD PTR [bp-28],ax
;|***   icmd[5] = z_axis;
; Line 2095
	*** 002f05	8b 46 ea 		mov	ax,WORD PTR [bp-22]	;z_axis
	*** 002f08	89 46 e6 		mov	WORD PTR [bp-26],ax
;|***   icmd[6] = 0x0;                                // calculate icmd[] checksum
; Line 2096
	*** 002f0b	c7 46 e8 00 00 		mov	WORD PTR [bp-24],0
;|***   for (i=0;i<6;i++) icmd[6]=icmd[6]+icmd[i];  // sum icmd[0] to icmd[5]
; Line 2097
	*** 002f10	c7 46 fe 00 00 		mov	WORD PTR [bp-2],0	;i
	*** 002f15	e9 03 00 		jmp	$F4044
					$FC4045:
	*** 002f18	ff 46 fe 		inc	WORD PTR [bp-2]	;i
					$F4044:
	*** 002f1b	83 7e fe 06 		cmp	WORD PTR [bp-2],6	;i
	*** 002f1f	7c 03 			jl	$JCC12063
	*** 002f21	e9 0e 00 		jmp	$FB4046
					$JCC12063:
	*** 002f24	8b 76 fe 		mov	si,WORD PTR [bp-2]	;i
	*** 002f27	d1 e6 			shl	si,1
	*** 002f29	8b 42 dc 		mov	ax,WORD PTR [bp-36][si]
	*** 002f2c	01 46 e8 		add	WORD PTR [bp-24],ax
	*** 002f2f	e9 e6 ff 		jmp	$FC4045
					$FB4046:
;|***     
;|***   icmd[6]=~icmd[6];                           // take bit-wise 1's complement
; Line 2099
	*** 002f32	f7 56 e8 		not	WORD PTR [bp-24]
;|*** 
;|***   _fmemcpy(ln200_command, icmd, 14);
; Line 2101
	*** 002f35	6a 0e 			push	14	;000eH
	*** 002f37	8d 46 dc 		lea	ax,WORD PTR [bp-36]	;icmd
	*** 002f3a	16 			push	ss
	*** 002f3b	50 			push	ax
	*** 002f3c	1e 			push	ds
	*** 002f3d	68 00 00 		push	OFFSET DGROUP:?ln200_command@@3QEDE	;ln200_command
	*** 002f40	9a 00 00 00 00 		call	FAR PTR __fmemcpy
	*** 002f45	83 c4 0a 		add	sp,10	;000aH
;|***   } // end prep_ln200_command()
; Line 2102
	*** 002f48	e9 00 00 		jmp	$EX4028
					$EX4028:
	*** 002f4b	5e 			pop	si
	*** 002f4c	5f 			pop	di
	*** 002f4d	c9 			leave	
	*** 002f4e	cb 			ret	

?prep_ln200_command@@ZAXXZ	ENDP
	PUBLIC	?time_stamp@@ZAXPEUTIMER@@@Z	; time_stamp
?time_stamp@@ZAXPEUTIMER@@@Z	PROC FAR	; time_stamp
;|***   
;|*** 
;|*** void time_stamp(struct TIMER * t_struct)
;|***   {  // uses the pc's internal timer, resolution ~880 nsec
; Line 2106
	*** 002f4f	c8 04 00 00 		enter	4,0
	*** 002f53	57 			push	di
	*** 002f54	56 			push	si
;	lsb = -2
;	msb = -4
;	t_struct = 6
;|***   unsigned int lsb;
;|***   unsigned int msb;
;|***   
;|***    _outp(0x43, 0xd2);
; Line 2110
	*** 002f55	68 d2 00 		push	210	;00d2H
	*** 002f58	6a 43 			push	67	;0043H
	*** 002f5a	9a 00 00 00 00 		call	FAR PTR __outp
	*** 002f5f	83 c4 04 		add	sp,4
;|***    lsb = _inp(0x40);
; Line 2111
	*** 002f62	6a 40 			push	64	;0040H
	*** 002f64	9a 00 00 00 00 		call	FAR PTR __inp
	*** 002f69	83 c4 02 		add	sp,2
	*** 002f6c	89 46 fe 		mov	WORD PTR [bp-2],ax	;lsb
;|***    msb = _inp(0x40);
; Line 2112
	*** 002f6f	6a 40 			push	64	;0040H
	*** 002f71	9a 00 00 00 00 		call	FAR PTR __inp
	*** 002f76	83 c4 02 		add	sp,2
	*** 002f79	89 46 fc 		mov	WORD PTR [bp-4],ax	;msb
;|***    t_struct->low = ~((msb << 8) | lsb);
; Line 2113
	*** 002f7c	8a 66 fc 		mov	ah,BYTE PTR [bp-4]	;msb
	*** 002f7f	2a c0 			sub	al,al
	*** 002f81	0b 46 fe 		or	ax,WORD PTR [bp-2]	;lsb
	*** 002f84	f7 d0 			not	ax
	*** 002f86	c4 5e 06 		les	bx,DWORD PTR [bp+6]	;t_struct
	*** 002f89	26 89 47 04 		mov	WORD PTR es:[bx+4],ax
;|***    t_struct->high = sys_timer.high;
; Line 2114
	*** 002f8d	8e 06 00 00 		mov	es,WORD PTR $T4071
	*** 002f91	26 a1 00 00 		mov	ax,WORD PTR es:?sys_timer@@3UTIMER@@E	;sys_timer
	*** 002f95	26 8b 16 02 00 		mov	dx,WORD PTR es:?sys_timer@@3UTIMER@@E+2	;sys_timer
	*** 002f9a	c4 5e 06 		les	bx,DWORD PTR [bp+6]	;t_struct
	*** 002f9d	26 89 07 		mov	WORD PTR es:[bx],ax
	*** 002fa0	26 89 57 02 		mov	WORD PTR es:[bx+2],dx
;|***    }
; Line 2115
	*** 002fa4	e9 00 00 		jmp	$EX4048
					$EX4048:
	*** 002fa7	5e 			pop	si
	*** 002fa8	5f 			pop	di
	*** 002fa9	c9 			leave	
	*** 002faa	cb 			ret	

?time_stamp@@ZAXPEUTIMER@@@Z	ENDP
	PUBLIC	?heartbeat@@ZAXXZ	; heartbeat
?heartbeat@@ZAXXZ	PROC FAR	; heartbeat
;|*** 
;|*** 
;|*** void heartbeat(void)
;|***   {
; Line 2119
	*** 002fab	c8 00 00 00 		enter	0,0
	*** 002faf	57 			push	di
	*** 002fb0	56 			push	si
;|***   write_bit(HEARTBEAT, (!read_bit(HEARTBEAT)));
; Line 2120
	*** 002fb1	6a 11 			push	17	;0011H
	*** 002fb3	9a 00 00 00 00 		call	FAR PTR ?read_bit@@ZAHH@Z	; read_bit
	*** 002fb8	83 c4 02 		add	sp,2
	*** 002fbb	3d 01 00 		cmp	ax,1
	*** 002fbe	1b c0 			sbb	ax,ax
	*** 002fc0	f7 d8 			neg	ax
	*** 002fc2	50 			push	ax
	*** 002fc3	6a 11 			push	17	;0011H
	*** 002fc5	9a 00 00 00 00 		call	FAR PTR ?write_bit@@ZAXHH@Z	; write_bit
	*** 002fca	83 c4 04 		add	sp,4
;|***   }
; Line 2121
	*** 002fcd	e9 00 00 		jmp	$EX4052
					$EX4052:
	*** 002fd0	5e 			pop	si
	*** 002fd1	5f 			pop	di
	*** 002fd2	c9 			leave	
	*** 002fd3	cb 			ret	

?heartbeat@@ZAXXZ	ENDP

_aak	PROC FAR
;|***   
; Line 2123
	*** 002fd4	c8 00 00 00 		enter	0,0
	*** 002fd8	57 			push	di
	*** 002fd9	56 			push	si
	*** 002fda	68 00 00 		push	SEG ?escc1@@3VCescc@@E	;escc1
	*** 002fdd	68 00 00 		push	OFFSET ?escc1@@3VCescc@@E	;escc1
	*** 002fe0	9a 00 00 00 00 		call	FAR PTR ??1Cescc@@REC@XZ	; Cescc::~Cescc
	*** 002fe5	e9 00 00 		jmp	$EX4054
					$EX4054:
	*** 002fe8	5e 			pop	si
	*** 002fe9	5f 			pop	di
	*** 002fea	c9 			leave	
	*** 002feb	cb 			ret	

_aak	ENDP

_aal	PROC FAR
	*** 002fec	c8 00 00 00 		enter	0,0
	*** 002ff0	57 			push	di
	*** 002ff1	56 			push	si
	*** 002ff2	68 00 00 		push	SEG _aak
	*** 002ff5	68 00 00 		push	OFFSET _aak
	*** 002ff8	9a 00 00 00 00 		call	FAR PTR __fatexit
	*** 002ffd	83 c4 04 		add	sp,4
	*** 003000	e9 00 00 		jmp	$EX4056
					$EX4056:
	*** 003003	5e 			pop	si
	*** 003004	5f 			pop	di
	*** 003005	c9 			leave	
	*** 003006	cb 			ret	

_aal	ENDP

_aan	PROC FAR
	*** 003007	c8 00 00 00 		enter	0,0
	*** 00300b	57 			push	di
	*** 00300c	56 			push	si
	*** 00300d	9a 00 00 00 00 		call	FAR PTR _aaj
	*** 003012	9a 00 00 00 00 		call	FAR PTR _aal
	*** 003017	e9 00 00 		jmp	$EX4063
					$EX4063:
	*** 00301a	5e 			pop	si
	*** 00301b	5f 			pop	di
	*** 00301c	c9 			leave	
	*** 00301d	cb 			ret	

_aan	ENDP
	PUBLIC	?dec@@ZAAEVios@@AEV1@@Z	; dec
?dec@@ZAAEVios@@AEV1@@Z	PROC FAR	; dec COMDAT
;|*** /***
;|*** *ios.h - definitions/declarations for the ios class.
;|*** *
;|*** *   Copyright (c) 1990-1992, Microsoft Corporation.  All rights reserved.
;|*** *
;|*** *Purpose:
;|*** *   This file defines the classes, values, macros, and functions
;|*** *   used by the ios class.
;|*** *   [AT&T C++]
;|*** *
;|*** ****/
;|*** 
;|*** #ifndef _INC_IOS
;|*** #define _INC_IOS
;|*** 
;|*** 
;|*** #ifdef M_I86HM
;|*** #define _HFAR_ __far
;|*** #else 
;|*** #define _HFAR_
;|*** #endif 
;|*** 
;|*** #ifndef NULL
;|*** #define NULL    0
;|*** #endif 
;|*** 
;|*** #ifndef EOF
;|*** #define EOF (-1)
;|*** #endif 
;|*** 
;|*** // Force word packing to avoid possible -Zp override
;|*** #pragma pack(2)
;|*** 
;|*** #pragma warning(disable:4505)       // disable unwanted /W4 warning
;|*** // #pragma warning(default:4505)    // use this to reenable, if necessary
;|*** 
;|*** class streambuf;
;|*** class ostream;
;|*** 
;|*** class ios {
;|*** 
;|*** public:
;|***     enum io_state {  goodbit = 0x00,
;|***              eofbit  = 0x01,
;|***              failbit = 0x02,
;|***              badbit  = 0x04 };
;|*** 
;|***     enum open_mode { in        = 0x01,
;|***              out       = 0x02,
;|***              ate       = 0x04,
;|***              app       = 0x08,
;|***              trunc     = 0x10,
;|***              nocreate  = 0x20,
;|***              noreplace = 0x40,
;|***              binary    = 0x80 };    // CONSIDER: not in latest spec.
;|*** 
;|***     enum seek_dir { beg=0, cur=1, end=2 };
;|*** 
;|***     enum {  skipws     = 0x0001,
;|***         left       = 0x0002,
;|***         right      = 0x0004,
;|***         internal   = 0x0008,
;|***         dec        = 0x0010,
;|***         oct        = 0x0020,
;|***         hex        = 0x0040,
;|***         showbase   = 0x0080,
;|***         showpoint  = 0x0100,
;|***         uppercase  = 0x0200,
;|***         showpos    = 0x0400,
;|***         scientific = 0x0800,
;|***         fixed      = 0x1000,
;|***         unitbuf    = 0x2000,
;|***         stdio      = 0x4000
;|***                  };
;|*** 
;|***     static const long basefield;    // dec | oct | hex
;|***     static const long adjustfield;  // left | right | internal
;|***     static const long floatfield;   // scientific | fixed
;|*** 
;|***     ios(streambuf*);            // differs from ANSI
;|***     virtual ~ios();
;|*** 
;|***     inline long flags() const;
;|***     inline long flags(long _l);
;|*** 
;|***     inline long setf(long _f,long _m);
;|***     inline long setf(long _l);
;|***     inline long unsetf(long _l);
;|*** 
;|***     inline int width() const;
;|***     inline int width(int _i);
;|*** 
;|***     inline ostream* tie(ostream* _os);
;|***     inline ostream* tie() const;
;|*** 
;|***     inline char fill() const;
;|***     inline char fill(char _c);
;|*** 
;|***     inline int precision(int _i);
;|***     inline int precision() const;
;|*** 
;|***     inline int rdstate() const;
;|***     inline void clear(int _i = 0);
;|*** 
;|*** //  inline operator void*() const;
;|***     operator void *() const { if(state&(badbit|failbit) ) return 0; return (void *)this; }
;|***     inline int operator!() const;
;|*** 
;|***     inline int  good() const;
;|***     inline int  eof() const;
;|***     inline int  fail() const;
;|***     inline int  bad() const;
;|*** 
;|***     inline streambuf* rdbuf() const;
;|*** 
;|***     inline long _HFAR_ & iword(int) const;
;|***     inline void _HFAR_ * _HFAR_ & pword(int) const;
;|*** 
;|***     static long bitalloc();
;|***     static int xalloc();
;|***     static void sync_with_stdio();
;|*** 
;|*** protected:
;|***     ios();
;|***     ios(const ios&);            // treat as private
;|***     ios& operator=(const ios&);
;|***     void init(streambuf*);
;|*** 
;|***     enum { skipping, tied };
;|***     streambuf*  bp;
;|*** 
;|***     int     state;
;|***     int     ispecial;           // not used
;|***     int     ospecial;           // not used
;|***     int     isfx_special;       // not used
;|***     int     osfx_special;       // not used
;|***     int     x_delbuf;           // if set, rdbuf() deleted by ~ios
;|*** 
;|***     ostream* x_tie;
;|***     long    x_flags;
;|***     int     x_precision;
;|***     int     x_width;
;|***     char    x_fill;
;|*** 
;|***     static void (*stdioflush)();    // not used
;|*** public:
;|***     int delbuf() const { return x_delbuf; }
;|***     void    delbuf(int _i) { x_delbuf = _i; }
;|*** 
;|*** private:
;|***     static long x_maxbit;
;|***     static long _HFAR_ * x_statebuf;  // used by xalloc()
;|***     static int x_curindex;
;|*** // consider: make interal static to ios::sync_with_stdio()
;|***     static int sunk_with_stdio;     // make sure sync_with done only once
;|*** };
;|*** 
;|*** inline ios& dec(ios& _strm) { _strm.setf(ios::dec,ios::basefield); return _strm; }
; Line 158
	*** 000000	c8 00 00 00 		enter	0,0
	*** 000004	57 			push	di
	*** 000005	56 			push	si
;	_strm = 6
	*** 000006	6a 00 			push	0
	*** 000008	6a 10 			push	16	;0010H
	*** 00000a	ff 36 02 00 		push	WORD PTR ?basefield@ios@@2JF+2	;ios::basefield
	*** 00000e	ff 36 00 00 		push	WORD PTR ?basefield@ios@@2JF	;ios::basefield
	*** 000012	ff 76 08 		push	WORD PTR [bp+8]
	*** 000015	ff 76 06 		push	WORD PTR [bp+6]	;_strm
	*** 000018	9a 00 00 00 00 		call	FAR PTR ?setf@ios@@RECJJJ@Z	; ios::setf
	*** 00001d	8b 46 06 		mov	ax,WORD PTR [bp+6]	;_strm
	*** 000020	8b 56 08 		mov	dx,WORD PTR [bp+8]
	*** 000023	e9 00 00 		jmp	$EX1971
					$EX1971:
	*** 000026	5e 			pop	si
	*** 000027	5f 			pop	di
	*** 000028	c9 			leave	
	*** 000029	cb 			ret	

?dec@@ZAAEVios@@AEV1@@Z	ENDP
	PUBLIC	?hex@@ZAAEVios@@AEV1@@Z	; hex
?hex@@ZAAEVios@@AEV1@@Z	PROC FAR	; hex COMDAT
;|*** inline ios& hex(ios& _strm) { _strm.setf(ios::hex,ios::basefield); return _strm; }
; Line 159
	*** 000000	c8 00 00 00 		enter	0,0
	*** 000004	57 			push	di
	*** 000005	56 			push	si
;	_strm = 6
	*** 000006	6a 00 			push	0
	*** 000008	6a 40 			push	64	;0040H
	*** 00000a	ff 36 02 00 		push	WORD PTR ?basefield@ios@@2JF+2	;ios::basefield
	*** 00000e	ff 36 00 00 		push	WORD PTR ?basefield@ios@@2JF	;ios::basefield
	*** 000012	ff 76 08 		push	WORD PTR [bp+8]
	*** 000015	ff 76 06 		push	WORD PTR [bp+6]	;_strm
	*** 000018	9a 00 00 00 00 		call	FAR PTR ?setf@ios@@RECJJJ@Z	; ios::setf
	*** 00001d	8b 46 06 		mov	ax,WORD PTR [bp+6]	;_strm
	*** 000020	8b 56 08 		mov	dx,WORD PTR [bp+8]
	*** 000023	e9 00 00 		jmp	$EX1974
					$EX1974:
	*** 000026	5e 			pop	si
	*** 000027	5f 			pop	di
	*** 000028	c9 			leave	
	*** 000029	cb 			ret	

?hex@@ZAAEVios@@AEV1@@Z	ENDP
	PUBLIC	?setf@ios@@RECJJJ@Z	; ios::setf
?setf@ios@@RECJJJ@Z	PROC FAR	; ios::setf COMDAT
;|*** inline ios& oct(ios& _strm) { _strm.setf(ios::oct,ios::basefield); return _strm; }
;|*** 
;|*** inline long ios::flags() const { return x_flags; }
;|*** inline long ios::flags(long _l){ long _lO; _lO = x_flags; x_flags = _l; return _lO; }
;|*** 
;|*** inline long ios::setf(long _l,long _m){ long _lO; _lO = x_flags; x_flags = (_l&_m) | (x_flags&(~_m)); return _lO; }
; Line 165
	*** 000000	c8 04 00 00 		enter	4,0
	*** 000004	57 			push	di
	*** 000005	56 			push	si
;	_lO = -4
;	this = 6
;	_l = 14
;	_m = 10
	*** 000006	c4 5e 06 		les	bx,DWORD PTR [bp+6]	;this
	*** 000009	26 8b 47 18 		mov	ax,WORD PTR es:[bx+24]
	*** 00000d	26 8b 57 1a 		mov	dx,WORD PTR es:[bx+26]
	*** 000011	89 46 fc 		mov	WORD PTR [bp-4],ax	;_lO
	*** 000014	89 56 fe 		mov	WORD PTR [bp-2],dx
	*** 000017	8b 4e 0a 		mov	cx,WORD PTR [bp+10]	;_m
	*** 00001a	8b 5e 0c 		mov	bx,WORD PTR [bp+12]
	*** 00001d	f7 d1 			not	cx
	*** 00001f	f7 d3 			not	bx
	*** 000021	23 c1 			and	ax,cx
	*** 000023	23 d3 			and	dx,bx
	*** 000025	8b 4e 0a 		mov	cx,WORD PTR [bp+10]	;_m
	*** 000028	8b 5e 0c 		mov	bx,WORD PTR [bp+12]
	*** 00002b	23 4e 0e 		and	cx,WORD PTR [bp+14]	;_l
	*** 00002e	23 5e 10 		and	bx,WORD PTR [bp+16]
	*** 000031	0b c1 			or	ax,cx
	*** 000033	0b d3 			or	dx,bx
	*** 000035	c4 5e 06 		les	bx,DWORD PTR [bp+6]	;this
	*** 000038	26 89 47 18 		mov	WORD PTR es:[bx+24],ax
	*** 00003c	26 89 57 1a 		mov	WORD PTR es:[bx+26],dx
	*** 000040	8b 46 fc 		mov	ax,WORD PTR [bp-4]	;_lO
	*** 000043	8b 56 fe 		mov	dx,WORD PTR [bp-2]
	*** 000046	e9 00 00 		jmp	$EX1988
					$EX1988:
	*** 000049	5e 			pop	si
	*** 00004a	5f 			pop	di
	*** 00004b	c9 			leave	
	*** 00004c	ca 0c 00 		ret	12	;0000000cH

?setf@ios@@RECJJJ@Z	ENDP
	PUBLIC	??6ostream@@RECAEV0@P7AAEV0@AEV0@@Z@Z	; ostream::operator<<
??6ostream@@RECAEV0@P7AAEV0@AEV0@@Z@Z	PROC FAR	; ostream::operator<< COMDAT
;|*** /***
;|*** *ostream.h - definitions/declarations for the ostream class
;|*** *
;|*** *   Copyright (c) 1991-1992, Microsoft Corporation.  All rights reserved.
;|*** *
;|*** *Purpose:
;|*** *   This file defines the classes, values, macros, and functions
;|*** *   used by the ostream class.
;|*** *   [AT&T C++]
;|*** *
;|*** ****/
;|*** 
;|*** #ifndef _INC_OSTREAM
;|*** #define _INC_OSTREAM
;|*** 
;|*** #include <ios.h>
;|*** 
;|*** // Force word packing to avoid possible -Zp override
;|*** #pragma pack(2)
;|*** 
;|*** #pragma warning(disable:4505)       // disable unwanted /W4 warning
;|*** // #pragma warning(default:4505)    // use this to reenable, if necessary
;|*** 
;|*** #ifdef M_I86HM
;|*** #define _HFAR_ __far
;|*** #else 
;|*** #define _HFAR_
;|*** #endif 
;|*** 
;|*** typedef long streamoff, streampos;
;|*** 
;|*** class ostream : virtual public ios {
;|*** 
;|*** public:
;|***     ostream(streambuf*);
;|***     virtual ~ostream();
;|*** 
;|***     ostream& flush();
;|***     int  opfx();
;|***     void osfx();
;|*** 
;|*** inline  ostream& operator<<(ostream& (*f)(ostream&));
;|*** inline  ostream& operator<<(ios& (*f)(ios&));
;|***     ostream& operator<<(const char _HFAR_ *);
;|*** inline  ostream& operator<<(const unsigned char _HFAR_ *);
;|*** inline  ostream& operator<<(const signed char _HFAR_ *);
;|*** inline  ostream& operator<<(char);
;|***     ostream& operator<<(unsigned char);
;|*** inline  ostream& operator<<(signed char);
;|***     ostream& operator<<(short);
;|***     ostream& operator<<(unsigned short);
;|***     ostream& operator<<(int);
;|***     ostream& operator<<(unsigned int);
;|***     ostream& operator<<(long);
;|***     ostream& operator<<(unsigned long);
;|*** inline  ostream& operator<<(float);
;|***     ostream& operator<<(double);
;|***     ostream& operator<<(long double);
;|***     ostream& operator<<(const void _HFAR_ *);
;|***     ostream& operator<<(streambuf*);
;|*** inline  ostream& put(char);
;|***     ostream& put(unsigned char);
;|*** inline  ostream& put(signed char);
;|***     ostream& write(const char _HFAR_ *,int);
;|*** inline  ostream& write(const unsigned char _HFAR_ *,int);
;|*** inline  ostream& write(const signed char _HFAR_ *,int);
;|***     ostream& seekp(streampos);
;|***     ostream& seekp(streamoff,ios::seek_dir);
;|***     streampos tellp();
;|*** 
;|*** protected:
;|***     ostream();
;|***     ostream(const ostream&);    // treat as private
;|***     ostream& operator=(streambuf*); // treat as private
;|***     ostream& operator=(const ostream& _os) {return operator=(_os.rdbuf()); }
;|***     int do_opfx(int);       // not used
;|***     void do_osfx();         // not used
;|*** 
;|*** private:
;|***     ostream(ios&);
;|***     ostream& writepad(const char _HFAR_ *, const char _HFAR_ *);
;|***     int x_floatused;
;|*** };
;|*** 
;|*** inline ostream& ostream::operator<<(ostream& (*f)(ostream&)) { (*f)(*this); return *this; }
; Line 85
	*** 000000	c8 00 00 00 		enter	0,0
	*** 000004	57 			push	di
	*** 000005	56 			push	si
;	this = 6
;	f = 10
	*** 000006	ff 76 08 		push	WORD PTR [bp+8]
	*** 000009	ff 76 06 		push	WORD PTR [bp+6]	;this
	*** 00000c	ff 5e 0a 		call	DWORD PTR [bp+10]	;f
	*** 00000f	83 c4 04 		add	sp,4
	*** 000012	8b 46 06 		mov	ax,WORD PTR [bp+6]	;this
	*** 000015	8b 56 08 		mov	dx,WORD PTR [bp+8]
	*** 000018	e9 00 00 		jmp	$EX2645
					$EX2645:
	*** 00001b	5e 			pop	si
	*** 00001c	5f 			pop	di
	*** 00001d	c9 			leave	
	*** 00001e	ca 08 00 		ret	8

??6ostream@@RECAEV0@P7AAEV0@AEV0@@Z@Z	ENDP
	PUBLIC	??6ostream@@RECAEV0@P7AAEVios@@AEV1@@Z@Z	; ostream::operator<<
??6ostream@@RECAEV0@P7AAEVios@@AEV1@@Z@Z	PROC FAR	; ostream::operator<< COMDAT
;|*** inline ostream& ostream::operator<<(ios& (*f)(ios& )) { (*f)(*this); return *this; }
; Line 86
	*** 000000	c8 04 00 00 		enter	4,0
	*** 000004	57 			push	di
	*** 000005	56 			push	si
;	this = 6
;	f = 10
	*** 000006	8b 46 08 		mov	ax,WORD PTR [bp+8]
	*** 000009	0b 46 06 		or	ax,WORD PTR [bp+6]	;this
	*** 00000c	74 03 			je	$JCC12
	*** 00000e	e9 09 00 		jmp	$L4091
					$JCC12:
	*** 000011	b8 00 00 		mov	ax,0
	*** 000014	ba 00 00 		mov	dx,0
	*** 000017	e9 10 00 		jmp	$L4092
					$L4091:
	*** 00001a	c4 5e 06 		les	bx,DWORD PTR [bp+6]	;this
	*** 00001d	26 c4 1f 		les	bx,DWORD PTR es:[bx]
	*** 000020	26 8b 47 02 		mov	ax,WORD PTR es:[bx+2]
	*** 000024	03 46 06 		add	ax,WORD PTR [bp+6]	;this
	*** 000027	8b 56 08 		mov	dx,WORD PTR [bp+8]
					$L4092:
	*** 00002a	89 46 fc 		mov	WORD PTR [bp-4],ax
	*** 00002d	89 56 fe 		mov	WORD PTR [bp-2],dx
	*** 000030	52 			push	dx
	*** 000031	50 			push	ax
	*** 000032	ff 5e 0a 		call	DWORD PTR [bp+10]	;f
	*** 000035	83 c4 04 		add	sp,4
	*** 000038	8b 46 06 		mov	ax,WORD PTR [bp+6]	;this
	*** 00003b	8b 56 08 		mov	dx,WORD PTR [bp+8]
	*** 00003e	e9 00 00 		jmp	$EX2649
					$EX2649:
	*** 000041	5e 			pop	si
	*** 000042	5f 			pop	di
	*** 000043	c9 			leave	
	*** 000044	ca 08 00 		ret	8

??6ostream@@RECAEV0@P7AAEVios@@AEV1@@Z@Z	ENDP
	PUBLIC	??6ostream@@RECAEV0@M@Z	; ostream::operator<<
??6ostream@@RECAEV0@M@Z	PROC FAR	; ostream::operator<< COMDAT
;|*** 
;|*** inline  ostream& ostream::operator<<(char c) { return operator<<((unsigned char) c); }
;|*** inline  ostream& ostream::operator<<(signed char c) { return operator<<((unsigned char) c); }
;|*** 
;|*** inline  ostream& ostream::operator<<(const unsigned char _HFAR_ * s) { return operator<<((const char _HFAR_ *) s); }
;|*** inline  ostream& ostream::operator<<(const signed char _HFAR_ * s) { return operator<<((const char _HFAR_ *) s); }
;|*** 
;|*** inline  ostream& ostream::operator<<(float f) { x_floatused = 1; return operator<<((double) f); }
; Line 94
	*** 000000	c8 00 00 00 		enter	0,0
	*** 000004	57 			push	di
	*** 000005	56 			push	si
;	this = 6
;	f = 10
	*** 000006	c4 5e 06 		les	bx,DWORD PTR [bp+6]	;this
	*** 000009	26 c7 47 04 01 00 	mov	WORD PTR es:[bx+4],1
	*** 00000f	8d 5e 0a 		lea	bx,WORD PTR [bp+10]	;f
	*** 000012	9a 00 00 00 00 		call	FAR PTR __aFflds
	*** 000017	9a 00 00 00 00 		call	FAR PTR __aFdcvt
	*** 00001c	83 ec 08 		sub	sp,8
	*** 00001f	8b dc 			mov	bx,sp
	*** 000021	9a 00 00 00 00 		call	FAR PTR __aFfstdp
	*** 000026	ff 76 08 		push	WORD PTR [bp+8]
	*** 000029	ff 76 06 		push	WORD PTR [bp+6]	;this
	*** 00002c	9a 00 00 00 00 		call	FAR PTR ??6ostream@@RECAEV0@N@Z	; ostream::operator<<
	*** 000031	e9 00 00 		jmp	$EX2668
					$EX2668:
	*** 000034	5e 			pop	si
	*** 000035	5f 			pop	di
	*** 000036	c9 			leave	
	*** 000037	ca 08 00 		ret	8

??6ostream@@RECAEV0@M@Z	ENDP
	PUBLIC	?endl@@ZAAEVostream@@AEV1@@Z	; endl
?endl@@ZAAEVostream@@AEV1@@Z	PROC FAR	; endl COMDAT
;|*** 
;|*** inline  ostream& ostream::put(char c) { return put((unsigned char) c); }
;|*** inline  ostream& ostream::put(signed char c) { return put((unsigned char) c); }
;|*** 
;|*** inline  ostream& ostream::write(const unsigned char _HFAR_ * s, int n) { return write((char _HFAR_ *) s, n); }
;|*** inline  ostream& ostream::write(const signed char _HFAR_ * s, int n) { return write((char _HFAR_ *) s, n); }
;|*** 
;|*** 
;|*** class ostream_withassign : public ostream {
;|***     public:
;|***         ostream_withassign();
;|***         ostream_withassign(streambuf* _is);
;|***         ~ostream_withassign();
;|***     ostream& operator=(const ostream& _os) { return ostream::operator=(_os.rdbuf()); }
;|***     ostream& operator=(streambuf* _sb) { return ostream::operator=(_sb); }
;|*** };
;|*** 
;|*** #ifndef _WINDLL
;|*** extern ostream_withassign cout;
;|*** extern ostream_withassign cerr;
;|*** extern ostream_withassign clog;
;|*** #endif 
;|*** 
;|*** inline ostream& flush(ostream& _outs) { return _outs.flush(); }
;|*** inline ostream& endl(ostream& _outs) { return _outs << '\n' << flush; }
; Line 119
	*** 000000	c8 00 00 00 		enter	0,0
	*** 000004	57 			push	di
	*** 000005	56 			push	si
;	_outs = 6
	*** 000006	68 00 00 		push	SEG ?flush@@ZAAEVostream@@AEV1@@Z	;flush
	*** 000009	68 00 00 		push	OFFSET ?flush@@ZAAEVostream@@AEV1@@Z	;flush
	*** 00000c	6a 0a 			push	10	;000aH
	*** 00000e	ff 76 08 		push	WORD PTR [bp+8]
	*** 000011	ff 76 06 		push	WORD PTR [bp+6]	;_outs
	*** 000014	9a 00 00 00 00 		call	FAR PTR ??6ostream@@RECAEV0@D@Z	; ostream::operator<<
	*** 000019	52 			push	dx
	*** 00001a	50 			push	ax
	*** 00001b	9a 00 00 00 00 		call	FAR PTR ??6ostream@@RECAEV0@P7AAEV0@AEV0@@Z@Z	; ostream::operator<<
	*** 000020	e9 00 00 		jmp	$EX2729
					$EX2729:
	*** 000023	5e 			pop	si
	*** 000024	5f 			pop	di
	*** 000025	c9 			leave	
	*** 000026	cb 			ret	

?endl@@ZAAEVostream@@AEV1@@Z	ENDP
	PUBLIC	??6ostream@@RECAEV0@D@Z	; ostream::operator<<
??6ostream@@RECAEV0@D@Z	PROC FAR	; ostream::operator<< COMDAT
;|*** inline  ostream& ostream::operator<<(char c) { return operator<<((unsigned char) c); }
; Line 88
	*** 000000	c8 00 00 00 		enter	0,0
	*** 000004	57 			push	di
	*** 000005	56 			push	si
;	this = 6
;	c = 10
	*** 000006	8a 46 0a 		mov	al,BYTE PTR [bp+10]	;c
	*** 000009	50 			push	ax
	*** 00000a	ff 76 08 		push	WORD PTR [bp+8]
	*** 00000d	ff 76 06 		push	WORD PTR [bp+6]	;this
	*** 000010	9a 00 00 00 00 		call	FAR PTR ??6ostream@@RECAEV0@E@Z	; ostream::operator<<
	*** 000015	e9 00 00 		jmp	$EX2652
					$EX2652:
	*** 000018	5e 			pop	si
	*** 000019	5f 			pop	di
	*** 00001a	c9 			leave	
	*** 00001b	ca 06 00 		ret	6

??6ostream@@RECAEV0@D@Z	ENDP
	PUBLIC	?flush@@ZAAEVostream@@AEV1@@Z	; flush
?flush@@ZAAEVostream@@AEV1@@Z	PROC FAR	; flush COMDAT
;|*** inline  ostream& ostream::operator<<(signed char c) { return operator<<((unsigned char) c); }
;|*** 
;|*** inline  ostream& ostream::operator<<(const unsigned char _HFAR_ * s) { return operator<<((const char _HFAR_ *) s); }
;|*** inline  ostream& ostream::operator<<(const signed char _HFAR_ * s) { return operator<<((const char _HFAR_ *) s); }
;|*** 
;|*** inline  ostream& ostream::operator<<(float f) { x_floatused = 1; return operator<<((double) f); }
;|*** 
;|*** inline  ostream& ostream::put(char c) { return put((unsigned char) c); }
;|*** inline  ostream& ostream::put(signed char c) { return put((unsigned char) c); }
;|*** 
;|*** inline  ostream& ostream::write(const unsigned char _HFAR_ * s, int n) { return write((char _HFAR_ *) s, n); }
;|*** inline  ostream& ostream::write(const signed char _HFAR_ * s, int n) { return write((char _HFAR_ *) s, n); }
;|*** 
;|*** 
;|*** class ostream_withassign : public ostream {
;|***     public:
;|***         ostream_withassign();
;|***         ostream_withassign(streambuf* _is);
;|***         ~ostream_withassign();
;|***     ostream& operator=(const ostream& _os) { return ostream::operator=(_os.rdbuf()); }
;|***     ostream& operator=(streambuf* _sb) { return ostream::operator=(_sb); }
;|*** };
;|*** 
;|*** #ifndef _WINDLL
;|*** extern ostream_withassign cout;
;|*** extern ostream_withassign cerr;
;|*** extern ostream_withassign clog;
;|*** #endif 
;|*** 
;|*** inline ostream& flush(ostream& _outs) { return _outs.flush(); }
; Line 118
	*** 000000	c8 00 00 00 		enter	0,0
	*** 000004	57 			push	di
	*** 000005	56 			push	si
;	_outs = 6
	*** 000006	ff 76 08 		push	WORD PTR [bp+8]
	*** 000009	ff 76 06 		push	WORD PTR [bp+6]	;_outs
	*** 00000c	9a 00 00 00 00 		call	FAR PTR ?flush@ostream@@RECAEV1@XZ	; ostream::flush
	*** 000011	e9 00 00 		jmp	$EX2726
					$EX2726:
	*** 000014	5e 			pop	si
	*** 000015	5f 			pop	di
	*** 000016	c9 			leave	
	*** 000017	cb 			ret	

?flush@@ZAAEVostream@@AEV1@@Z	ENDP
DMMTEST_TEXT	ENDS
END
