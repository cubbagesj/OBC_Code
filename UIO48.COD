;	Static Name Aliases
;
	TITLE   c:\cba\uio48.cpp
	.286p
INCLUDELIB      LLIBCE
INCLUDELIB	OLDNAMES.LIB
UIO48_TEXT	SEGMENT  WORD PUBLIC 'CODE'
UIO48_TEXT	ENDS
_DATA	SEGMENT  WORD PUBLIC 'DATA'
_DATA	ENDS
CONST	SEGMENT  WORD PUBLIC 'CONST'
CONST	ENDS
_BSS	SEGMENT  WORD PUBLIC 'BSS'
_BSS	ENDS
DGROUP	GROUP	CONST, _BSS, _DATA
	ASSUME DS: DGROUP, SS: DGROUP
_BSS      SEGMENT
PUBLIC  ?base_port@@3IE
?base_port@@3IE	DW 01H DUP (?)
PUBLIC  ?port_images@@3QIII
?port_images@@3QIII	DW 06H DUP (?)
_BSS      ENDS
UIO48_TEXT      SEGMENT
	ASSUME	CS: UIO48_TEXT
	PUBLIC	?init_io@@ZAXI@Z	; init_io
?init_io@@ZAXI@Z	PROC FAR	; init_io
;|*** /* UIO48.C 
;|*** 
;|***   Copyright 1996 by WinSystems Inc.
;|*** 
;|***   Permission is hereby granted to the purchaser of the WinSystems
;|***   UIO cards and CPU products incorporating the UIO device, to distribute
;|***   any binary file or files compiled using this source code directly or
;|***   in any work derived by the user from this file. In no case may the
;|***   source code, original or derived from this file, be distributed to any
;|***   third party except by explicit permission of WinSystems. This file is
;|***   distributed on an "As-is" basis and no warranty as to performance,
;|***   fitness of purposes, or any other warranty is expressed or implied.
;|***   In no case shall WinSystems be liable for any direct or indirect loss
;|***   or damage, real or consequential resulting from the usage of this
;|***   source code. It is the user's sole responsibility to determine
;|***   fitness for any considered purpose.
;|*** */
;|*** /**************************************************************************
;|*** * Name  : uio48.c
;|*** *
;|*** * Project : PCM-UIO48 Software Samples/Examples
;|*** *
;|*** * Date  : October 30, 1996
;|*** *
;|*** * Revision: 1.00
;|*** *
;|*** * Author  : Steve Mottin
;|*** *
;|*** ****************************************************************************
;|*** *
;|*** * Changes :
;|*** *
;|*** * Date    Revision  Description
;|*** * ________  ________  ______________________________________________
;|*** * 10/30/96  1.00    Created
;|*** *
;|*** *****************************************************************************
;|*** */
;|*** 
;|*** #include <dos.h>
;|*** #include <conio.h>
;|*** #include "uio48.h"
;|*** 
;|*** #define outportb _outp
;|*** #define inportb  _inp
;|*** 
;|*** /* This global holds the base address of the UIO chip */
;|*** 
;|*** unsigned base_port;
;|*** 
;|*** /* This global array holds the image values of the last write to each I/O
;|***    ports. This allows bit manipulation routines to work without having to
;|***    actually do a read-modify-write to the I/O port.
;|*** */
;|*** 
;|*** unsigned port_images[6];
;|*** 
;|*** /*===========================================================================
;|*** *                              INIT_IO
;|*** *
;|*** *  This function take a single argument :
;|*** *
;|*** *
;|*** *  io_address  :    This is the base I/O address of the 16C48 UIO Chip
;|*** *         on the board.
;|*** *
;|*** *
;|*** *  This function initializes all I/O pins for input, disables all interrupt
;|*** *  sensing, and sets the image values.
;|*** *
;|*** *===========================================================================*/
;|*** 
;|*** void init_io(unsigned io_address)
;|*** {
; Line 74
	*** 000000	55 			push	bp
	*** 000001	8b ec 			mov	bp,sp
	*** 000003	57 			push	di
;	io_address = 6
;	register bx = x
;|*** int x;
;|*** 
;|***   /* Save the specified address for later use */
;|*** 
;|***   base_port = io_address;
; Line 79
	*** 000004	8b 46 06 		mov	ax,WORD PTR [bp+6]	;io_address
	*** 000007	a3 00 00 		mov	WORD PTR ?base_port@@3IE,ax	;base_port
;|*** 
;|***   /* Clear all of the I/O ports. This also makes them inputs */
;|*** 
;|***   for(x=0; x < 7; x++)
; Line 83
	*** 00000a	33 db 			xor	bx,bx
					$F724:
;|***     outportb(base_port+x, 0);
; Line 84
	*** 00000c	33 c0 			xor	ax,ax
	*** 00000e	8b 16 00 00 		mov	dx,WORD PTR ?base_port@@3IE	;base_port
	*** 000012	03 d3 			add	dx,bx
	*** 000014	ee 			out	dx, al

	*** 000015	43 			inc	bx
	*** 000016	83 fb 07 		cmp	bx,7
	*** 000019	7c f1 			jl	$F724
	*** 00001b	b9 06 00 		mov	cx,6
	*** 00001e	bf 00 00 		mov	di,OFFSET DGROUP:?port_images@@3QIII	;port_images
	*** 000021	1e 			push	ds
	*** 000022	07 			pop	es
	*** 000023	f3 			rep
	*** 000024	ab 			stosw
;|*** 
;|***   /* Clear our image values as well */
;|*** 
;|***   for(x=0; x < 6; x++)
;|***     port_images[x] = 0;
;|*** 
;|***   /* Set page 2 access, for interrupt enables */
;|*** 
;|***   outportb(base_port+7,0x80);
; Line 93
	*** 000025	b8 80 00 		mov	ax,128	;0080H
	*** 000028	8b 16 00 00 		mov	dx,WORD PTR ?base_port@@3IE	;base_port
	*** 00002c	83 c2 07 		add	dx,7
	*** 00002f	ee 			out	dx, al

;|*** 
;|***   /* Clear all interrupt enables */
;|***   
;|***   outportb(base_port+8,0);
; Line 97
	*** 000030	33 c0 			xor	ax,ax
	*** 000032	8b ca 			mov	cx,dx
	*** 000034	8b 16 00 00 		mov	dx,WORD PTR ?base_port@@3IE	;base_port
	*** 000038	83 c2 08 		add	dx,8
	*** 00003b	ee 			out	dx, al

;|***   outportb(base_port+9,0);
; Line 98
	*** 00003c	8b 16 00 00 		mov	dx,WORD PTR ?base_port@@3IE	;base_port
	*** 000040	83 c2 09 		add	dx,9
	*** 000043	ee 			out	dx, al

;|***   outportb(base_port+0x0a,0);
; Line 99
	*** 000044	8b 16 00 00 		mov	dx,WORD PTR ?base_port@@3IE	;base_port
	*** 000048	83 c2 0a 		add	dx,10	;000aH
	*** 00004b	ee 			out	dx, al

;|*** 
;|***   /* Restore normal page 0 register access */
;|***   outportb(base_port+7,0);
; Line 102
	*** 00004c	8b d1 			mov	dx,cx
	*** 00004e	ee 			out	dx, al

;|*** 
;|*** }
; Line 104
	*** 00004f	5f 			pop	di
	*** 000050	c9 			leave	
	*** 000051	cb 			ret	

?init_io@@ZAXI@Z	ENDP
	PUBLIC	?read_bit@@ZAHH@Z	; read_bit
?read_bit@@ZAHH@Z	PROC FAR	; read_bit
;|*** 
;|*** /*===========================================================================
;|*** *
;|*** *                                READ_BIT
;|*** *
;|*** *
;|*** *  This function takes a single argument :
;|*** *
;|*** *
;|*** *  bit_number    :  The integer argument specifies the bit number to read.
;|*** *                   Valid arguments are from 1 to 48.
;|*** *
;|*** *  return value : The current state of the specified bit, 1 or 0.
;|*** *
;|*** *  This function returns the state of the current I/O pin specified by
;|*** *  the argument bit_number.
;|*** *
;|*** *===========================================================================*/
;|*** 
;|*** int read_bit(int bit_number)
;|*** {
; Line 125
	*** 000052	55 			push	bp
	*** 000053	8b ec 			mov	bp,sp
	*** 000055	57 			push	di
;	bit_number = 6
;	port = -2
;	register di = val
	*** 000056	8b 5e 06 		mov	bx,WORD PTR [bp+6]	;bit_number
;|*** unsigned port;
;|*** int val;
;|*** 
;|***   /* Adjust the bit_number to 0 to 47 numbering */
;|*** 
;|***   --bit_number;
; Line 131
	*** 000059	4b 			dec	bx
;|*** 
;|***   /* Calculate the I/O port address based on the updated bit_number */
;|*** 
;|***   port = (bit_number / 8) + base_port;
;|*** 
;|***   /* Get the current contents of the port */
;|*** 
;|***   val = inportb(port);
; Line 139
	*** 00005a	8b c3 			mov	ax,bx
	*** 00005c	99 			cwd	
	*** 00005d	83 e2 07 		and	dx,7
	*** 000060	03 c2 			add	ax,dx
	*** 000062	c1 f8 03 		sar	ax,3
	*** 000065	8b d0 			mov	dx,ax
	*** 000067	03 16 00 00 		add	dx,WORD PTR ?base_port@@3IE	;base_port
	*** 00006b	ec 			in	al,dx
	*** 00006c	2a e4 			sub	ah,ah
	*** 00006e	8b f8 			mov	di,ax
;|*** 
;|***   /* Get just the bit we specified */
;|*** 
;|***   val = val & (1 << (bit_number % 8));
;|***   
;|***   /* Adjust the return for a 0 or 1 value */
;|*** 
;|***   if(val)
; Line 147
	*** 000070	8b c3 			mov	ax,bx
	*** 000072	b9 08 00 		mov	cx,8
	*** 000075	99 			cwd	
	*** 000076	f7 f9 			idiv	cx
	*** 000078	8b ca 			mov	cx,dx
	*** 00007a	b8 01 00 		mov	ax,1
	*** 00007d	d3 e0 			shl	ax,cl
	*** 00007f	23 c7 			and	ax,di
	*** 000081	3d 01 00 		cmp	ax,1
	*** 000084	1b c0 			sbb	ax,ax
	*** 000086	40 			inc	ax
;|***     return 1;
;|*** 
;|***   return 0;
;|*** }
; Line 151
	*** 000087	5f 			pop	di
	*** 000088	c9 			leave	
	*** 000089	cb 			ret	

?read_bit@@ZAHH@Z	ENDP
	PUBLIC	?write_bit@@ZAXHH@Z	; write_bit
?write_bit@@ZAXHH@Z	PROC FAR	; write_bit
;|*** 
;|*** /*===========================================================================
;|*** *
;|*** *                                WRITE_BIT
;|*** *
;|*** * This function takes two arguments :
;|*** *
;|*** *
;|*** *  bit_number :  The I/O pin to access is specified by bit_number 1 to 48.
;|*** *
;|*** *  val  :   The setting for the specified bit, either 1 or 0.
;|*** *
;|*** *  This function sets the specified I/O pin to either high or low as dictated
;|*** *  by the val argument. A non zero value for val sets the bit.
;|*** *
;|*** *===========================================================================*/
;|***  
;|*** void write_bit(int bit_number, int val)
;|*** {
; Line 170
	*** 00008a	c8 06 00 00 		enter	6,0
;	bit_number = 6
;	val = 8
;	port = -4
;	temp = -2
;	register bx = mask
;|*** unsigned port;
;|*** unsigned temp;
;|*** unsigned mask;
;|***  
;|*** 
;|***   /* Adjust bit_number for 0 based numbering */
;|*** 
;|***   --bit_number;
;|*** 
;|***   /* Calculate the I/O address of the port based on the bit number */
;|*** 
;|***   port = (bit_number / 8) + base_port;
; Line 182
	*** 00008e	ff 4e 06 		dec	WORD PTR [bp+6]	;bit_number
	*** 000091	8b 46 06 		mov	ax,WORD PTR [bp+6]	;bit_number
	*** 000094	99 			cwd	
	*** 000095	83 e2 07 		and	dx,7
	*** 000098	03 c2 			add	ax,dx
	*** 00009a	c1 f8 03 		sar	ax,3
	*** 00009d	8b c8 			mov	cx,ax
	*** 00009f	03 06 00 00 		add	ax,WORD PTR ?base_port@@3IE	;base_port
	*** 0000a3	89 46 fc 		mov	WORD PTR [bp-4],ax	;port
;|*** 
;|***   /* Use the image value to avoid having to read the port first. */
;|*** 
;|***   temp = port_images[bit_number / 8]; /* Get current value */
; Line 186
	*** 0000a6	8b d9 			mov	bx,cx
	*** 0000a8	03 d9 			add	bx,cx
	*** 0000aa	81 c3 00 00 		add	bx,OFFSET DGROUP:?port_images@@3QIII	;port_images
	*** 0000ae	89 5e fa 		mov	WORD PTR [bp-6],bx
	*** 0000b1	8b 07 			mov	ax,WORD PTR [bx]
	*** 0000b3	89 46 fe 		mov	WORD PTR [bp-2],ax	;temp
;|*** 
;|***   /* Calculate a bit mask for the specified bit */
;|*** 
;|***   mask = (1 << (bit_number % 8));
; Line 190
	*** 0000b6	bb 01 00 		mov	bx,1
	*** 0000b9	8b 46 06 		mov	ax,WORD PTR [bp+6]	;bit_number
	*** 0000bc	b9 08 00 		mov	cx,8
	*** 0000bf	99 			cwd	
	*** 0000c0	f7 f9 			idiv	cx
	*** 0000c2	8b ca 			mov	cx,dx
	*** 0000c4	d3 e3 			shl	bx,cl
;|*** 
;|***   /* Check whether the request was to set or clear and mask accordingly */
;|*** 
;|***   if(val)   /* If the bit is to be set */
; Line 194
	*** 0000c6	83 7e 08 00 		cmp	WORD PTR [bp+8],0	;val
	*** 0000ca	74 06 			je	$I741
;|***     temp = temp | mask;
; Line 195
	*** 0000cc	09 5e fe 		or	WORD PTR [bp-2],bx	;temp
;|***   else
; Line 196
	*** 0000cf	eb 06 			jmp	SHORT $I742
	*** 0000d1	90 			nop	
					$I741:
;|***     temp = temp & ~mask;
; Line 197
	*** 0000d2	f7 d3 			not	bx
	*** 0000d4	21 5e fe 		and	WORD PTR [bp-2],bx	;temp
					$I742:
;|***   
;|***   /* Update the image value with the value we're about to write */
;|*** 
;|***   port_images[bit_number / 8] = temp;
; Line 201
	*** 0000d7	8b 5e fa 		mov	bx,WORD PTR [bp-6]
	*** 0000da	8b 46 fe 		mov	ax,WORD PTR [bp-2]	;temp
	*** 0000dd	89 07 			mov	WORD PTR [bx],ax
;|*** 
;|***   /* Now actually update the port. Only the specified bit is affected */
;|*** 
;|***   outportb(port,temp);
; Line 205
	*** 0000df	8b 56 fc 		mov	dx,WORD PTR [bp-4]	;port
	*** 0000e2	ee 			out	dx, al

;|*** }
; Line 206
	*** 0000e3	c9 			leave	
	*** 0000e4	cb 			ret	
	*** 0000e5	90 			nop	

?write_bit@@ZAXHH@Z	ENDP
	PUBLIC	?set_bit@@ZAXH@Z	; set_bit
?set_bit@@ZAXH@Z	PROC FAR	; set_bit
;|*** 
;|*** /*===========================================================================
;|*** *                                  SET_BIT
;|*** *
;|*** *
;|*** *  This function takes a single argument :
;|*** *
;|*** *  bit_number :  The bit number to set.
;|*** *
;|*** *  This function sets the specified bit.
;|*** *
;|*** *===========================================================================*/     
;|*** 
;|*** void set_bit(int bit_number)
;|*** {
; Line 221
	*** 0000e6	55 			push	bp
	*** 0000e7	8b ec 			mov	bp,sp
;	bit_number = 6
;|*** 
;|***   write_bit(bit_number,1);
; Line 223
	*** 0000e9	6a 01 			push	1
	*** 0000eb	ff 76 06 		push	WORD PTR [bp+6]	;bit_number
	*** 0000ee	0e 			push	cs
	*** 0000ef	e8 00 00 		call	NEAR PTR ?write_bit@@ZAXHH@Z	; write_bit
;|*** }
; Line 224
	*** 0000f2	c9 			leave	
	*** 0000f3	cb 			ret	

?set_bit@@ZAXH@Z	ENDP
	PUBLIC	?clr_bit@@ZAXH@Z	; clr_bit
?clr_bit@@ZAXH@Z	PROC FAR	; clr_bit
;|*** 
;|*** /*===========================================================================
;|*** *                                  CLR_BIT
;|*** *
;|*** *
;|*** *  This function takes a single argument :
;|*** *
;|*** *  bit_number :  The bit number to clear.
;|*** *
;|*** *  This function clears the specified bit.
;|*** *
;|*** *===========================================================================*/     
;|*** 
;|*** void clr_bit(int bit_number)
;|*** {
; Line 239
	*** 0000f4	55 			push	bp
	*** 0000f5	8b ec 			mov	bp,sp
;	bit_number = 6
;|***   write_bit(bit_number,0);
; Line 240
	*** 0000f7	6a 00 			push	0
	*** 0000f9	ff 76 06 		push	WORD PTR [bp+6]	;bit_number
	*** 0000fc	0e 			push	cs
	*** 0000fd	e8 00 00 		call	NEAR PTR ?write_bit@@ZAXHH@Z	; write_bit
;|*** }
; Line 241
	*** 000100	c9 			leave	
	*** 000101	cb 			ret	

?clr_bit@@ZAXH@Z	ENDP
	PUBLIC	?enab_int@@ZAXHH@Z	; enab_int
?enab_int@@ZAXHH@Z	PROC FAR	; enab_int
;|*** 
;|*** /*===========================================================================
;|*** *
;|*** *                               ENAB_INT
;|*** *
;|*** *  This function takes two arguments :
;|*** *
;|*** *  bit_number  : The bit number to enable intterups for. Range from 1 to 48.
;|*** *
;|*** *  polarity   : This specifies the polarity of the interrupt. A non-zero
;|*** *               argument enables rising-edge interrupt. A zero argument
;|*** *               enables the interrupt on the flling edge.
;|*** *
;|*** *  This function enables within the 16C48 an interrupt for the specified bit
;|*** *  at the specified polarity. This function does not setup the interrupt 
;|*** *  controller, nor does it supply an interrupr handler.
;|*** *
;|*** *============================================================================*/
;|*** 
;|*** void enab_int(int bit_number, int polarity)
;|*** {
; Line 262
	*** 000102	c8 04 00 00 		enter	4,0
	*** 000106	57 			push	di
;	bit_number = 6
;	polarity = 8
;	port = -4
;	temp = -2
;	register bx = mask
	*** 000107	8b 7e 06 		mov	di,WORD PTR [bp+6]	;bit_number
;|*** unsigned port;
;|*** unsigned temp;
;|*** unsigned mask;
;|*** 
;|***   /* Adjust for 0 based numbering */ 
;|***   
;|***   --bit_number;
;|*** 
;|***   /* Calculate the I/O address based uppon the bit number */
;|*** 
;|***   port = (bit_number / 8) + base_port + 8;
; Line 273
	*** 00010a	8d 45 ff 		lea	ax,WORD PTR [di-1]
	*** 00010d	8b c8 			mov	cx,ax
	*** 00010f	99 			cwd	
	*** 000110	83 e2 07 		and	dx,7
	*** 000113	03 c2 			add	ax,dx
	*** 000115	c1 f8 03 		sar	ax,3
	*** 000118	03 06 00 00 		add	ax,WORD PTR ?base_port@@3IE	;base_port
	*** 00011c	05 08 00 		add	ax,8
	*** 00011f	89 46 fc 		mov	WORD PTR [bp-4],ax	;port
;|*** 
;|***   /* Calculate a bit mask based on the specified bit number */
;|*** 
;|***   mask = (1 << (bit_number % 8));
; Line 277
	*** 000122	bb 01 00 		mov	bx,1
	*** 000125	8b c1 			mov	ax,cx
	*** 000127	b9 08 00 		mov	cx,8
	*** 00012a	99 			cwd	
	*** 00012b	f7 f9 			idiv	cx
	*** 00012d	8b ca 			mov	cx,dx
	*** 00012f	d3 e3 			shl	bx,cl
;|*** 
;|***   /* Turn on page 2 access */
;|*** 
;|***   outportb(base_port+7,0x80);
; Line 281
	*** 000131	b8 80 00 		mov	ax,128	;0080H
	*** 000134	8b 16 00 00 		mov	dx,WORD PTR ?base_port@@3IE	;base_port
	*** 000138	83 c2 07 		add	dx,7
	*** 00013b	ee 			out	dx, al

;|*** 
;|***   /* Get the current state of the interrupt enable register */
;|*** 
;|***   temp = inportb(port);
; Line 285
	*** 00013c	8b c2 			mov	ax,dx
	*** 00013e	8b 56 fc 		mov	dx,WORD PTR [bp-4]	;port
	*** 000141	8b c8 			mov	cx,ax
	*** 000143	ec 			in	al,dx
	*** 000144	2a e4 			sub	ah,ah
	*** 000146	89 46 fe 		mov	WORD PTR [bp-2],ax	;temp
;|*** 
;|***   /* Set the enable bit for our bit number */
;|*** 
;|***   temp = temp | mask;
; Line 289
	*** 000149	09 5e fe 		or	WORD PTR [bp-2],bx	;temp
;|*** 
;|***   /* Now update the interrupt enable register */
;|*** 
;|***   outportb(port,temp);
; Line 293
	*** 00014c	8b 46 fe 		mov	ax,WORD PTR [bp-2]	;temp
	*** 00014f	ee 			out	dx, al

;|*** 
;|***   /* Turn on access to page 1 for polarity control */
;|*** 
;|***   outportb(base_port+7,0x40);
; Line 297
	*** 000150	b8 40 00 		mov	ax,64	;0040H
	*** 000153	8b d1 			mov	dx,cx
	*** 000155	ee 			out	dx, al

;|*** 
;|***   /* Get the current state of the polarity register */
;|*** 
;|***   temp = inportb(port);   /* Get current polarity settings */
; Line 301
	*** 000156	8b 56 fc 		mov	dx,WORD PTR [bp-4]	;port
	*** 000159	ec 			in	al,dx
	*** 00015a	89 46 fe 		mov	WORD PTR [bp-2],ax	;temp
;|*** 
;|***   /* Set the polarity according to the argument in the image value */
;|*** 
;|***   if(polarity)    /* If the bit is to be set */
; Line 305
	*** 00015d	83 7e 08 00 		cmp	WORD PTR [bp+8],0	;polarity
	*** 000161	74 05 			je	$I753
;|***     temp = temp | mask;
; Line 306
	*** 000163	09 5e fe 		or	WORD PTR [bp-2],bx	;temp
;|***   else
; Line 307
	*** 000166	eb 05 			jmp	SHORT $I754
					$I753:
;|***     temp = temp & ~mask;
; Line 308
	*** 000168	f7 d3 			not	bx
	*** 00016a	21 5e fe 		and	WORD PTR [bp-2],bx	;temp
					$I754:
;|***   
;|***   /* Write out the new polarity value */
;|*** 
;|***   outportb(port,temp);
; Line 312
	*** 00016d	8b 46 fe 		mov	ax,WORD PTR [bp-2]	;temp
	*** 000170	ee 			out	dx, al

;|*** 
;|***   /* Set access back to Page 0 */
;|*** 
;|***   outportb(base_port+7,0x0);
; Line 316
	*** 000171	33 c0 			xor	ax,ax
	*** 000173	8b 16 00 00 		mov	dx,WORD PTR ?base_port@@3IE	;base_port
	*** 000177	83 c2 07 		add	dx,7
	*** 00017a	ee 			out	dx, al

;|*** 
;|*** }
; Line 318
	*** 00017b	5f 			pop	di
	*** 00017c	c9 			leave	
	*** 00017d	cb 			ret	

?enab_int@@ZAXHH@Z	ENDP
	PUBLIC	?disab_int@@ZAXH@Z	; disab_int
?disab_int@@ZAXH@Z	PROC FAR	; disab_int
;|*** 
;|*** /*===========================================================================
;|*** *
;|*** *                               DISAB_INT
;|*** *
;|*** * This function takes a single argument :
;|*** *
;|*** * bit_number : Specifies the bit number to act upon. Range is from 1 to 48.
;|*** *
;|*** * This function shuts off the interrupt enabled for the specified bit.
;|*** *
;|*** *===========================================================================*/
;|***       
;|*** void disab_int(int bit_number)
;|*** {
; Line 333
	*** 00017e	55 			push	bp
	*** 00017f	8b ec 			mov	bp,sp
	*** 000181	57 			push	di
	*** 000182	56 			push	si
;	bit_number = 6
;	port = -2
;	register bx = temp
;	mask = -6
	*** 000183	8b 7e 06 		mov	di,WORD PTR [bp+6]	;bit_number
;|*** unsigned port;
;|*** unsigned temp;
;|*** unsigned mask;
;|*** 
;|***   /* Adjust the bit_number for 0 based numbering */
;|***  
;|***   --bit_number;
; Line 340
	*** 000186	4f 			dec	di
;|*** 
;|***   /* Calculate the I/O Address for the enable port */
;|*** 
;|***   port = (bit_number / 8) + base_port + 8;
;|*** 
;|***   /* Calculate the proper bit mask for this bit number */
;|*** 
;|***   mask = (1 << (bit_number % 8));
;|*** 
;|***   /* Turn on access to page 2 registers */
;|*** 
;|***   outportb(base_port+7,0x80);
; Line 352
	*** 000187	b8 80 00 		mov	ax,128	;0080H
	*** 00018a	8b 16 00 00 		mov	dx,WORD PTR ?base_port@@3IE	;base_port
	*** 00018e	83 c2 07 		add	dx,7
	*** 000191	ee 			out	dx, al

;|*** 
;|***   /* Get the current state of the enable register */
;|*** 
;|***   temp = inportb(port);
; Line 356
	*** 000192	8b c7 			mov	ax,di
	*** 000194	8b ca 			mov	cx,dx
	*** 000196	8b df 			mov	bx,di
	*** 000198	99 			cwd	
	*** 000199	83 e2 07 		and	dx,7
	*** 00019c	03 c2 			add	ax,dx
	*** 00019e	c1 f8 03 		sar	ax,3
	*** 0001a1	8b d0 			mov	dx,ax
	*** 0001a3	03 16 00 00 		add	dx,WORD PTR ?base_port@@3IE	;base_port
	*** 0001a7	83 c2 08 		add	dx,8
	*** 0001aa	ec 			in	al,dx
	*** 0001ab	8b f7 			mov	si,di
	*** 0001ad	8a d8 			mov	bl,al
	*** 0001af	2a ff 			sub	bh,bh
;|*** 
;|***   /* Clear the enable bit int the image for our bit number */
;|*** 
;|***   temp = temp & ~mask;
; Line 360
	*** 0001b1	8b fa 			mov	di,dx
	*** 0001b3	8b c6 			mov	ax,si
	*** 0001b5	ba 08 00 		mov	dx,8
	*** 0001b8	8b f2 			mov	si,dx
	*** 0001ba	99 			cwd	
	*** 0001bb	f7 fe 			idiv	si
	*** 0001bd	8b c1 			mov	ax,cx
	*** 0001bf	8b ca 			mov	cx,dx
	*** 0001c1	ba 01 00 		mov	dx,1
	*** 0001c4	d3 e2 			shl	dx,cl
	*** 0001c6	f7 d2 			not	dx
	*** 0001c8	23 da 			and	bx,dx
;|***   
;|***   /* Update the enable register with the new information */
;|*** 
;|***   outportb(port,temp);
; Line 364
	*** 0001ca	8b c8 			mov	cx,ax
	*** 0001cc	8b c3 			mov	ax,bx
	*** 0001ce	8b d7 			mov	dx,di
	*** 0001d0	ee 			out	dx, al

;|*** 
;|***   /* Set access back to page 0 */
;|*** 
;|***   outportb(base_port+7,0x0);
; Line 368
	*** 0001d1	33 c0 			xor	ax,ax
	*** 0001d3	8b d1 			mov	dx,cx
	*** 0001d5	ee 			out	dx, al

;|*** 
;|*** }
; Line 370
	*** 0001d6	5e 			pop	si
	*** 0001d7	5f 			pop	di
	*** 0001d8	c9 			leave	
	*** 0001d9	cb 			ret	

?disab_int@@ZAXH@Z	ENDP
	PUBLIC	?clr_int@@ZAXH@Z	; clr_int
?clr_int@@ZAXH@Z	PROC FAR	; clr_int
;|*** 
;|*** /*==========================================================================
;|*** *
;|*** *                                CLR_INT
;|*** *
;|*** *  This function takes a single argument :
;|*** *
;|*** *  bit_number : This argument specifies the bit interrupt to clear. Range
;|*** *               is 1 to 24.
;|*** *
;|*** *
;|*** *  This function is use to clear a bit interrupt once it has been recognized.
;|*** *  The interrupt left enabled.
;|*** *
;|*** *===========================================================================*/
;|*** 
;|*** void clr_int(int bit_number)
;|*** {
; Line 388
	*** 0001da	c8 02 00 00 		enter	2,0
	*** 0001de	57 			push	di
	*** 0001df	56 			push	si
;	bit_number = 6
;	port = -2
;	register bx = temp
;	mask = -6
	*** 0001e0	8b 7e 06 		mov	di,WORD PTR [bp+6]	;bit_number
;|*** unsigned port;
;|*** unsigned temp;
;|*** unsigned mask;
;|***  
;|*** 
;|***   /* Adjust for 0 based numbering */
;|*** 
;|***   --bit_number;
; Line 396
	*** 0001e3	4f 			dec	di
;|*** 
;|***   /* Calculate the correct I/O address for our enable register */
;|*** 
;|***   port = (bit_number / 8) + base_port + 8;
;|*** 
;|***   /* Calculate a bit mask for this bit number */
;|*** 
;|***   mask = (1 << (bit_number % 8));
;|*** 
;|***   /* Set access to page 2 for the enable register */
;|*** 
;|***   outportb(base_port+7,0x80);
; Line 408
	*** 0001e4	b8 80 00 		mov	ax,128	;0080H
	*** 0001e7	8b 16 00 00 		mov	dx,WORD PTR ?base_port@@3IE	;base_port
	*** 0001eb	83 c2 07 		add	dx,7
	*** 0001ee	ee 			out	dx, al

;|*** 
;|***   /* Get current state of the enable register */
;|*** 
;|***   temp = inportb(port);
; Line 412
	*** 0001ef	8b c7 			mov	ax,di
	*** 0001f1	8b ca 			mov	cx,dx
	*** 0001f3	8b df 			mov	bx,di
	*** 0001f5	99 			cwd	
	*** 0001f6	83 e2 07 		and	dx,7
	*** 0001f9	03 c2 			add	ax,dx
	*** 0001fb	c1 f8 03 		sar	ax,3
	*** 0001fe	8b d0 			mov	dx,ax
	*** 000200	03 16 00 00 		add	dx,WORD PTR ?base_port@@3IE	;base_port
	*** 000204	83 c2 08 		add	dx,8
	*** 000207	ec 			in	al,dx
	*** 000208	8b f7 			mov	si,di
	*** 00020a	8a d8 			mov	bl,al
	*** 00020c	2a ff 			sub	bh,bh
;|*** 
;|***   /* Temporarily clear only OUR enable. This clears the interrupt */
;|*** 
;|***   temp = temp & ~mask;    /* clear the enable for this bit */
; Line 416
	*** 00020e	8b fa 			mov	di,dx
	*** 000210	8b c6 			mov	ax,si
	*** 000212	ba 08 00 		mov	dx,8
	*** 000215	8b f2 			mov	si,dx
	*** 000217	99 			cwd	
	*** 000218	f7 fe 			idiv	si
	*** 00021a	8b c1 			mov	ax,cx
	*** 00021c	8b ca 			mov	cx,dx
	*** 00021e	ba 01 00 		mov	dx,1
	*** 000221	d3 e2 			shl	dx,cl
	*** 000223	8b ca 			mov	cx,dx
	*** 000225	f7 d2 			not	dx
	*** 000227	23 da 			and	bx,dx
;|***   
;|***   /* Write out the temporary value */ 
;|*** 
;|***   outportb(port,temp);
; Line 420
	*** 000229	89 46 fe 		mov	WORD PTR [bp-2],ax	;port
	*** 00022c	8b c3 			mov	ax,bx
	*** 00022e	8b d7 			mov	dx,di
	*** 000230	ee 			out	dx, al

;|*** 
;|***   /* Re-enable our interrupt bit */
;|*** 
;|***   temp = temp | mask;
; Line 424
	*** 000231	0b d9 			or	bx,cx
;|*** 
;|***   /* Write it out */
;|*** 
;|***   outportb(port,temp);
; Line 428
	*** 000233	8b c3 			mov	ax,bx
	*** 000235	ee 			out	dx, al

;|*** 
;|***   /* Set access back to page 0 */
;|*** 
;|***   outportb(base_port+7,0x0);
; Line 432
	*** 000236	33 c0 			xor	ax,ax
	*** 000238	8b 56 fe 		mov	dx,WORD PTR [bp-2]	;port
	*** 00023b	ee 			out	dx, al

;|*** 
;|*** }
; Line 434
	*** 00023c	5e 			pop	si
	*** 00023d	5f 			pop	di
	*** 00023e	c9 			leave	
	*** 00023f	cb 			ret	

?clr_int@@ZAXH@Z	ENDP
	PUBLIC	?get_int@@ZAHXZ	; get_int
?get_int@@ZAHXZ	PROC FAR	; get_int
;|*** 
;|*** 
;|*** /*==========================================================================
;|*** *
;|*** *                                GET_INT
;|*** *
;|*** *  This function take no arguments.
;|*** *
;|*** *  return value : The value returned is the highest level bit interrupt
;|*** *                 currently pending. Range is 1 to 24.
;|*** *
;|*** *  This function returns the highest level interrupt pending. If no interrupt
;|*** *  is pending, a zero is returned. This function does NOT clear the interrupt.
;|*** *
;|*** *===========================================================================*/
;|***  
;|*** int get_int(void)
;|*** {
; Line 452
	*** 000240	c8 04 00 00 		enter	4,0
	*** 000244	57 			push	di
;	register bx = x
;	temp = -2
;|*** int temp;
;|*** int x;
;|*** 
;|***   /* read the master interrupt pending register, mask off undefined bits */
;|*** 
;|***   temp = inportb(base_port+6) & 0x07;
;|*** 
;|***   /* If there are no interrupts pending, return a 0 */
;|*** 
;|***   if((temp & 7) == 0)
; Line 462
	*** 000245	8b 16 00 00 		mov	dx,WORD PTR ?base_port@@3IE	;base_port
	*** 000249	83 c2 06 		add	dx,6
	*** 00024c	ec 			in	al,dx
	*** 00024d	a8 07 			test	al,7
	*** 00024f	75 03 			jne	$JCC591
	*** 000251	e9 a2 00 		jmp	$L803
					$JCC591:
;|***     return(0);
;|*** 
;|***   /* There is something pending, now we need to identify what it is */
;|*** 
;|***   
;|***   /* Set access to page 3 for interrupt id registers */
;|*** 
;|***   outportb(base_port+7,0xc0);
; Line 470
	*** 000254	b8 c0 00 		mov	ax,192	;00c0H
	*** 000257	8b 16 00 00 		mov	dx,WORD PTR ?base_port@@3IE	;base_port
	*** 00025b	83 c2 07 		add	dx,7
	*** 00025e	89 56 fc 		mov	WORD PTR [bp-4],dx
	*** 000261	ee 			out	dx, al

;|*** 
;|***   /* Read interrupt ID register for port 0 */
;|*** 
;|***   temp = inportb(base_port+8);
;|*** 
;|*** 
;|***   /* See if any bit set, if so return the bit number */
;|*** 
;|***   if(temp !=0)
; Line 479
	*** 000262	8b 16 00 00 		mov	dx,WORD PTR ?base_port@@3IE	;base_port
	*** 000266	83 c2 08 		add	dx,8
	*** 000269	ec 			in	al,dx
	*** 00026a	8b f8 			mov	di,ax
	*** 00026c	0b f8 			or	di,ax
	*** 00026e	74 13 			je	$I770
;|***   {
;|***     for(x=0; x <=7; x++)
; Line 481
	*** 000270	33 db 			xor	bx,bx
					$F771:
;|***     {
;|***       if(temp & (1 << x))
; Line 483
	*** 000272	8b cb 			mov	cx,bx
	*** 000274	b8 01 00 		mov	ax,1
	*** 000277	d3 e0 			shl	ax,cl
	*** 000279	85 c7 			test	ax,di
	*** 00027b	75 4f 			jne	$L794
	*** 00027d	43 			inc	bx
	*** 00027e	83 fb 07 		cmp	bx,7
	*** 000281	7e ef 			jle	$F771
					$I770:
;|***       {
;|***         outportb(base_port+7,0);  /* Turn off access */
;|***         return(x+1);    /* Return bitnumber with active int */
;|***       }
;|***     }
;|***   }
;|*** 
;|***   /* None in Port 0, read port 1 interrupt ID register */
;|*** 
;|***   temp = inportb(base_port+9);
;|*** 
;|***   /* See if any bit set, if so return the bit number */
;|*** 
;|***   if(temp !=0)
; Line 497
	*** 000283	8b 16 00 00 		mov	dx,WORD PTR ?base_port@@3IE	;base_port
	*** 000287	83 c2 09 		add	dx,9
	*** 00028a	ec 			in	al,dx
	*** 00028b	2a e4 			sub	ah,ah
	*** 00028d	8b f8 			mov	di,ax
	*** 00028f	0b f8 			or	di,ax
	*** 000291	74 13 			je	$I775
;|***   {
;|***     for(x=0; x <=7; x++)
; Line 499
	*** 000293	33 db 			xor	bx,bx
					$F776:
;|***     {
;|***       if(temp & (1 << x))
; Line 501
	*** 000295	8b cb 			mov	cx,bx
	*** 000297	b8 01 00 		mov	ax,1
	*** 00029a	d3 e0 			shl	ax,cl
	*** 00029c	85 c7 			test	ax,di
	*** 00029e	75 38 			jne	$L795
	*** 0002a0	43 			inc	bx
	*** 0002a1	83 fb 07 		cmp	bx,7
	*** 0002a4	7e ef 			jle	$F776
					$I775:
;|***       {
;|***         outportb(base_port+7,0);  /* Turn off access */
;|***         return(x+9);    /* Return bitnumber with active int */
;|***       }
;|***     }
;|***   }
;|*** 
;|***   /* Lastly, read status of port 2 int id */
;|***   
;|***   temp = inportb(base_port+0x0a);    /* Read port 2 status */
;|*** 
;|***   /* If any pending, return the appropriate bit number */
;|*** 
;|***   if(temp !=0)
; Line 515
	*** 0002a6	8b 16 00 00 		mov	dx,WORD PTR ?base_port@@3IE	;base_port
	*** 0002aa	83 c2 0a 		add	dx,10	;000aH
	*** 0002ad	ec 			in	al,dx
	*** 0002ae	2a e4 			sub	ah,ah
	*** 0002b0	8b f8 			mov	di,ax
	*** 0002b2	0b f8 			or	di,ax
	*** 0002b4	74 3a 			je	$I780
;|***   {
;|***     for(x=0; x <=7; x++)
; Line 517
	*** 0002b6	33 db 			xor	bx,bx
					$F781:
;|***     {
;|***       if(temp & (1 << x))
; Line 519
	*** 0002b8	8b cb 			mov	cx,bx
	*** 0002ba	b8 01 00 		mov	ax,1
	*** 0002bd	d3 e0 			shl	ax,cl
	*** 0002bf	85 c7 			test	ax,di
	*** 0002c1	75 21 			jne	$L796
	*** 0002c3	43 			inc	bx
	*** 0002c4	83 fb 07 		cmp	bx,7
	*** 0002c7	7e ef 			jle	$F781
	*** 0002c9	eb 25 			jmp	SHORT $I780
	*** 0002cb	90 			nop	
					$L794:
;|***         outportb(base_port+7,0);  /* Turn off access */
; Line 485
	*** 0002cc	33 c0 			xor	ax,ax
	*** 0002ce	8b 56 fc 		mov	dx,WORD PTR [bp-4]
	*** 0002d1	ee 			out	dx, al

;|***         return(x+1);    /* Return bitnumber with active int */
; Line 486
	*** 0002d2	8d 47 01 		lea	ax,WORD PTR [bx+1]
	*** 0002d5	5f 			pop	di
	*** 0002d6	c9 			leave	
	*** 0002d7	cb 			ret	
;|***       }
;|***     }
;|***   }
;|*** 
;|***   /* None in Port 0, read port 1 interrupt ID register */
;|*** 
;|***   temp = inportb(base_port+9);
; Line 493
					$L795:
;|*** 
;|***   /* See if any bit set, if so return the bit number */
;|*** 
;|***   if(temp !=0)
;|***   {
;|***     for(x=0; x <=7; x++)
;|***     {
;|***       if(temp & (1 << x))
;|***       {
;|***         outportb(base_port+7,0);  /* Turn off access */
; Line 503
	*** 0002d8	33 c0 			xor	ax,ax
	*** 0002da	8b 56 fc 		mov	dx,WORD PTR [bp-4]
	*** 0002dd	ee 			out	dx, al

;|***         return(x+9);    /* Return bitnumber with active int */
; Line 504
	*** 0002de	8d 47 09 		lea	ax,WORD PTR [bx+9]
	*** 0002e1	5f 			pop	di
	*** 0002e2	c9 			leave	
	*** 0002e3	cb 			ret	
;|***       }
;|***     }
;|***   }
;|*** 
;|***   /* Lastly, read status of port 2 int id */
;|***   
;|***   temp = inportb(base_port+0x0a);    /* Read port 2 status */
; Line 511
					$L796:
;|*** 
;|***   /* If any pending, return the appropriate bit number */
;|*** 
;|***   if(temp !=0)
;|***   {
;|***     for(x=0; x <=7; x++)
;|***     {
;|***       if(temp & (1 << x))
;|***       {
;|***         outportb(base_port+7,0);  /* Turn off access */
; Line 521
	*** 0002e4	33 c0 			xor	ax,ax
	*** 0002e6	8b 56 fc 		mov	dx,WORD PTR [bp-4]
	*** 0002e9	ee 			out	dx, al

;|***         return(x+17);   /* Return bitnumber with active int */
; Line 522
	*** 0002ea	8d 47 11 		lea	ax,WORD PTR [bx+17]
	*** 0002ed	5f 			pop	di
	*** 0002ee	c9 			leave	
	*** 0002ef	cb 			ret	
;|***       }
;|***     }
;|***   }
;|*** 
;|***   /* We should never get here unless the hardware is misbehaving but just
;|***       to be sure. We'll turn the page access back to 0 and return a 0 for
;|***       no interrupt found.
;|***   */
;|*** 
;|*** 
;|***   outportb(base_port+7,0);
; Line 533
					$I780:
	*** 0002f0	33 c0 			xor	ax,ax
	*** 0002f2	8b 56 fc 		mov	dx,WORD PTR [bp-4]
	*** 0002f5	ee 			out	dx, al

;|***   return 0;
; Line 534
					$L803:
	*** 0002f6	33 c0 			xor	ax,ax
;|*** }
; Line 535
	*** 0002f8	5f 			pop	di
	*** 0002f9	c9 			leave	
	*** 0002fa	cb 			ret	
	*** 0002fb	90 			nop	

?get_int@@ZAHXZ	ENDP
	PUBLIC	?read_port@@ZAIH@Z	; read_port
?read_port@@ZAIH@Z	PROC FAR	; read_port
;|*** 
;|*** 
;|*** unsigned read_port(int port_number)
;|***   {
; Line 539
	*** 0002fc	55 			push	bp
	*** 0002fd	8b ec 			mov	bp,sp
;	port_number = 6
;|***   return inportb(port_number + base_port) & 0x00ff;
; Line 540
	*** 0002ff	8b 56 06 		mov	dx,WORD PTR [bp+6]	;port_number
	*** 000302	03 16 00 00 		add	dx,WORD PTR ?base_port@@3IE	;base_port
	*** 000306	ec 			in	al,dx
	*** 000307	2a e4 			sub	ah,ah
;|***   }
; Line 541
	*** 000309	c9 			leave	
	*** 00030a	cb 			ret	
	*** 00030b	90 			nop	

?read_port@@ZAIH@Z	ENDP
UIO48_TEXT	ENDS
END
