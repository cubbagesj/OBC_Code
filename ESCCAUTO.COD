;	Static Name Aliases
;
	TITLE   c:\cba\esccauto.cpp
	.286p
INCLUDELIB      LLIBCE
INCLUDELIB	OLDNAMES.LIB
ESCCAUTO_TEXT	SEGMENT  WORD PUBLIC 'CODE'
ESCCAUTO_TEXT	ENDS
_DATA	SEGMENT  WORD PUBLIC 'DATA'
_DATA	ENDS
CONST	SEGMENT  WORD PUBLIC 'CONST'
CONST	ENDS
_BSS	SEGMENT  WORD PUBLIC 'BSS'
_BSS	ENDS
DGROUP	GROUP	CONST, _BSS, _DATA
	ASSUME DS: DGROUP, SS: DGROUP
PUBLIC  ?odd@@3HE
EXTRN	__ffree:FAR
EXTRN	__fmalloc:FAR
EXTRN	__dos_setvect:FAR
EXTRN	?time_stamp@@ZAXPEUTIMER@@@Z:FAR
EXTRN	__dos_getvect:FAR
EXTRN	?ln200_buffer@@3QIEI:BYTE
EXTRN	?ln200_new_data@@3IE:WORD
EXTRN	?ln200_data_frame@@3KE:DWORD
EXTRN	?frame@@3KE:DWORD
EXTRN	?ln200_time@@3UTIMER@@E:FWORD
EXTRN	?ln200_rx_num@@3KE:DWORD
_DATA      SEGMENT
?odd@@3HE	DW	00H
_DATA      ENDS
_BSS      SEGMENT
PUBLIC  ?t1@@3PEVCescc@@E
?t1@@3PEVCescc@@E	DW 02H DUP (?)
_BSS      ENDS
ESCCAUTO_TEXT      SEGMENT
	ASSUME	CS: ESCCAUTO_TEXT
	PUBLIC	??0Cescc@@REC@XZ	; Cescc::Cescc
??0Cescc@@REC@XZ	PROC FAR	; Cescc::Cescc
;|*** // esccauto.cpp
;|*** 
;|*** // modified 2/25/2004 by jtm
;|*** // removed some code for unused modes
;|*** // improved code style
;|*** // added comments
;|*** // added application-specific code for autonomous model
;|*** // search for "jtm" to find changes from original
;|*** 
;|*** // original code supplied by Carl George
;|*** // of Commtech, Inc., Wichita, KS
;|*** // as a general purpose driver for 
;|*** // the ESCC-104 synchronous serial board
;|*** // check their web site for additional information
;|*** 
;|*** #include "esccauto.h"           
;|*** #include "conio.h"
;|*** #include "stdlib.h"
;|*** #include "malloc.h"
;|*** #include "dos.h"
;|*** #include "memory.h"
;|*** #include "dmmtest.h"
;|*** 
;|*** struct TIMER
;|***   {
;|***   unsigned long high;
;|***   unsigned int  low;
;|***   };
;|*** 
;|*** struct LN200
;|***   {
;|***   unsigned int  new_data;
;|***   long unsigned frame;
;|***   unsigned long time_high;
;|***   unsigned      time_low;
;|***   unsigned      data[16];
;|***   };
;|*** 
;|*** extern unsigned char ln200_buffer[32];
;|*** extern unsigned ln200_new_data;
;|*** extern unsigned long ln200_data_frame;
;|*** extern char pcm[96];
;|*** 
;|*** int odd = 0;
;|*** 
;|*** Cescc *t1; // makes the instance of Cescc class object visible to the ISR
;|***           
;|*** Cescc::Cescc()  // constructor
;|***   {
; Line 49
	*** 000000	c8 0c 00 00 		enter	12,0
	*** 000004	57 			push	di
	*** 000005	56 			push	si
;	this = 6
;	i = -10
;	j = -4
	*** 000006	8b 46 06 		mov	ax,WORD PTR [bp+6]	;this
	*** 000009	8b 56 08 		mov	dx,WORD PTR [bp+8]
	*** 00000c	a3 00 00 		mov	WORD PTR ?t1@@3PEVCescc@@E,ax	;t1
	*** 00000f	89 16 02 00 		mov	WORD PTR ?t1@@3PEVCescc@@E+2,dx	;t1
	*** 000013	8b d8 			mov	bx,ax
	*** 000015	89 56 fe 		mov	WORD PTR [bp-2],dx
	*** 000018	05 7a 00 		add	ax,122	;007aH
	*** 00001b	89 46 f8 		mov	WORD PTR [bp-8],ax
	*** 00001e	89 56 fa 		mov	WORD PTR [bp-6],dx
	*** 000021	8e c2 			mov	es,dx
	*** 000023	8b f0 			mov	si,ax
	*** 000025	33 c0 			xor	ax,ax
	*** 000027	99 			cwd	
	*** 000028	b9 40 00 		mov	cx,64	;0040H
	*** 00002b	8d bc 80 00 		lea	di,WORD PTR [si+128]
	*** 00002f	f3 			rep
	*** 000030	ab 			stosw
	*** 000031	c7 46 f4 02 00 		mov	WORD PTR [bp-12],2
;|***   unsigned i,j;
;|***   
;|***   t1 = this;
;|***   
;|***   for(i=0;i<MAX_PORTS;i++)
; Line 54
					$F1420:
	*** 000036	8e 46 fe 		mov	es,WORD PTR [bp-2]
	*** 000039	26 89 07 		mov	WORD PTR es:[bx],ax
	*** 00003c	8e 46 fe 		mov	es,WORD PTR [bp-2]
	*** 00003f	26 89 47 04 		mov	WORD PTR es:[bx+4],ax
	*** 000043	8e 46 fe 		mov	es,WORD PTR [bp-2]
	*** 000046	26 89 47 08 		mov	WORD PTR es:[bx+8],ax
	*** 00004a	99 			cwd	
	*** 00004b	b9 20 00 		mov	cx,32	;0020H
	*** 00004e	8b 76 f8 		mov	si,WORD PTR [bp-8]
	*** 000051	8b 7e fa 		mov	di,WORD PTR [bp-6]
	*** 000054	57 			push	di
	*** 000055	8b fe 			mov	di,si
	*** 000057	07 			pop	es
	*** 000058	f3 			rep
	*** 000059	ab 			stosw
;|***     {
;|***     port_list[i] = 0;
;|***     port_open_list[i] = 0;                 
;|***     interrupt_list[i] = 0;
;|***     for(j=0;j<MAX_RBUFS;j++)rxbuffer[i][j] = 0;
;|***     for(j=0;j<MAX_TBUFS;j++)txbuffer[i][j] = 0;
;|***     timer_status[i] = 0;
;|***     current_rxbuf[i] = 0;
; Line 62
	*** 00005a	8e 46 fe 		mov	es,WORD PTR [bp-2]
	*** 00005d	26 89 87 8a 01 		mov	WORD PTR es:[bx+394],ax
	*** 000062	8e 46 fe 		mov	es,WORD PTR [bp-2]
	*** 000065	26 89 87 7a 01 		mov	WORD PTR es:[bx+378],ax
;|***     current_txbuf[i] = 0;
;|***     max_rxbuf[i] = 0;
; Line 64
	*** 00006a	8e 46 fe 		mov	es,WORD PTR [bp-2]
	*** 00006d	26 89 87 7e 01 		mov	WORD PTR es:[bx+382],ax
	*** 000072	8e 46 fe 		mov	es,WORD PTR [bp-2]
	*** 000075	26 89 87 82 01 		mov	WORD PTR es:[bx+386],ax
;|***     max_txbuf[i] = 0;
; Line 65
	*** 00007a	8e 46 fe 		mov	es,WORD PTR [bp-2]
	*** 00007d	26 89 87 86 01 		mov	WORD PTR es:[bx+390],ax
;|***     tx_type[i] = 0x08;
; Line 66
	*** 000082	8e 46 fe 		mov	es,WORD PTR [bp-2]
	*** 000085	26 c7 87 8e 01 08 00 	mov	WORD PTR es:[bx+398],8
;|***     istxing[i] = 0; //==1 if a frame is being sent ,==0 if no txing is going on
;|***     port_dmat_list[i] = 0;
; Line 68
	*** 00008c	8e 46 fe 		mov	es,WORD PTR [bp-2]
	*** 00008f	26 89 87 92 01 		mov	WORD PTR es:[bx+402],ax
	*** 000094	8e 46 fe 		mov	es,WORD PTR [bp-2]
	*** 000097	26 89 47 0c 		mov	WORD PTR es:[bx+12],ax
;|***     port_dmar_list[i] = 0;
;|***     port_status[i] = 0;
; Line 70
	*** 00009b	8e 46 fe 		mov	es,WORD PTR [bp-2]
	*** 00009e	26 89 47 10 		mov	WORD PTR es:[bx+16],ax
	*** 0000a2	8e 46 fe 		mov	es,WORD PTR [bp-2]
	*** 0000a5	26 89 87 96 01 		mov	WORD PTR es:[bx+406],ax
;|***     channel[i] = 0;
;|***     eopmode[i] = 0;
; Line 72
	*** 0000aa	8e 46 fe 		mov	es,WORD PTR [bp-2]
	*** 0000ad	26 89 87 9a 01 		mov	WORD PTR es:[bx+410],ax
	*** 0000b2	8e 46 fe 		mov	es,WORD PTR [bp-2]
	*** 0000b5	26 89 87 9e 01 		mov	WORD PTR es:[bx+414],ax
	*** 0000ba	83 c3 02 		add	bx,2
	*** 0000bd	83 46 f8 40 		add	WORD PTR [bp-8],64	;0040H
	*** 0000c1	ff 4e f4 		dec	WORD PTR [bp-12]
	*** 0000c4	74 03 			je	$JCC196
	*** 0000c6	e9 6d ff 		jmp	$F1420
					$JCC196:
;|***     }
; Line 73
	*** 0000c9	8b 76 06 		mov	si,WORD PTR [bp+6]	;this
	*** 0000cc	8b c6 			mov	ax,si
	*** 0000ce	8b 56 08 		mov	dx,WORD PTR [bp+8]
	*** 0000d1	05 34 00 		add	ax,52	;0034H
	*** 0000d4	8b d8 			mov	bx,ax
	*** 0000d6	8e da 			mov	ds,dx
	ASSUME DS: NOTHING
	*** 0000d8	8d 44 14 		lea	ax,WORD PTR [si+20]
	*** 0000db	8e c2 			mov	es,dx
	*** 0000dd	c7 46 fa 10 00 		mov	WORD PTR [bp-6],16	;0010H
	*** 0000e2	8b f0 			mov	si,ax
	*** 0000e4	8b 4e fa 		mov	cx,WORD PTR [bp-6]
;|***     
;|***   for(i=0;i<16;i++)
; Line 75
					$F1429:
;|***     {
;|***     hooked_irqs[i] = 0;
; Line 77
	*** 0000e7	26 c7 04 00 00 		mov	WORD PTR es:[si],0
;|***     old_service_routines[i] = NULL;
; Line 78
	*** 0000ec	c7 07 00 00 		mov	WORD PTR [bx],0
	*** 0000f0	c7 47 02 00 00 		mov	WORD PTR [bx+2],0
	*** 0000f5	83 c3 04 		add	bx,4
	*** 0000f8	83 c6 02 		add	si,2
	*** 0000fb	49 			dec	cx
	*** 0000fc	75 e9 			jne	$F1429
;|***     }
; Line 79
	*** 0000fe	16 			push	ss
	*** 0000ff	1f 			pop	ds
	ASSUME DS: DGROUP
	*** 000100	8b 76 06 		mov	si,WORD PTR [bp+6]	;this
;|***     
;|***   next_port = 0;
;|***   next_irq =0;
; Line 82
	*** 000103	33 c0 			xor	ax,ax
	*** 000105	8e 46 08 		mov	es,WORD PTR [bp+8]
	*** 000108	26 89 44 74 		mov	WORD PTR es:[si+116],ax
	*** 00010c	26 89 44 76 		mov	WORD PTR es:[si+118],ax
;|***   upper_irq = 0;
; Line 83
	*** 000110	26 89 44 78 		mov	WORD PTR es:[si+120],ax
;|*** 
;|***   // not needed once fixed settings PVR reg in init_escc for channela in
;|***   // ln200com.cpp  
;|***   //  outp(0x240 + PCR,inp(0x240 + PCR) & ~0x08);//set DTR to output
;|***   //  outp(0x240 + PVR,inp(0x240 + PVR) | 0x08);//set DTR
;|*** 
;|***   } // end constructor
; Line 90
	*** 000114	8b c6 			mov	ax,si
	*** 000116	8c c2 			mov	dx,es
	*** 000118	5e 			pop	si
	*** 000119	5f 			pop	di
	*** 00011a	c9 			leave	
	*** 00011b	ca 04 00 		ret	4

??0Cescc@@REC@XZ	ENDP
	PUBLIC	??1Cescc@@REC@XZ	; Cescc::~Cescc
??1Cescc@@REC@XZ	PROC FAR	; Cescc::~Cescc
;|*** 
;|*** 
;|*** 
;|*** Cescc::~Cescc()  // destructor
;|***   {
; Line 95
	*** 00011e	c8 18 00 00 		enter	24,0
	*** 000122	57 			push	di
	*** 000123	56 			push	si
;	this = 6
;	i = -16
;	j = -6
	*** 000124	8b 4e 06 		mov	cx,WORD PTR [bp+6]	;this
;|***   unsigned i,j;
;|***   
;|***   //check if any open ports left if so then unhook unterrupts and kill them free any buffers etc
;|***   //printf("in destructor\n\r");
;|***   //walk the port list and turn off ints at the uarts
;|***   for(i=0;i<next_port;i++)
; Line 101
	*** 000127	c7 46 f0 00 00 		mov	WORD PTR [bp-16],0	;i
	*** 00012c	8b d9 			mov	bx,cx
	*** 00012e	8e 46 08 		mov	es,WORD PTR [bp+8]
	*** 000131	26 83 7f 74 00 		cmp	WORD PTR es:[bx+116],0
	*** 000136	75 03 			jne	$JCC310
	*** 000138	e9 52 01 		jmp	$FB1439
					$JCC310:
	*** 00013b	8b c1 			mov	ax,cx
	*** 00013d	8c 46 f8 		mov	WORD PTR [bp-8],es
	*** 000140	05 7a 00 		add	ax,122	;007aH
	*** 000143	89 46 f2 		mov	WORD PTR [bp-14],ax
	*** 000146	8c 46 f4 		mov	WORD PTR [bp-12],es
					$F1437:
;|***     {
;|***     if(port_list[i]!=0)
; Line 103
	*** 000149	8e 46 f8 		mov	es,WORD PTR [bp-8]
	*** 00014c	26 8b 07 		mov	ax,WORD PTR es:[bx]
	*** 00014f	89 46 ee 		mov	WORD PTR [bp-18],ax
	*** 000152	0b c0 			or	ax,ax
	*** 000154	75 03 			jne	$JCC340
	*** 000156	e9 19 01 		jmp	$FC1438
					$JCC340:
;|***       {
;|***       outp(port_list[i]+PVR,(inp(port_list[i]+PVR)&0xfe)+channel[i]); //set current channel (a or b)
; Line 105
	*** 000159	8b d0 			mov	dx,ax
	*** 00015b	83 c2 1c 		add	dx,28	;001cH
	*** 00015e	ec 			in	al,dx
	*** 00015f	25 fe 00 		and	ax,254	;00feH
	*** 000162	26 03 87 9a 01 		add	ax,WORD PTR es:[bx+410]
	*** 000167	ee 			out	dx, al

;|***       outp(port_list[i]+IMR0,0xff);//disable interrupts at escc!!!
; Line 106
	*** 000168	b8 ff 00 		mov	ax,255	;00ffH
	*** 00016b	8b 56 ee 		mov	dx,WORD PTR [bp-18]
	*** 00016e	83 c2 1a 		add	dx,26	;001aH
	*** 000171	ee 			out	dx, al

;|***       outp(port_list[i]+IMR1,0xff);
; Line 107
	*** 000172	8b 56 ee 		mov	dx,WORD PTR [bp-18]
	*** 000175	83 c2 1b 		add	dx,27	;001bH
	*** 000178	ee 			out	dx, al

;|***       outp(port_list[i]+PIM,0xff);
; Line 108
	*** 000179	8b 56 ee 		mov	dx,WORD PTR [bp-18]
	*** 00017c	83 c2 1d 		add	dx,29	;001dH
	*** 00017f	ee 			out	dx, al

;|***       //if the port is open we need to free all the allocated buffer spaces
;|***       //ffree ignores NULL arguments so we should be safe freeing all of these pointers
;|***       //as the ones that were allocated will not be null, all others should be NULL!!!
;|***       for(j=0;j<max_rxbuf[i];j++) _ffree(rxbuffer[i][j]);
; Line 112
	*** 000180	c7 46 fa 00 00 		mov	WORD PTR [bp-6],0	;j
	*** 000185	26 83 bf 82 01 00 	cmp	WORD PTR es:[bx+386],0
	*** 00018b	74 31 			je	$FB1443
	*** 00018d	89 5e f6 		mov	WORD PTR [bp-10],bx
	*** 000190	8b 46 f2 		mov	ax,WORD PTR [bp-14]
	*** 000193	8b 56 f4 		mov	dx,WORD PTR [bp-12]
	*** 000196	89 56 fe 		mov	WORD PTR [bp-2],dx
	*** 000199	8b f0 			mov	si,ax
	*** 00019b	8b 7e fa 		mov	di,WORD PTR [bp-6]	;j
					$F1441:
	*** 00019e	8e 46 fe 		mov	es,WORD PTR [bp-2]
	*** 0001a1	26 ff 74 02 		push	WORD PTR es:[si+2]
	*** 0001a5	26 ff 34 		push	WORD PTR es:[si]
	*** 0001a8	9a 00 00 00 00 		call	FAR PTR __ffree
	*** 0001ad	83 c4 04 		add	sp,4
	*** 0001b0	83 c6 04 		add	si,4
	*** 0001b3	47 			inc	di
	*** 0001b4	c4 5e f6 		les	bx,DWORD PTR [bp-10]
	*** 0001b7	26 39 bf 82 01 		cmp	WORD PTR es:[bx+386],di
	*** 0001bc	77 e0 			ja	$F1441
					$FB1443:
;|***       for(j=0;j<max_txbuf[i];j++) _ffree(txbuffer[i][j]);
; Line 113
	*** 0001be	33 c9 			xor	cx,cx
	*** 0001c0	26 39 8f 86 01 		cmp	WORD PTR es:[bx+390],cx
	*** 0001c5	74 36 			je	$FB1446
	*** 0001c7	89 5e f6 		mov	WORD PTR [bp-10],bx
	*** 0001ca	8b 46 f2 		mov	ax,WORD PTR [bp-14]
	*** 0001cd	8b 56 f4 		mov	dx,WORD PTR [bp-12]
	*** 0001d0	05 80 00 		add	ax,128	;0080H
	*** 0001d3	89 56 fe 		mov	WORD PTR [bp-2],dx
	*** 0001d6	89 4e fa 		mov	WORD PTR [bp-6],cx	;j
	*** 0001d9	8b f0 			mov	si,ax
	*** 0001db	8b f9 			mov	di,cx
					$F1444:
	*** 0001dd	8e 46 fe 		mov	es,WORD PTR [bp-2]
	*** 0001e0	26 ff 74 02 		push	WORD PTR es:[si+2]
	*** 0001e4	26 ff 34 		push	WORD PTR es:[si]
	*** 0001e7	9a 00 00 00 00 		call	FAR PTR __ffree
	*** 0001ec	83 c4 04 		add	sp,4
	*** 0001ef	83 c6 04 		add	si,4
	*** 0001f2	47 			inc	di
	*** 0001f3	c4 5e f6 		les	bx,DWORD PTR [bp-10]
	*** 0001f6	26 39 bf 86 01 		cmp	WORD PTR es:[bx+390],di
	*** 0001fb	77 e0 			ja	$F1444
					$FB1446:
;|***       
;|***       if(port_dmat_list[i]!=0)
; Line 115
	*** 0001fd	26 8b 47 0c 		mov	ax,WORD PTR es:[bx+12]
	*** 000201	89 46 ec 		mov	WORD PTR [bp-20],ax
	*** 000204	0b c0 			or	ax,ax
	*** 000206	74 34 			je	$I1447
;|***         {
;|***         if(port_dmat_list[i]==1) outp(DMA_MASK_LO,5);
; Line 117
	*** 000208	3d 01 00 		cmp	ax,1
	*** 00020b	75 05 			jne	$I1448
	*** 00020d	b8 05 00 		mov	ax,5
	*** 000210	e6 0a 			out	10	;000aH, al

;|***         if(port_dmat_list[i]==3) outp(DMA_MASK_LO,7);
; Line 118
					$I1448:
	*** 000212	83 7e ec 03 		cmp	WORD PTR [bp-20],3
	*** 000216	75 05 			jne	$I1449
	*** 000218	b8 07 00 		mov	ax,7
	*** 00021b	e6 0a 			out	10	;000aH, al

;|***         if(port_dmat_list[i]==5) outp(DMA_MASK_HI,5);
; Line 119
					$I1449:
	*** 00021d	83 7e ec 05 		cmp	WORD PTR [bp-20],5
	*** 000221	75 05 			jne	$I1450
	*** 000223	b8 05 00 		mov	ax,5
	*** 000226	e6 d4 			out	212	;00d4H, al

;|***         if(port_dmat_list[i]==7) outp(DMA_MASK_HI,7);
; Line 120
					$I1450:
	*** 000228	83 7e ec 07 		cmp	WORD PTR [bp-20],7
	*** 00022c	75 05 			jne	$I1451
	*** 00022e	b8 07 00 		mov	ax,7
	*** 000231	e6 d4 			out	212	;00d4H, al

;|***         outp(port_list[i]+XBCH,0);//turn DMA off
; Line 121
					$I1451:
	*** 000233	33 c0 			xor	ax,ax
	*** 000235	26 8b 17 		mov	dx,WORD PTR es:[bx]
	*** 000238	83 c2 0b 		add	dx,11	;000bH
	*** 00023b	ee 			out	dx, al

;|***         }
;|***         
;|***       if(port_dmar_list[i]!=0)
; Line 124
					$I1447:
	*** 00023c	26 8b 47 10 		mov	ax,WORD PTR es:[bx+16]
	*** 000240	89 46 ea 		mov	WORD PTR [bp-22],ax
	*** 000243	0b c0 			or	ax,ax
	*** 000245	74 2b 			je	$FC1438
;|***         {
;|***         if(port_dmar_list[i]==1) outp(DMA_MASK_LO,5);
; Line 126
	*** 000247	3d 01 00 		cmp	ax,1
	*** 00024a	75 05 			jne	$I1453
	*** 00024c	b8 05 00 		mov	ax,5
	*** 00024f	e6 0a 			out	10	;000aH, al

;|***         if(port_dmar_list[i]==3) outp(DMA_MASK_LO,7);
; Line 127
					$I1453:
	*** 000251	83 7e ea 03 		cmp	WORD PTR [bp-22],3
	*** 000255	75 05 			jne	$I1454
	*** 000257	b8 07 00 		mov	ax,7
	*** 00025a	e6 0a 			out	10	;000aH, al

;|***         if(port_dmar_list[i]==5) outp(DMA_MASK_HI,5);
; Line 128
					$I1454:
	*** 00025c	83 7e ea 05 		cmp	WORD PTR [bp-22],5
	*** 000260	75 05 			jne	$I1455
	*** 000262	b8 05 00 		mov	ax,5
	*** 000265	e6 d4 			out	212	;00d4H, al

;|***         if(port_dmar_list[i]==7) outp(DMA_MASK_HI,7);
; Line 129
					$I1455:
	*** 000267	83 7e ea 07 		cmp	WORD PTR [bp-22],7
	*** 00026b	75 05 			jne	$FC1438
	*** 00026d	b8 07 00 		mov	ax,7
	*** 000270	e6 d4 			out	212	;00d4H, al

;|***   for(i=0;i<next_port;i++)
; Line 101
					$FC1438:
	*** 000272	83 c3 02 		add	bx,2
	*** 000275	83 46 f2 40 		add	WORD PTR [bp-14],64	;0040H
	*** 000279	ff 46 f0 		inc	WORD PTR [bp-16]	;i
	*** 00027c	8b 46 f0 		mov	ax,WORD PTR [bp-16]	;i
	*** 00027f	c4 76 06 		les	si,DWORD PTR [bp+6]	;this
	*** 000282	26 39 44 74 		cmp	WORD PTR es:[si+116],ax
	*** 000286	76 03 			jbe	$JCC646
	*** 000288	e9 be fe 		jmp	$F1437
					$JCC646:
	*** 00028b	8b ce 			mov	cx,si
;|***     {
;|***     if(port_list[i]!=0)
;|***       {
;|***       outp(port_list[i]+PVR,(inp(port_list[i]+PVR)&0xfe)+channel[i]); //set current channel (a or b)
;|***       outp(port_list[i]+IMR0,0xff);//disable interrupts at escc!!!
;|***       outp(port_list[i]+IMR1,0xff);
;|***       outp(port_list[i]+PIM,0xff);
;|***       //if the port is open we need to free all the allocated buffer spaces
;|***       //ffree ignores NULL arguments so we should be safe freeing all of these pointers
;|***       //as the ones that were allocated will not be null, all others should be NULL!!!
;|***       for(j=0;j<max_rxbuf[i];j++) _ffree(rxbuffer[i][j]);
;|***       for(j=0;j<max_txbuf[i];j++) _ffree(txbuffer[i][j]);
;|***       
;|***       if(port_dmat_list[i]!=0)
;|***         {
;|***         if(port_dmat_list[i]==1) outp(DMA_MASK_LO,5);
;|***         if(port_dmat_list[i]==3) outp(DMA_MASK_LO,7);
;|***         if(port_dmat_list[i]==5) outp(DMA_MASK_HI,5);
;|***         if(port_dmat_list[i]==7) outp(DMA_MASK_HI,7);
;|***         outp(port_list[i]+XBCH,0);//turn DMA off
;|***         }
;|***         
;|***       if(port_dmar_list[i]!=0)
;|***         {
;|***         if(port_dmar_list[i]==1) outp(DMA_MASK_LO,5);
;|***         if(port_dmar_list[i]==3) outp(DMA_MASK_LO,7);
;|***         if(port_dmar_list[i]==5) outp(DMA_MASK_HI,5);
;|***         if(port_dmar_list[i]==7) outp(DMA_MASK_HI,7);
;|***         }
;|***       }
;|***     }
; Line 132
					$FB1439:
;|***   
;|***   //walk the hooked IRQ list and replace the ISR's
;|***   for(i=0;i<next_irq;i++)
; Line 135
	*** 00028d	c7 46 f0 00 00 		mov	WORD PTR [bp-16],0	;i
	*** 000292	8b d9 			mov	bx,cx
	*** 000294	26 83 7f 76 00 		cmp	WORD PTR es:[bx+118],0
	*** 000299	75 03 			jne	$JCC665
	*** 00029b	e9 f3 00 		jmp	$EX1434
					$JCC665:
	*** 00029e	8b c1 			mov	ax,cx
	*** 0002a0	05 34 00 		add	ax,52	;0034H
	*** 0002a3	8b f8 			mov	di,ax
	*** 0002a5	8c 46 f8 		mov	WORD PTR [bp-8],es
	*** 0002a8	8b c1 			mov	ax,cx
	*** 0002aa	05 14 00 		add	ax,20	;0014H
	*** 0002ad	8b f0 			mov	si,ax
	*** 0002af	8c 46 fe 		mov	WORD PTR [bp-2],es
					$F1457:
;|***     {
;|***     if(hooked_irqs[i]<8)
; Line 137
	*** 0002b2	8e 46 fe 		mov	es,WORD PTR [bp-2]
	*** 0002b5	26 8b 04 		mov	ax,WORD PTR es:[si]
	*** 0002b8	89 46 e8 		mov	WORD PTR [bp-24],ax
	*** 0002bb	3d 08 00 		cmp	ax,8
	*** 0002be	73 58 			jae	$I1460
;|***       {
;|***       _dos_setvect(hooked_irqs[i]+8,old_service_routines[i]);
; Line 139
	*** 0002c0	8e 46 f8 		mov	es,WORD PTR [bp-8]
	*** 0002c3	26 ff 75 02 		push	WORD PTR es:[di+2]
	*** 0002c7	26 ff 35 		push	WORD PTR es:[di]
	*** 0002ca	05 08 00 		add	ax,8
	*** 0002cd	50 			push	ax
	*** 0002ce	9a 00 00 00 00 		call	FAR PTR __dos_setvect
	*** 0002d3	83 c4 06 		add	sp,6
;|***       //be nice and mask the IRQ at the PIC...could be bad I suppose... but it is nicer
;|***       j = inp(0x21);
; Line 141
	*** 0002d6	e4 21 			in	al,33	;0021H
	*** 0002d8	2a e4 			sub	ah,ah
	*** 0002da	89 46 fa 		mov	WORD PTR [bp-6],ax	;j
;|***       if(hooked_irqs[i] ==3) j = j|0x08;
; Line 142
	*** 0002dd	8e 46 fe 		mov	es,WORD PTR [bp-2]
	*** 0002e0	26 8b 04 		mov	ax,WORD PTR es:[si]
	*** 0002e3	89 46 e8 		mov	WORD PTR [bp-24],ax
	*** 0002e6	3d 03 00 		cmp	ax,3
	*** 0002e9	75 04 			jne	$I1461
	*** 0002eb	80 4e fa 08 		or	BYTE PTR [bp-6],8	;j
;|***       if(hooked_irqs[i] ==4) j = j|0x10;
; Line 143
					$I1461:
	*** 0002ef	3d 04 00 		cmp	ax,4
	*** 0002f2	75 04 			jne	$I1462
	*** 0002f4	80 4e fa 10 		or	BYTE PTR [bp-6],16	;0010H	;j
;|***       if(hooked_irqs[i] ==5) j = j|0x20;
; Line 144
					$I1462:
	*** 0002f8	3d 05 00 		cmp	ax,5
	*** 0002fb	75 04 			jne	$I1463
	*** 0002fd	80 4e fa 20 		or	BYTE PTR [bp-6],32	;0020H	;j
;|***       if(hooked_irqs[i] ==6) j = j|0x40;
; Line 145
					$I1463:
	*** 000301	3d 06 00 		cmp	ax,6
	*** 000304	75 04 			jne	$I1464
	*** 000306	80 4e fa 40 		or	BYTE PTR [bp-6],64	;0040H	;j
;|***       if(hooked_irqs[i] ==7) j = j|0x80;
; Line 146
					$I1464:
	*** 00030a	3d 07 00 		cmp	ax,7
	*** 00030d	75 04 			jne	$I1465
	*** 00030f	80 4e fa 80 		or	BYTE PTR [bp-6],128	;0080H	;j
;|***       outp(0x21,j);
; Line 147
					$I1465:
	*** 000313	8b 46 fa 		mov	ax,WORD PTR [bp-6]	;j
	*** 000316	e6 21 			out	33	;0021H, al

;|***       }
;|***         
;|***     if(hooked_irqs[i]>8)
; Line 150
					$I1460:
	*** 000318	83 7e e8 08 		cmp	WORD PTR [bp-24],8
	*** 00031c	76 5b 			jbe	$FC1458
;|***       {    
;|***       _dos_setvect(hooked_irqs[i]-8+0x70,old_service_routines[i]);
; Line 152
	*** 00031e	8e 46 f8 		mov	es,WORD PTR [bp-8]
	*** 000321	26 ff 75 02 		push	WORD PTR es:[di+2]
	*** 000325	26 ff 35 		push	WORD PTR es:[di]
	*** 000328	8b 46 e8 		mov	ax,WORD PTR [bp-24]
	*** 00032b	05 68 00 		add	ax,104	;0068H
	*** 00032e	50 			push	ax
	*** 00032f	9a 00 00 00 00 		call	FAR PTR __dos_setvect
	*** 000334	83 c4 06 		add	sp,6
;|***       j = inp(0xa1);
; Line 153
	*** 000337	e4 a1 			in	al,161	;00a1H
	*** 000339	2a e4 			sub	ah,ah
	*** 00033b	89 46 fa 		mov	WORD PTR [bp-6],ax	;j
;|***       if(hooked_irqs[i] ==9)  j = j|0x02;
; Line 154
	*** 00033e	8e 46 fe 		mov	es,WORD PTR [bp-2]
	*** 000341	26 8b 04 		mov	ax,WORD PTR es:[si]
	*** 000344	89 46 e8 		mov	WORD PTR [bp-24],ax
	*** 000347	3d 09 00 		cmp	ax,9
	*** 00034a	75 04 			jne	$I1467
	*** 00034c	80 4e fa 02 		or	BYTE PTR [bp-6],2	;j
;|***       if(hooked_irqs[i] ==10) j = j|0x04;
; Line 155
					$I1467:
	*** 000350	3d 0a 00 		cmp	ax,10	;000aH
	*** 000353	75 04 			jne	$I1468
	*** 000355	80 4e fa 04 		or	BYTE PTR [bp-6],4	;j
;|***       if(hooked_irqs[i] ==11) j = j|0x08;
; Line 156
					$I1468:
	*** 000359	3d 0b 00 		cmp	ax,11	;000bH
	*** 00035c	75 04 			jne	$I1469
	*** 00035e	80 4e fa 08 		or	BYTE PTR [bp-6],8	;j
;|***       if(hooked_irqs[i] ==12) j = j|0x10;
; Line 157
					$I1469:
	*** 000362	3d 0c 00 		cmp	ax,12	;000cH
	*** 000365	75 04 			jne	$I1470
	*** 000367	80 4e fa 10 		or	BYTE PTR [bp-6],16	;0010H	;j
;|***       if(hooked_irqs[i] ==15) j = j|0x80;
; Line 158
					$I1470:
	*** 00036b	3d 0f 00 		cmp	ax,15	;000fH
	*** 00036e	75 04 			jne	$I1471
	*** 000370	80 4e fa 80 		or	BYTE PTR [bp-6],128	;0080H	;j
;|***       outp(0xa1,j);
; Line 159
					$I1471:
	*** 000374	8b 46 fa 		mov	ax,WORD PTR [bp-6]	;j
	*** 000377	e6 a1 			out	161	;00a1H, al

;|***   for(i=0;i<next_irq;i++)
; Line 135
					$FC1458:
	*** 000379	83 c7 04 		add	di,4
	*** 00037c	83 c6 02 		add	si,2
	*** 00037f	ff 46 f0 		inc	WORD PTR [bp-16]	;i
	*** 000382	8b 46 f0 		mov	ax,WORD PTR [bp-16]	;i
	*** 000385	c4 5e 06 		les	bx,DWORD PTR [bp+6]	;this
	*** 000388	26 39 47 76 		cmp	WORD PTR es:[bx+118],ax
	*** 00038c	76 03 			jbe	$JCC908
	*** 00038e	e9 21 ff 		jmp	$F1457
					$JCC908:
;|***     {
;|***     if(hooked_irqs[i]<8)
;|***       {
;|***       _dos_setvect(hooked_irqs[i]+8,old_service_routines[i]);
;|***       //be nice and mask the IRQ at the PIC...could be bad I suppose... but it is nicer
;|***       j = inp(0x21);
;|***       if(hooked_irqs[i] ==3) j = j|0x08;
;|***       if(hooked_irqs[i] ==4) j = j|0x10;
;|***       if(hooked_irqs[i] ==5) j = j|0x20;
;|***       if(hooked_irqs[i] ==6) j = j|0x40;
;|***       if(hooked_irqs[i] ==7) j = j|0x80;
;|***       outp(0x21,j);
;|***       }
;|***         
;|***     if(hooked_irqs[i]>8)
;|***       {    
;|***       _dos_setvect(hooked_irqs[i]-8+0x70,old_service_routines[i]);
;|***       j = inp(0xa1);
;|***       if(hooked_irqs[i] ==9)  j = j|0x02;
;|***       if(hooked_irqs[i] ==10) j = j|0x04;
;|***       if(hooked_irqs[i] ==11) j = j|0x08;
;|***       if(hooked_irqs[i] ==12) j = j|0x10;
;|***       if(hooked_irqs[i] ==15) j = j|0x80;
;|***       outp(0xa1,j);
;|***       } 
;|***     }
;|***   }  // end destructor
; Line 162
					$EX1434:
	*** 000391	5e 			pop	si
	*** 000392	5f 			pop	di
	*** 000393	c9 			leave	
	*** 000394	ca 04 00 		ret	4
	*** 000397	90 			nop	

??1Cescc@@REC@XZ	ENDP
	PUBLIC	?add_port@Cescc@@RECIIIIII@Z	; Cescc::add_port
?add_port@Cescc@@RECIIIIII@Z	PROC FAR	; Cescc::add_port
;|*** 
;|*** 
;|*** 
;|*** 
;|*** 
;|*** unsigned Cescc::add_port(unsigned base, unsigned chan, unsigned irq, unsigned dmar, unsigned dmat)
;|***   {
; Line 169
	*** 000398	c8 08 00 00 		enter	8,0
	*** 00039c	57 			push	di
	*** 00039d	56 			push	si
;	base = 18
;	chan = 16
;	irq = 14
;	dmar = 12
;	dmat = 10
;	this = 6
;	i = -2
;	avail = -8
	*** 00039e	c4 7e 06 		les	di,DWORD PTR [bp+6]	;this
;|***   unsigned i;
;|***   unsigned avail;
;|***   
;|***   avail = next_port;      // next_port is reset to 0 in Cescc() contructor
; Line 173
	*** 0003a1	33 f6 			xor	si,si
	*** 0003a3	26 8b 4d 74 		mov	cx,WORD PTR es:[di+116]
;|***                           // then incremented at end of this function  
;|***   for(i=0;i<=next_port;i++)
; Line 175
	*** 0003a7	89 4e f8 		mov	WORD PTR [bp-8],cx	;avail
	*** 0003aa	8c c0 			mov	ax,es
	*** 0003ac	8e d8 			mov	ds,ax
	ASSUME DS: NOTHING
	*** 0003ae	89 76 fe 		mov	WORD PTR [bp-2],si	;i
	*** 0003b1	8b df 			mov	bx,di
	*** 0003b3	8b ce 			mov	cx,si
					$F1481:
;|***     {
;|***     if(port_list[i]==0)   //port_list is the table of escc base addresses for each port
; Line 177
	*** 0003b5	83 3f 00 		cmp	WORD PTR [bx],0
	*** 0003b8	74 10 			je	$L2082
;|***   for(i=0;i<=next_port;i++)
; Line 175
	*** 0003ba	83 c3 02 		add	bx,2
	*** 0003bd	41 			inc	cx
	*** 0003be	26 39 4d 74 		cmp	WORD PTR es:[di+116],cx
	*** 0003c2	73 f1 			jae	$F1481
	*** 0003c4	8b 4e f8 		mov	cx,WORD PTR [bp-8]	;avail
	*** 0003c7	eb 04 			jmp	SHORT $FB1483
	*** 0003c9	90 			nop	
					$L2082:
	*** 0003ca	89 4e fe 		mov	WORD PTR [bp-2],cx	;i
;|***     {
;|***     if(port_list[i]==0)   //port_list is the table of escc base addresses for each port
;|***       {                   //find first unused (available) slot in port_list table
;|***       avail = i;          //and use the slot for the port you are adding now
;|***       break;
;|***       }
;|***     }
; Line 182
					$FB1483:
;|***     
;|***   port_list[avail] = base;            //store port base address
; Line 184
	*** 0003cd	8b f1 			mov	si,cx
	*** 0003cf	03 f1 			add	si,cx
	*** 0003d1	8b df 			mov	bx,di
	*** 0003d3	8b 46 12 		mov	ax,WORD PTR [bp+18]	;base
	*** 0003d6	26 89 00 		mov	WORD PTR es:[bx][si],ax
;|***   interrupt_list[avail] = irq;        //store port irq
; Line 185
	*** 0003d9	03 de 			add	bx,si
	*** 0003db	8b 56 0e 		mov	dx,WORD PTR [bp+14]	;irq
	*** 0003de	26 89 57 08 		mov	WORD PTR es:[bx+8],dx
;|***   port_dmar_list[avail] = dmar;       //store port rx dma channel
; Line 186
	*** 0003e2	8b 56 0c 		mov	dx,WORD PTR [bp+12]	;dmar
	*** 0003e5	26 89 57 10 		mov	WORD PTR es:[bx+16],dx
;|***   port_dmat_list[avail] = dmat;       //store port tx dma channel                     
; Line 187
	*** 0003e9	8b 56 0a 		mov	dx,WORD PTR [bp+10]	;dmat
	*** 0003ec	26 89 57 0c 		mov	WORD PTR es:[bx+12],dx
;|***   channel[avail] = chan;              //store port channel number 0 or 1 (A or B)
; Line 188
	*** 0003f0	8b 56 10 		mov	dx,WORD PTR [bp+16]	;chan
	*** 0003f3	26 89 97 9a 01 		mov	WORD PTR es:[bx+410],dx
;|*** 
;|***   //set up the ESCC port register so we can access both channels   
;|***   //note this *****MUST***** be the first access to the escc or we can't rely on talking to a specific
;|***   //channel (defaults to channel 1, or the upper channel when bit 0 is defined as an input)
;|***   //this is because bit 0 of the escc universal port is wired to select either channel A or B
;|***   outp(base+PCR,0xe0);  //bit 0 = channel select  (output; 0 selects channel A; 1 selects channel B)
; Line 194
	*** 0003f8	8b d0 			mov	dx,ax
	*** 0003fa	83 c2 1e 		add	dx,30	;001eH
	*** 0003fd	b8 e0 00 		mov	ax,224	;00e0H
	*** 000400	ee 			out	dx, al

;|***             //bit 1 = not used      (output)
;|***             //bit 2 = not used      (output)
;|***             //bit 3 = DTR channel 0   (output)
;|***             //bit 4 = DTR channel 1   (output)
;|***             //bit 5 = DSR channel 0   (input)
;|***             //bit 6 = DSR channel 1   (input)
;|***             //bit 7 = TC for DMA (off ISA bus)(input)
;|***             
;|***   outp(base+IPC,0x03);  //escc int pin must be slave mode active high push pull to work.
; Line 203
	*** 000401	b8 03 00 		mov	ax,3
	*** 000404	8b 56 12 		mov	dx,WORD PTR [bp+18]	;base
	*** 000407	83 c2 19 		add	dx,25	;0019H
	*** 00040a	ee 			out	dx, al

;|***   
;|***   //check current interrupts against ones that are hooked and hook new interrupt if necessary
;|***   for(i=0;i<16;i++)
; Line 206
	*** 00040b	c7 46 fe 00 00 		mov	WORD PTR [bp-2],0	;i
	*** 000410	8b c7 			mov	ax,di
	*** 000412	8c c2 			mov	dx,es
	*** 000414	05 14 00 		add	ax,20	;0014H
	*** 000417	8e da 			mov	ds,dx
	ASSUME DS: NOTHING
	*** 000419	89 4e f8 		mov	WORD PTR [bp-8],cx	;avail
	*** 00041c	8b d8 			mov	bx,ax
	*** 00041e	8b 4e fe 		mov	cx,WORD PTR [bp-2]	;i
	*** 000421	8b 7e 0e 		mov	di,WORD PTR [bp+14]	;irq
					$F1485:
;|***     {
;|***     if(hooked_irqs[i]==irq) goto skip_irqsetup;
; Line 208
	*** 000424	39 3f 			cmp	WORD PTR [bx],di
	*** 000426	75 08 			jne	$L2080
	*** 000428	8b 76 06 		mov	si,WORD PTR [bp+6]	;this
	*** 00042b	16 			push	ss
	*** 00042c	1f 			pop	ds
	ASSUME DS: DGROUP
	*** 00042d	e9 35 01 		jmp	$skip_irqsetup1489
					$L2080:
;|***   for(i=0;i<16;i++)
; Line 206
	*** 000430	83 c3 02 		add	bx,2
	*** 000433	41 			inc	cx
	*** 000434	83 f9 10 		cmp	cx,16	;0010H
	*** 000437	72 eb 			jb	$F1485
;|***     {
;|***     if(hooked_irqs[i]==irq) goto skip_irqsetup;
;|***     }                                          
; Line 209
	*** 000439	16 			push	ss
	*** 00043a	1f 			pop	ds
	ASSUME DS: DGROUP
;|*** 
;|***   _disable();
; Line 211
	*** 00043b	fa 			cli	
	*** 00043c	8b 76 06 		mov	si,WORD PTR [bp+6]	;this
;|***   
;|***   //next_irq reset to 0 at end of Cescc constructor then incremented at end of add_port()
;|***   if(irq<8)
; Line 214
	*** 00043f	83 ff 08 		cmp	di,8
	*** 000442	72 03 			jb	$JCC1090
	*** 000444	e9 91 00 		jmp	$I1491
					$JCC1090:
;|***     {
;|***     old_service_routines[next_irq] = _dos_getvect(irq+8); //get old vector and save
; Line 216
	*** 000447	8d 45 08 		lea	ax,WORD PTR [di+8]
	*** 00044a	50 			push	ax
	*** 00044b	9a 00 00 00 00 		call	FAR PTR __dos_getvect
	*** 000450	83 c4 02 		add	sp,2
	*** 000453	8e 46 08 		mov	es,WORD PTR [bp+8]
	*** 000456	26 8b 5c 76 		mov	bx,WORD PTR es:[si+118]
	*** 00045a	c1 e3 02 		shl	bx,2
	*** 00045d	26 89 40 34 		mov	WORD PTR es:[bx+52][si],ax
	*** 000461	26 89 50 36 		mov	WORD PTR es:[bx+54][si],dx
;|***     _dos_setvect(irq+8,escc_isr);   //put in our routine
; Line 217
	*** 000465	68 00 00 		push	SEG ?escc_isr@Cescc@@JEAXXZ	;Cescc::escc_isr
	*** 000468	68 00 00 		push	OFFSET ?escc_isr@Cescc@@JEAXXZ	;Cescc::escc_isr
	*** 00046b	8d 45 08 		lea	ax,WORD PTR [di+8]
	*** 00046e	50 			push	ax
	*** 00046f	9a 00 00 00 00 		call	FAR PTR __dos_setvect
	*** 000474	83 c4 06 		add	sp,6
;|***     outp(base+PVR,(inp(base+PVR)&0xfe)+chan); //set current channel (a or b)
; Line 218
	*** 000477	8b 56 12 		mov	dx,WORD PTR [bp+18]	;base
	*** 00047a	83 c2 1c 		add	dx,28	;001cH
	*** 00047d	ec 			in	al,dx
	*** 00047e	25 fe 00 		and	ax,254	;00feH
	*** 000481	03 46 10 		add	ax,WORD PTR [bp+16]	;chan
	*** 000484	ee 			out	dx, al

;|***     outp(base+IMR0,0xff);//disable ints from uart
; Line 219
	*** 000485	b8 ff 00 		mov	ax,255	;00ffH
	*** 000488	8b 56 12 		mov	dx,WORD PTR [bp+18]	;base
	*** 00048b	83 c2 1a 		add	dx,26	;001aH
	*** 00048e	ee 			out	dx, al

;|***     outp(base+IMR1,0xff);//disable ints from uart
; Line 220
	*** 00048f	8b 56 12 		mov	dx,WORD PTR [bp+18]	;base
	*** 000492	83 c2 1b 		add	dx,27	;001bH
	*** 000495	ee 			out	dx, al

;|***     outp(base+PIM,0xff);//disable ints from universal port
; Line 221
	*** 000496	8b 56 12 		mov	dx,WORD PTR [bp+18]	;base
	*** 000499	83 c2 1d 		add	dx,29	;001dH
	*** 00049c	ee 			out	dx, al

;|***     i = inp(0x21);
; Line 222
	*** 00049d	e4 21 			in	al,33	;0021H
	*** 00049f	89 46 fe 		mov	WORD PTR [bp-2],ax	;i
;|***     if(irq ==3) i = i&0xf7;
; Line 223
	*** 0004a2	83 ff 03 		cmp	di,3
	*** 0004a5	75 05 			jne	$I1492
	*** 0004a7	81 66 fe f7 00 		and	WORD PTR [bp-2],247	;00f7H	;i
;|***     if(irq ==4) i = i&0xef;
; Line 224
					$I1492:
	*** 0004ac	83 ff 04 		cmp	di,4
	*** 0004af	75 05 			jne	$I1493
	*** 0004b1	81 66 fe ef 00 		and	WORD PTR [bp-2],239	;00efH	;i
;|***     if(irq ==5) i = i&0xdf;
; Line 225
					$I1493:
	*** 0004b6	83 ff 05 		cmp	di,5
	*** 0004b9	75 05 			jne	$I1494
	*** 0004bb	81 66 fe df 00 		and	WORD PTR [bp-2],223	;00dfH	;i
;|***     if(irq ==6) i = i&0xbf;
; Line 226
					$I1494:
	*** 0004c0	83 ff 06 		cmp	di,6
	*** 0004c3	75 05 			jne	$I1495
	*** 0004c5	81 66 fe bf 00 		and	WORD PTR [bp-2],191	;00bfH	;i
;|***     if(irq ==7) i = i&0x7f;
; Line 227
					$I1495:
	*** 0004ca	83 ff 07 		cmp	di,7
	*** 0004cd	75 04 			jne	$I1496
	*** 0004cf	83 66 fe 7f 		and	WORD PTR [bp-2],127	;007fH	;i
;|***     outp(0x21,i);
; Line 228
					$I1496:
	*** 0004d3	8b 46 fe 		mov	ax,WORD PTR [bp-2]	;i
	*** 0004d6	e6 21 			out	33	;0021H, al

;|***     }
;|*** 
;|***   if(irq>8)
; Line 231
					$I1491:
	*** 0004d8	83 ff 08 		cmp	di,8
	*** 0004db	76 76 			jbe	$I1497
;|***     {
;|***     old_service_routines[next_irq] = _dos_getvect(irq+0x70 -8);
; Line 233
	*** 0004dd	8d 45 68 		lea	ax,WORD PTR [di+104]
	*** 0004e0	50 			push	ax
	*** 0004e1	9a 00 00 00 00 		call	FAR PTR __dos_getvect
	*** 0004e6	83 c4 02 		add	sp,2
	*** 0004e9	8e 46 08 		mov	es,WORD PTR [bp+8]
	*** 0004ec	26 8b 5c 76 		mov	bx,WORD PTR es:[si+118]
	*** 0004f0	c1 e3 02 		shl	bx,2
	*** 0004f3	26 89 40 34 		mov	WORD PTR es:[bx+52][si],ax
	*** 0004f7	26 89 50 36 		mov	WORD PTR es:[bx+54][si],dx
;|***     _dos_setvect(irq+0x70-8,escc_isr);
; Line 234
	*** 0004fb	68 00 00 		push	SEG ?escc_isr@Cescc@@JEAXXZ	;Cescc::escc_isr
	*** 0004fe	68 00 00 		push	OFFSET ?escc_isr@Cescc@@JEAXXZ	;Cescc::escc_isr
	*** 000501	8d 45 68 		lea	ax,WORD PTR [di+104]
	*** 000504	50 			push	ax
	*** 000505	9a 00 00 00 00 		call	FAR PTR __dos_setvect
	*** 00050a	83 c4 06 		add	sp,6
;|***     i = inp(0xa1);
; Line 235
	*** 00050d	e4 a1 			in	al,161	;00a1H
	*** 00050f	2a e4 			sub	ah,ah
	*** 000511	89 46 fe 		mov	WORD PTR [bp-2],ax	;i
;|***     if(irq ==9)         i = i&0xfd;
; Line 236
	*** 000514	83 ff 09 		cmp	di,9
	*** 000517	75 05 			jne	$I1498
	*** 000519	81 66 fe fd 00 		and	WORD PTR [bp-2],253	;00fdH	;i
;|***     if(irq ==10)        i = i&0xfb;
; Line 237
					$I1498:
	*** 00051e	83 ff 0a 		cmp	di,10	;000aH
	*** 000521	75 05 			jne	$I1499
	*** 000523	81 66 fe fb 00 		and	WORD PTR [bp-2],251	;00fbH	;i
;|***     if(irq ==11)        i = i&0xf7;
; Line 238
					$I1499:
	*** 000528	83 ff 0b 		cmp	di,11	;000bH
	*** 00052b	75 05 			jne	$I1500
	*** 00052d	81 66 fe f7 00 		and	WORD PTR [bp-2],247	;00f7H	;i
;|***     if(irq ==12)        i = i&0xef;
; Line 239
					$I1500:
	*** 000532	83 ff 0c 		cmp	di,12	;000cH
	*** 000535	75 05 			jne	$I1501
	*** 000537	81 66 fe ef 00 		and	WORD PTR [bp-2],239	;00efH	;i
;|***     if(irq ==15)        i = i&0x7f;
; Line 240
					$I1501:
	*** 00053c	83 ff 0f 		cmp	di,15	;000fH
	*** 00053f	75 04 			jne	$I1502
	*** 000541	83 66 fe 7f 		and	WORD PTR [bp-2],127	;007fH	;i
;|***     outp(0xa1,i);
; Line 241
					$I1502:
	*** 000545	8b 46 fe 		mov	ax,WORD PTR [bp-2]	;i
	*** 000548	e6 a1 			out	161	;00a1H, al

;|***     upper_irq = 1;
; Line 242
	*** 00054a	8e 46 08 		mov	es,WORD PTR [bp+8]
	*** 00054d	26 c7 44 78 01 00 	mov	WORD PTR es:[si+120],1
;|***     }
;|***     
;|***   _enable();
; Line 245
					$I1497:
	*** 000553	fb 			sti	
;|*** 
;|***   hooked_irqs[next_irq] = irq;
; Line 247
	*** 000554	8e 46 08 		mov	es,WORD PTR [bp+8]
	*** 000557	26 8b 5c 76 		mov	bx,WORD PTR es:[si+118]
	*** 00055b	03 db 			add	bx,bx
	*** 00055d	26 89 78 14 		mov	WORD PTR es:[bx+20][si],di
;|***   next_irq++;
; Line 248
	*** 000561	26 ff 44 76 		inc	WORD PTR es:[si+118]
;|*** 
;|***   //note we will wait until we get the init_port call before enabling the ints at the uart
;|***   //this will prevent bad things from happening like not having a buffer to put data in !!:)  
;|***   skip_irqsetup:
; Line 252
					$skip_irqsetup1489:
;|***   if(avail==next_port) next_port++;
; Line 253
	*** 000565	8b 46 f8 		mov	ax,WORD PTR [bp-8]	;avail
	*** 000568	8e 46 08 		mov	es,WORD PTR [bp+8]
	*** 00056b	26 39 44 74 		cmp	WORD PTR es:[si+116],ax
	*** 00056f	75 04 			jne	$I1503
	*** 000571	26 ff 44 74 		inc	WORD PTR es:[si+116]
;|***   return (avail);
; Line 254
					$I1503:
	*** 000575	8b 46 f8 		mov	ax,WORD PTR [bp-8]	;avail
;|***   }     //  end add_port()
; Line 255
	*** 000578	5e 			pop	si
	*** 000579	5f 			pop	di
	*** 00057a	c9 			leave	
	*** 00057b	ca 0e 00 		ret	14	;0000000eH
	*** 00057e	90 			nop	
	*** 00057f	90 			nop	

?add_port@Cescc@@RECIIIIII@Z	ENDP
	PUBLIC	?kill_port@Cescc@@RECII@Z	; Cescc::kill_port
?kill_port@Cescc@@RECII@Z	PROC FAR	; Cescc::kill_port
;|*** 
;|*** 
;|*** 
;|*** 
;|*** unsigned Cescc::kill_port(unsigned port)
;|***   {
; Line 261
	*** 000580	c8 0a 00 00 		enter	10,0
	*** 000584	57 			push	di
	*** 000585	56 			push	si
;	port = 10
;	this = 6
;	i = -6
	*** 000586	8b 7e 0a 		mov	di,WORD PTR [bp+10]	;port
	*** 000589	c4 5e 06 		les	bx,DWORD PTR [bp+6]	;this
;|***   //here we should set the port list stuff to 0, and unhook the irq
;|***   //walk the port list and check the irq to see if any other ports are using it, if not then 
;|***   //unhook the irq, and mask it at the pic
;|***   
;|***   unsigned i;
;|***   
;|***   //free the buffers for this port
;|***   for(i=0;i<max_rxbuf[port];i++)
; Line 269
	*** 00058c	33 c9 			xor	cx,cx
	*** 00058e	8b f3 			mov	si,bx
	*** 000590	8b c7 			mov	ax,di
	*** 000592	03 c7 			add	ax,di
	*** 000594	89 46 f8 		mov	WORD PTR [bp-8],ax
	*** 000597	03 f0 			add	si,ax
	*** 000599	26 39 8c 82 01 		cmp	WORD PTR es:[si+386],cx
	*** 00059e	74 4b 			je	$FB1510
	*** 0005a0	8b c7 			mov	ax,di
	*** 0005a2	c1 e0 06 		shl	ax,6
	*** 0005a5	03 c3 			add	ax,bx
	*** 0005a7	05 7a 00 		add	ax,122	;007aH
	*** 0005aa	8c 46 fe 		mov	WORD PTR [bp-2],es
	*** 0005ad	8b f8 			mov	di,ax
	*** 0005af	8b f1 			mov	si,cx
					$F1508:
;|***     {
;|***     _ffree(rxbuffer[port][i]);
; Line 271
	*** 0005b1	8e 46 fe 		mov	es,WORD PTR [bp-2]
	*** 0005b4	26 ff 75 02 		push	WORD PTR es:[di+2]
	*** 0005b8	26 ff 35 		push	WORD PTR es:[di]
	*** 0005bb	9a 00 00 00 00 		call	FAR PTR __ffree
	*** 0005c0	83 c4 04 		add	sp,4
;|***     rxbuffer[port][i] = NULL; //wipe them since they are now gone
; Line 272
	*** 0005c3	8e 46 fe 		mov	es,WORD PTR [bp-2]
	*** 0005c6	8b df 			mov	bx,di
	*** 0005c8	83 c7 04 		add	di,4
	*** 0005cb	2b c0 			sub	ax,ax
	*** 0005cd	26 89 47 02 		mov	WORD PTR es:[bx+2],ax
	*** 0005d1	26 89 07 		mov	WORD PTR es:[bx],ax
	*** 0005d4	46 			inc	si
	*** 0005d5	8b 5e f8 		mov	bx,WORD PTR [bp-8]
	*** 0005d8	8e 46 08 		mov	es,WORD PTR [bp+8]
	*** 0005db	03 5e 06 		add	bx,WORD PTR [bp+6]	;this
	*** 0005de	26 39 b7 82 01 		cmp	WORD PTR es:[bx+386],si
	*** 0005e3	77 cc 			ja	$F1508
	*** 0005e5	8b 5e 06 		mov	bx,WORD PTR [bp+6]	;this
	*** 0005e8	8b 7e 0a 		mov	di,WORD PTR [bp+10]	;port
;|***     }
; Line 273
					$FB1510:
;|***     
;|***   for(i=0;i<max_txbuf[port];i++)
; Line 275
	*** 0005eb	33 c9 			xor	cx,cx
	*** 0005ed	8b f3 			mov	si,bx
	*** 0005ef	03 76 f8 		add	si,WORD PTR [bp-8]
	*** 0005f2	26 39 8c 86 01 		cmp	WORD PTR es:[si+390],cx
	*** 0005f7	74 4b 			je	$FB1513
	*** 0005f9	8b c7 			mov	ax,di
	*** 0005fb	c1 e0 06 		shl	ax,6
	*** 0005fe	03 c3 			add	ax,bx
	*** 000600	05 fa 00 		add	ax,250	;00faH
	*** 000603	8c 46 fe 		mov	WORD PTR [bp-2],es
	*** 000606	8b f8 			mov	di,ax
	*** 000608	8b f1 			mov	si,cx
					$F1511:
;|***     {
;|***     _ffree(txbuffer[port][i]);
; Line 277
	*** 00060a	8e 46 fe 		mov	es,WORD PTR [bp-2]
	*** 00060d	26 ff 75 02 		push	WORD PTR es:[di+2]
	*** 000611	26 ff 35 		push	WORD PTR es:[di]
	*** 000614	9a 00 00 00 00 		call	FAR PTR __ffree
	*** 000619	83 c4 04 		add	sp,4
;|***     txbuffer[port][i] = NULL;
; Line 278
	*** 00061c	8e 46 fe 		mov	es,WORD PTR [bp-2]
	*** 00061f	8b df 			mov	bx,di
	*** 000621	83 c7 04 		add	di,4
	*** 000624	2b c0 			sub	ax,ax
	*** 000626	26 89 47 02 		mov	WORD PTR es:[bx+2],ax
	*** 00062a	26 89 07 		mov	WORD PTR es:[bx],ax
	*** 00062d	46 			inc	si
	*** 00062e	8b 5e f8 		mov	bx,WORD PTR [bp-8]
	*** 000631	8e 46 08 		mov	es,WORD PTR [bp+8]
	*** 000634	03 5e 06 		add	bx,WORD PTR [bp+6]	;this
	*** 000637	26 39 b7 86 01 		cmp	WORD PTR es:[bx+390],si
	*** 00063c	77 cc 			ja	$F1511
	*** 00063e	8b 5e 06 		mov	bx,WORD PTR [bp+6]	;this
	*** 000641	8b 7e 0a 		mov	di,WORD PTR [bp+10]	;port
;|***     }
; Line 279
					$FB1513:
;|***   
;|***   //we are done with the base address so kill the links
;|***   outp(port_list[port]+PVR,(inp(port_list[port]+PVR)&0xfe)+channel[port]); //set current channel (a or b)
; Line 282
	*** 000644	8b f3 			mov	si,bx
	*** 000646	03 76 f8 		add	si,WORD PTR [bp-8]
	*** 000649	26 8b 14 		mov	dx,WORD PTR es:[si]
	*** 00064c	8b c2 			mov	ax,dx
	*** 00064e	83 c2 1c 		add	dx,28	;001cH
	*** 000651	8b c8 			mov	cx,ax
	*** 000653	8b c6 			mov	ax,si
	*** 000655	8d b7 9a 01 		lea	si,WORD PTR [bx+410]
	*** 000659	03 76 f8 		add	si,WORD PTR [bp-8]
	*** 00065c	89 46 f6 		mov	WORD PTR [bp-10],ax
	*** 00065f	ec 			in	al,dx
	*** 000660	25 fe 00 		and	ax,254	;00feH
	*** 000663	26 03 04 		add	ax,WORD PTR es:[si]
	*** 000666	ee 			out	dx, al

;|***   outp(port_list[port]+IMR0,0xff); //turn off channel specific interrupts
; Line 283
	*** 000667	8b d1 			mov	dx,cx
	*** 000669	83 c2 1a 		add	dx,26	;001aH
	*** 00066c	b8 ff 00 		mov	ax,255	;00ffH
	*** 00066f	ee 			out	dx, al

;|***   outp(port_list[port]+IMR1,0xff);
; Line 284
	*** 000670	8b d1 			mov	dx,cx
	*** 000672	83 c2 1b 		add	dx,27	;001bH
	*** 000675	ee 			out	dx, al

;|***   //should also turn off DSR/DTR interrupts here...since we will no longer have the port address
;|***   //after the next line and if it fires we will have a stuck int line.
;|***   //need Interrupt masks stored somewhere since we cannot read them back (write only)
;|*** 
;|***   port_list[port] = 0;
;|***   port_open_list[port] = 0;
; Line 290
	*** 000676	8b 76 f6 		mov	si,WORD PTR [bp-10]
	*** 000679	33 c0 			xor	ax,ax
	*** 00067b	26 89 04 		mov	WORD PTR es:[si],ax
	*** 00067e	26 89 44 04 		mov	WORD PTR es:[si+4],ax
;|***   port_dmar_list[port] = 0;
;|***   port_dmat_list[port] = 0;
; Line 292
	*** 000682	26 89 44 10 		mov	WORD PTR es:[si+16],ax
	*** 000686	26 89 44 0c 		mov	WORD PTR es:[si+12],ax
;|***   interrupt_list[port] = 0;
; Line 293
	*** 00068a	26 89 44 08 		mov	WORD PTR es:[si+8],ax
;|***   
;|***   if(port == (next_port-1)) next_port--; //if it was the last port then we can safely decrement the
; Line 295
	*** 00068e	26 8b 47 74 		mov	ax,WORD PTR es:[bx+116]
	*** 000692	2b c7 			sub	ax,di
	*** 000694	48 			dec	ax
	*** 000695	75 04 			jne	$I1514
	*** 000697	26 ff 4f 74 		dec	WORD PTR es:[bx+116]
;|***                                          //next_port specifier
;|***   return TRUE;
; Line 297
					$I1514:
	*** 00069b	33 c0 			xor	ax,ax
;|***   }  // end kill_port()
; Line 298
	*** 00069d	5e 			pop	si
	*** 00069e	5f 			pop	di
	*** 00069f	c9 			leave	
	*** 0006a0	ca 06 00 		ret	6
	*** 0006a3	90 			nop	

?kill_port@Cescc@@RECII@Z	ENDP
	PUBLIC	?init_port@Cescc@@RECIIIPEUescc_regs@@II@Z	; Cescc::init_port
?init_port@Cescc@@RECIIIPEUescc_regs@@II@Z	PROC FAR	; Cescc::init_port
;|*** 
;|*** 
;|*** 
;|*** 
;|*** unsigned Cescc::init_port(  unsigned port,
;|***               unsigned opmode,
;|***               struct escc_regs *esccregs,
;|***               unsigned rbufs,
;|***               unsigned tbufs)
;|***   {
; Line 308
	*** 0006a4	c8 0e 00 00 		enter	14,0
	*** 0006a8	57 			push	di
	*** 0006a9	56 			push	si
;	timeout_cntr = -4
;	port = 20
;	opmode = 18
;	esccregs = 14
;	rbufs = 12
;	tbufs = 10
;	this = 6
;	i = -8
	*** 0006aa	8b 5e 0c 		mov	bx,WORD PTR [bp+12]	;rbufs
;|***   //set the port (from the list, make sure it is in the list...) to the settings given
;|***   //probably a good idea to verify all params before continuing
;|***   //set up the registers and reset the 82526 here
;|***   if(rbufs<2) return FALSE;
; Line 312
	*** 0006ad	83 fb 02 		cmp	bx,2
	*** 0006b0	73 06 			jae	$I1522
					$L2311:
	*** 0006b2	b8 01 00 		mov	ax,1
	*** 0006b5	e9 17 06 		jmp	$EX1521
;|***   if(rbufs>MAX_RBUFS) return FALSE;
; Line 313
					$I1522:
	*** 0006b8	83 fb 10 		cmp	bx,16	;0010H
	*** 0006bb	77 f5 			ja	$L2311
;|***   if(tbufs<2) return FALSE;        
; Line 314
	*** 0006bd	8b 5e 0a 		mov	bx,WORD PTR [bp+10]	;tbufs
	*** 0006c0	83 fb 02 		cmp	bx,2
	*** 0006c3	72 ed 			jb	$L2311
;|***   if(tbufs>MAX_TBUFS) return FALSE;
; Line 315
	*** 0006c5	83 fb 10 		cmp	bx,16	;0010H
	*** 0006c8	77 e8 			ja	$L2311
;|***   if((opmode!=OPMODE_HDLC)&&(opmode!=OPMODE_BISYNC)&&(opmode!=OPMODE_ASYNC)) return FALSE;
; Line 316
	*** 0006ca	8b 5e 12 		mov	bx,WORD PTR [bp+18]	;opmode
	*** 0006cd	0b db 			or	bx,bx
	*** 0006cf	74 0a 			je	$I1526
	*** 0006d1	83 fb 02 		cmp	bx,2
	*** 0006d4	74 05 			je	$I1526
	*** 0006d6	83 fb 01 		cmp	bx,1
	*** 0006d9	75 d7 			jne	$L2311
;|***   
;|***   //allocate the memory for the buffers
;|***   //unsigned long datasize;      
;|***   unsigned i;
; Line 320
					$I1526:
;|***   for(i=0;i<max_rxbuf[port];i++)
; Line 321
	*** 0006db	33 c9 			xor	cx,cx
	*** 0006dd	8b 76 14 		mov	si,WORD PTR [bp+20]	;port
	*** 0006e0	03 f6 			add	si,si
	*** 0006e2	89 76 f6 		mov	WORD PTR [bp-10],si
	*** 0006e5	c4 5e 06 		les	bx,DWORD PTR [bp+6]	;this
	*** 0006e8	26 39 88 82 01 		cmp	WORD PTR es:[bx+386][si],cx
	*** 0006ed	74 4c 			je	$FB1530
	*** 0006ef	8b 46 14 		mov	ax,WORD PTR [bp+20]	;port
	*** 0006f2	c1 e0 06 		shl	ax,6
	*** 0006f5	03 c3 			add	ax,bx
	*** 0006f7	05 7a 00 		add	ax,122	;007aH
	*** 0006fa	89 46 fc 		mov	WORD PTR [bp-4],ax	;timeout_cntr
	*** 0006fd	8c 46 fe 		mov	WORD PTR [bp-2],es
	*** 000700	89 4e f8 		mov	WORD PTR [bp-8],cx	;i
	*** 000703	8b f8 			mov	di,ax
	*** 000705	8b f1 			mov	si,cx
					$F1528:
;|***     {
;|***     _ffree(rxbuffer[port][i]);//just in case this isn't the first call to here
; Line 323
	*** 000707	8e 46 fe 		mov	es,WORD PTR [bp-2]
	*** 00070a	26 ff 75 02 		push	WORD PTR es:[di+2]
	*** 00070e	26 ff 35 		push	WORD PTR es:[di]
	*** 000711	9a 00 00 00 00 		call	FAR PTR __ffree
	*** 000716	83 c4 04 		add	sp,4
;|***     rxbuffer[port][i]=NULL;   
; Line 324
	*** 000719	8e 46 fe 		mov	es,WORD PTR [bp-2]
	*** 00071c	8b df 			mov	bx,di
	*** 00071e	83 c7 04 		add	di,4
	*** 000721	2b c0 			sub	ax,ax
	*** 000723	26 89 47 02 		mov	WORD PTR es:[bx+2],ax
	*** 000727	26 89 07 		mov	WORD PTR es:[bx],ax
	*** 00072a	46 			inc	si
	*** 00072b	8b 5e f6 		mov	bx,WORD PTR [bp-10]
	*** 00072e	8e 46 08 		mov	es,WORD PTR [bp+8]
	*** 000731	03 5e 06 		add	bx,WORD PTR [bp+6]	;this
	*** 000734	26 39 b7 82 01 		cmp	WORD PTR es:[bx+386],si
	*** 000739	77 cc 			ja	$F1528
;|***     }                       
; Line 325
					$FB1530:
;|***   
;|***   for(i=0;i<max_txbuf[port];i++)
; Line 327
	*** 00073b	33 c9 			xor	cx,cx
	*** 00073d	8b 76 06 		mov	si,WORD PTR [bp+6]	;this
	*** 000740	8b 7e 14 		mov	di,WORD PTR [bp+20]	;port
	*** 000743	8b de 			mov	bx,si
	*** 000745	03 5e f6 		add	bx,WORD PTR [bp-10]
	*** 000748	26 39 8f 86 01 		cmp	WORD PTR es:[bx+390],cx
	*** 00074d	74 51 			je	$FB1533
	*** 00074f	8b c7 			mov	ax,di
	*** 000751	c1 e0 06 		shl	ax,6
	*** 000754	03 c6 			add	ax,si
	*** 000756	05 fa 00 		add	ax,250	;00faH
	*** 000759	89 46 fc 		mov	WORD PTR [bp-4],ax	;timeout_cntr
	*** 00075c	8c 46 fe 		mov	WORD PTR [bp-2],es
	*** 00075f	89 4e f8 		mov	WORD PTR [bp-8],cx	;i
	*** 000762	8b f8 			mov	di,ax
	*** 000764	8b f1 			mov	si,cx
					$F1531:
;|***     {
;|***     _ffree(txbuffer[port][i]);//just in case this isn't the first call to here
; Line 329
	*** 000766	8e 46 fe 		mov	es,WORD PTR [bp-2]
	*** 000769	26 ff 75 02 		push	WORD PTR es:[di+2]
	*** 00076d	26 ff 35 		push	WORD PTR es:[di]
	*** 000770	9a 00 00 00 00 		call	FAR PTR __ffree
	*** 000775	83 c4 04 		add	sp,4
;|***     txbuffer[port][i]=NULL;
; Line 330
	*** 000778	8e 46 fe 		mov	es,WORD PTR [bp-2]
	*** 00077b	8b df 			mov	bx,di
	*** 00077d	83 c7 04 		add	di,4
	*** 000780	2b c0 			sub	ax,ax
	*** 000782	26 89 47 02 		mov	WORD PTR es:[bx+2],ax
	*** 000786	26 89 07 		mov	WORD PTR es:[bx],ax
	*** 000789	46 			inc	si
	*** 00078a	8b 5e f6 		mov	bx,WORD PTR [bp-10]
	*** 00078d	8e 46 08 		mov	es,WORD PTR [bp+8]
	*** 000790	03 5e 06 		add	bx,WORD PTR [bp+6]	;this
	*** 000793	26 39 b7 86 01 		cmp	WORD PTR es:[bx+390],si
	*** 000798	77 cc 			ja	$F1531
	*** 00079a	8b 76 06 		mov	si,WORD PTR [bp+6]	;this
	*** 00079d	8b 7e 14 		mov	di,WORD PTR [bp+20]	;port
;|***     }
; Line 331
					$FB1533:
;|*** 
;|***   //datasize = (unsigned long)rbufs * sizeof(struct buf);
;|***   for(i=0;i<rbufs;i++)
; Line 334
	*** 0007a0	33 c9 			xor	cx,cx
	*** 0007a2	39 4e 0c 		cmp	WORD PTR [bp+12],cx	;rbufs
	*** 0007a5	74 4a 			je	$FB1536
	*** 0007a7	8b c7 			mov	ax,di
	*** 0007a9	c1 e0 06 		shl	ax,6
	*** 0007ac	03 c6 			add	ax,si
	*** 0007ae	05 7a 00 		add	ax,122	;007aH
	*** 0007b1	89 46 fc 		mov	WORD PTR [bp-4],ax	;timeout_cntr
	*** 0007b4	8c 46 fe 		mov	WORD PTR [bp-2],es
	*** 0007b7	89 4e f8 		mov	WORD PTR [bp-8],cx	;i
	*** 0007ba	8b f8 			mov	di,ax
	*** 0007bc	8b f1 			mov	si,cx
					$F1534:
	*** 0007be	68 06 04 		push	1030	;0406H
	*** 0007c1	9a 00 00 00 00 		call	FAR PTR __fmalloc
	*** 0007c6	83 c4 02 		add	sp,2
	*** 0007c9	8e 46 fe 		mov	es,WORD PTR [bp-2]
	*** 0007cc	26 89 05 		mov	WORD PTR es:[di],ax
	*** 0007cf	26 89 55 02 		mov	WORD PTR es:[di+2],dx
;|***     {
;|***     rxbuffer[port][i] = (struct buf huge *)_fmalloc(sizeof(struct buf)); //create rxbuffers for this port
;|***     if(rxbuffer[port][i]==NULL) return FALSE;                            //something failed
; Line 337
	*** 0007d3	8e 46 fe 		mov	es,WORD PTR [bp-2]
	*** 0007d6	26 8b 45 02 		mov	ax,WORD PTR es:[di+2]
	*** 0007da	26 0b 05 		or	ax,WORD PTR es:[di]
	*** 0007dd	75 03 			jne	$JCC2013
	*** 0007df	e9 d0 fe 		jmp	$L2311
					$JCC2013:
;|***   for(i=0;i<rbufs;i++)
; Line 334
	*** 0007e2	83 c7 04 		add	di,4
	*** 0007e5	46 			inc	si
	*** 0007e6	3b 76 0c 		cmp	si,WORD PTR [bp+12]	;rbufs
	*** 0007e9	72 d3 			jb	$F1534
	*** 0007eb	8b 76 06 		mov	si,WORD PTR [bp+6]	;this
	*** 0007ee	8b 7e 14 		mov	di,WORD PTR [bp+20]	;port
					$FB1536:
;|***     {
;|***     rxbuffer[port][i] = (struct buf huge *)_fmalloc(sizeof(struct buf)); //create rxbuffers for this port
;|***     if(rxbuffer[port][i]==NULL) return FALSE;                            //something failed
;|***     }
;|***   
;|***   //datasize = (unsigned long)tbufs * sizeof(struct buf);
;|***   for(i=0;i<tbufs;i++)
; Line 341
	*** 0007f1	c7 46 f8 00 00 		mov	WORD PTR [bp-8],0	;i
	*** 0007f6	83 7e 0a 00 		cmp	WORD PTR [bp+10],0	;tbufs
	*** 0007fa	74 4b 			je	$FB1542
	*** 0007fc	8b c7 			mov	ax,di
	*** 0007fe	c1 e0 06 		shl	ax,6
	*** 000801	03 c6 			add	ax,si
	*** 000803	05 fa 00 		add	ax,250	;00faH
	*** 000806	8b 4e 08 		mov	cx,WORD PTR [bp+8]
	*** 000809	89 46 fc 		mov	WORD PTR [bp-4],ax	;timeout_cntr
	*** 00080c	89 4e fe 		mov	WORD PTR [bp-2],cx
	*** 00080f	8b f8 			mov	di,ax
	*** 000811	8b 76 f8 		mov	si,WORD PTR [bp-8]	;i
					$F1540:
	*** 000814	68 06 04 		push	1030	;0406H
	*** 000817	9a 00 00 00 00 		call	FAR PTR __fmalloc
	*** 00081c	83 c4 02 		add	sp,2
	*** 00081f	8e 46 fe 		mov	es,WORD PTR [bp-2]
	*** 000822	26 89 05 		mov	WORD PTR es:[di],ax
	*** 000825	26 89 55 02 		mov	WORD PTR es:[di+2],dx
;|***     {
;|***     txbuffer[port][i] = (struct buf huge *)_fmalloc(sizeof(struct buf)); //create txbuffers for this port     
;|***     if(txbuffer[port][i]==NULL) return FALSE;
; Line 344
	*** 000829	8e 46 fe 		mov	es,WORD PTR [bp-2]
	*** 00082c	26 8b 45 02 		mov	ax,WORD PTR es:[di+2]
	*** 000830	26 0b 05 		or	ax,WORD PTR es:[di]
	*** 000833	75 03 			jne	$JCC2099
	*** 000835	e9 7a fe 		jmp	$L2311
					$JCC2099:
;|***   for(i=0;i<tbufs;i++)
; Line 341
	*** 000838	83 c7 04 		add	di,4
	*** 00083b	46 			inc	si
	*** 00083c	3b 76 0a 		cmp	si,WORD PTR [bp+10]	;tbufs
	*** 00083f	72 d3 			jb	$F1540
	*** 000841	8b 76 06 		mov	si,WORD PTR [bp+6]	;this
	*** 000844	8b 7e 14 		mov	di,WORD PTR [bp+20]	;port
					$FB1542:
;|***     {
;|***     txbuffer[port][i] = (struct buf huge *)_fmalloc(sizeof(struct buf)); //create txbuffers for this port     
;|***     if(txbuffer[port][i]==NULL) return FALSE;
;|***     }
;|***     
;|***   current_rxbuf[port] = 0;
;|***   current_txbuf[port] = 0;
; Line 348
	*** 000847	33 c0 			xor	ax,ax
	*** 000849	8b de 			mov	bx,si
	*** 00084b	03 5e f6 		add	bx,WORD PTR [bp-10]
	*** 00084e	8e 46 08 		mov	es,WORD PTR [bp+8]
	*** 000851	26 89 87 7a 01 		mov	WORD PTR es:[bx+378],ax
	*** 000856	26 89 87 7e 01 		mov	WORD PTR es:[bx+382],ax
;|***   max_rxbuf[port] = rbufs;
; Line 349
	*** 00085b	8b 4e 0c 		mov	cx,WORD PTR [bp+12]	;rbufs
	*** 00085e	26 89 8f 82 01 		mov	WORD PTR es:[bx+386],cx
;|***   max_txbuf[port] = tbufs;
; Line 350
	*** 000863	8b 56 0a 		mov	dx,WORD PTR [bp+10]	;tbufs
	*** 000866	26 89 97 86 01 		mov	WORD PTR es:[bx+390],dx
;|*** 
;|***   for(i=0;i<rbufs;i++)
; Line 352
	*** 00086b	89 46 f8 		mov	WORD PTR [bp-8],ax	;i
	*** 00086e	3b c8 			cmp	cx,ax
	*** 000870	76 3a 			jbe	$FB1548
	*** 000872	8b c7 			mov	ax,di
	*** 000874	c1 e0 06 		shl	ax,6
	*** 000877	03 c6 			add	ax,si
	*** 000879	05 7a 00 		add	ax,122	;007aH
	*** 00087c	8b 4e 08 		mov	cx,WORD PTR [bp+8]
	*** 00087f	89 46 fc 		mov	WORD PTR [bp-4],ax	;timeout_cntr
	*** 000882	8e d9 			mov	ds,cx
	ASSUME DS: NOTHING
	*** 000884	8b 46 0c 		mov	ax,WORD PTR [bp+12]	;rbufs
	*** 000887	8b 5e fc 		mov	bx,WORD PTR [bp-4]	;timeout_cntr
	*** 00088a	8b c8 			mov	cx,ax
					$F1546:
;|***     {
;|***     rxbuffer[port][i]->valid = 0;
; Line 354
	*** 00088c	c4 37 			les	si,DWORD PTR [bx]
	*** 00088e	26 c7 04 00 00 		mov	WORD PTR es:[si],0
;|***     rxbuffer[port][i]->no_bytes = 0;
; Line 355
	*** 000893	c4 37 			les	si,DWORD PTR [bx]
	*** 000895	26 c7 44 02 00 00 	mov	WORD PTR es:[si+2],0
;|***     rxbuffer[port][i]->max = 0;
; Line 356
	*** 00089b	c4 37 			les	si,DWORD PTR [bx]
	*** 00089d	83 c3 04 		add	bx,4
	*** 0008a0	26 c7 44 04 00 00 	mov	WORD PTR es:[si+4],0
	*** 0008a6	49 			dec	cx
	*** 0008a7	75 e3 			jne	$F1546
	*** 0008a9	8b 7e 14 		mov	di,WORD PTR [bp+20]	;port
;|***     }
; Line 357
					$FB1548:
;|***   
;|***   for(i=0;i<tbufs;i++)
; Line 359
	*** 0008ac	c7 46 f8 00 00 		mov	WORD PTR [bp-8],0	;i
	*** 0008b1	83 7e 0a 00 		cmp	WORD PTR [bp+10],0	;tbufs
	*** 0008b5	74 3b 			je	$FB1551
	*** 0008b7	8b c7 			mov	ax,di
	*** 0008b9	c1 e0 06 		shl	ax,6
	*** 0008bc	03 46 06 		add	ax,WORD PTR [bp+6]	;this
	*** 0008bf	8b 56 08 		mov	dx,WORD PTR [bp+8]
	*** 0008c2	05 fa 00 		add	ax,250	;00faH
	*** 0008c5	89 46 fc 		mov	WORD PTR [bp-4],ax	;timeout_cntr
	*** 0008c8	8e da 			mov	ds,dx
	ASSUME DS: NOTHING
	*** 0008ca	8b 46 0a 		mov	ax,WORD PTR [bp+10]	;tbufs
	*** 0008cd	8b 5e fc 		mov	bx,WORD PTR [bp-4]	;timeout_cntr
	*** 0008d0	8b c8 			mov	cx,ax
					$F1549:
;|***     {
;|***     txbuffer[port][i]->valid = 0;      //valid indicates data (1) or garbage (0)
; Line 361
	*** 0008d2	c4 37 			les	si,DWORD PTR [bx]
	*** 0008d4	26 c7 04 00 00 		mov	WORD PTR es:[si],0
;|***     txbuffer[port][i]->no_bytes = 0;   //no_bytes is the number of bytes in the frame <= FRAME_SIZE
; Line 362
	*** 0008d9	c4 37 			les	si,DWORD PTR [bx]
	*** 0008db	26 c7 44 02 00 00 	mov	WORD PTR es:[si+2],0
;|***     txbuffer[port][i]->max = 0;        //max is the number of bytes to be tx'ed this time <= 32
; Line 363
	*** 0008e1	c4 37 			les	si,DWORD PTR [bx]
	*** 0008e3	83 c3 04 		add	bx,4
	*** 0008e6	26 c7 44 04 00 00 	mov	WORD PTR es:[si+4],0
	*** 0008ec	49 			dec	cx
	*** 0008ed	75 e3 			jne	$F1549
	*** 0008ef	8b 7e 14 		mov	di,WORD PTR [bp+20]	;port
;|***     }
; Line 364
					$FB1551:
	*** 0008f2	16 			push	ss
	*** 0008f3	1f 			pop	ds
	ASSUME DS: DGROUP
	*** 0008f4	8b 76 06 		mov	si,WORD PTR [bp+6]	;this
;|*** 
;|***   //set channel for this port; PVR bit0 selects channel A (bit0 = 0) or B (bit0 = 1)
;|***   outp(port_list[port]+PVR,(inp(port_list[port]+PVR)&0xfe)+channel[port]);  //select channel A or B
; Line 367
	*** 0008f7	8b de 			mov	bx,si
	*** 0008f9	03 5e f6 		add	bx,WORD PTR [bp-10]
	*** 0008fc	8e 46 08 		mov	es,WORD PTR [bp+8]
	*** 0008ff	26 8b 17 		mov	dx,WORD PTR es:[bx]
	*** 000902	83 c2 1c 		add	dx,28	;001cH
	*** 000905	ec 			in	al,dx
	*** 000906	25 fe 00 		and	ax,254	;00feH
	*** 000909	8b cb 			mov	cx,bx
	*** 00090b	8b de 			mov	bx,si
	*** 00090d	03 5e f6 		add	bx,WORD PTR [bp-10]
	*** 000910	26 03 87 9a 01 		add	ax,WORD PTR es:[bx+410]
	*** 000915	ee 			out	dx, al

;|*** 
;|***   eopmode[port] = opmode;
; Line 369
	*** 000916	8b d9 			mov	bx,cx
	*** 000918	8b 46 12 		mov	ax,WORD PTR [bp+18]	;opmode
	*** 00091b	26 89 87 9e 01 		mov	WORD PTR es:[bx+414],ax
;|*** 
;|***   if(opmode == OPMODE_ASYNC)    //ASYNC not used by LN200 or biphase-M 5/18/98
; Line 371
	*** 000920	48 			dec	ax
	*** 000921	74 03 			je	$JCC2337
	*** 000923	e9 99 00 		jmp	$I1552
					$JCC2337:
;|***     {
;|***     outp(port_list[port]+MODE,esccregs->mode);
; Line 373
	*** 000926	c4 5e 0e 		les	bx,DWORD PTR [bp+14]	;esccregs
	*** 000929	26 8b 47 02 		mov	ax,WORD PTR es:[bx+2]
	*** 00092d	8b de 			mov	bx,si
	*** 00092f	03 5e f6 		add	bx,WORD PTR [bp-10]
	*** 000932	8e 46 08 		mov	es,WORD PTR [bp+8]
	*** 000935	26 8b 17 		mov	dx,WORD PTR es:[bx]
	*** 000938	8b ca 			mov	cx,dx
	*** 00093a	83 c2 02 		add	dx,2
	*** 00093d	ee 			out	dx, al

;|***     outp(port_list[port]+TIMR,esccregs->timr);
; Line 374
	*** 00093e	8b d1 			mov	dx,cx
	*** 000940	83 c2 03 		add	dx,3
	*** 000943	c4 5e 0e 		les	bx,DWORD PTR [bp+14]	;esccregs
	*** 000946	26 8b 47 04 		mov	ax,WORD PTR es:[bx+4]
	*** 00094a	ee 			out	dx, al

;|***     outp(port_list[port]+TCR,esccregs->tcr);
; Line 375
	*** 00094b	26 8b 47 34 		mov	ax,WORD PTR es:[bx+52]
	*** 00094f	8b d1 			mov	dx,cx
	*** 000951	83 c2 06 		add	dx,6
	*** 000954	ee 			out	dx, al

;|***     outp(port_list[port]+DAFO,esccregs->dafo);
; Line 376
	*** 000955	26 8b 47 36 		mov	ax,WORD PTR es:[bx+54]
	*** 000959	8b d1 			mov	dx,cx
	*** 00095b	83 c2 07 		add	dx,7
	*** 00095e	ee 			out	dx, al

;|***     outp(port_list[port]+RFC,esccregs->rfc);
; Line 377
	*** 00095f	26 8b 47 38 		mov	ax,WORD PTR es:[bx+56]
	*** 000963	8b d1 			mov	dx,cx
	*** 000965	83 c2 08 		add	dx,8
	*** 000968	ee 			out	dx, al

;|***     outp(port_list[port]+XBCL,esccregs->xbcl);
; Line 378
	*** 000969	26 8b 47 06 		mov	ax,WORD PTR es:[bx+6]
	*** 00096d	8b d1 			mov	dx,cx
	*** 00096f	83 c2 0a 		add	dx,10	;000aH
	*** 000972	ee 			out	dx, al

;|***     outp(port_list[port]+XBCH,esccregs->xbch);
; Line 379
	*** 000973	26 8b 47 08 		mov	ax,WORD PTR es:[bx+8]
	*** 000977	8b d1 			mov	dx,cx
	*** 000979	83 c2 0b 		add	dx,11	;000bH
	*** 00097c	ee 			out	dx, al

;|***     outp(port_list[port]+CCR0,esccregs->ccr0);
; Line 380
	*** 00097d	26 8b 47 0a 		mov	ax,WORD PTR es:[bx+10]
	*** 000981	8b d1 			mov	dx,cx
	*** 000983	83 c2 0c 		add	dx,12	;000cH
	*** 000986	ee 			out	dx, al

;|***     outp(port_list[port]+CCR1,esccregs->ccr1);
; Line 381
	*** 000987	26 8b 47 0c 		mov	ax,WORD PTR es:[bx+12]
	*** 00098b	8b d1 			mov	dx,cx
	*** 00098d	83 c2 0d 		add	dx,13	;000dH
	*** 000990	ee 			out	dx, al

;|***     outp(port_list[port]+CCR2,esccregs->ccr2);
; Line 382
	*** 000991	26 8b 47 0e 		mov	ax,WORD PTR es:[bx+14]
	*** 000995	8b d1 			mov	dx,cx
	*** 000997	83 c2 0e 		add	dx,14	;000eH
	*** 00099a	ee 			out	dx, al

;|***     outp(port_list[port]+BGR,esccregs->bgr);
; Line 383
	*** 00099b	26 8b 47 14 		mov	ax,WORD PTR es:[bx+20]
	*** 00099f	8b d1 			mov	dx,cx
	*** 0009a1	83 c2 14 		add	dx,20	;0014H
	*** 0009a4	ee 			out	dx, al

;|***     outp(port_list[port]+PVR,(esccregs->pvr&0xfe)+channel[port]);
; Line 384
	*** 0009a5	26 8a 47 1e 		mov	al,BYTE PTR es:[bx+30]
	*** 0009a9	25 fe 00 		and	ax,254	;00feH
	*** 0009ac	8b de 			mov	bx,si
	*** 0009ae	03 5e f6 		add	bx,WORD PTR [bp-10]
	*** 0009b1	8e 46 08 		mov	es,WORD PTR [bp+8]
	*** 0009b4	26 03 87 9a 01 		add	ax,WORD PTR es:[bx+410]
	*** 0009b9	8b d1 			mov	dx,cx
	*** 0009bb	83 c2 1c 		add	dx,28	;001cH
	*** 0009be	ee 			out	dx, al

;|***     }
;|*** 
;|***   if(opmode==OPMODE_HDLC)
; Line 387
					$I1552:
	*** 0009bf	83 7e 12 00 		cmp	WORD PTR [bp+18],0	;opmode
	*** 0009c3	74 03 			je	$JCC2499
	*** 0009c5	e9 dd 00 		jmp	$I1553
					$JCC2499:
;|***     {
;|***     //this is mode specific to hdlc/sdlc...need to do various things for different modes
;|***     //copy the regset to the escc in question
;|***     //outp(port_list[port]+register,esccregs->register);
;|*** 
;|***     outp(port_list[port]+CCR4,esccregs->ccr4); //code to access CCR4 for biphase-M
; Line 393
	*** 0009c8	c4 5e 0e 		les	bx,DWORD PTR [bp+14]	;esccregs
	*** 0009cb	26 8b 47 12 		mov	ax,WORD PTR es:[bx+18]
	*** 0009cf	8b de 			mov	bx,si
	*** 0009d1	03 5e f6 		add	bx,WORD PTR [bp-10]
	*** 0009d4	8e 46 08 		mov	es,WORD PTR [bp+8]
	*** 0009d7	26 8b 17 		mov	dx,WORD PTR es:[bx]
	*** 0009da	8b ca 			mov	cx,dx
	*** 0009dc	83 c2 1f 		add	dx,31	;001fH
	*** 0009df	ee 			out	dx, al

;|***     
;|***     outp(port_list[port]+MODE,esccregs->mode);
; Line 395
	*** 0009e0	8b d1 			mov	dx,cx
	*** 0009e2	83 c2 02 		add	dx,2
	*** 0009e5	c4 5e 0e 		les	bx,DWORD PTR [bp+14]	;esccregs
	*** 0009e8	26 8b 47 02 		mov	ax,WORD PTR es:[bx+2]
	*** 0009ec	ee 			out	dx, al

;|***     outp(port_list[port]+TIMR,esccregs->timr);
; Line 396
	*** 0009ed	26 8b 47 04 		mov	ax,WORD PTR es:[bx+4]
	*** 0009f1	8b d1 			mov	dx,cx
	*** 0009f3	83 c2 03 		add	dx,3
	*** 0009f6	ee 			out	dx, al

;|***     outp(port_list[port]+XAD1,esccregs->xad1);
; Line 397
	*** 0009f7	26 8b 47 24 		mov	ax,WORD PTR es:[bx+36]
	*** 0009fb	8b d1 			mov	dx,cx
	*** 0009fd	83 c2 04 		add	dx,4
	*** 000a00	ee 			out	dx, al

;|***     outp(port_list[port]+XAD2,esccregs->xad2);
; Line 398
	*** 000a01	26 8b 47 26 		mov	ax,WORD PTR es:[bx+38]
	*** 000a05	8b d1 			mov	dx,cx
	*** 000a07	83 c2 05 		add	dx,5
	*** 000a0a	ee 			out	dx, al

;|***     outp(port_list[port]+RAH1,esccregs->rah1);
; Line 399
	*** 000a0b	26 8b 47 28 		mov	ax,WORD PTR es:[bx+40]
	*** 000a0f	8b d1 			mov	dx,cx
	*** 000a11	83 c2 06 		add	dx,6
	*** 000a14	ee 			out	dx, al

;|***     outp(port_list[port]+RAH2,esccregs->rah2);
; Line 400
	*** 000a15	26 8b 47 2a 		mov	ax,WORD PTR es:[bx+42]
	*** 000a19	8b d1 			mov	dx,cx
	*** 000a1b	83 c2 07 		add	dx,7
	*** 000a1e	ee 			out	dx, al

;|***     outp(port_list[port]+RAL1,esccregs->ral1);
; Line 401
	*** 000a1f	26 8b 47 2c 		mov	ax,WORD PTR es:[bx+44]
	*** 000a23	8b d1 			mov	dx,cx
	*** 000a25	83 c2 08 		add	dx,8
	*** 000a28	ee 			out	dx, al

;|***     outp(port_list[port]+RAL2,esccregs->ral2);
; Line 402
	*** 000a29	26 8b 47 2e 		mov	ax,WORD PTR es:[bx+46]
	*** 000a2d	8b d1 			mov	dx,cx
	*** 000a2f	83 c2 09 		add	dx,9
	*** 000a32	ee 			out	dx, al

;|***     outp(port_list[port]+XBCL,esccregs->xbcl);
; Line 403
	*** 000a33	26 8b 47 06 		mov	ax,WORD PTR es:[bx+6]
	*** 000a37	8b d1 			mov	dx,cx
	*** 000a39	83 c2 0a 		add	dx,10	;000aH
	*** 000a3c	ee 			out	dx, al

;|***     outp(port_list[port]+XBCH,esccregs->xbch);
; Line 404
	*** 000a3d	26 8b 47 08 		mov	ax,WORD PTR es:[bx+8]
	*** 000a41	8b d1 			mov	dx,cx
	*** 000a43	83 c2 0b 		add	dx,11	;000bH
	*** 000a46	ee 			out	dx, al

;|***     outp(port_list[port]+CCR0,esccregs->ccr0);
; Line 405
	*** 000a47	26 8b 47 0a 		mov	ax,WORD PTR es:[bx+10]
	*** 000a4b	8b d1 			mov	dx,cx
	*** 000a4d	83 c2 0c 		add	dx,12	;000cH
	*** 000a50	ee 			out	dx, al

;|***     outp(port_list[port]+CCR1,esccregs->ccr1);
; Line 406
	*** 000a51	26 8b 47 0c 		mov	ax,WORD PTR es:[bx+12]
	*** 000a55	8b d1 			mov	dx,cx
	*** 000a57	83 c2 0d 		add	dx,13	;000dH
	*** 000a5a	ee 			out	dx, al

;|***     outp(port_list[port]+CCR2,esccregs->ccr2);
; Line 407
	*** 000a5b	26 8b 47 0e 		mov	ax,WORD PTR es:[bx+14]
	*** 000a5f	8b d1 			mov	dx,cx
	*** 000a61	83 c2 0e 		add	dx,14	;000eH
	*** 000a64	ee 			out	dx, al

;|***     outp(port_list[port]+CCR3,esccregs->ccr3);
; Line 408
	*** 000a65	26 8b 47 10 		mov	ax,WORD PTR es:[bx+16]
	*** 000a69	8b d1 			mov	dx,cx
	*** 000a6b	83 c2 0f 		add	dx,15	;000fH
	*** 000a6e	ee 			out	dx, al

;|***     outp(port_list[port]+BGR,esccregs->bgr);
; Line 409
	*** 000a6f	26 8b 47 14 		mov	ax,WORD PTR es:[bx+20]
	*** 000a73	8b d1 			mov	dx,cx
	*** 000a75	83 c2 14 		add	dx,20	;0014H
	*** 000a78	ee 			out	dx, al

;|***     outp(port_list[port]+RLCR,esccregs->rlcr);
; Line 410
	*** 000a79	26 8b 47 30 		mov	ax,WORD PTR es:[bx+48]
	*** 000a7d	8b d1 			mov	dx,cx
	*** 000a7f	83 c2 15 		add	dx,21	;0015H
	*** 000a82	ee 			out	dx, al

;|***     outp(port_list[port]+PRE,esccregs->pre);
; Line 411
	*** 000a83	26 8b 47 32 		mov	ax,WORD PTR es:[bx+50]
	*** 000a87	8b d1 			mov	dx,cx
	*** 000a89	42 			inc	dx
	*** 000a8a	ee 			out	dx, al

;|***     outp(port_list[port]+PVR,(esccregs->pvr&0xfe)+channel[port]);
; Line 412
	*** 000a8b	26 8a 47 1e 		mov	al,BYTE PTR es:[bx+30]
	*** 000a8f	25 fe 00 		and	ax,254	;00feH
	*** 000a92	8b de 			mov	bx,si
	*** 000a94	03 5e f6 		add	bx,WORD PTR [bp-10]
	*** 000a97	8e 46 08 		mov	es,WORD PTR [bp+8]
	*** 000a9a	26 03 87 9a 01 		add	ax,WORD PTR es:[bx+410]
	*** 000a9f	8b d1 			mov	dx,cx
	*** 000aa1	83 c2 1c 		add	dx,28	;001cH
	*** 000aa4	ee 			out	dx, al

;|***     }
;|*** 
;|***   if(opmode == OPMODE_BISYNC)
; Line 415
					$I1553:
	*** 000aa5	83 7e 12 02 		cmp	WORD PTR [bp+18],2	;opmode
	*** 000aa9	74 03 			je	$JCC2729
	*** 000aab	e9 bf 00 		jmp	$I1554
					$JCC2729:
;|***     {
;|***     outp(port_list[port]+MODE,esccregs->mode);
; Line 417
	*** 000aae	c4 5e 0e 		les	bx,DWORD PTR [bp+14]	;esccregs
	*** 000ab1	26 8b 47 02 		mov	ax,WORD PTR es:[bx+2]
	*** 000ab5	8b de 			mov	bx,si
	*** 000ab7	03 5e f6 		add	bx,WORD PTR [bp-10]
	*** 000aba	8e 46 08 		mov	es,WORD PTR [bp+8]
	*** 000abd	26 8b 17 		mov	dx,WORD PTR es:[bx]
	*** 000ac0	8b ca 			mov	cx,dx
	*** 000ac2	83 c2 02 		add	dx,2
	*** 000ac5	ee 			out	dx, al

;|***     outp(port_list[port]+TIMR,esccregs->timr);
; Line 418
	*** 000ac6	8b d1 			mov	dx,cx
	*** 000ac8	83 c2 03 		add	dx,3
	*** 000acb	c4 5e 0e 		les	bx,DWORD PTR [bp+14]	;esccregs
	*** 000ace	26 8b 47 04 		mov	ax,WORD PTR es:[bx+4]
	*** 000ad2	ee 			out	dx, al

;|***     outp(port_list[port]+XAD1,esccregs->synl);
; Line 419
	*** 000ad3	26 8b 47 3a 		mov	ax,WORD PTR es:[bx+58]
	*** 000ad7	8b d1 			mov	dx,cx
	*** 000ad9	83 c2 04 		add	dx,4
	*** 000adc	ee 			out	dx, al

;|***     outp(port_list[port]+XAD2,esccregs->synh);
; Line 420
	*** 000add	26 8b 47 3c 		mov	ax,WORD PTR es:[bx+60]
	*** 000ae1	8b d1 			mov	dx,cx
	*** 000ae3	83 c2 05 		add	dx,5
	*** 000ae6	ee 			out	dx, al

;|***     outp(port_list[port]+RAH1,esccregs->tcr);
; Line 421
	*** 000ae7	26 8b 47 34 		mov	ax,WORD PTR es:[bx+52]
	*** 000aeb	8b d1 			mov	dx,cx
	*** 000aed	83 c2 06 		add	dx,6
	*** 000af0	ee 			out	dx, al

;|***     outp(port_list[port]+RAH2,esccregs->dafo);
; Line 422
	*** 000af1	26 8b 47 36 		mov	ax,WORD PTR es:[bx+54]
	*** 000af5	8b d1 			mov	dx,cx
	*** 000af7	83 c2 07 		add	dx,7
	*** 000afa	ee 			out	dx, al

;|***     outp(port_list[port]+RAL1,esccregs->rfc);
; Line 423
	*** 000afb	26 8b 47 38 		mov	ax,WORD PTR es:[bx+56]
	*** 000aff	8b d1 			mov	dx,cx
	*** 000b01	83 c2 08 		add	dx,8
	*** 000b04	ee 			out	dx, al

;|***     outp(port_list[port]+XBCL,esccregs->xbcl);
; Line 424
	*** 000b05	26 8b 47 06 		mov	ax,WORD PTR es:[bx+6]
	*** 000b09	8b d1 			mov	dx,cx
	*** 000b0b	83 c2 0a 		add	dx,10	;000aH
	*** 000b0e	ee 			out	dx, al

;|***     outp(port_list[port]+XBCH,esccregs->xbch);
; Line 425
	*** 000b0f	26 8b 47 08 		mov	ax,WORD PTR es:[bx+8]
	*** 000b13	8b d1 			mov	dx,cx
	*** 000b15	83 c2 0b 		add	dx,11	;000bH
	*** 000b18	ee 			out	dx, al

;|***     outp(port_list[port]+CCR0,esccregs->ccr0);
; Line 426
	*** 000b19	26 8b 47 0a 		mov	ax,WORD PTR es:[bx+10]
	*** 000b1d	8b d1 			mov	dx,cx
	*** 000b1f	83 c2 0c 		add	dx,12	;000cH
	*** 000b22	ee 			out	dx, al

;|***     outp(port_list[port]+CCR1,esccregs->ccr1);
; Line 427
	*** 000b23	26 8b 47 0c 		mov	ax,WORD PTR es:[bx+12]
	*** 000b27	8b d1 			mov	dx,cx
	*** 000b29	83 c2 0d 		add	dx,13	;000dH
	*** 000b2c	ee 			out	dx, al

;|***     outp(port_list[port]+CCR2,esccregs->ccr2);
; Line 428
	*** 000b2d	26 8b 47 0e 		mov	ax,WORD PTR es:[bx+14]
	*** 000b31	8b d1 			mov	dx,cx
	*** 000b33	83 c2 0e 		add	dx,14	;000eH
	*** 000b36	ee 			out	dx, al

;|***     outp(port_list[port]+CCR3,esccregs->ccr3);
; Line 429
	*** 000b37	26 8b 47 10 		mov	ax,WORD PTR es:[bx+16]
	*** 000b3b	8b d1 			mov	dx,cx
	*** 000b3d	83 c2 0f 		add	dx,15	;000fH
	*** 000b40	ee 			out	dx, al

;|***     outp(port_list[port]+BGR,esccregs->bgr);
; Line 430
	*** 000b41	26 8b 47 14 		mov	ax,WORD PTR es:[bx+20]
	*** 000b45	8b d1 			mov	dx,cx
	*** 000b47	83 c2 14 		add	dx,20	;0014H
	*** 000b4a	ee 			out	dx, al

;|***     outp(port_list[port]+PRE,esccregs->pre);
; Line 431
	*** 000b4b	26 8b 47 32 		mov	ax,WORD PTR es:[bx+50]
	*** 000b4f	8b d1 			mov	dx,cx
	*** 000b51	42 			inc	dx
	*** 000b52	ee 			out	dx, al

;|***     outp(port_list[port]+PVR,(esccregs->pvr&0xfe)+channel[port]);
; Line 432
	*** 000b53	26 8a 47 1e 		mov	al,BYTE PTR es:[bx+30]
	*** 000b57	25 fe 00 		and	ax,254	;00feH
	*** 000b5a	8b de 			mov	bx,si
	*** 000b5c	03 5e f6 		add	bx,WORD PTR [bp-10]
	*** 000b5f	8e 46 08 		mov	es,WORD PTR [bp+8]
	*** 000b62	26 03 87 9a 01 		add	ax,WORD PTR es:[bx+410]
	*** 000b67	8b d1 			mov	dx,cx
	*** 000b69	83 c2 1c 		add	dx,28	;001cH
	*** 000b6c	ee 			out	dx, al

;|***     }
;|*** 
;|***   //not really necessary because it will be done in txframe but just in case....
;|***   if(port_dmar_list[port]!=0) setupdmar(port,rxbuffer[port][current_rxbuf[port]]->frame);
; Line 436
					$I1554:
	*** 000b6d	8b de 			mov	bx,si
	*** 000b6f	8e 46 08 		mov	es,WORD PTR [bp+8]
	*** 000b72	83 c3 10 		add	bx,16	;0010H
	*** 000b75	03 5e f6 		add	bx,WORD PTR [bp-10]
	*** 000b78	26 83 3f 00 		cmp	WORD PTR es:[bx],0
	*** 000b7c	74 2e 			je	$I1555
	*** 000b7e	57 			push	di
	*** 000b7f	8d 9c 7a 01 		lea	bx,WORD PTR [si+378]
	*** 000b83	03 5e f6 		add	bx,WORD PTR [bp-10]
	*** 000b86	26 8b 07 		mov	ax,WORD PTR es:[bx]
	*** 000b89	8b df 			mov	bx,di
	*** 000b8b	c1 e3 04 		shl	bx,4
	*** 000b8e	8b cb 			mov	cx,bx
	*** 000b90	8b d8 			mov	bx,ax
	*** 000b92	03 d9 			add	bx,cx
	*** 000b94	c1 e3 02 		shl	bx,2
	*** 000b97	03 de 			add	bx,si
	*** 000b99	26 8b 4f 7a 		mov	cx,WORD PTR es:[bx+122]
	*** 000b9d	26 8b 57 7c 		mov	dx,WORD PTR es:[bx+124]
	*** 000ba1	83 c1 06 		add	cx,6
	*** 000ba4	52 			push	dx
	*** 000ba5	51 			push	cx
	*** 000ba6	06 			push	es
	*** 000ba7	56 			push	si
	*** 000ba8	0e 			push	cs
	*** 000ba9	e8 00 00 		call	NEAR PTR ?setupdmar@Cescc@@JECXIPEX@Z	; Cescc::setupdmar
;|***   if(port_dmat_list[port]!=0) setupdmat(port,txbuffer[port][current_txbuf[port]]->frame,FRAME_SIZE);
; Line 437
					$I1555:
	*** 000bac	8b de 			mov	bx,si
	*** 000bae	8e 46 08 		mov	es,WORD PTR [bp+8]
	*** 000bb1	83 c3 0c 		add	bx,12	;000cH
	*** 000bb4	03 5e f6 		add	bx,WORD PTR [bp-10]
	*** 000bb7	26 83 3f 00 		cmp	WORD PTR es:[bx],0
	*** 000bbb	74 33 			je	$I1556
	*** 000bbd	57 			push	di
	*** 000bbe	8d 9c 7e 01 		lea	bx,WORD PTR [si+382]
	*** 000bc2	03 5e f6 		add	bx,WORD PTR [bp-10]
	*** 000bc5	26 8b 07 		mov	ax,WORD PTR es:[bx]
	*** 000bc8	8b df 			mov	bx,di
	*** 000bca	c1 e3 04 		shl	bx,4
	*** 000bcd	8b cb 			mov	cx,bx
	*** 000bcf	8b d8 			mov	bx,ax
	*** 000bd1	03 d9 			add	bx,cx
	*** 000bd3	c1 e3 02 		shl	bx,2
	*** 000bd6	03 de 			add	bx,si
	*** 000bd8	26 8b 8f fa 00 		mov	cx,WORD PTR es:[bx+250]
	*** 000bdd	26 8b 97 fc 00 		mov	dx,WORD PTR es:[bx+252]
	*** 000be2	83 c1 06 		add	cx,6
	*** 000be5	52 			push	dx
	*** 000be6	51 			push	cx
	*** 000be7	68 00 04 		push	1024	;0400H
	*** 000bea	06 			push	es
	*** 000beb	56 			push	si
	*** 000bec	0e 			push	cs
	*** 000bed	e8 00 00 		call	NEAR PTR ?setupdmat@Cescc@@JECXIPEXI@Z	; Cescc::setupdmat
;|***   
;|***   outp(port_list[port]+CMDR,XRES);//reset transmitter
; Line 439
					$I1556:
	*** 000bf0	b8 01 00 		mov	ax,1
	*** 000bf3	8b de 			mov	bx,si
	*** 000bf5	03 5e f6 		add	bx,WORD PTR [bp-10]
	*** 000bf8	8e 46 08 		mov	es,WORD PTR [bp+8]
	*** 000bfb	26 8b 17 		mov	dx,WORD PTR es:[bx]
	*** 000bfe	ee 			out	dx, al

;|***   
;|***   unsigned long timeout_cntr = 0;
; Line 441
	*** 000bff	2b c0 			sub	ax,ax
	*** 000c01	89 46 fe 		mov	WORD PTR [bp-2],ax
	*** 000c04	89 46 fc 		mov	WORD PTR [bp-4],ax	;timeout_cntr
;|*** 
;|***   while((inp(port_list[port]+STAR)&CEC)==CEC)
; Line 443
					$FC1559:
	*** 000c07	8b de 			mov	bx,si
	*** 000c09	03 5e f6 		add	bx,WORD PTR [bp-10]
	*** 000c0c	26 8b 17 		mov	dx,WORD PTR es:[bx]
	*** 000c0f	ec 			in	al,dx
	*** 000c10	24 04 			and	al,4
	*** 000c12	3c 04 			cmp	al,4
	*** 000c14	75 34 			jne	$FB1560
;|***     {
;|***     timeout_cntr++;
;|***     if(timeout_cntr>1000000)
; Line 446
	*** 000c16	83 46 fc 01 		add	WORD PTR [bp-4],1	;timeout_cntr
	*** 000c1a	83 56 fe 00 		adc	WORD PTR [bp-2],0
	*** 000c1e	83 7e fe 0f 		cmp	WORD PTR [bp-2],15	;000fH
	*** 000c22	72 e3 			jb	$FC1559
	*** 000c24	77 07 			ja	$L2140
	*** 000c26	81 7e fc 40 42 		cmp	WORD PTR [bp-4],16960	;4240H	;timeout_cntr
	*** 000c2b	76 da 			jbe	$FC1559
					$L2140:
;|***       {
;|***       //bad error condition here must indicate that we are not ready for business
;|***       outp(port_list[port]+IMR0,0xff);
; Line 449
	*** 000c2d	8b de 			mov	bx,si
	*** 000c2f	03 5e f6 		add	bx,WORD PTR [bp-10]
	*** 000c32	26 8b 17 		mov	dx,WORD PTR es:[bx]
	*** 000c35	8b c2 			mov	ax,dx
	*** 000c37	83 c2 1a 		add	dx,26	;001aH
	*** 000c3a	8b c8 			mov	cx,ax
	*** 000c3c	b8 ff 00 		mov	ax,255	;00ffH
	*** 000c3f	ee 			out	dx, al

;|***       outp(port_list[port]+IMR1,0xff);
; Line 450
	*** 000c40	8b d1 			mov	dx,cx
	*** 000c42	83 c2 1b 		add	dx,27	;001bH
	*** 000c45	ee 			out	dx, al

	*** 000c46	e9 69 fa 		jmp	$L2311
	*** 000c49	90 			nop	
;|***       return FALSE;
;|***       }
;|***     }//wait for CEC = 0//need a timeout loop here (only wait so long...now it could be infinite if no txclock input to hscx)
; Line 453
					$FB1560:
;|***   
;|***   outp(port_list[port]+CMDR,RHR); //reset receiver
; Line 455
	*** 000c4a	8b de 			mov	bx,si
	*** 000c4c	03 5e f6 		add	bx,WORD PTR [bp-10]
	*** 000c4f	b8 40 00 		mov	ax,64	;0040H
	*** 000c52	26 8b 17 		mov	dx,WORD PTR es:[bx]
	*** 000c55	ee 			out	dx, al

;|***   timeout_cntr=0;
; Line 456
	*** 000c56	2b c0 			sub	ax,ax
	*** 000c58	89 46 fe 		mov	WORD PTR [bp-2],ax
	*** 000c5b	89 46 fc 		mov	WORD PTR [bp-4],ax	;timeout_cntr
;|***   while((inp(port_list[port]+STAR)&CEC)==CEC)
; Line 457
					$FC1563:
	*** 000c5e	8b de 			mov	bx,si
	*** 000c60	03 5e f6 		add	bx,WORD PTR [bp-10]
	*** 000c63	26 8b 17 		mov	dx,WORD PTR es:[bx]
	*** 000c66	ec 			in	al,dx
	*** 000c67	24 04 			and	al,4
	*** 000c69	3c 04 			cmp	al,4
	*** 000c6b	75 19 			jne	$FB1564
;|***     {
;|***     timeout_cntr++;
;|***     if(timeout_cntr>1000000)
; Line 460
	*** 000c6d	83 46 fc 01 		add	WORD PTR [bp-4],1	;timeout_cntr
	*** 000c71	83 56 fe 00 		adc	WORD PTR [bp-2],0
	*** 000c75	83 7e fe 0f 		cmp	WORD PTR [bp-2],15	;000fH
	*** 000c79	72 e3 			jb	$FC1563
	*** 000c7b	77 b0 			ja	$L2140
	*** 000c7d	81 7e fc 40 42 		cmp	WORD PTR [bp-4],16960	;4240H	;timeout_cntr
	*** 000c82	76 da 			jbe	$FC1563
	*** 000c84	eb a7 			jmp	SHORT $L2140
;|***       {
;|***       //bad error condition here must indicate that we are not ready for business
;|***       outp(port_list[port]+IMR0,0xff);//mask all interrupts 
;|***       outp(port_list[port]+IMR1,0xff);
;|***       return FALSE;
;|***       }
;|***     }//wait for CEC = 0//need a timeout loop here (only wait so long...now it could be infinite if no txclock input to hscx)
; Line 467
					$FB1564:
;|*** 
;|***   port_open_list[port] = 1;  //flag this port open
; Line 469
	*** 000c86	8b 5e 06 		mov	bx,WORD PTR [bp+6]	;this
	*** 000c89	03 5e f6 		add	bx,WORD PTR [bp-10]
	*** 000c8c	26 c7 47 04 01 00 	mov	WORD PTR es:[bx+4],1
	*** 000c92	8b f3 			mov	si,bx
	*** 000c94	8b 5e 0e 		mov	bx,WORD PTR [bp+14]	;esccregs
;|***   
;|***   outp(port_list[port]+IMR0,esccregs->imr0);//flame on, unmask escc interrupts
; Line 471
	*** 000c97	26 8b 14 		mov	dx,WORD PTR es:[si]
	*** 000c9a	8b c2 			mov	ax,dx
	*** 000c9c	83 c2 1a 		add	dx,26	;001aH
	*** 000c9f	8e 5e 10 		mov	ds,WORD PTR [bp+16]
	ASSUME DS: NOTHING
	*** 000ca2	8b c8 			mov	cx,ax
	*** 000ca4	8b 47 1a 		mov	ax,WORD PTR [bx+26]
	*** 000ca7	ee 			out	dx, al

;|***   outp(port_list[port]+IMR1,esccregs->imr1);
; Line 472
	*** 000ca8	8b 47 1c 		mov	ax,WORD PTR [bx+28]
	*** 000cab	8b d1 			mov	dx,cx
	*** 000cad	83 c2 1b 		add	dx,27	;001bH
	*** 000cb0	ee 			out	dx, al

;|***   outp(port_list[port]+PIM,esccregs->pim);
; Line 473
	*** 000cb1	8b 47 20 		mov	ax,WORD PTR [bx+32]
	*** 000cb4	8b d1 			mov	dx,cx
	*** 000cb6	83 c2 1d 		add	dx,29	;001dH
	*** 000cb9	ee 			out	dx, al

;|***   
;|***   if(opmode==OPMODE_BISYNC) outp(port_list[port]+CMDR,HUNT);//start receive engine...search for SYN
; Line 475
	*** 000cba	83 7e 12 02 		cmp	WORD PTR [bp+18],2	;opmode
	*** 000cbe	75 0d 			jne	$I1566
	*** 000cc0	b8 04 00 		mov	ax,4
	*** 000cc3	8b 5e 06 		mov	bx,WORD PTR [bp+6]	;this
	*** 000cc6	8b 76 f6 		mov	si,WORD PTR [bp-10]
	*** 000cc9	26 8b 10 		mov	dx,WORD PTR es:[bx][si]
	*** 000ccc	ee 			out	dx, al

;|***   if(esccregs->cmdr !=0);//could write the command if we wanted to but we won't for now
; Line 476
					$I1566:
;|***   return TRUE;
; Line 477
	*** 000ccd	33 c0 			xor	ax,ax
;|***   }  //  end init_port()
; Line 478
					$EX1521:
	*** 000ccf	16 			push	ss
	*** 000cd0	1f 			pop	ds
	ASSUME DS: DGROUP
	*** 000cd1	5e 			pop	si
	*** 000cd2	5f 			pop	di
	*** 000cd3	c9 			leave	
	*** 000cd4	ca 10 00 		ret	16	;00000010H
	*** 000cd7	90 			nop	

?init_port@Cescc@@RECIIIPEUescc_regs@@II@Z	ENDP
	PUBLIC	?rx_port@Cescc@@RECIIPEDI@Z	; Cescc::rx_port
?rx_port@Cescc@@RECIIPEDI@Z	PROC FAR	; Cescc::rx_port
;|*** 
;|*** 
;|*** 
;|*** 
;|*** 
;|*** 
;|*** unsigned Cescc::rx_port(unsigned port,char far *buf, unsigned num_bytes)
;|***   {
; Line 486
	*** 000cd8	c8 0a 00 00 		enter	10,0
	*** 000cdc	57 			push	di
	*** 000cdd	56 			push	si
;	port = 16
;	buf = 12
;	num_bytes = 10
;	this = 6
;	i = -4
;	j = -2
	*** 000cde	c5 4e 06 		lds	cx,DWORD PTR [bp+6]	;this
	ASSUME DS: NOTHING
	*** 000ce1	8b 7e 10 		mov	di,WORD PTR [bp+16]	;port
;|***   //returns the number of bytes transfered to buf (one frame worth)
;|***   //retval = rxbuffer[port][next_rbuf].no_bytes
;|***   //buf = rxbuffer[port][next_rbuf].frame
;|***   //rxbuffer[port][next_rbuf].valid = 0;
;|***   // next_rbuf++;
;|***   // if (next_rbuf > max_rbufs) next_rbuf =0 ;
;|***   unsigned i,j;
;|***   
;|***   // select channel A or B
;|***   outp(port_list[port]+PVR,(inp(port_list[port]+PVR)&0xfe)+channel[port]);
; Line 496
	*** 000ce4	8b f7 			mov	si,di
	*** 000ce6	03 f7 			add	si,di
	*** 000ce8	8b d9 			mov	bx,cx
	*** 000cea	89 76 fa 		mov	WORD PTR [bp-6],si
	*** 000ced	8b 10 			mov	dx,WORD PTR [bx][si]
	*** 000cef	81 c3 9a 01 		add	bx,410	;019aH
	*** 000cf3	83 c2 1c 		add	dx,28	;001cH
	*** 000cf6	ec 			in	al,dx
	*** 000cf7	25 fe 00 		and	ax,254	;00feH
	*** 000cfa	03 00 			add	ax,WORD PTR [bx][si]
	*** 000cfc	ee 			out	dx, al

;|***   
;|***   // this is the section for autonomous model jtm
;|***   if((eopmode[port]==OPMODE_HDLC)||(eopmode[port]==OPMODE_BISYNC))
; Line 499
	*** 000cfd	8b d9 			mov	bx,cx
	*** 000cff	81 c3 9e 01 		add	bx,414	;019eH
	*** 000d03	83 38 00 		cmp	WORD PTR [bx][si],0
	*** 000d06	75 03 			jne	$JCC3334
	*** 000d08	e9 db 00 		jmp	$I1576
					$JCC3334:
	*** 000d0b	8b d9 			mov	bx,cx
	*** 000d0d	81 c3 9e 01 		add	bx,414	;019eH
	*** 000d11	83 38 02 		cmp	WORD PTR [bx][si],2
	*** 000d14	75 03 			jne	$JCC3348
	*** 000d16	e9 cd 00 		jmp	$I1576
					$JCC3348:
;|***     {
;|***     // select the escc buffer pool assigned to this channel
;|***     i = current_rxbuf[port];
;|***     i++;
;|***     if(i==max_rxbuf[port]) i = 0;
;|***     
;|***     // step through the buffer pool to see if any has a message
;|***     do{
;|***       if(rxbuffer[port][i]->valid == 1)
;|***         {
;|***         // this escc buffer claims it has a message
;|***         // check for error conditions
;|***         // fail if the escc buffer holds more than the user's buffer can hold
;|***         if(rxbuffer[port][i]->no_bytes > num_bytes) return 0;
;|***         
;|***         // user's buffer is ok so copy the message over
;|***         for(j=0;j<rxbuffer[port][i]->no_bytes;j++)
;|***           {
;|***           buf[j] = (rxbuffer[port][i]->frame[j]);
;|***           }
;|***         
;|***         // release the escc buffer to be used again  
;|***         rxbuffer[port][i]->valid = 0;
;|***         
;|***         // tell the user how many chars were in the message
;|***         return j;
;|***         }
;|***       
;|***       i++; // this escc buffer has no message so try the next one
;|***       
;|***       //wrap back to 0 if at end of buffer pool
;|***       if(i==max_rxbuf[port])i = 0;
;|***       
;|***       // repeat the do loop until you've checked all the buffers
;|***       // or until you find one with a message
;|***       }while(i!=current_rxbuf[port]);
;|***     
;|***     // tell the user that no messages were found
;|***     return 0;
;|***     }
;|*** 
;|***   if(eopmode[port]==OPMODE_ASYNC)
; Line 541
	*** 000d19	8b d9 			mov	bx,cx
	*** 000d1b	81 c3 9e 01 		add	bx,414	;019eH
	*** 000d1f	83 38 01 		cmp	WORD PTR [bx][si],1
	*** 000d22	75 4e 			jne	$L2317
;|***     {
;|***     i = current_rxbuf[port];
;|***     i++;
; Line 544
	*** 000d24	8b d9 			mov	bx,cx
	*** 000d26	81 c3 7a 01 		add	bx,378	;017aH
	*** 000d2a	03 de 			add	bx,si
	*** 000d2c	8b 07 			mov	ax,WORD PTR [bx]
	*** 000d2e	40 			inc	ax
	*** 000d2f	8b f0 			mov	si,ax
;|***     if(i==max_rxbuf[port]) i = 0;
; Line 545
	*** 000d31	8b d9 			mov	bx,cx
	*** 000d33	81 c3 82 01 		add	bx,386	;0182H
	*** 000d37	03 5e fa 		add	bx,WORD PTR [bp-6]
	*** 000d3a	3b 07 			cmp	ax,WORD PTR [bx]
	*** 000d3c	75 02 			jne	$L2142
	*** 000d3e	33 f6 			xor	si,si
					$L2142:
;|***     do{
;|***       if(rxbuffer[port][i]->valid ==1)
; Line 547
	*** 000d40	8b df 			mov	bx,di
	*** 000d42	c1 e3 04 		shl	bx,4
	*** 000d45	03 de 			add	bx,si
	*** 000d47	c1 e3 02 		shl	bx,2
	*** 000d4a	03 d9 			add	bx,cx
	*** 000d4c	c4 5f 7a 		les	bx,DWORD PTR [bx+122]
	*** 000d4f	26 83 3f 01 		cmp	WORD PTR es:[bx],1
	*** 000d53	74 23 			je	$L2146
;|***         {
;|***         //we got a frame so copy the .frame to the buf and invalidate it 
;|***         //always assume that async will store both byte and status 
;|***         //such that data is allways multiples of 2
;|***         if((rxbuffer[port][i]->no_bytes) > num_bytes) return 0;
;|***         for(j=0;j<(rxbuffer[port][i]->no_bytes);j++)
;|***         buf[j] = (rxbuffer[port][i]->frame[j]);//copy to user buffer
;|***         rxbuffer[port][i]->valid = 0;//invalidate so it can be used again
;|***         return j; //give back the # bytes copied
;|***         }
;|***         
;|***       i++;  //try the next one
;|***       if(i==max_rxbuf[port])i = 0;//wrap to 0 if at end of buffers
; Line 560
	*** 000d55	46 			inc	si
	*** 000d56	8b d9 			mov	bx,cx
	*** 000d58	81 c3 82 01 		add	bx,386	;0182H
	*** 000d5c	03 5e fa 		add	bx,WORD PTR [bp-6]
	*** 000d5f	39 37 			cmp	WORD PTR [bx],si
	*** 000d61	75 02 			jne	$DC1590
	*** 000d63	33 f6 			xor	si,si
;|***       
;|***       }while(i!=current_rxbuf[port]);
; Line 562
					$DC1590:
	*** 000d65	8b d9 			mov	bx,cx
	*** 000d67	81 c3 7a 01 		add	bx,378	;017aH
	*** 000d6b	03 5e fa 		add	bx,WORD PTR [bp-6]
	*** 000d6e	39 37 			cmp	WORD PTR [bx],si
	*** 000d70	75 ce 			jne	$L2142
					$L2317:
	*** 000d72	16 			push	ss
	*** 000d73	1f 			pop	ds
	ASSUME DS: DGROUP
	*** 000d74	e9 25 01 		jmp	$L2149
	*** 000d77	90 			nop	
					$L2146:
;|***         if((rxbuffer[port][i]->no_bytes) > num_bytes) return 0;
; Line 552
	*** 000d78	8b df 			mov	bx,di
	*** 000d7a	c1 e3 04 		shl	bx,4
	*** 000d7d	03 de 			add	bx,si
	*** 000d7f	c1 e3 02 		shl	bx,2
	*** 000d82	03 d9 			add	bx,cx
	*** 000d84	83 c3 7a 		add	bx,122	;007aH
	*** 000d87	89 5e f6 		mov	WORD PTR [bp-10],bx
	*** 000d8a	c4 1f 			les	bx,DWORD PTR [bx]
	*** 000d8c	8b 46 0a 		mov	ax,WORD PTR [bp+10]	;num_bytes
	*** 000d8f	26 39 47 02 		cmp	WORD PTR es:[bx+2],ax
	*** 000d93	76 0b 			jbe	$I1593
					$L2316:
	*** 000d95	33 c0 			xor	ax,ax
					$L2158:
	*** 000d97	16 			push	ss
	*** 000d98	1f 			pop	ds
	ASSUME DS: DGROUP
	*** 000d99	5e 			pop	si
	*** 000d9a	5f 			pop	di
	*** 000d9b	c9 			leave	
	*** 000d9c	ca 0c 00 		ret	12	;0000000cH
	*** 000d9f	90 			nop	
;|***         for(j=0;j<(rxbuffer[port][i]->no_bytes);j++)
; Line 553
					$I1593:
	*** 000da0	c7 46 fe 00 00 		mov	WORD PTR [bp-2],0	;j
	*** 000da5	8b 5e f6 		mov	bx,WORD PTR [bp-10]
	*** 000da8	c4 1f 			les	bx,DWORD PTR [bx]
	*** 000daa	26 83 7f 02 00 		cmp	WORD PTR es:[bx+2],0
	*** 000daf	74 26 			je	$FB1596
	*** 000db1	89 76 fc 		mov	WORD PTR [bp-4],si	;i
	*** 000db4	8b 76 fe 		mov	si,WORD PTR [bp-2]	;j
					$F1594:
;|***         buf[j] = (rxbuffer[port][i]->frame[j]);//copy to user buffer
; Line 554
	*** 000db7	8b 5e f6 		mov	bx,WORD PTR [bp-10]
	*** 000dba	c4 1f 			les	bx,DWORD PTR [bx]
	*** 000dbc	83 c3 06 		add	bx,6
	*** 000dbf	26 8a 00 		mov	al,BYTE PTR es:[bx][si]
	*** 000dc2	c4 5e 0c 		les	bx,DWORD PTR [bp+12]	;buf
	*** 000dc5	26 88 00 		mov	BYTE PTR es:[bx][si],al
	*** 000dc8	46 			inc	si
	*** 000dc9	8b 5e f6 		mov	bx,WORD PTR [bp-10]
	*** 000dcc	c4 1f 			les	bx,DWORD PTR [bx]
	*** 000dce	26 39 77 02 		cmp	WORD PTR es:[bx+2],si
	*** 000dd2	77 e3 			ja	$F1594
	*** 000dd4	89 76 fe 		mov	WORD PTR [bp-2],si	;j
					$FB1596:
;|***         rxbuffer[port][i]->valid = 0;//invalidate so it can be used again
; Line 555
	*** 000dd7	8b 5e f6 		mov	bx,WORD PTR [bp-10]
	*** 000dda	c4 1f 			les	bx,DWORD PTR [bx]
	*** 000ddc	26 c7 07 00 00 		mov	WORD PTR es:[bx],0
;|***         return j; //give back the # bytes copied
; Line 556
					$L2315:
	*** 000de1	8b 46 fe 		mov	ax,WORD PTR [bp-2]	;j
	*** 000de4	eb b1 			jmp	SHORT $L2158
;|***   if((eopmode[port]==OPMODE_HDLC)||(eopmode[port]==OPMODE_BISYNC))
; Line 499
					$I1576:
;|***     {
;|***     // select the escc buffer pool assigned to this channel
;|***     i = current_rxbuf[port];
;|***     i++;
; Line 503
	*** 000de6	8b f1 			mov	si,cx
	*** 000de8	81 c6 7a 01 		add	si,378	;017aH
	*** 000dec	03 76 fa 		add	si,WORD PTR [bp-6]
	*** 000def	8b 04 			mov	ax,WORD PTR [si]
	*** 000df1	40 			inc	ax
	*** 000df2	8b d8 			mov	bx,ax
;|***     if(i==max_rxbuf[port]) i = 0;
; Line 504
	*** 000df4	8b f1 			mov	si,cx
	*** 000df6	81 c6 82 01 		add	si,386	;0182H
	*** 000dfa	03 76 fa 		add	si,WORD PTR [bp-6]
	*** 000dfd	3b 04 			cmp	ax,WORD PTR [si]
	*** 000dff	75 02 			jne	$L2144
	*** 000e01	33 db 			xor	bx,bx
					$L2144:
;|***     
;|***     // step through the buffer pool to see if any has a message
;|***     do{
;|***       if(rxbuffer[port][i]->valid == 1)
; Line 508
	*** 000e03	8b f7 			mov	si,di
	*** 000e05	c1 e6 04 		shl	si,4
	*** 000e08	03 f3 			add	si,bx
	*** 000e0a	c1 e6 02 		shl	si,2
	*** 000e0d	03 f1 			add	si,cx
	*** 000e0f	c4 74 7a 		les	si,DWORD PTR [si+122]
	*** 000e12	26 83 3c 01 		cmp	WORD PTR es:[si],1
	*** 000e16	74 20 			je	$L2148
;|***         {
;|***         // this escc buffer claims it has a message
;|***         // check for error conditions
;|***         // fail if the escc buffer holds more than the user's buffer can hold
;|***         if(rxbuffer[port][i]->no_bytes > num_bytes) return 0;
;|***         
;|***         // user's buffer is ok so copy the message over
;|***         for(j=0;j<rxbuffer[port][i]->no_bytes;j++)
;|***           {
;|***           buf[j] = (rxbuffer[port][i]->frame[j]);
;|***           }
;|***         
;|***         // release the escc buffer to be used again  
;|***         rxbuffer[port][i]->valid = 0;
;|***         
;|***         // tell the user how many chars were in the message
;|***         return j;
;|***         }
;|***       
;|***       i++; // this escc buffer has no message so try the next one
;|***       
;|***       //wrap back to 0 if at end of buffer pool
;|***       if(i==max_rxbuf[port])i = 0;
; Line 531
	*** 000e18	43 			inc	bx
	*** 000e19	8b f1 			mov	si,cx
	*** 000e1b	81 c6 82 01 		add	si,386	;0182H
	*** 000e1f	03 76 fa 		add	si,WORD PTR [bp-6]
	*** 000e22	39 1c 			cmp	WORD PTR [si],bx
	*** 000e24	75 02 			jne	$DC1579
	*** 000e26	33 db 			xor	bx,bx
;|***       
;|***       // repeat the do loop until you've checked all the buffers
;|***       // or until you find one with a message
;|***       }while(i!=current_rxbuf[port]);
; Line 535
					$DC1579:
	*** 000e28	8b f1 			mov	si,cx
	*** 000e2a	81 c6 7a 01 		add	si,378	;017aH
	*** 000e2e	03 76 fa 		add	si,WORD PTR [bp-6]
	*** 000e31	39 1c 			cmp	WORD PTR [si],bx
	*** 000e33	75 ce 			jne	$L2144
	*** 000e35	e9 3a ff 		jmp	$L2317
					$L2148:
;|***         if(rxbuffer[port][i]->no_bytes > num_bytes) return 0;
; Line 513
	*** 000e38	8b f7 			mov	si,di
	*** 000e3a	c1 e6 04 		shl	si,4
	*** 000e3d	03 f3 			add	si,bx
	*** 000e3f	c1 e6 02 		shl	si,2
	*** 000e42	03 f1 			add	si,cx
	*** 000e44	83 c6 7a 		add	si,122	;007aH
	*** 000e47	89 76 f6 		mov	WORD PTR [bp-10],si
	*** 000e4a	c4 34 			les	si,DWORD PTR [si]
	*** 000e4c	8b 46 0a 		mov	ax,WORD PTR [bp+10]	;num_bytes
	*** 000e4f	26 39 44 02 		cmp	WORD PTR es:[si+2],ax
	*** 000e53	76 03 			jbe	$JCC3667
	*** 000e55	e9 3d ff 		jmp	$L2316
					$JCC3667:
;|***         
;|***         // user's buffer is ok so copy the message over
;|***         for(j=0;j<rxbuffer[port][i]->no_bytes;j++)
; Line 516
	*** 000e58	c7 46 fe 00 00 		mov	WORD PTR [bp-2],0	;j
	*** 000e5d	8b 76 f6 		mov	si,WORD PTR [bp-10]
	*** 000e60	c4 34 			les	si,DWORD PTR [si]
	*** 000e62	26 83 7c 02 00 		cmp	WORD PTR es:[si+2],0
	*** 000e67	74 26 			je	$FB1585
	*** 000e69	89 5e fc 		mov	WORD PTR [bp-4],bx	;i
	*** 000e6c	8b 76 fe 		mov	si,WORD PTR [bp-2]	;j
					$F1583:
;|***           {
;|***           buf[j] = (rxbuffer[port][i]->frame[j]);
; Line 518
	*** 000e6f	8b 5e f6 		mov	bx,WORD PTR [bp-10]
	*** 000e72	c4 1f 			les	bx,DWORD PTR [bx]
	*** 000e74	83 c3 06 		add	bx,6
	*** 000e77	26 8a 00 		mov	al,BYTE PTR es:[bx][si]
	*** 000e7a	c4 5e 0c 		les	bx,DWORD PTR [bp+12]	;buf
	*** 000e7d	26 88 00 		mov	BYTE PTR es:[bx][si],al
	*** 000e80	46 			inc	si
	*** 000e81	8b 5e f6 		mov	bx,WORD PTR [bp-10]
	*** 000e84	c4 1f 			les	bx,DWORD PTR [bx]
	*** 000e86	26 39 77 02 		cmp	WORD PTR es:[bx+2],si
	*** 000e8a	77 e3 			ja	$F1583
	*** 000e8c	89 76 fe 		mov	WORD PTR [bp-2],si	;j
;|***           }
; Line 519
					$FB1585:
;|***         
;|***         // release the escc buffer to be used again  
;|***         rxbuffer[port][i]->valid = 0;
; Line 522
	*** 000e8f	8b 76 f6 		mov	si,WORD PTR [bp-10]
	*** 000e92	c4 34 			les	si,DWORD PTR [si]
	*** 000e94	26 c7 04 00 00 		mov	WORD PTR es:[si],0
	*** 000e99	e9 45 ff 		jmp	$L2315
					$L2149:
;|***         
;|***         // tell the user how many chars were in the message
;|***         return j;
;|***         }
;|***       
;|***       i++; // this escc buffer has no message so try the next one
;|***       
;|***       //wrap back to 0 if at end of buffer pool
;|***       if(i==max_rxbuf[port])i = 0;
;|***       
;|***       // repeat the do loop until you've checked all the buffers
;|***       // or until you find one with a message
;|***       }while(i!=current_rxbuf[port]);
;|***     
;|***     // tell the user that no messages were found
;|***     return 0;
; Line 538
	*** 000e9c	33 c0 			xor	ax,ax
;|***     }
;|*** 
;|***   if(eopmode[port]==OPMODE_ASYNC)
;|***     {
;|***     i = current_rxbuf[port];
;|***     i++;
;|***     if(i==max_rxbuf[port]) i = 0;
;|***     do{
;|***       if(rxbuffer[port][i]->valid ==1)
;|***         {
;|***         //we got a frame so copy the .frame to the buf and invalidate it 
;|***         //always assume that async will store both byte and status 
;|***         //such that data is allways multiples of 2
;|***         if((rxbuffer[port][i]->no_bytes) > num_bytes) return 0;
;|***         for(j=0;j<(rxbuffer[port][i]->no_bytes);j++)
;|***         buf[j] = (rxbuffer[port][i]->frame[j]);//copy to user buffer
;|***         rxbuffer[port][i]->valid = 0;//invalidate so it can be used again
;|***         return j; //give back the # bytes copied
;|***         }
;|***         
;|***       i++;  //try the next one
;|***       if(i==max_rxbuf[port])i = 0;//wrap to 0 if at end of buffers
;|***       
;|***       }while(i!=current_rxbuf[port]);
;|***   
;|***     return 0; //no received frames so no bytes xfred
;|***     }
;|***   return 0;
;|***   }   //  end rx_port(); returns # bytes transfered, 0 if fails
; Line 567
	*** 000e9e	5e 			pop	si
	*** 000e9f	5f 			pop	di
	*** 000ea0	c9 			leave	
	*** 000ea1	ca 0c 00 		ret	12	;0000000cH

?rx_port@Cescc@@RECIIPEDI@Z	ENDP
	PUBLIC	?tx_port@Cescc@@RECIIPEDI@Z	; Cescc::tx_port
?tx_port@Cescc@@RECIIPEDI@Z	PROC FAR	; Cescc::tx_port
;|*** 
;|*** 
;|*** 
;|*** 
;|*** 
;|***   // tx_port() does only a small portion of the actual tx processing.
;|***   // escc_isr() does most of the work.
;|*** unsigned Cescc::tx_port(unsigned port,char far *buf, unsigned num_bytes)
;|***   {
; Line 576
	*** 000ea4	c8 12 00 00 		enter	18,0
	*** 000ea8	57 			push	di
	*** 000ea9	56 			push	si
;	num_bytes = 10
;	this = 6
;	bloc = -12
;	i = -6
;	j = -2
;	port = 16
;	buf = 12
	*** 000eaa	8b 4e 0a 		mov	cx,WORD PTR [bp+10]	;num_bytes
;|***   unsigned far *bloc;
;|***   if(num_bytes==0) return  -1;
; Line 578
	*** 000ead	0b c9 			or	cx,cx
	*** 000eaf	75 0b 			jne	$I1604
	*** 000eb1	b8 ff ff 		mov	ax,-1	;ffffH
					$L2192:
	*** 000eb4	16 			push	ss
	*** 000eb5	1f 			pop	ds
	ASSUME DS: DGROUP
	*** 000eb6	5e 			pop	si
	*** 000eb7	5f 			pop	di
	*** 000eb8	c9 			leave	
	*** 000eb9	ca 0c 00 		ret	12	;0000000cH
;|***   if(num_bytes>FRAME_SIZE) return -2;
; Line 579
					$I1604:
	*** 000ebc	81 f9 00 04 		cmp	cx,1024	;0400H
	*** 000ec0	76 06 			jbe	$I1605
	*** 000ec2	b8 fe ff 		mov	ax,-2	;fffeH
	*** 000ec5	eb ed 			jmp	SHORT $L2192
	*** 000ec7	90 			nop	
;|***   
;|***   unsigned i,j;
; Line 581
					$I1605:
;|***   
;|***   bloc = (unsigned far*)buf;
; Line 583
	*** 000ec8	8b 46 0c 		mov	ax,WORD PTR [bp+12]	;buf
	*** 000ecb	8b 56 0e 		mov	dx,WORD PTR [bp+14]
	*** 000ece	89 46 f4 		mov	WORD PTR [bp-12],ax	;bloc
	*** 000ed1	89 56 f6 		mov	WORD PTR [bp-10],dx
	*** 000ed4	8b 4e 10 		mov	cx,WORD PTR [bp+16]	;port
	*** 000ed7	c5 7e 06 		lds	di,DWORD PTR [bp+6]	;this
	ASSUME DS: NOTHING
;|***   
;|***   outp(port_list[port]+PVR,(inp(port_list[port]+PVR)&0xfe)+channel[port]); //select channel A or B
; Line 585
	*** 000eda	8b f1 			mov	si,cx
	*** 000edc	03 f1 			add	si,cx
	*** 000ede	8b df 			mov	bx,di
	*** 000ee0	89 76 f2 		mov	WORD PTR [bp-14],si
	*** 000ee3	8b 10 			mov	dx,WORD PTR [bx][si]
	*** 000ee5	81 c3 9a 01 		add	bx,410	;019aH
	*** 000ee9	83 c2 1c 		add	dx,28	;001cH
	*** 000eec	ec 			in	al,dx
	*** 000eed	25 fe 00 		and	ax,254	;00feH
	*** 000ef0	03 00 			add	ax,WORD PTR [bx][si]
	*** 000ef2	ee 			out	dx, al

;|***   
;|***   //all of this is operating mode specific,...need different cases for async, hdlc, bisync
;|***   i = current_txbuf[port];
; Line 588
	*** 000ef3	8d b5 7e 01 		lea	si,WORD PTR [di+382]
	*** 000ef7	03 76 f2 		add	si,WORD PTR [bp-14]
	*** 000efa	8b 1c 			mov	bx,WORD PTR [si]
;|***   
;|***   // The following do loop cycles through this port's txbuffers once,
;|***   // starting with current_txbuf[], then (in the first if statement)
;|***   // examines each txbuffer until it finds an an empty one
;|***   do  //while(i!=current_txbuf[port]) //Search through txbuffers.....
; Line 593
					$D1609:
;|***     {
;|***     if(txbuffer[port][i]->valid ==0)  //.....and find an empty one.
; Line 595
	*** 000efc	8b f1 			mov	si,cx
	*** 000efe	c1 e6 04 		shl	si,4
	*** 000f01	03 f3 			add	si,bx
	*** 000f03	c1 e6 02 		shl	si,2
	*** 000f06	03 f7 			add	si,di
	*** 000f08	c4 b4 fa 00 		les	si,DWORD PTR [si+250]
	*** 000f0c	26 83 3c 00 		cmp	WORD PTR es:[si],0
	*** 000f10	74 1e 			je	$L2197
;|***       {                               
;|***       if(port_dmat_list[port]==0)     //If we are not using DMA transfers to FIFO.....
;|***         {
;|***         if((istxing[port]==0)&&(num_bytes<=32))//.....and this port is not currently txing a frame.....
;|***           {                                    //.....and we only need to fill the FIFO once (<=32 bytes)......
;|***                                              //.....then we can complete the send here and now.....
;|***           //printf("sending =<32\n\r");        //.....WITHOUT using a txbuffer.
;|***           txbuffer[port][i]->valid = 0;        //???  So declare this txbuffer free.....
;|***           for(j=0;j<num_bytes;j++)
;|***             outp(port_list[port]+FIFO,buf[j]);//and write directly to FIFO from user's buffer
;|***           istxing[port] = 1;   //flag that this port is actively txing
;|***           outp(port_list[port]+CMDR,tx_type[port]+XME); //send XTF+XME command to escc
;|***           return num_bytes; //done
;|***           }
;|***         
;|***         // If the message is too big to fit in the FIFO (> 32 bytes)
;|***         // or if this port is currently txing, 
;|***         // then we need to store the message in a txbuffer.
;|***         for(j=0;j<num_bytes;j++)   // so load the message into a txbuffer
;|***           txbuffer[port][i]->frame[j] = buf[j];
;|***         txbuffer[port][i]->valid = 1; //flag the isr that this txbuffer has a pending message,
;|***         txbuffer[port][i]->max = num_bytes; //and record how many bytes are to be tx'ed.
;|***         txbuffer[port][i]->no_bytes = 0;    //no_bytes is number actually sent
;|***         //current_txbuf[port]++;
;|***         //if(current_txbuf[port]==max_txbuf[port]) current_txbuf[port] = 0;
;|***         if(istxing[port]==1) //If this port is currently txing, we will let the isr
;|***           {          //reload the FIFO and tx the data when an XPR occurs.
;|***           //printf("txing queued\n\r");
;|***           return j;//return number of bytes xfred       //j==num_bytes after previous for loop
;|***           }
;|***         else // If this port is not currently txing
;|***              // we will load the FIFO and issue the tx command.
;|***           {
;|***           //printf("initiating transfer\n\r");
;|***           //outp(port_list[port]+CMDR,XRES);           //will force a tx interrupt and send the frame
;|***           if(num_bytes>32)
;|***             {
;|***             //printf("sending =32\n\r");
;|***             txbuffer[port][i]->no_bytes = 32;
;|***             for(j=0;j<16;j++)
;|***               outpw(port_list[port]+FIFO,bloc[j]);   //load next 32 bytes into fifo
;|***             istxing[port]=1;
;|***             outp(port_list[port]+CMDR,tx_type[port]);               //command escc to tx
;|***             }
;|***           return num_bytes; //return number of bytes xfrd
;|***           }  // end else this port is not txing
;|***         }  // end not dma
;|***       
;|***       else  // do a DMA style transfer
;|***         {
;|***         // printf("txing DMA style\n\r");
;|***         //
;|***         // copy the contents of the char string supplied to
;|***         // the tx_port function to the next available tx buffer
;|***         for(j=0;j<num_bytes;j++)
;|***           txbuffer[port][i]->frame[j] = buf[j];
;|***         txbuffer[port][i]->valid = 1;  // mark the tx buffer as containing valid data
;|***         txbuffer[port][i]->max = num_bytes;  // max stores number of bytes to be tx'ed
;|***         txbuffer[port][i]->no_bytes = 0;   // 
;|***         
;|***         if(istxing[port]==1)  // if this port is already txing
;|***           { 
;|***           //printf("txing queued\n\r");
;|***           return j;// just return the number of bytes xfred
;|***           }
;|***           
;|***         else   // this port is NOT already txing
;|***           {
;|***           //ok here we initiate the dma transfer
;|***           //the num_bytes passed to the dma controller needs to be modified as the 
;|***           //16 bit dma's use half the transfers for the same num_bytes...
;|***           setupdmat(port,txbuffer[port][i]->frame,num_bytes);
;|***           istxing[port] = 1;
;|***           outp(port_list[port]+CMDR,tx_type[port]);
;|***           return j;
;|***           }  // end else
;|***         }  // end dma style
;|***       }  // end if this txbuffer avaiable
;|***     i++; //look at next txbuffer
;|***     if(i==max_txbuf[port]) i = 0; //if this is highest buffer, then reset to first buffer
; Line 675
	*** 000f12	43 			inc	bx
	*** 000f13	8d b5 86 01 		lea	si,WORD PTR [di+390]
	*** 000f17	03 76 f2 		add	si,WORD PTR [bp-14]
	*** 000f1a	39 1c 			cmp	WORD PTR [si],bx
	*** 000f1c	75 02 			jne	$DC1610
	*** 000f1e	33 db 			xor	bx,bx
;|***     
;|***     }while(i!=current_txbuf[port]); //continue looking for available txbuffer until cycled through buffers once
; Line 677
					$DC1610:
	*** 000f20	8d b5 7e 01 		lea	si,WORD PTR [di+382]
	*** 000f24	03 76 f2 		add	si,WORD PTR [bp-14]
	*** 000f27	39 1c 			cmp	WORD PTR [si],bx
	*** 000f29	75 d1 			jne	$D1609
	*** 000f2b	16 			push	ss
	*** 000f2c	1f 			pop	ds
	ASSUME DS: DGROUP
	*** 000f2d	e9 50 02 		jmp	$L2174
					$L2197:
	*** 000f30	89 5e fa 		mov	WORD PTR [bp-6],bx	;i
	*** 000f33	8b 76 0a 		mov	si,WORD PTR [bp+10]	;num_bytes
;|***       if(port_dmat_list[port]==0)     //If we are not using DMA transfers to FIFO.....
; Line 597
	*** 000f36	8d 5d 0c 		lea	bx,WORD PTR [di+12]
	*** 000f39	03 5e f2 		add	bx,WORD PTR [bp-14]
	*** 000f3c	83 3f 00 		cmp	WORD PTR [bx],0
	*** 000f3f	74 03 			je	$JCC3903
	*** 000f41	e9 72 01 		jmp	$I1613
					$JCC3903:
;|***         {
;|***         if((istxing[port]==0)&&(num_bytes<=32))//.....and this port is not currently txing a frame.....
; Line 599
	*** 000f44	8b df 			mov	bx,di
	*** 000f46	03 5e f2 		add	bx,WORD PTR [bp-14]
	*** 000f49	83 bf 92 01 00 		cmp	WORD PTR [bx+402],0
	*** 000f4e	74 03 			je	$JCC3918
	*** 000f50	e9 81 00 		jmp	$I1614
					$JCC3918:
	*** 000f53	83 fe 20 		cmp	si,32	;0020H
	*** 000f56	77 7c 			ja	$I1614
;|***           {                                    //.....and we only need to fill the FIFO once (<=32 bytes)......
;|***                                              //.....then we can complete the send here and now.....
;|***           //printf("sending =<32\n\r");        //.....WITHOUT using a txbuffer.
;|***           txbuffer[port][i]->valid = 0;        //???  So declare this txbuffer free.....
; Line 603
	*** 000f58	8b d9 			mov	bx,cx
	*** 000f5a	c1 e3 04 		shl	bx,4
	*** 000f5d	03 5e fa 		add	bx,WORD PTR [bp-6]	;i
	*** 000f60	c1 e3 02 		shl	bx,2
	*** 000f63	03 df 			add	bx,di
	*** 000f65	c4 9f fa 00 		les	bx,DWORD PTR [bx+250]
	*** 000f69	26 c7 07 00 00 		mov	WORD PTR es:[bx],0
;|***           for(j=0;j<num_bytes;j++)
; Line 604
	*** 000f6e	c7 46 fe 00 00 		mov	WORD PTR [bp-2],0	;j
	*** 000f73	0b f6 			or	si,si
	*** 000f75	75 0b 			jne	$L2183
	*** 000f77	8b 4e 0a 		mov	cx,WORD PTR [bp+10]	;num_bytes
	*** 000f7a	8e 46 08 		mov	es,WORD PTR [bp+8]
	*** 000f7d	eb 27 			jmp	SHORT $FB1617
	*** 000f7f	90 			nop	
	*** 000f80	90 			nop	
	*** 000f81	90 			nop	
					$L2183:
	*** 000f82	8b 76 fe 		mov	si,WORD PTR [bp-2]	;j
	*** 000f85	8b 4e 0a 		mov	cx,WORD PTR [bp+10]	;num_bytes
	*** 000f88	8e 5e 0e 		mov	ds,WORD PTR [bp+14]
	ASSUME DS: NOTHING
	*** 000f8b	8e 46 08 		mov	es,WORD PTR [bp+8]
					$F1615:
;|***             outp(port_list[port]+FIFO,buf[j]);//and write directly to FIFO from user's buffer
; Line 605
	*** 000f8e	8b 5e 0c 		mov	bx,WORD PTR [bp+12]	;buf
	*** 000f91	8a 00 			mov	al,BYTE PTR [bx][si]
	*** 000f93	98 			cbw	
	*** 000f94	8b 5e 06 		mov	bx,WORD PTR [bp+6]	;this
	*** 000f97	03 5e f2 		add	bx,WORD PTR [bp-14]
	*** 000f9a	26 8b 17 		mov	dx,WORD PTR es:[bx]
	*** 000f9d	83 c2 20 		add	dx,32	;0020H
	*** 000fa0	ee 			out	dx, al

	*** 000fa1	46 			inc	si
	*** 000fa2	3b f1 			cmp	si,cx
	*** 000fa4	72 e8 			jb	$F1615
					$FB1617:
	*** 000fa6	16 			push	ss
	*** 000fa7	1f 			pop	ds
	ASSUME DS: DGROUP
	*** 000fa8	8b 76 06 		mov	si,WORD PTR [bp+6]	;this
;|***           istxing[port] = 1;   //flag that this port is actively txing
; Line 606
	*** 000fab	8b de 			mov	bx,si
	*** 000fad	03 5e f2 		add	bx,WORD PTR [bp-14]
	*** 000fb0	26 c7 87 92 01 01 00 	mov	WORD PTR es:[bx+402],1
;|***           outp(port_list[port]+CMDR,tx_type[port]+XME); //send XTF+XME command to escc
; Line 607
	*** 000fb7	8b d3 			mov	dx,bx
	*** 000fb9	8d 9c 8e 01 		lea	bx,WORD PTR [si+398]
	*** 000fbd	03 5e f2 		add	bx,WORD PTR [bp-14]
	*** 000fc0	26 8b 07 		mov	ax,WORD PTR es:[bx]
	*** 000fc3	8b da 			mov	bx,dx
	*** 000fc5	05 02 00 		add	ax,2
	*** 000fc8	26 8b 17 		mov	dx,WORD PTR es:[bx]
	*** 000fcb	ee 			out	dx, al

;|***           return num_bytes; //done
; Line 608
	*** 000fcc	8b c1 			mov	ax,cx
	*** 000fce	5e 			pop	si
	*** 000fcf	5f 			pop	di
	*** 000fd0	c9 			leave	
	*** 000fd1	ca 0c 00 		ret	12	;0000000cH
;|***           }
;|***         
;|***         // If the message is too big to fit in the FIFO (> 32 bytes)
;|***         // or if this port is currently txing, 
;|***         // then we need to store the message in a txbuffer.
;|***         for(j=0;j<num_bytes;j++)   // so load the message into a txbuffer
; Line 614
					$I1614:
	*** 000fd4	c7 46 fe 00 00 		mov	WORD PTR [bp-2],0	;j
	*** 000fd9	0b f6 			or	si,si
	*** 000fdb	74 37 			je	$FB1620
	*** 000fdd	8b c1 			mov	ax,cx
	*** 000fdf	c1 e0 04 		shl	ax,4
	*** 000fe2	03 46 fa 		add	ax,WORD PTR [bp-6]	;i
	*** 000fe5	c1 e0 02 		shl	ax,2
	*** 000fe8	03 c7 			add	ax,di
	*** 000fea	05 fa 00 		add	ax,250	;00faH
	*** 000fed	89 46 ee 		mov	WORD PTR [bp-18],ax
	*** 000ff0	8c 5e f0 		mov	WORD PTR [bp-16],ds
	*** 000ff3	8b 76 fe 		mov	si,WORD PTR [bp-2]	;j
	*** 000ff6	8e 5e 0e 		mov	ds,WORD PTR [bp+14]
	ASSUME DS: NOTHING
					$F1618:
;|***           txbuffer[port][i]->frame[j] = buf[j];
; Line 615
	*** 000ff9	8b 5e 0c 		mov	bx,WORD PTR [bp+12]	;buf
	*** 000ffc	8a 00 			mov	al,BYTE PTR [bx][si]
	*** 000ffe	c4 5e ee 		les	bx,DWORD PTR [bp-18]
	*** 001001	26 c4 1f 		les	bx,DWORD PTR es:[bx]
	*** 001004	26 88 40 06 		mov	BYTE PTR es:[bx+6][si],al
	*** 001008	46 			inc	si
	*** 001009	3b 76 0a 		cmp	si,WORD PTR [bp+10]	;num_bytes
	*** 00100c	72 eb 			jb	$F1618
	*** 00100e	89 76 fe 		mov	WORD PTR [bp-2],si	;j
	*** 001011	8e 5e 08 		mov	ds,WORD PTR [bp+8]
	ASSUME DS: NOTHING
					$FB1620:
;|***         txbuffer[port][i]->valid = 1; //flag the isr that this txbuffer has a pending message,
; Line 616
	*** 001014	8b d9 			mov	bx,cx
	*** 001016	c1 e3 04 		shl	bx,4
	*** 001019	03 5e fa 		add	bx,WORD PTR [bp-6]	;i
	*** 00101c	c1 e3 02 		shl	bx,2
	*** 00101f	03 df 			add	bx,di
	*** 001021	81 c3 fa 00 		add	bx,250	;00faH
	*** 001025	89 5e ee 		mov	WORD PTR [bp-18],bx
	*** 001028	8c 5e f0 		mov	WORD PTR [bp-16],ds
	*** 00102b	c4 37 			les	si,DWORD PTR [bx]
	*** 00102d	26 c7 04 01 00 		mov	WORD PTR es:[si],1
;|***         txbuffer[port][i]->max = num_bytes; //and record how many bytes are to be tx'ed.
; Line 617
	*** 001032	8b 46 0a 		mov	ax,WORD PTR [bp+10]	;num_bytes
	*** 001035	c4 37 			les	si,DWORD PTR [bx]
	*** 001037	26 89 44 04 		mov	WORD PTR es:[si+4],ax
;|***         txbuffer[port][i]->no_bytes = 0;    //no_bytes is number actually sent
; Line 618
	*** 00103b	c4 1f 			les	bx,DWORD PTR [bx]
	*** 00103d	26 c7 47 02 00 00 	mov	WORD PTR es:[bx+2],0
;|***         //current_txbuf[port]++;
;|***         //if(current_txbuf[port]==max_txbuf[port]) current_txbuf[port] = 0;
;|***         if(istxing[port]==1) //If this port is currently txing, we will let the isr
; Line 621
	*** 001043	8b 5e f2 		mov	bx,WORD PTR [bp-14]
	*** 001046	83 b9 92 01 01 		cmp	WORD PTR [bx+402][di],1
	*** 00104b	75 07 			jne	$I1621
;|***           {          //reload the FIFO and tx the data when an XPR occurs.
;|***           //printf("txing queued\n\r");
;|***           return j;//return number of bytes xfred       //j==num_bytes after previous for loop
; Line 624
					$L2318:
	*** 00104d	8b 46 fe 		mov	ax,WORD PTR [bp-2]	;j
	*** 001050	e9 61 fe 		jmp	$L2192
	*** 001053	90 			nop	
;|***           }
;|***         else // If this port is not currently txing
; Line 626
					$I1621:
;|***              // we will load the FIFO and issue the tx command.
;|***           {
;|***           //printf("initiating transfer\n\r");
;|***           //outp(port_list[port]+CMDR,XRES);           //will force a tx interrupt and send the frame
;|***           if(num_bytes>32)
; Line 631
	*** 001054	83 7e 0a 20 		cmp	WORD PTR [bp+10],32	;0020H	;num_bytes
	*** 001058	76 56 			jbe	$I1623
;|***             {
;|***             //printf("sending =32\n\r");
;|***             txbuffer[port][i]->no_bytes = 32;
; Line 634
	*** 00105a	8b 5e ee 		mov	bx,WORD PTR [bp-18]
	*** 00105d	c4 1f 			les	bx,DWORD PTR [bx]
	*** 00105f	26 c7 47 02 20 00 	mov	WORD PTR es:[bx+2],32	;0020H
	*** 001065	8b 46 f4 		mov	ax,WORD PTR [bp-12]	;bloc
	*** 001068	8b 56 f6 		mov	dx,WORD PTR [bp-10]
	*** 00106b	89 56 fe 		mov	WORD PTR [bp-2],dx	;j
	*** 00106e	c7 46 f8 10 00 		mov	WORD PTR [bp-8],16	;0010H
	*** 001073	8b d8 			mov	bx,ax
	*** 001075	8b 7e f8 		mov	di,WORD PTR [bp-8]
;|***             for(j=0;j<16;j++)
; Line 635
	*** 001078	8e 46 fe 		mov	es,WORD PTR [bp-2]	;j
					$F1624:
;|***               outpw(port_list[port]+FIFO,bloc[j]);   //load next 32 bytes into fifo
; Line 636
	*** 00107b	26 8b 07 		mov	ax,WORD PTR es:[bx]
	*** 00107e	8b 76 06 		mov	si,WORD PTR [bp+6]	;this
	*** 001081	03 76 f2 		add	si,WORD PTR [bp-14]
	*** 001084	8b 14 			mov	dx,WORD PTR [si]
	*** 001086	83 c2 20 		add	dx,32	;0020H
	*** 001089	ef 			out	dx, ax

	*** 00108a	83 c3 02 		add	bx,2
	*** 00108d	4f 			dec	di
	*** 00108e	75 eb 			jne	$F1624
	*** 001090	8b 7e 06 		mov	di,WORD PTR [bp+6]	;this
;|***             istxing[port]=1;
; Line 637
	*** 001093	8b df 			mov	bx,di
	*** 001095	03 5e f2 		add	bx,WORD PTR [bp-14]
	*** 001098	c7 87 92 01 01 00 	mov	WORD PTR [bx+402],1
;|***             outp(port_list[port]+CMDR,tx_type[port]);               //command escc to tx
; Line 638
	*** 00109e	8b c3 			mov	ax,bx
	*** 0010a0	8d 9d 8e 01 		lea	bx,WORD PTR [di+398]
	*** 0010a4	8b 76 f2 		mov	si,WORD PTR [bp-14]
	*** 0010a7	8b d0 			mov	dx,ax
	*** 0010a9	8b 00 			mov	ax,WORD PTR [bx][si]
	*** 0010ab	8b da 			mov	bx,dx
	*** 0010ad	8b 17 			mov	dx,WORD PTR [bx]
	*** 0010af	ee 			out	dx, al

;|***             }
;|***           return num_bytes; //return number of bytes xfrd
; Line 640
					$I1623:
	*** 0010b0	8b 46 0a 		mov	ax,WORD PTR [bp+10]	;num_bytes
	*** 0010b3	e9 fe fd 		jmp	$L2192
;|***           }  // end else this port is not txing
;|***         }  // end not dma
;|***       
;|***       else  // do a DMA style transfer
; Line 644
					$I1613:
;|***         {
;|***         // printf("txing DMA style\n\r");
;|***         //
;|***         // copy the contents of the char string supplied to
;|***         // the tx_port function to the next available tx buffer
;|***         for(j=0;j<num_bytes;j++)
; Line 650
	*** 0010b6	c7 46 fe 00 00 		mov	WORD PTR [bp-2],0	;j
	*** 0010bb	0b f6 			or	si,si
	*** 0010bd	74 37 			je	$FB1630
	*** 0010bf	8b c1 			mov	ax,cx
	*** 0010c1	c1 e0 04 		shl	ax,4
	*** 0010c4	03 46 fa 		add	ax,WORD PTR [bp-6]	;i
	*** 0010c7	c1 e0 02 		shl	ax,2
	*** 0010ca	03 c7 			add	ax,di
	*** 0010cc	05 fa 00 		add	ax,250	;00faH
	*** 0010cf	89 46 ee 		mov	WORD PTR [bp-18],ax
	*** 0010d2	8c 5e f0 		mov	WORD PTR [bp-16],ds
	*** 0010d5	8b 76 fe 		mov	si,WORD PTR [bp-2]	;j
	*** 0010d8	8e 5e 0e 		mov	ds,WORD PTR [bp+14]
	ASSUME DS: NOTHING
					$F1628:
;|***           txbuffer[port][i]->frame[j] = buf[j];
; Line 651
	*** 0010db	8b 5e 0c 		mov	bx,WORD PTR [bp+12]	;buf
	*** 0010de	8a 00 			mov	al,BYTE PTR [bx][si]
	*** 0010e0	c4 5e ee 		les	bx,DWORD PTR [bp-18]
	*** 0010e3	26 c4 1f 		les	bx,DWORD PTR es:[bx]
	*** 0010e6	26 88 40 06 		mov	BYTE PTR es:[bx+6][si],al
	*** 0010ea	46 			inc	si
	*** 0010eb	3b 76 0a 		cmp	si,WORD PTR [bp+10]	;num_bytes
	*** 0010ee	72 eb 			jb	$F1628
	*** 0010f0	89 76 fe 		mov	WORD PTR [bp-2],si	;j
	*** 0010f3	8e 5e 08 		mov	ds,WORD PTR [bp+8]
	ASSUME DS: NOTHING
					$FB1630:
;|***         txbuffer[port][i]->valid = 1;  // mark the tx buffer as containing valid data
; Line 652
	*** 0010f6	8b d9 			mov	bx,cx
	*** 0010f8	c1 e3 04 		shl	bx,4
	*** 0010fb	03 5e fa 		add	bx,WORD PTR [bp-6]	;i
	*** 0010fe	c1 e3 02 		shl	bx,2
	*** 001101	03 df 			add	bx,di
	*** 001103	81 c3 fa 00 		add	bx,250	;00faH
	*** 001107	89 5e ee 		mov	WORD PTR [bp-18],bx
	*** 00110a	8c 5e f0 		mov	WORD PTR [bp-16],ds
	*** 00110d	c4 37 			les	si,DWORD PTR [bx]
	*** 00110f	26 c7 04 01 00 		mov	WORD PTR es:[si],1
;|***         txbuffer[port][i]->max = num_bytes;  // max stores number of bytes to be tx'ed
; Line 653
	*** 001114	8b 46 0a 		mov	ax,WORD PTR [bp+10]	;num_bytes
	*** 001117	c4 37 			les	si,DWORD PTR [bx]
	*** 001119	26 89 44 04 		mov	WORD PTR es:[si+4],ax
;|***         txbuffer[port][i]->no_bytes = 0;   // 
; Line 654
	*** 00111d	c4 1f 			les	bx,DWORD PTR [bx]
	*** 00111f	26 c7 47 02 00 00 	mov	WORD PTR es:[bx+2],0
;|***         
;|***         if(istxing[port]==1)  // if this port is already txing
; Line 656
	*** 001125	8d 9d 92 01 		lea	bx,WORD PTR [di+402]
	*** 001129	8b 76 f2 		mov	si,WORD PTR [bp-14]
	*** 00112c	83 38 01 		cmp	WORD PTR [bx][si],1
	*** 00112f	75 03 			jne	$JCC4399
	*** 001131	e9 19 ff 		jmp	$L2318
					$JCC4399:
;|***           { 
;|***           //printf("txing queued\n\r");
;|***           return j;// just return the number of bytes xfred
;|***           }
;|***           
;|***         else   // this port is NOT already txing
; Line 662
	*** 001134	16 			push	ss
	*** 001135	1f 			pop	ds
	ASSUME DS: DGROUP
	*** 001136	8b 76 10 		mov	si,WORD PTR [bp+16]	;port
;|***           {
;|***           //ok here we initiate the dma transfer
;|***           //the num_bytes passed to the dma controller needs to be modified as the 
;|***           //16 bit dma's use half the transfers for the same num_bytes...
;|***           setupdmat(port,txbuffer[port][i]->frame,num_bytes);
; Line 667
	*** 001139	56 			push	si
	*** 00113a	c4 5e ee 		les	bx,DWORD PTR [bp-18]
	*** 00113d	26 8b 07 		mov	ax,WORD PTR es:[bx]
	*** 001140	26 8b 57 02 		mov	dx,WORD PTR es:[bx+2]
	*** 001144	05 06 00 		add	ax,6
	*** 001147	52 			push	dx
	*** 001148	50 			push	ax
	*** 001149	ff 76 0a 		push	WORD PTR [bp+10]	;num_bytes
	*** 00114c	ff 76 08 		push	WORD PTR [bp+8]
	*** 00114f	57 			push	di
	*** 001150	0e 			push	cs
	*** 001151	e8 00 00 		call	NEAR PTR ?setupdmat@Cescc@@JECXIPEXI@Z	; Cescc::setupdmat
;|***           istxing[port] = 1;
; Line 668
	*** 001154	8b df 			mov	bx,di
	*** 001156	03 5e f2 		add	bx,WORD PTR [bp-14]
	*** 001159	8e 46 08 		mov	es,WORD PTR [bp+8]
	*** 00115c	26 c7 87 92 01 01 00 	mov	WORD PTR es:[bx+402],1
;|***           outp(port_list[port]+CMDR,tx_type[port]);
; Line 669
	*** 001163	26 8b 17 		mov	dx,WORD PTR es:[bx]
	*** 001166	8b df 			mov	bx,di
	*** 001168	8e 46 08 		mov	es,WORD PTR [bp+8]
	*** 00116b	81 c3 8e 01 		add	bx,398	;018eH
	*** 00116f	03 5e f2 		add	bx,WORD PTR [bp-14]
	*** 001172	26 8b 07 		mov	ax,WORD PTR es:[bx]
	*** 001175	ee 			out	dx, al

;|***           return j;
; Line 670
	*** 001176	8b 46 fe 		mov	ax,WORD PTR [bp-2]	;j
	*** 001179	5e 			pop	si
	*** 00117a	5f 			pop	di
	*** 00117b	c9 			leave	
	*** 00117c	ca 0c 00 		ret	12	;0000000cH
	*** 00117f	90 			nop	
					$L2174:
;|***           }  // end else
;|***         }  // end dma style
;|***       }  // end if this txbuffer avaiable
;|***     i++; //look at next txbuffer
;|***     if(i==max_txbuf[port]) i = 0; //if this is highest buffer, then reset to first buffer
;|***     
;|***     }while(i!=current_txbuf[port]); //continue looking for available txbuffer until cycled through buffers once
;|***   
;|***   //if here then there are no txbufs available so indicate no bytes xfred
;|***   return -3;
; Line 680
	*** 001180	b8 fd ff 		mov	ax,-3	;fffdH
;|***   }         //  end tx_port(); returns # bytes transfered,0 if fails
; Line 681
	*** 001183	5e 			pop	si
	*** 001184	5f 			pop	di
	*** 001185	c9 			leave	
	*** 001186	ca 0c 00 		ret	12	;0000000cH
	*** 001189	90 			nop	

?tx_port@Cescc@@RECIIPEDI@Z	ENDP
	PUBLIC	?set_control_lines@Cescc@@RECIIII@Z	; Cescc::set_control_lines
?set_control_lines@Cescc@@RECIIII@Z	PROC FAR	; Cescc::set_control_lines
;|*** 
;|*** 
;|*** 
;|*** 
;|*** 
;|*** unsigned Cescc::set_control_lines(unsigned port, unsigned dtr, unsigned rts)
;|***   {
; Line 688
	*** 00118a	c8 06 00 00 		enter	6,0
	*** 00118e	57 			push	di
	*** 00118f	56 			push	si
;	port = 14
;	dtr = 12
;	rts = 10
;	this = 6
	*** 001190	8b 5e 06 		mov	bx,WORD PTR [bp+6]	;this
;|***   
;|***   if(port_open_list!=0)
; Line 690
	*** 001193	8b c3 			mov	ax,bx
	*** 001195	8b 56 08 		mov	dx,WORD PTR [bp+8]
	*** 001198	05 04 00 		add	ax,4
	*** 00119b	0b d0 			or	dx,ax
	*** 00119d	75 03 			jne	$JCC4509
	*** 00119f	e9 9e 00 		jmp	$I1639
					$JCC4509:
	*** 0011a2	8b 7e 0e 		mov	di,WORD PTR [bp+14]	;port
;|***     {                                                                         
;|***     outp(port_list[port]+PVR,(inp(port_list[port]+PVR)&0xfe)+channel[port]); //select channel A or B
; Line 692
	*** 0011a5	8b f3 			mov	si,bx
	*** 0011a7	8e 46 08 		mov	es,WORD PTR [bp+8]
	*** 0011aa	8b c7 			mov	ax,di
	*** 0011ac	03 c7 			add	ax,di
	*** 0011ae	03 f0 			add	si,ax
	*** 0011b0	26 8b 14 		mov	dx,WORD PTR es:[si]
	*** 0011b3	89 56 fc 		mov	WORD PTR [bp-4],dx
	*** 0011b6	83 c2 1c 		add	dx,28	;001cH
	*** 0011b9	8b c8 			mov	cx,ax
	*** 0011bb	ec 			in	al,dx
	*** 0011bc	25 fe 00 		and	ax,254	;00feH
	*** 0011bf	8d b7 9a 01 		lea	si,WORD PTR [bx+410]
	*** 0011c3	03 f1 			add	si,cx
	*** 0011c5	8b c8 			mov	cx,ax
	*** 0011c7	26 8b 04 		mov	ax,WORD PTR es:[si]
	*** 0011ca	89 46 fa 		mov	WORD PTR [bp-6],ax
	*** 0011cd	03 c1 			add	ax,cx
	*** 0011cf	ee 			out	dx, al

;|***     //needs modified for correct registers on escc
;|***     if(dtr ==1) outp(port_list[port]+PVR,inp(port_list[port]+PVR)|(1<<(3+channel[port])));//set DTR
; Line 694
	*** 0011d0	83 7e 0c 01 		cmp	WORD PTR [bp+12],1	;dtr
	*** 0011d4	75 1d 			jne	$I1640
	*** 0011d6	ec 			in	al,dx
	*** 0011d7	2a e4 			sub	ah,ah
	*** 0011d9	8b cf 			mov	cx,di
	*** 0011db	03 cf 			add	cx,di
	*** 0011dd	8d b7 9a 01 		lea	si,WORD PTR [bx+410]
	*** 0011e1	03 f1 			add	si,cx
	*** 0011e3	26 8a 0c 		mov	cl,BYTE PTR es:[si]
	*** 0011e6	80 c1 03 		add	cl,3
	*** 0011e9	8b f0 			mov	si,ax
	*** 0011eb	b8 01 00 		mov	ax,1
	*** 0011ee	d3 e0 			shl	ax,cl
	*** 0011f0	0b c6 			or	ax,si
	*** 0011f2	ee 			out	dx, al

;|***     if(channel[port]==0) if(dtr ==0) outp(port_list[port]+PVR,inp(port_list[port]+PVR)&0xf7);//clear DTR
; Line 695
					$I1640:
	*** 0011f3	83 7e fa 00 		cmp	WORD PTR [bp-6],0
	*** 0011f7	75 0b 			jne	$I1641
	*** 0011f9	83 7e 0c 00 		cmp	WORD PTR [bp+12],0	;dtr
	*** 0011fd	75 05 			jne	$I1641
	*** 0011ff	ec 			in	al,dx
	*** 001200	25 f7 00 		and	ax,247	;00f7H
	*** 001203	ee 			out	dx, al

;|***     if(channel[port]==1) if(dtr ==0) outp(port_list[port]+PVR,inp(port_list[port]+PVR)&0xef);
; Line 696
					$I1641:
	*** 001204	83 7e fa 01 		cmp	WORD PTR [bp-6],1
	*** 001208	75 0b 			jne	$I1643
	*** 00120a	83 7e 0c 00 		cmp	WORD PTR [bp+12],0	;dtr
	*** 00120e	75 05 			jne	$I1643
	*** 001210	ec 			in	al,dx
	*** 001211	25 ef 00 		and	ax,239	;00efH
	*** 001214	ee 			out	dx, al

;|***     if(rts ==1) outp(port_list[port]+MODE,inp(port_list[port]+MODE)|0x04);//set the rts bit in MODE
; Line 697
					$I1643:
	*** 001215	83 7e 0a 01 		cmp	WORD PTR [bp+10],1	;rts
	*** 001219	75 0c 			jne	$I1645
	*** 00121b	8b 56 fc 		mov	dx,WORD PTR [bp-4]
	*** 00121e	83 c2 02 		add	dx,2
	*** 001221	ec 			in	al,dx
	*** 001222	0c 04 			or	al,4
	*** 001224	2a e4 			sub	ah,ah
	*** 001226	ee 			out	dx, al

;|***     if(rts ==0) outp(port_list[port]+MODE,inp(port_list[port]+MODE)&0xfb);//clear the RTS bit in mode
; Line 698
					$I1645:
	*** 001227	83 7e 0a 00 		cmp	WORD PTR [bp+10],0	;rts
	*** 00122b	75 0b 			jne	$I1646
	*** 00122d	8b 56 fc 		mov	dx,WORD PTR [bp-4]
	*** 001230	83 c2 02 		add	dx,2
	*** 001233	ec 			in	al,dx
	*** 001234	25 fb 00 		and	ax,251	;00fbH
	*** 001237	ee 			out	dx, al

;|***     return TRUE;
; Line 699
					$I1646:
	*** 001238	33 c0 			xor	ax,ax
	*** 00123a	5e 			pop	si
	*** 00123b	5f 			pop	di
	*** 00123c	c9 			leave	
	*** 00123d	ca 0a 00 		ret	10	;0000000aH
;|***     }
;|***   else return FALSE;
; Line 701
					$I1639:
	*** 001240	b8 01 00 		mov	ax,1
;|***   }
; Line 702
	*** 001243	5e 			pop	si
	*** 001244	5f 			pop	di
	*** 001245	c9 			leave	
	*** 001246	ca 0a 00 		ret	10	;0000000aH
	*** 001249	90 			nop	

?set_control_lines@Cescc@@RECIIII@Z	ENDP
	PUBLIC	?get_control_lines@Cescc@@RECII@Z	; Cescc::get_control_lines
?get_control_lines@Cescc@@RECII@Z	PROC FAR	; Cescc::get_control_lines
;|*** 
;|*** 
;|*** 
;|*** 
;|*** 
;|*** 
;|*** unsigned Cescc::get_control_lines(unsigned port)
;|***   {
; Line 710
	*** 00124a	c8 0a 00 00 		enter	10,0
	*** 00124e	57 			push	di
	*** 00124f	56 			push	si
;	port = 10
;	this = 6
;	cts = -2
;	dsr = -2
;	dcd = -8
;	dtr = -4
;	rts = -6
;	retval = -12
	*** 001250	8b 5e 06 		mov	bx,WORD PTR [bp+6]	;this
;|***   unsigned cts,dsr,dcd,dtr,rts;
;|***   unsigned retval;
;|***   
;|***   if(port_open_list!=0)
; Line 714
	*** 001253	8b c3 			mov	ax,bx
	*** 001255	8b 56 08 		mov	dx,WORD PTR [bp+8]
	*** 001258	05 04 00 		add	ax,4
	*** 00125b	0b d0 			or	dx,ax
	*** 00125d	75 03 			jne	$JCC4701
	*** 00125f	e9 84 00 		jmp	$I1657
					$JCC4701:
	*** 001262	8b 7e 0a 		mov	di,WORD PTR [bp+10]	;port
;|***     {
;|***     outp(port_list[port]+PVR,(inp(port_list[port]+PVR)&0xfe)+channel[port]); //select channel A or B
; Line 716
	*** 001265	8b f3 			mov	si,bx
	*** 001267	8e 46 08 		mov	es,WORD PTR [bp+8]
	*** 00126a	03 ff 			add	di,di
	*** 00126c	03 f7 			add	si,di
	*** 00126e	26 8b 14 		mov	dx,WORD PTR es:[si]
	*** 001271	8b c2 			mov	ax,dx
	*** 001273	83 c2 1c 		add	dx,28	;001cH
	*** 001276	8b c8 			mov	cx,ax
	*** 001278	ec 			in	al,dx
	*** 001279	8d b7 9a 01 		lea	si,WORD PTR [bx+410]
	*** 00127d	03 f7 			add	si,di
	*** 00127f	25 fe 00 		and	ax,254	;00feH
	*** 001282	26 03 04 		add	ax,WORD PTR es:[si]
	*** 001285	ee 			out	dx, al

;|***     //needs modified for correct registers on escc
;|***     dsr = (inp(port_list[port]+PVR)>>5+channel[port])&0x01;
; Line 718
	*** 001286	ec 			in	al,dx
	*** 001287	8b f9 			mov	di,cx
	*** 001289	26 8a 0c 		mov	cl,BYTE PTR es:[si]
	*** 00128c	89 4e f6 		mov	WORD PTR [bp-10],cx
	*** 00128f	80 c1 05 		add	cl,5
	*** 001292	d2 e8 			shr	al,cl
	*** 001294	25 01 00 		and	ax,1
	*** 001297	89 46 fe 		mov	WORD PTR [bp-2],ax	;cts
;|***     dtr = (inp(port_list[port]+PVR)>>3+channel[port])&1;
; Line 719
	*** 00129a	ec 			in	al,dx
	*** 00129b	8a 4e f6 		mov	cl,BYTE PTR [bp-10]
	*** 00129e	80 c1 03 		add	cl,3
	*** 0012a1	d2 e8 			shr	al,cl
	*** 0012a3	25 01 00 		and	ax,1
	*** 0012a6	89 46 fc 		mov	WORD PTR [bp-4],ax	;dtr
;|***     rts = (inp(port_list[port]+MODE)>>2)&1;
; Line 720
	*** 0012a9	8d 55 02 		lea	dx,WORD PTR [di+2]
	*** 0012ac	ec 			in	al,dx
	*** 0012ad	24 04 			and	al,4
	*** 0012af	c0 e8 02 		shr	al,2
	*** 0012b2	2a e4 			sub	ah,ah
	*** 0012b4	89 46 fa 		mov	WORD PTR [bp-6],ax	;rts
;|***     dcd = (inp(port_list[port]+VSTR)>>7)&1;
; Line 721
	*** 0012b7	8d 55 14 		lea	dx,WORD PTR [di+20]
	*** 0012ba	ec 			in	al,dx
	*** 0012bb	c0 e8 07 		shr	al,7
	*** 0012be	89 46 f8 		mov	WORD PTR [bp-8],ax	;dcd
;|***     cts = (inp(port_list[port]+STAR)>>1)&1;
;|***     retval = (dsr<<4)+(dtr<<3)+(dcd<<2)+(cts<<1)+rts;
;|***     return retval;  //return  = bit flags  X X X DSR DTR DCD CTS RTS
; Line 724
	*** 0012c1	8b d7 			mov	dx,di
	*** 0012c3	ec 			in	al,dx
	*** 0012c4	24 02 			and	al,2
	*** 0012c6	d0 e8 			shr	al,1
	*** 0012c8	8b c8 			mov	cx,ax
	*** 0012ca	8b 46 fe 		mov	ax,WORD PTR [bp-2]	;cts
	*** 0012cd	03 c0 			add	ax,ax
	*** 0012cf	03 46 fc 		add	ax,WORD PTR [bp-4]	;dtr
	*** 0012d2	03 c0 			add	ax,ax
	*** 0012d4	03 46 f8 		add	ax,WORD PTR [bp-8]	;dcd
	*** 0012d7	03 c0 			add	ax,ax
	*** 0012d9	03 c1 			add	ax,cx
	*** 0012db	03 c0 			add	ax,ax
	*** 0012dd	03 46 fa 		add	ax,WORD PTR [bp-6]	;rts
	*** 0012e0	5e 			pop	si
	*** 0012e1	5f 			pop	di
	*** 0012e2	c9 			leave	
	*** 0012e3	ca 06 00 		ret	6
;|***     }
;|***   else return 0;
; Line 726
					$I1657:
	*** 0012e6	33 c0 			xor	ax,ax
;|***   }
; Line 727
	*** 0012e8	5e 			pop	si
	*** 0012e9	5f 			pop	di
	*** 0012ea	c9 			leave	
	*** 0012eb	ca 06 00 		ret	6

?get_control_lines@Cescc@@RECII@Z	ENDP
	PUBLIC	?get_port_status@Cescc@@RECII@Z	; Cescc::get_port_status
?get_port_status@Cescc@@RECII@Z	PROC FAR	; Cescc::get_port_status
;|*** 
;|*** 
;|*** 
;|*** 
;|*** 
;|*** 
;|*** unsigned Cescc::get_port_status(unsigned port)
;|***   {
; Line 735
	*** 0012ee	c8 02 00 00 		enter	2,0
	*** 0012f2	57 			push	di
	*** 0012f3	56 			push	si
;	port = 10
;	this = 6
;	register cx = st
	*** 0012f4	c4 7e 06 		les	di,DWORD PTR [bp+6]	;this
	*** 0012f7	8b 5e 0a 		mov	bx,WORD PTR [bp+10]	;port
;|***   unsigned st;
;|***   
;|***   if(port_open_list[port]!=0)
; Line 738
	*** 0012fa	8b c3 			mov	ax,bx
	*** 0012fc	03 c3 			add	ax,bx
	*** 0012fe	8d 75 04 		lea	si,WORD PTR [di+4]
	*** 001301	03 f0 			add	si,ax
	*** 001303	26 83 3c 00 		cmp	WORD PTR es:[si],0
	*** 001307	74 1d 			je	$I1663
;|***     {
;|***     st = port_status[port];
; Line 740
	*** 001309	8d b5 96 01 		lea	si,WORD PTR [di+406]
	*** 00130d	03 f0 			add	si,ax
	*** 00130f	26 8b 0c 		mov	cx,WORD PTR es:[si]
;|***     port_status[port] = 0;
; Line 741
	*** 001312	8b f7 			mov	si,di
	*** 001314	03 f0 			add	si,ax
	*** 001316	8b c1 			mov	ax,cx
	*** 001318	26 c7 84 96 01 00 00 	mov	WORD PTR es:[si+406],0
;|***     return st;
; Line 742
	*** 00131f	5e 			pop	si
	*** 001320	5f 			pop	di
	*** 001321	c9 			leave	
	*** 001322	ca 06 00 		ret	6
	*** 001325	90 			nop	
;|***     }
;|***   else return 0;
; Line 744
					$I1663:
	*** 001326	33 c0 			xor	ax,ax
;|***   }
; Line 745
	*** 001328	5e 			pop	si
	*** 001329	5f 			pop	di
	*** 00132a	c9 			leave	
	*** 00132b	ca 06 00 		ret	6

?get_port_status@Cescc@@RECII@Z	ENDP
	PUBLIC	?clear_rx_buffer@Cescc@@RECII@Z	; Cescc::clear_rx_buffer
?clear_rx_buffer@Cescc@@RECII@Z	PROC FAR	; Cescc::clear_rx_buffer
;|*** 
;|*** 
;|*** 
;|*** 
;|*** 
;|*** 
;|*** unsigned Cescc::clear_rx_buffer(unsigned port)
;|***   {
; Line 753
	*** 00132e	c8 06 00 00 		enter	6,0
	*** 001332	57 			push	di
	*** 001333	56 			push	si
;	port = 10
;	this = 6
;	register cx = i
	*** 001334	c5 5e 06 		lds	bx,DWORD PTR [bp+6]	;this
	ASSUME DS: NOTHING
	*** 001337	8b 7e 0a 		mov	di,WORD PTR [bp+10]	;port
;|***   //set all rxbuffer[port][..].valid = 0 here                             
;|***   //and reset the receiver on the 82526
;|***   unsigned i;
;|***   outp(port_list[port]+PVR,(inp(port_list[port]+PVR)&0xfe)+channel[port]);  //select channel A or B
; Line 757
	*** 00133a	8b f3 			mov	si,bx
	*** 00133c	8b c7 			mov	ax,di
	*** 00133e	03 c7 			add	ax,di
	*** 001340	03 f0 			add	si,ax
	*** 001342	89 46 fa 		mov	WORD PTR [bp-6],ax
	*** 001345	8b 14 			mov	dx,WORD PTR [si]
	*** 001347	83 c2 1c 		add	dx,28	;001cH
	*** 00134a	8d b7 9a 01 		lea	si,WORD PTR [bx+410]
	*** 00134e	03 f0 			add	si,ax
	*** 001350	ec 			in	al,dx
	*** 001351	25 fe 00 		and	ax,254	;00feH
	*** 001354	03 04 			add	ax,WORD PTR [si]
	*** 001356	ee 			out	dx, al

;|***   if(port_open_list[port] != 0)
; Line 758
	*** 001357	8d 77 04 		lea	si,WORD PTR [bx+4]
	*** 00135a	03 76 fa 		add	si,WORD PTR [bp-6]
	*** 00135d	83 3c 00 		cmp	WORD PTR [si],0
	*** 001360	75 03 			jne	$JCC4960
	*** 001362	e9 89 00 		jmp	$I1669
					$JCC4960:
;|***     {
;|***     if(rxbuffer[port]!=NULL)
; Line 760
	*** 001365	8b c3 			mov	ax,bx
	*** 001367	8c da 			mov	dx,ds
	*** 001369	8b cf 			mov	cx,di
	*** 00136b	c1 e1 06 		shl	cx,6
	*** 00136e	03 c1 			add	ax,cx
	*** 001370	05 7a 00 		add	ax,122	;007aH
	*** 001373	0b d0 			or	dx,ax
	*** 001375	74 77 			je	$I1669
;|***       {
;|***       for(i=0;i<max_rxbuf[port];i++) rxbuffer[port][i]->valid = 0;//wipe all received frames
; Line 762
	*** 001377	33 c9 			xor	cx,cx
	*** 001379	8b f3 			mov	si,bx
	*** 00137b	03 76 fa 		add	si,WORD PTR [bp-6]
	*** 00137e	39 8c 82 01 		cmp	WORD PTR [si+386],cx
	*** 001382	74 2d 			je	$FB1673
	*** 001384	8b c7 			mov	ax,di
	*** 001386	c1 e0 06 		shl	ax,6
	*** 001389	03 c3 			add	ax,bx
	*** 00138b	05 7a 00 		add	ax,122	;007aH
	*** 00138e	8c 5e fe 		mov	WORD PTR [bp-2],ds
	*** 001391	8b d8 			mov	bx,ax
					$F1671:
	*** 001393	8e 46 fe 		mov	es,WORD PTR [bp-2]
	*** 001396	26 c4 37 		les	si,DWORD PTR es:[bx]
	*** 001399	83 c3 04 		add	bx,4
	*** 00139c	26 c7 04 00 00 		mov	WORD PTR es:[si],0
	*** 0013a1	41 			inc	cx
	*** 0013a2	8b 76 06 		mov	si,WORD PTR [bp+6]	;this
	*** 0013a5	03 76 fa 		add	si,WORD PTR [bp-6]
	*** 0013a8	39 8c 82 01 		cmp	WORD PTR [si+386],cx
	*** 0013ac	77 e5 			ja	$F1671
	*** 0013ae	8b 5e 06 		mov	bx,WORD PTR [bp+6]	;this
					$FB1673:
	*** 0013b1	16 			push	ss
	*** 0013b2	1f 			pop	ds
	ASSUME DS: DGROUP
;|***       current_rxbuf[port] = 0;  
; Line 763
	*** 0013b3	8b f3 			mov	si,bx
	*** 0013b5	03 76 fa 		add	si,WORD PTR [bp-6]
	*** 0013b8	8e 46 08 		mov	es,WORD PTR [bp+8]
	*** 0013bb	26 c7 84 7a 01 00 00 	mov	WORD PTR es:[si+378],0
;|***       port_status[port] = port_status[port]&0xfdff;//reset the rxready condition
; Line 764
	*** 0013c2	8c c0 			mov	ax,es
	*** 0013c4	8e 46 08 		mov	es,WORD PTR [bp+8]
	*** 0013c7	8b ce 			mov	cx,si
	*** 0013c9	8d b7 96 01 		lea	si,WORD PTR [bx+406]
	*** 0013cd	03 76 fa 		add	si,WORD PTR [bp-6]
	*** 0013d0	26 8b 14 		mov	dx,WORD PTR es:[si]
	*** 0013d3	80 e6 fd 		and	dh,253	;00fdH
	*** 0013d6	8b f1 			mov	si,cx
	*** 0013d8	8e c0 			mov	es,ax
	*** 0013da	26 89 94 96 01 		mov	WORD PTR es:[si+406],dx
;|***       outp(port_list[port]+CMDR,RHR); //reset the HDLC receiver
; Line 765
	*** 0013df	26 8b 14 		mov	dx,WORD PTR es:[si]
	*** 0013e2	b8 40 00 		mov	ax,64	;0040H
	*** 0013e5	ee 			out	dx, al

;|***       return TRUE;                    //success 
; Line 766
	*** 0013e6	33 c0 			xor	ax,ax
	*** 0013e8	5e 			pop	si
	*** 0013e9	5f 			pop	di
	*** 0013ea	c9 			leave	
	*** 0013eb	ca 06 00 		ret	6
;|***       }
;|***     }
;|***     
;|***   return FALSE;         //no rxbuffer pointer so port not open (failed)
; Line 770
					$I1669:
	*** 0013ee	16 			push	ss
	*** 0013ef	1f 			pop	ds
	ASSUME DS: DGROUP
	*** 0013f0	b8 01 00 		mov	ax,1
;|***   }
; Line 771
	*** 0013f3	5e 			pop	si
	*** 0013f4	5f 			pop	di
	*** 0013f5	c9 			leave	
	*** 0013f6	ca 06 00 		ret	6
	*** 0013f9	90 			nop	

?clear_rx_buffer@Cescc@@RECII@Z	ENDP
	PUBLIC	?clear_tx_buffer@Cescc@@RECII@Z	; Cescc::clear_tx_buffer
?clear_tx_buffer@Cescc@@RECII@Z	PROC FAR	; Cescc::clear_tx_buffer
;|*** 
;|*** 
;|*** 
;|*** 
;|*** 
;|*** unsigned Cescc::clear_tx_buffer(unsigned port)
;|***   {          
; Line 778
	*** 0013fa	c8 04 00 00 		enter	4,0
	*** 0013fe	57 			push	di
	*** 0013ff	56 			push	si
;	port = 10
;	this = 6
;	register cx = i
	*** 001400	c5 5e 06 		lds	bx,DWORD PTR [bp+6]	;this
	ASSUME DS: NOTHING
	*** 001403	8b 7e 0a 		mov	di,WORD PTR [bp+10]	;port
;|***   unsigned i;
;|***   //set all txbuffer[port][..].valid = 0 here
;|***   //and reset the transmitter on the 82526
;|***   outp(port_list[port]+PVR,(inp(port_list[port]+PVR)&0xfe)+channel[port]); //select channel A or B
; Line 782
	*** 001406	8b f3 			mov	si,bx
	*** 001408	8b c7 			mov	ax,di
	*** 00140a	03 c7 			add	ax,di
	*** 00140c	03 f0 			add	si,ax
	*** 00140e	8b 14 			mov	dx,WORD PTR [si]
	*** 001410	83 c2 1c 		add	dx,28	;001cH
	*** 001413	8b c8 			mov	cx,ax
	*** 001415	8d b7 9a 01 		lea	si,WORD PTR [bx+410]
	*** 001419	03 f0 			add	si,ax
	*** 00141b	ec 			in	al,dx
	*** 00141c	25 fe 00 		and	ax,254	;00feH
	*** 00141f	03 04 			add	ax,WORD PTR [si]
	*** 001421	ee 			out	dx, al

;|***   if(port_open_list[port] != 0)                                             
; Line 783
	*** 001422	8d 77 04 		lea	si,WORD PTR [bx+4]
	*** 001425	03 f1 			add	si,cx
	*** 001427	83 3c 00 		cmp	WORD PTR [si],0
	*** 00142a	74 74 			je	$I1678
;|***     {
;|***     if(txbuffer[port]!=NULL)
; Line 785
	*** 00142c	8b c3 			mov	ax,bx
	*** 00142e	8c da 			mov	dx,ds
	*** 001430	8b cf 			mov	cx,di
	*** 001432	c1 e1 06 		shl	cx,6
	*** 001435	03 c1 			add	ax,cx
	*** 001437	05 fa 00 		add	ax,250	;00faH
	*** 00143a	0b d0 			or	dx,ax
	*** 00143c	74 62 			je	$I1678
;|***       {          
;|***       for(i=0;i<max_txbuf[port];i++) txbuffer[port][i]->valid = 0; //wipe all data frames to be sent
; Line 787
	*** 00143e	33 c9 			xor	cx,cx
	*** 001440	8b f3 			mov	si,bx
	*** 001442	8b c7 			mov	ax,di
	*** 001444	03 c7 			add	ax,di
	*** 001446	03 f0 			add	si,ax
	*** 001448	39 8c 86 01 		cmp	WORD PTR [si+390],cx
	*** 00144c	74 30 			je	$FB1682
	*** 00144e	8b c7 			mov	ax,di
	*** 001450	c1 e0 06 		shl	ax,6
	*** 001453	03 c3 			add	ax,bx
	*** 001455	05 fa 00 		add	ax,250	;00faH
	*** 001458	8c 5e fe 		mov	WORD PTR [bp-2],ds
	*** 00145b	8b d8 			mov	bx,ax
					$F1680:
	*** 00145d	8e 46 fe 		mov	es,WORD PTR [bp-2]
	*** 001460	26 c4 37 		les	si,DWORD PTR es:[bx]
	*** 001463	83 c3 04 		add	bx,4
	*** 001466	26 c7 04 00 00 		mov	WORD PTR es:[si],0
	*** 00146b	41 			inc	cx
	*** 00146c	8b 76 06 		mov	si,WORD PTR [bp+6]	;this
	*** 00146f	8b c7 			mov	ax,di
	*** 001471	03 c7 			add	ax,di
	*** 001473	03 f0 			add	si,ax
	*** 001475	39 8c 86 01 		cmp	WORD PTR [si+390],cx
	*** 001479	77 e2 			ja	$F1680
	*** 00147b	8b 5e 06 		mov	bx,WORD PTR [bp+6]	;this
					$FB1682:
;|***       istxing[port] = 0;  //not sending anymore
;|***       current_txbuf[port] = 0;
; Line 789
	*** 00147e	33 c0 			xor	ax,ax
	*** 001480	8b f3 			mov	si,bx
	*** 001482	8b cf 			mov	cx,di
	*** 001484	03 cf 			add	cx,di
	*** 001486	03 f1 			add	si,cx
	*** 001488	89 84 92 01 		mov	WORD PTR [si+402],ax
	*** 00148c	89 84 7e 01 		mov	WORD PTR [si+382],ax
;|***       outp(port_list[port]+CMDR,XRES);//reset the transmitter
; Line 790
	*** 001490	8b 14 			mov	dx,WORD PTR [si]
	*** 001492	b8 01 00 		mov	ax,1
	*** 001495	ee 			out	dx, al

;|***       return TRUE;
; Line 791
	*** 001496	33 c0 			xor	ax,ax
	*** 001498	16 			push	ss
	*** 001499	1f 			pop	ds
	ASSUME DS: DGROUP
	*** 00149a	5e 			pop	si
	*** 00149b	5f 			pop	di
	*** 00149c	c9 			leave	
	*** 00149d	ca 06 00 		ret	6
;|***       }
;|***     }
;|***   return FALSE; //port not open or buffer not allocated return false (failed)
; Line 794
					$I1678:
	*** 0014a0	16 			push	ss
	*** 0014a1	1f 			pop	ds
	ASSUME DS: DGROUP
	*** 0014a2	b8 01 00 		mov	ax,1
;|***   }
; Line 795
	*** 0014a5	5e 			pop	si
	*** 0014a6	5f 			pop	di
	*** 0014a7	c9 			leave	
	*** 0014a8	ca 06 00 		ret	6
	*** 0014ab	90 			nop	

?clear_tx_buffer@Cescc@@RECII@Z	ENDP
	PUBLIC	?set_tx_type@Cescc@@RECIII@Z	; Cescc::set_tx_type
?set_tx_type@Cescc@@RECIII@Z	PROC FAR	; Cescc::set_tx_type
;|*** 
;|*** 
;|*** 
;|*** 
;|*** 
;|*** 
;|*** unsigned Cescc::set_tx_type(unsigned port,unsigned type)
;|***   {
; Line 803
	*** 0014ac	55 			push	bp
	*** 0014ad	8b ec 			mov	bp,sp
	*** 0014af	56 			push	si
;	port = 12
;	type = 10
;	this = 6
	*** 0014b0	8b 5e 0a 		mov	bx,WORD PTR [bp+10]	;type
;|***   //quite specific to hdlc/sdlc
;|***   if(type==AUTO_MODE) tx_type[port]=0x04;
; Line 805
	*** 0014b3	0b db 			or	bx,bx
	*** 0014b5	75 12 			jne	$I1687
	*** 0014b7	8b 76 0c 		mov	si,WORD PTR [bp+12]	;port
	*** 0014ba	03 f6 			add	si,si
	*** 0014bc	03 76 06 		add	si,WORD PTR [bp+6]	;this
	*** 0014bf	8e 46 08 		mov	es,WORD PTR [bp+8]
	*** 0014c2	26 c7 84 8e 01 04 00 	mov	WORD PTR es:[si+398],4
;|***   if(type==TRANSPARENT_MODE) tx_type[port] = 0x08;
; Line 806
					$I1687:
	*** 0014c9	83 fb 01 		cmp	bx,1
	*** 0014cc	75 0f 			jne	$I1688
	*** 0014ce	8b 76 0c 		mov	si,WORD PTR [bp+12]	;port
	*** 0014d1	03 f6 			add	si,si
	*** 0014d3	c4 5e 06 		les	bx,DWORD PTR [bp+6]	;this
	*** 0014d6	26 c7 80 8e 01 08 00 	mov	WORD PTR es:[bx+398][si],8
;|***   return TRUE;
; Line 807
					$I1688:
	*** 0014dd	33 c0 			xor	ax,ax
;|***   }
; Line 808
	*** 0014df	5e 			pop	si
	*** 0014e0	c9 			leave	
	*** 0014e1	ca 08 00 		ret	8

?set_tx_type@Cescc@@RECIII@Z	ENDP
	PUBLIC	?set_tx_address@Cescc@@RECIII@Z	; Cescc::set_tx_address
?set_tx_address@Cescc@@RECIII@Z	PROC FAR	; Cescc::set_tx_address
;|***   
;|*** 
;|*** 
;|*** 
;|*** unsigned Cescc::set_tx_address(unsigned port,unsigned address)
;|***   {
; Line 814
	*** 0014e4	c8 02 00 00 		enter	2,0
	*** 0014e8	57 			push	di
	*** 0014e9	56 			push	si
;	port = 12
;	address = 10
;	this = 6
	*** 0014ea	8b 7e 0c 		mov	di,WORD PTR [bp+12]	;port
	*** 0014ed	c4 5e 06 		les	bx,DWORD PTR [bp+6]	;this
;|***   //xad1 is high byte
;|***   //xad2 is low byte
;|***   outp(port_list[port]+PVR,(inp(port_list[port]+PVR)&0xfe)+channel[port]);
; Line 817
	*** 0014f0	8b c7 			mov	ax,di
	*** 0014f2	03 c7 			add	ax,di
	*** 0014f4	8b f3 			mov	si,bx
	*** 0014f6	03 f0 			add	si,ax
	*** 0014f8	26 8b 14 		mov	dx,WORD PTR es:[si]
	*** 0014fb	89 56 fe 		mov	WORD PTR [bp-2],dx
	*** 0014fe	83 c2 1c 		add	dx,28	;001cH
	*** 001501	8b c8 			mov	cx,ax
	*** 001503	8d b7 9a 01 		lea	si,WORD PTR [bx+410]
	*** 001507	03 f0 			add	si,ax
	*** 001509	ec 			in	al,dx
	*** 00150a	25 fe 00 		and	ax,254	;00feH
	*** 00150d	26 03 04 		add	ax,WORD PTR es:[si]
	*** 001510	ee 			out	dx, al

;|***   if(port_open_list[port] != 0)
; Line 818
	*** 001511	8d 77 04 		lea	si,WORD PTR [bx+4]
	*** 001514	03 f1 			add	si,cx
	*** 001516	26 83 3c 00 		cmp	WORD PTR es:[si],0
	*** 00151a	74 24 			je	$I1693
	*** 00151c	8b 4e 0a 		mov	cx,WORD PTR [bp+10]	;address
;|***     {
;|***     outp(port_list[port]+XAD2,address&0xff);
; Line 820
	*** 00151f	8b c1 			mov	ax,cx
	*** 001521	2a e4 			sub	ah,ah
	*** 001523	8b 56 fe 		mov	dx,WORD PTR [bp-2]
	*** 001526	83 c2 05 		add	dx,5
	*** 001529	ee 			out	dx, al

;|***     outp(port_list[port]+XAD1,address>>8);
; Line 821
	*** 00152a	8b c1 			mov	ax,cx
	*** 00152c	8a c4 			mov	al,ah
	*** 00152e	2a e4 			sub	ah,ah
	*** 001530	8b 56 fe 		mov	dx,WORD PTR [bp-2]
	*** 001533	83 c2 04 		add	dx,4
	*** 001536	ee 			out	dx, al

;|***     return TRUE;
; Line 822
	*** 001537	33 c0 			xor	ax,ax
	*** 001539	5e 			pop	si
	*** 00153a	5f 			pop	di
	*** 00153b	c9 			leave	
	*** 00153c	ca 08 00 		ret	8
	*** 00153f	90 			nop	
;|***     }
;|***   else return FALSE;
; Line 824
					$I1693:
	*** 001540	b8 01 00 		mov	ax,1
;|***   }
; Line 825
	*** 001543	5e 			pop	si
	*** 001544	5f 			pop	di
	*** 001545	c9 			leave	
	*** 001546	ca 08 00 		ret	8
	*** 001549	90 			nop	

?set_tx_address@Cescc@@RECIII@Z	ENDP
	PUBLIC	?set_rx_address1@Cescc@@RECIII@Z	; Cescc::set_rx_address1
?set_rx_address1@Cescc@@RECIII@Z	PROC FAR	; Cescc::set_rx_address1
;|*** 
;|*** 
;|*** 
;|*** 
;|*** 
;|*** 
;|*** unsigned Cescc::set_rx_address1(unsigned port,unsigned address)
;|***   {                                                                         
; Line 833
	*** 00154a	c8 02 00 00 		enter	2,0
	*** 00154e	57 			push	di
	*** 00154f	56 			push	si
;	port = 12
;	address = 10
;	this = 6
	*** 001550	8b 7e 0c 		mov	di,WORD PTR [bp+12]	;port
	*** 001553	c4 5e 06 		les	bx,DWORD PTR [bp+6]	;this
;|***   outp(port_list[port]+PVR,(inp(port_list[port]+PVR)&0xfe)+channel[port]);  //select channel A or B
; Line 834
	*** 001556	8b c7 			mov	ax,di
	*** 001558	03 c7 			add	ax,di
	*** 00155a	8b f3 			mov	si,bx
	*** 00155c	03 f0 			add	si,ax
	*** 00155e	26 8b 14 		mov	dx,WORD PTR es:[si]
	*** 001561	89 56 fe 		mov	WORD PTR [bp-2],dx
	*** 001564	83 c2 1c 		add	dx,28	;001cH
	*** 001567	8b c8 			mov	cx,ax
	*** 001569	8d b7 9a 01 		lea	si,WORD PTR [bx+410]
	*** 00156d	03 f0 			add	si,ax
	*** 00156f	ec 			in	al,dx
	*** 001570	25 fe 00 		and	ax,254	;00feH
	*** 001573	26 03 04 		add	ax,WORD PTR es:[si]
	*** 001576	ee 			out	dx, al

;|***   if(port_open_list[port] != 0)
; Line 835
	*** 001577	8d 77 04 		lea	si,WORD PTR [bx+4]
	*** 00157a	03 f1 			add	si,cx
	*** 00157c	26 83 3c 00 		cmp	WORD PTR es:[si],0
	*** 001580	74 24 			je	$I1699
	*** 001582	8b 4e 0a 		mov	cx,WORD PTR [bp+10]	;address
;|***     {
;|***     outp(port_list[port]+RAL1,address&0xff);
; Line 837
	*** 001585	8b c1 			mov	ax,cx
	*** 001587	2a e4 			sub	ah,ah
	*** 001589	8b 56 fe 		mov	dx,WORD PTR [bp-2]
	*** 00158c	83 c2 08 		add	dx,8
	*** 00158f	ee 			out	dx, al

;|***     outp(port_list[port]+RAH1,address>>8);
; Line 838
	*** 001590	8b c1 			mov	ax,cx
	*** 001592	8a c4 			mov	al,ah
	*** 001594	2a e4 			sub	ah,ah
	*** 001596	8b 56 fe 		mov	dx,WORD PTR [bp-2]
	*** 001599	83 c2 06 		add	dx,6
	*** 00159c	ee 			out	dx, al

;|***     return TRUE;
; Line 839
	*** 00159d	33 c0 			xor	ax,ax
	*** 00159f	5e 			pop	si
	*** 0015a0	5f 			pop	di
	*** 0015a1	c9 			leave	
	*** 0015a2	ca 08 00 		ret	8
	*** 0015a5	90 			nop	
;|***     }
;|***   else return FALSE;
; Line 841
					$I1699:
	*** 0015a6	b8 01 00 		mov	ax,1
;|***   }
; Line 842
	*** 0015a9	5e 			pop	si
	*** 0015aa	5f 			pop	di
	*** 0015ab	c9 			leave	
	*** 0015ac	ca 08 00 		ret	8
	*** 0015af	90 			nop	

?set_rx_address1@Cescc@@RECIII@Z	ENDP
	PUBLIC	?set_rx_address2@Cescc@@RECIII@Z	; Cescc::set_rx_address2
?set_rx_address2@Cescc@@RECIII@Z	PROC FAR	; Cescc::set_rx_address2
;|*** 
;|*** 
;|*** 
;|*** 
;|*** 
;|*** 
;|*** unsigned Cescc::set_rx_address2(unsigned port,unsigned address)
;|***   {                                                                         
; Line 850
	*** 0015b0	c8 02 00 00 		enter	2,0
	*** 0015b4	57 			push	di
	*** 0015b5	56 			push	si
;	port = 12
;	address = 10
;	this = 6
	*** 0015b6	8b 7e 0c 		mov	di,WORD PTR [bp+12]	;port
	*** 0015b9	c4 5e 06 		les	bx,DWORD PTR [bp+6]	;this
;|***   outp(port_list[port]+PVR,(inp(port_list[port]+PVR)&0xfe)+channel[port]);
; Line 851
	*** 0015bc	8b c7 			mov	ax,di
	*** 0015be	03 c7 			add	ax,di
	*** 0015c0	8b f3 			mov	si,bx
	*** 0015c2	03 f0 			add	si,ax
	*** 0015c4	26 8b 14 		mov	dx,WORD PTR es:[si]
	*** 0015c7	89 56 fe 		mov	WORD PTR [bp-2],dx
	*** 0015ca	83 c2 1c 		add	dx,28	;001cH
	*** 0015cd	8b c8 			mov	cx,ax
	*** 0015cf	8d b7 9a 01 		lea	si,WORD PTR [bx+410]
	*** 0015d3	03 f0 			add	si,ax
	*** 0015d5	ec 			in	al,dx
	*** 0015d6	25 fe 00 		and	ax,254	;00feH
	*** 0015d9	26 03 04 		add	ax,WORD PTR es:[si]
	*** 0015dc	ee 			out	dx, al

;|***   if(port_open_list[port] != 0)
; Line 852
	*** 0015dd	8d 77 04 		lea	si,WORD PTR [bx+4]
	*** 0015e0	03 f1 			add	si,cx
	*** 0015e2	26 83 3c 00 		cmp	WORD PTR es:[si],0
	*** 0015e6	74 24 			je	$I1705
	*** 0015e8	8b 4e 0a 		mov	cx,WORD PTR [bp+10]	;address
;|***     {
;|***     outp(port_list[port]+RAL2,address&0xff);
; Line 854
	*** 0015eb	8b c1 			mov	ax,cx
	*** 0015ed	2a e4 			sub	ah,ah
	*** 0015ef	8b 56 fe 		mov	dx,WORD PTR [bp-2]
	*** 0015f2	83 c2 09 		add	dx,9
	*** 0015f5	ee 			out	dx, al

;|***     outp(port_list[port]+RAH2,address>>8);
; Line 855
	*** 0015f6	8b c1 			mov	ax,cx
	*** 0015f8	8a c4 			mov	al,ah
	*** 0015fa	2a e4 			sub	ah,ah
	*** 0015fc	8b 56 fe 		mov	dx,WORD PTR [bp-2]
	*** 0015ff	83 c2 07 		add	dx,7
	*** 001602	ee 			out	dx, al

;|***     return TRUE;
; Line 856
	*** 001603	33 c0 			xor	ax,ax
	*** 001605	5e 			pop	si
	*** 001606	5f 			pop	di
	*** 001607	c9 			leave	
	*** 001608	ca 08 00 		ret	8
	*** 00160b	90 			nop	
;|***     }
;|***   else return FALSE;
; Line 858
					$I1705:
	*** 00160c	b8 01 00 		mov	ax,1
;|***   }
; Line 859
	*** 00160f	5e 			pop	si
	*** 001610	5f 			pop	di
	*** 001611	c9 			leave	
	*** 001612	ca 08 00 		ret	8
	*** 001615	90 			nop	

?set_rx_address2@Cescc@@RECIII@Z	ENDP
	PUBLIC	?start_timer@Cescc@@RECII@Z	; Cescc::start_timer
?start_timer@Cescc@@RECII@Z	PROC FAR	; Cescc::start_timer
;|*** 
;|*** 
;|*** 
;|*** 
;|*** 
;|*** 
;|*** unsigned Cescc::start_timer(unsigned port)
;|***   {                                                                         
; Line 867
	*** 001616	55 			push	bp
	*** 001617	8b ec 			mov	bp,sp
	*** 001619	57 			push	di
	*** 00161a	56 			push	si
;	port = 10
;	this = 6
	*** 00161b	8b 7e 0a 		mov	di,WORD PTR [bp+10]	;port
	*** 00161e	c4 5e 06 		les	bx,DWORD PTR [bp+6]	;this
;|***   outp(port_list[port]+PVR,(inp(port_list[port]+PVR)&0xfe)+channel[port]);
; Line 868
	*** 001621	8b c7 			mov	ax,di
	*** 001623	03 c7 			add	ax,di
	*** 001625	8b f3 			mov	si,bx
	*** 001627	03 f0 			add	si,ax
	*** 001629	26 8b 14 		mov	dx,WORD PTR es:[si]
	*** 00162c	83 c2 1c 		add	dx,28	;001cH
	*** 00162f	8b c8 			mov	cx,ax
	*** 001631	8d b7 9a 01 		lea	si,WORD PTR [bx+410]
	*** 001635	03 f0 			add	si,ax
	*** 001637	ec 			in	al,dx
	*** 001638	25 fe 00 		and	ax,254	;00feH
	*** 00163b	26 03 04 		add	ax,WORD PTR es:[si]
	*** 00163e	ee 			out	dx, al

;|***   if(port_open_list[port] != 0)
; Line 869
	*** 00163f	8d 77 04 		lea	si,WORD PTR [bx+4]
	*** 001642	03 f1 			add	si,cx
	*** 001644	26 83 3c 00 		cmp	WORD PTR es:[si],0
	*** 001648	74 1c 			je	$I1710
;|***     {
;|***     timer_status[port] = 0;
; Line 871
	*** 00164a	8b f7 			mov	si,di
	*** 00164c	03 f7 			add	si,di
	*** 00164e	03 f3 			add	si,bx
	*** 001650	b8 10 00 		mov	ax,16	;0010H
	*** 001653	26 c7 84 8a 01 00 00 	mov	WORD PTR es:[si+394],0
;|***     outp(port_list[port]+CMDR,STI);//send start timer command
; Line 872
	*** 00165a	26 8b 14 		mov	dx,WORD PTR es:[si]
	*** 00165d	ee 			out	dx, al

;|***     return TRUE;
; Line 873
	*** 00165e	33 c0 			xor	ax,ax
	*** 001660	5e 			pop	si
	*** 001661	5f 			pop	di
	*** 001662	c9 			leave	
	*** 001663	ca 06 00 		ret	6
;|***     }
;|***   else return FALSE;
; Line 875
					$I1710:
	*** 001666	b8 01 00 		mov	ax,1
;|***   }                 
; Line 876
	*** 001669	5e 			pop	si
	*** 00166a	5f 			pop	di
	*** 00166b	c9 			leave	
	*** 00166c	ca 06 00 		ret	6
	*** 00166f	90 			nop	

?start_timer@Cescc@@RECII@Z	ENDP
	PUBLIC	?stop_timer@Cescc@@RECII@Z	; Cescc::stop_timer
?stop_timer@Cescc@@RECII@Z	PROC FAR	; Cescc::stop_timer
;|*** 
;|*** 
;|*** 
;|*** 
;|*** 
;|*** 
;|*** unsigned Cescc::stop_timer(unsigned port)                                 
;|***   {
; Line 884
	*** 001670	c8 02 00 00 		enter	2,0
	*** 001674	57 			push	di
	*** 001675	56 			push	si
;	port = 10
;	this = 6
	*** 001676	8b 7e 0a 		mov	di,WORD PTR [bp+10]	;port
	*** 001679	c4 5e 06 		les	bx,DWORD PTR [bp+6]	;this
;|***   outp(port_list[port]+PVR,(inp(port_list[port]+PVR)&0xfe)+channel[port]);
; Line 885
	*** 00167c	8b c7 			mov	ax,di
	*** 00167e	03 c7 			add	ax,di
	*** 001680	8b f3 			mov	si,bx
	*** 001682	03 f0 			add	si,ax
	*** 001684	26 8b 14 		mov	dx,WORD PTR es:[si]
	*** 001687	89 56 fe 		mov	WORD PTR [bp-2],dx
	*** 00168a	83 c2 1c 		add	dx,28	;001cH
	*** 00168d	8b c8 			mov	cx,ax
	*** 00168f	8d b7 9a 01 		lea	si,WORD PTR [bx+410]
	*** 001693	03 f0 			add	si,ax
	*** 001695	ec 			in	al,dx
	*** 001696	25 fe 00 		and	ax,254	;00feH
	*** 001699	26 03 04 		add	ax,WORD PTR es:[si]
	*** 00169c	ee 			out	dx, al

;|***   if(port_open_list[port] != 0)
; Line 886
	*** 00169d	8d 77 04 		lea	si,WORD PTR [bx+4]
	*** 0016a0	03 f1 			add	si,cx
	*** 0016a2	26 83 3c 00 		cmp	WORD PTR es:[si],0
	*** 0016a6	74 12 			je	$I1715
;|***     {
;|***     outp(port_list[port]+TIMR,inp(port_list[port]+TIMR));//writing the timr register stops the timer
; Line 888
	*** 0016a8	8b 56 fe 		mov	dx,WORD PTR [bp-2]
	*** 0016ab	83 c2 03 		add	dx,3
	*** 0016ae	ec 			in	al,dx
	*** 0016af	2a e4 			sub	ah,ah
	*** 0016b1	ee 			out	dx, al

;|***     return TRUE;
; Line 889
	*** 0016b2	33 c0 			xor	ax,ax
	*** 0016b4	5e 			pop	si
	*** 0016b5	5f 			pop	di
	*** 0016b6	c9 			leave	
	*** 0016b7	ca 06 00 		ret	6
;|***     }
;|***   else return FALSE;
; Line 891
					$I1715:
	*** 0016ba	b8 01 00 		mov	ax,1
;|***   }                 
; Line 892
	*** 0016bd	5e 			pop	si
	*** 0016be	5f 			pop	di
	*** 0016bf	c9 			leave	
	*** 0016c0	ca 06 00 		ret	6
	*** 0016c3	90 			nop	

?stop_timer@Cescc@@RECII@Z	ENDP
	PUBLIC	?is_timer_expired@Cescc@@RECII@Z	; Cescc::is_timer_expired
?is_timer_expired@Cescc@@RECII@Z	PROC FAR	; Cescc::is_timer_expired
;|*** 
;|*** 
;|*** 
;|*** 
;|*** 
;|*** 
;|*** unsigned Cescc::is_timer_expired(unsigned port)
;|***   {
; Line 900
	*** 0016c4	c8 02 00 00 		enter	2,0
	*** 0016c8	57 			push	di
	*** 0016c9	56 			push	si
;	port = 10
;	this = 6
	*** 0016ca	c4 7e 06 		les	di,DWORD PTR [bp+6]	;this
	*** 0016cd	8b 5e 0a 		mov	bx,WORD PTR [bp+10]	;port
;|***   if(port_open_list[port] != 0)
; Line 901
	*** 0016d0	8b c3 			mov	ax,bx
	*** 0016d2	03 c3 			add	ax,bx
	*** 0016d4	89 46 fe 		mov	WORD PTR [bp-2],ax
	*** 0016d7	8d 75 04 		lea	si,WORD PTR [di+4]
	*** 0016da	03 f0 			add	si,ax
	*** 0016dc	26 83 3c 00 		cmp	WORD PTR es:[si],0
	*** 0016e0	74 36 			je	$I1720
;|***     {
;|***     if(timer_status[port]==1)
; Line 903
	*** 0016e2	8d b5 8a 01 		lea	si,WORD PTR [di+394]
	*** 0016e6	03 f0 			add	si,ax
	*** 0016e8	26 83 3c 01 		cmp	WORD PTR es:[si],1
	*** 0016ec	75 2a 			jne	$I1720
;|***       {
;|***       timer_status[port] =0;
; Line 905
	*** 0016ee	8b f7 			mov	si,di
	*** 0016f0	03 f0 			add	si,ax
	*** 0016f2	26 c7 84 8a 01 00 00 	mov	WORD PTR es:[si+394],0
;|***       port_status[port] = port_status[port]&(~TIMER_INTERRUPT);
; Line 906
	*** 0016f9	8b c6 			mov	ax,si
	*** 0016fb	8d b5 96 01 		lea	si,WORD PTR [di+406]
	*** 0016ff	03 76 fe 		add	si,WORD PTR [bp-2]
	*** 001702	26 8b 0c 		mov	cx,WORD PTR es:[si]
	*** 001705	8b f0 			mov	si,ax
	*** 001707	80 e5 fe 		and	ch,254	;00feH
	*** 00170a	26 89 8c 96 01 		mov	WORD PTR es:[si+406],cx
;|***       return TRUE;
; Line 907
	*** 00170f	33 c0 			xor	ax,ax
	*** 001711	5e 			pop	si
	*** 001712	5f 			pop	di
	*** 001713	c9 			leave	
	*** 001714	ca 06 00 		ret	6
	*** 001717	90 			nop	
;|***       }
;|***     else return FALSE;
;|***     }
;|***   return FALSE;
; Line 911
					$I1720:
	*** 001718	b8 01 00 		mov	ax,1
;|***   }
; Line 912
	*** 00171b	5e 			pop	si
	*** 00171c	5f 			pop	di
	*** 00171d	c9 			leave	
	*** 00171e	ca 06 00 		ret	6
	*** 001721	90 			nop	

?is_timer_expired@Cescc@@RECII@Z	ENDP
	PUBLIC	?wait_for_timer_expired@Cescc@@RECII@Z	; Cescc::wait_for_timer_expired
?wait_for_timer_expired@Cescc@@RECII@Z	PROC FAR	; Cescc::wait_for_timer_expired
;|*** 
;|*** 
;|*** 
;|*** 
;|*** 
;|*** 
;|*** 
;|*** unsigned Cescc::wait_for_timer_expired(unsigned port)
;|***   {
; Line 921
	*** 001722	c8 06 00 00 		enter	6,0
	*** 001726	57 			push	di
	*** 001727	56 			push	si
;	port = 10
;	this = 6
;	timer_timeout = -4
	*** 001728	c5 7e 06 		lds	di,DWORD PTR [bp+6]	;this
	ASSUME DS: NOTHING
	*** 00172b	8b 5e 0a 		mov	bx,WORD PTR [bp+10]	;port
;|***   unsigned long timer_timeout;
;|***   timer_timeout = 0;
; Line 923
	*** 00172e	2b c0 			sub	ax,ax
	*** 001730	89 46 fe 		mov	WORD PTR [bp-2],ax
	*** 001733	89 46 fc 		mov	WORD PTR [bp-4],ax	;timer_timeout
;|***   
;|***   if(port_open_list[port]!=0)
; Line 925
	*** 001736	8b c3 			mov	ax,bx
	*** 001738	03 c3 			add	ax,bx
	*** 00173a	89 46 fa 		mov	WORD PTR [bp-6],ax
	*** 00173d	8d 75 04 		lea	si,WORD PTR [di+4]
	*** 001740	03 f0 			add	si,ax
	*** 001742	83 3c 00 		cmp	WORD PTR [si],0
	*** 001745	75 05 			jne	$L2211
;|***     {
;|***     while(timer_status[port]==0)
;|***       {
;|***       timer_timeout++;
;|***       if(timer_timeout>1000000)
;|***         {
;|***         return FALSE;
;|***         }
;|***       }
;|***     timer_status[port] = 0;
;|***     port_status[port] = port_status[port]&(~TIMER_INTERRUPT);
;|***     return TRUE;
;|***     }
;|***     
;|***   else return FALSE;
; Line 940
					$L2319:
	*** 001747	b8 01 00 		mov	ax,1
	*** 00174a	eb 47 			jmp	SHORT $EX1725
					$L2211:
;|***     while(timer_status[port]==0)
; Line 927
	*** 00174c	8d b5 8a 01 		lea	si,WORD PTR [di+394]
	*** 001750	03 76 fa 		add	si,WORD PTR [bp-6]
	*** 001753	83 3c 00 		cmp	WORD PTR [si],0
	*** 001756	75 1a 			jne	$FB1730
;|***       {
;|***       timer_timeout++;
;|***       if(timer_timeout>1000000)
; Line 930
	*** 001758	83 46 fc 01 		add	WORD PTR [bp-4],1	;timer_timeout
	*** 00175c	83 56 fe 00 		adc	WORD PTR [bp-2],0
	*** 001760	83 7e fe 0f 		cmp	WORD PTR [bp-2],15	;000fH
	*** 001764	72 e6 			jb	$L2211
	*** 001766	77 df 			ja	$L2319
	*** 001768	81 7e fc 40 42 		cmp	WORD PTR [bp-4],16960	;4240H	;timer_timeout
	*** 00176d	76 dd 			jbe	$L2211
	*** 00176f	eb d6 			jmp	SHORT $L2319
	*** 001771	90 			nop	
;|***         {
;|***         return FALSE;
;|***         }
;|***       }
; Line 934
					$FB1730:
;|***     timer_status[port] = 0;
; Line 935
	*** 001772	8b f7 			mov	si,di
	*** 001774	03 76 fa 		add	si,WORD PTR [bp-6]
	*** 001777	c7 84 8a 01 00 00 	mov	WORD PTR [si+394],0
;|***     port_status[port] = port_status[port]&(~TIMER_INTERRUPT);
; Line 936
	*** 00177d	8b c6 			mov	ax,si
	*** 00177f	8d b5 96 01 		lea	si,WORD PTR [di+406]
	*** 001783	03 76 fa 		add	si,WORD PTR [bp-6]
	*** 001786	8b 0c 			mov	cx,WORD PTR [si]
	*** 001788	8b f0 			mov	si,ax
	*** 00178a	80 e5 fe 		and	ch,254	;00feH
	*** 00178d	89 8c 96 01 		mov	WORD PTR [si+406],cx
;|***     return TRUE;
; Line 937
	*** 001791	33 c0 			xor	ax,ax
;|***     }
;|***     
;|***   else return FALSE;
;|***   }
; Line 941
					$EX1725:
	*** 001793	16 			push	ss
	*** 001794	1f 			pop	ds
	ASSUME DS: DGROUP
	*** 001795	5e 			pop	si
	*** 001796	5f 			pop	di
	*** 001797	c9 			leave	
	*** 001798	ca 06 00 		ret	6
	*** 00179b	90 			nop	

?wait_for_timer_expired@Cescc@@RECII@Z	ENDP
ESCCAUTO_TEXT      ENDS
CONST      SEGMENT
$T2297	DW SEG ?ln200_buffer@@3QIEI 
CONST      ENDS
ESCCAUTO_TEXT      SEGMENT
	ASSUME	CS: ESCCAUTO_TEXT
	PUBLIC	?escc_isr@Cescc@@JEAXXZ	; Cescc::escc_isr
?escc_isr@Cescc@@JEAXXZ	PROC FAR	; Cescc::escc_isr
;|*** 
;|*** 
;|*** 
;|*** 
;|*** 
;|*** 
;|*** void interrupt far Cescc::escc_isr(void)
;|***   {
; Line 949
	*** 00179c	60 			pusha
	*** 00179d	1e 			push	ds
	*** 00179e	06 			push	es
	*** 00179f	8b ec 			mov	bp,sp
	*** 0017a1	83 ec 2e 		sub	sp,46	;002eH
	*** 0017a4	1e 			push	ds
	*** 0017a5	b8 00 00 		mov	ax,DGROUP
	*** 0017a8	8e d8 			mov	ds,ax
	ASSUME DS: DGROUP
	*** 0017aa	fc 			cld	
;	this = 0
;	isr0 = -2
;	isr1 = -26
;	pis = -30
;	i = -24
;	chanstor = -32
;	j = -10
;	k = -6
;	inthit = -28
;	lsb = -18
;	msb = -20
;	bloc = -18
;	ok_to_tx = -26
;	irxbuf = -14
;	itxbuf = -14
;|***   unsigned isr0;
;|***   unsigned isr1;
;|***   unsigned pis;
;|***   unsigned i; 
;|***   unsigned chanstor;
;|***   unsigned j,k;
;|***   unsigned inthit;
;|***   unsigned lsb = 0;
;|***   unsigned msb = 0;
;|***   unsigned far *bloc;
;|***   unsigned ok_to_tx = 0;
;|*** 
;|***   extern unsigned long frame;
;|***   extern LN200 ln200;
;|***   extern TIMER ln200_time;
;|***   extern TIMER sys_timer; 
;|***   extern unsigned long ln200_rx_num;
;|*** 
;|***   struct buf far *irxbuf;
;|***   struct buf far *itxbuf;
;|***   
;|***   //_disable();
;|***   //_enable();      //12/8/03 rem out
;|***   
;|***   isr0 = 0;
;|***   isr1 = 0;
;|***   pis = 0;
;|***   j = 0;
;|***   
;|*** 
;|***   startisr:
; Line 980
					$startisr1755:
;|***   
;|***   inthit = 0; // clear any lingering garbage
;|***   
;|***   for(i=0;i<t1->next_port;i++) // for all opened ports
; Line 984
	*** 0017ab	33 c0 			xor	ax,ax
	*** 0017ad	89 46 e4 		mov	WORD PTR [bp-28],ax	;inthit
	*** 0017b0	89 46 e8 		mov	WORD PTR [bp-24],ax	;i
	*** 0017b3	c4 1e 00 00 		les	bx,DWORD PTR ?t1@@3PEVCescc@@E	;t1
	*** 0017b7	26 39 47 74 		cmp	WORD PTR es:[bx+116],ax
	*** 0017bb	75 03 			jne	$JCC6075
	*** 0017bd	e9 7c 15 		jmp	$FB1758
					$JCC6075:
	*** 0017c0	33 ff 			xor	di,di
	*** 0017c2	89 7e ea 		mov	WORD PTR [bp-22],di
	*** 0017c5	89 7e ec 		mov	WORD PTR [bp-20],di	;msb
	*** 0017c8	89 7e f8 		mov	WORD PTR [bp-8],di
	*** 0017cb	8b f7 			mov	si,di
					$F1756:
;|***     {
;|***     // store the active channel (A or B) to be restored when ISR terminates
;|***     chanstor = inp(t1->port_list[i]+PVR)&0x1;
; Line 987
	*** 0017cd	26 8b 10 		mov	dx,WORD PTR es:[bx][si]
	*** 0017d0	83 c2 1c 		add	dx,28	;001cH
	*** 0017d3	ec 			in	al,dx
	*** 0017d4	25 01 00 		and	ax,1
	*** 0017d7	89 46 e0 		mov	WORD PTR [bp-32],ax	;chanstor
	*** 0017da	ec 			in	al,dx
	*** 0017db	25 fe 00 		and	ax,254	;00feH
	*** 0017de	03 de 			add	bx,si
	*** 0017e0	26 03 87 9a 01 		add	ax,WORD PTR es:[bx+410]
	*** 0017e5	ee 			out	dx, al

;|***   
;|***     // set the active channel to A or B as selected by the for-loop index                                    
;|***     outp(t1->port_list[i]+PVR,(inp(t1->port_list[i]+PVR)&0xfe)+t1->channel[i]); //set channel A or B
;|*** 
;|***     // shut this channel down if it was never properly initialized
;|***     if(t1->port_open_list[i]==0)
; Line 993
	*** 0017e6	8b 1e 00 00 		mov	bx,WORD PTR ?t1@@3PEVCescc@@E	;t1
	*** 0017ea	26 83 78 04 00 		cmp	WORD PTR es:[bx+4][si],0
	*** 0017ef	75 1b 			jne	$I1759
;|***       {
;|***       if(t1->port_list[i]!=0) // the channel was never assigned a base address
; Line 995
	*** 0017f1	26 83 38 00 		cmp	WORD PTR es:[bx][si],0
	*** 0017f5	74 15 			je	$I1759
;|***         {
;|***         outp(t1->port_list[i]+IMR0,0xff);  // so shut off all its interrupts
; Line 997
	*** 0017f7	b8 ff 00 		mov	ax,255	;00ffH
	*** 0017fa	26 8b 10 		mov	dx,WORD PTR es:[bx][si]
	*** 0017fd	8b ca 			mov	cx,dx
	*** 0017ff	83 c2 1a 		add	dx,26	;001aH
	*** 001802	ee 			out	dx, al

;|***         outp(t1->port_list[i]+IMR1,0xff);
; Line 998
	*** 001803	8b d1 			mov	dx,cx
	*** 001805	83 c2 1b 		add	dx,27	;001bH
	*** 001808	ee 			out	dx, al

;|***         goto nextpt; //skip to end of the big for() loop
; Line 999
	*** 001809	e9 04 15 		jmp	$I1919
;|***         }
;|***       }
;|***   
;|***     // read this channel's interrupt status registers and store locally  
;|***     isr0 = inp(t1->port_list[i]+ISR0);
; Line 1004
					$I1759:
	*** 00180c	26 8b 10 		mov	dx,WORD PTR es:[bx][si]
	*** 00180f	8b c2 			mov	ax,dx
	*** 001811	83 c2 1a 		add	dx,26	;001aH
	*** 001814	8b c8 			mov	cx,ax
	*** 001816	ec 			in	al,dx
	*** 001817	2a e4 			sub	ah,ah
	*** 001819	89 46 fe 		mov	WORD PTR [bp-2],ax	;isr0
;|***     isr1 = inp(t1->port_list[i]+ISR1);
; Line 1005
	*** 00181c	8b d1 			mov	dx,cx
	*** 00181e	83 c2 1b 		add	dx,27	;001bH
	*** 001821	ec 			in	al,dx
	*** 001822	89 46 e6 		mov	WORD PTR [bp-26],ax	;isr1
;|***     pis = inp(t1->port_list[i]+PIS); // universal port interrupts
;|***     
;|***     // skip to next channel if no interrupts set for this channel
;|***     if((isr0+isr1+pis)==0) goto nextpt;
; Line 1009
	*** 001825	8b d1 			mov	dx,cx
	*** 001827	83 c2 1d 		add	dx,29	;001dH
	*** 00182a	ec 			in	al,dx
	*** 00182b	89 46 e2 		mov	WORD PTR [bp-30],ax	;pis
	*** 00182e	03 46 e6 		add	ax,WORD PTR [bp-26]	;isr1
	*** 001831	03 46 fe 		add	ax,WORD PTR [bp-2]	;isr0
	*** 001834	75 03 			jne	$JCC6196
	*** 001836	e9 d7 14 		jmp	$I1919
					$JCC6196:
;|***   
;|***     // or else service this channel's interrupts
;|***     inthit = 1;
; Line 1012
	*** 001839	c7 46 e4 01 00 		mov	WORD PTR [bp-28],1	;inthit
;|*** 
;|***     // check each interrupt event and service them as needed
;|***     // ISR0 first
;|***     if((isr0&RME)==RME)  //  RME Receive Message End
; Line 1016
	*** 00183e	8a 46 fe 		mov	al,BYTE PTR [bp-2]	;isr0
	*** 001841	24 80 			and	al,128	;0080H
	*** 001843	3c 80 			cmp	al,128	;0080H
	*** 001845	74 03 			je	$JCC6213
	*** 001847	e9 00 07 		jmp	$I1765
					$JCC6213:
;|***       {
;|***       if(t1->eopmode[i]==OPMODE_HDLC)
; Line 1018
	*** 00184a	26 83 b8 9e 01 00 	cmp	WORD PTR es:[bx+414][si],0
	*** 001850	74 06 			je	$L2254
					$L2253:
	*** 001852	8b 7e ec 		mov	di,WORD PTR [bp-20]	;msb
	*** 001855	e9 e7 02 		jmp	$I1766
					$L2254:
;|***         {
;|***         if(t1->port_dmar_list[i]==0)  // if not using DMA
; Line 1020
	*** 001858	26 83 78 10 00 		cmp	WORD PTR es:[bx+16][si],0
	*** 00185d	74 03 			je	$JCC6237
	*** 00185f	e9 aa 01 		jmp	$I1767
					$JCC6237:
;|***           {
;|***           
;|***           // get "k", the total number of bytes received in this message
;|***           
;|***           // then fill the rbuf frame (char frame[]) with the rest of the
;|***           // chars still remaining in the rx fifo
;|***           
;|***           // remember that the rx fifo is only 32 chars deep
;|***           
;|***           // the low 4 bits of RBCH and 8 bits of RBCL indicate the total length in chars
;|***           // of the received message (0 to 4095)
;|***           
;|***           // additionally, the low 4 bits of RBCL indicate the number of chars currently
;|***           // in the rx fifo
;|***           
;|***           // read total number of chars received in this message
;|***           k = (unsigned)((inp(t1->port_list[i]+RBCH)&0x0f) <<8) +
;|***               (unsigned) (inp(t1->port_list[i]+RBCL)&0xff);
; Line 1038
	*** 001862	26 8b 10 		mov	dx,WORD PTR es:[bx][si]
	*** 001865	8b c2 			mov	ax,dx
	*** 001867	83 c2 0b 		add	dx,11	;000bH
	*** 00186a	8b c8 			mov	cx,ax
	*** 00186c	ec 			in	al,dx
	*** 00186d	8a e0 			mov	ah,al
	*** 00186f	25 00 0f 		and	ax,3840	;0f00H
	*** 001872	8b d1 			mov	dx,cx
	*** 001874	83 c2 0a 		add	dx,10	;000aH
	*** 001877	8b c8 			mov	cx,ax
	*** 001879	ec 			in	al,dx
	*** 00187a	2a e4 			sub	ah,ah
	*** 00187c	03 c8 			add	cx,ax
	*** 00187e	89 4e fa 		mov	WORD PTR [bp-6],cx	;k
;|***           
;|***           // get the right buffer to use
;|***           irxbuf = (t1->rxbuffer[i][t1->current_rxbuf[i]]);     
; Line 1041
	*** 001881	26 8b 98 7a 01 		mov	bx,WORD PTR es:[bx+378][si]
	*** 001886	c1 e3 02 		shl	bx,2
	*** 001889	03 1e 00 00 		add	bx,WORD PTR ?t1@@3PEVCescc@@E	;t1
	*** 00188d	8b 7e ec 		mov	di,WORD PTR [bp-20]	;msb
	*** 001890	26 8b 41 7a 		mov	ax,WORD PTR es:[bx+122][di]
	*** 001894	26 8b 51 7c 		mov	dx,WORD PTR es:[bx+124][di]
	*** 001898	89 46 f2 		mov	WORD PTR [bp-14],ax	;irxbuf
	*** 00189b	89 56 f4 		mov	WORD PTR [bp-12],dx
;|***           
;|***           //the reads are done as byte access so that odd frame lengths will be received correctly
;|***           //the fifo can not be accessed both as word and byte in same pool, meaning 
;|***           //if you start doing 16 bit xfrs you must do all 16 bit xfrs...
;|***           //note it might be quicker to just do an extra 16 bit xfr as opposed to doing it byte wise
;|***           //but that only stands a chance of working for rx, txing you must do byte transfers
;|***           //as the number of writes to the fifo determines what gets sent out.
;|***           
;|***           // read the final message chars from the rx fifo and add them to the buffer
;|***           for(j=irxbuf->no_bytes;j<k;j++) // j = num bytes received before this fifo dump
; Line 1051
	*** 00189e	8b d8 			mov	bx,ax
	*** 0018a0	8e c2 			mov	es,dx
	*** 0018a2	26 8b 47 02 		mov	ax,WORD PTR es:[bx+2]
	*** 0018a6	89 46 f6 		mov	WORD PTR [bp-10],ax	;j
	*** 0018a9	3b c1 			cmp	ax,cx
	*** 0018ab	72 03 			jb	$JCC6315
	*** 0018ad	e9 56 01 		jmp	$L2275
					$JCC6315:
	*** 0018b0	8b d8 			mov	bx,ax
	*** 0018b2	89 76 f8 		mov	WORD PTR [bp-8],si
					$F1770:
;|***             {
;|***             irxbuf->frame[j] = inp(t1->port_list[i]+FIFO);
; Line 1053
	*** 0018b5	c4 3e 00 00 		les	di,DWORD PTR ?t1@@3PEVCescc@@E	;t1
	*** 0018b9	03 fe 			add	di,si
	*** 0018bb	26 8b 15 		mov	dx,WORD PTR es:[di]
	*** 0018be	83 c2 20 		add	dx,32	;0020H
	*** 0018c1	ec 			in	al,dx
	*** 0018c2	c4 7e f2 		les	di,DWORD PTR [bp-14]	;irxbuf
	*** 0018c5	26 88 41 06 		mov	BYTE PTR es:[bx+6][di],al
	*** 0018c9	43 			inc	bx
	*** 0018ca	3b d9 			cmp	bx,cx
	*** 0018cc	72 e7 			jb	$F1770
					$FB1772:
;|***             }
;|***             
;|***           outp(t1->port_list[i]+CMDR,RMC);// release fifo
; Line 1056
	*** 0018ce	b8 80 00 		mov	ax,128	;0080H
	*** 0018d1	c4 1e 00 00 		les	bx,DWORD PTR ?t1@@3PEVCescc@@E	;t1
	*** 0018d5	8b 76 f8 		mov	si,WORD PTR [bp-8]
	*** 0018d8	26 8b 10 		mov	dx,WORD PTR es:[bx][si]
	*** 0018db	ee 			out	dx, al

;|***           irxbuf->valid = 1;              // validate the rbuf we just used
; Line 1057
	*** 0018dc	c4 5e f2 		les	bx,DWORD PTR [bp-14]	;irxbuf
	*** 0018df	26 c7 07 01 00 		mov	WORD PTR es:[bx],1
;|***           irxbuf->no_bytes = k;           // update the total number of bytes received
; Line 1058
	*** 0018e4	8b 46 fa 		mov	ax,WORD PTR [bp-6]	;k
	*** 0018e7	26 89 47 02 		mov	WORD PTR es:[bx+2],ax
;|***           
;|***           // new code specific to receiving ln200 messages in the autonomous model
;|***           // added 3/25/2004 jtm
;|***           if(k==33)
; Line 1062
	*** 0018eb	3d 21 00 		cmp	ax,33	;0021H
	*** 0018ee	75 60 			jne	$I1773
;|***             {
;|***             if(odd) // keep only every other ln200 message since they are 
; Line 1064
	*** 0018f0	83 3e 00 00 00 		cmp	WORD PTR ?odd@@3HE,0	;odd
	*** 0018f5	74 4d 			je	$I1774
;|***               {     // coming in at 200 Hz
;|***               ln200_rx_num++;
; Line 1066
	*** 0018f7	83 06 00 00 01 		add	WORD PTR ?ln200_rx_num@@3KE,1	;ln200_rx_num
	*** 0018fc	83 16 02 00 00 		adc	WORD PTR ?ln200_rx_num@@3KE+2,0	;ln200_rx_num
;|***               
;|***               _fmemcpy(ln200_buffer, irxbuf->frame, k);  // copy message to app buffer
; Line 1068
	*** 001901	8e 06 00 00 		mov	es,WORD PTR $T2297
	*** 001905	8b 46 f2 		mov	ax,WORD PTR [bp-14]	;irxbuf
	*** 001908	8b 56 f4 		mov	dx,WORD PTR [bp-12]
	*** 00190b	05 06 00 		add	ax,6
	*** 00190e	8b 4e fa 		mov	cx,WORD PTR [bp-6]	;k
	*** 001911	1e 			push	ds
	*** 001912	bf 00 00 		mov	di,OFFSET ?ln200_buffer@@3QIEI	;ln200_buffer
	*** 001915	8b f0 			mov	si,ax
	*** 001917	8e da 			mov	ds,dx
	ASSUME DS: NOTHING
	*** 001919	d1 e9 			shr	cx,1
	*** 00191b	f3 			rep
	*** 00191c	a5 			movsw
	*** 00191d	13 c9 			adc	cx,cx
	*** 00191f	f3 			rep
	*** 001920	a4 			movsb
	*** 001921	1f 			pop	ds
	ASSUME DS: DGROUP
;|***               ln200_new_data = 1;                      // flag new data available
; Line 1069
	*** 001922	c7 06 00 00 01 00 	mov	WORD PTR ?ln200_new_data@@3IE,1	;ln200_new_data
;|***               ln200_data_frame = frame;                     // record frame number
; Line 1070
	*** 001928	a1 00 00 		mov	ax,WORD PTR ?frame@@3KE	;frame
	*** 00192b	8b 16 02 00 		mov	dx,WORD PTR ?frame@@3KE+2	;frame
	*** 00192f	a3 00 00 		mov	WORD PTR ?ln200_data_frame@@3KE,ax	;ln200_data_frame
	*** 001932	89 16 02 00 		mov	WORD PTR ?ln200_data_frame@@3KE+2,dx	;ln200_data_frame
;|***               time_stamp(&ln200_time);
; Line 1071
	*** 001936	68 00 00 		push	SEG ?ln200_time@@3UTIMER@@E	;ln200_time
	*** 001939	68 00 00 		push	OFFSET ?ln200_time@@3UTIMER@@E	;ln200_time
	*** 00193c	9a 00 00 00 00 		call	FAR PTR ?time_stamp@@ZAXPEUTIMER@@@Z	; time_stamp
	*** 001941	83 c4 04 		add	sp,4
;|***               }
;|***             odd = !odd;  
; Line 1073
					$I1774:
	*** 001944	83 3e 00 00 01 		cmp	WORD PTR ?odd@@3HE,1	;odd
	*** 001949	1b c0 			sbb	ax,ax
	*** 00194b	f7 d8 			neg	ax
	*** 00194d	a3 00 00 		mov	WORD PTR ?odd@@3HE,ax	;odd
;|***             }  
;|***           irxbuf->valid = 0;                       // release the escc buffer to be used again  
; Line 1075
					$I1773:
;|***           irxbuf->no_bytes = 0;
; Line 1076
	*** 001950	33 c0 			xor	ax,ax
	*** 001952	c4 5e f2 		les	bx,DWORD PTR [bp-14]	;irxbuf
	*** 001955	26 89 07 		mov	WORD PTR es:[bx],ax
	*** 001958	26 89 47 02 		mov	WORD PTR es:[bx+2],ax
;|***           // end autonomous-specific code
;|*** 
;|***                                  
;|***           // select the next buffer for the next reception
;|***           t1->current_rxbuf[i]++;
; Line 1081
	*** 00195c	c4 1e 00 00 		les	bx,DWORD PTR ?t1@@3PEVCescc@@E	;t1
	*** 001960	8b 76 f8 		mov	si,WORD PTR [bp-8]
	*** 001963	26 8b 80 7a 01 		mov	ax,WORD PTR es:[bx+378][si]
	*** 001968	40 			inc	ax
	*** 001969	26 89 80 7a 01 		mov	WORD PTR es:[bx+378][si],ax
;|***           // rollover to the first buffer if we've reached the end of available buffers
;|***           if(t1->current_rxbuf[i]==t1->max_rxbuf[i]) 
; Line 1083
	*** 00196e	c4 1e 00 00 		les	bx,DWORD PTR ?t1@@3PEVCescc@@E	;t1
	*** 001972	03 5e f8 		add	bx,WORD PTR [bp-8]
	*** 001975	26 8b 87 82 01 		mov	ax,WORD PTR es:[bx+386]
	*** 00197a	26 39 87 7a 01 		cmp	WORD PTR es:[bx+378],ax
	*** 00197f	75 0e 			jne	$I1775
;|***             {
;|***             t1->current_rxbuf[i]=0;
; Line 1085
	*** 001981	8b 1e 00 00 		mov	bx,WORD PTR ?t1@@3PEVCescc@@E	;t1
	*** 001985	03 5e f8 		add	bx,WORD PTR [bp-8]
	*** 001988	26 c7 87 7a 01 00 00 	mov	WORD PTR es:[bx+378],0
;|***             }
;|***           
;|***           // make sure the next selected buffer is not in use (an error condition)
;|***           if(t1->rxbuffer[i][t1->current_rxbuf[i]]->valid ==1) 
; Line 1089
					$I1775:
	*** 00198f	c4 1e 00 00 		les	bx,DWORD PTR ?t1@@3PEVCescc@@E	;t1
	*** 001993	03 5e f8 		add	bx,WORD PTR [bp-8]
	*** 001996	26 8b b7 7a 01 		mov	si,WORD PTR es:[bx+378]
	*** 00199b	03 76 ea 		add	si,WORD PTR [bp-22]
	*** 00199e	c1 e6 02 		shl	si,2
	*** 0019a1	8b 1e 00 00 		mov	bx,WORD PTR ?t1@@3PEVCescc@@E	;t1
	*** 0019a5	26 c4 58 7a 		les	bx,DWORD PTR es:[bx+122][si]
	*** 0019a9	26 83 3f 01 		cmp	WORD PTR es:[bx],1
	*** 0019ad	75 15 			jne	$I1776
;|***             {
;|***             // An error occured and the main program isn't done with 
;|***             // the frame that is about to be used for received data.
;|***             // Set the receive buffers overflowed bit of the status word for this port here.
;|***             t1->port_status[i] = t1->port_status[i] | RX_BUFFER_OVERFLOW;
; Line 1094
	*** 0019af	c4 1e 00 00 		les	bx,DWORD PTR ?t1@@3PEVCescc@@E	;t1
	*** 0019b3	8b 76 f8 		mov	si,WORD PTR [bp-8]
	*** 0019b6	26 8b 80 96 01 		mov	ax,WORD PTR es:[bx+406][si]
	*** 0019bb	0c 40 			or	al,64	;0040H
	*** 0019bd	03 de 			add	bx,si
	*** 0019bf	26 89 87 96 01 		mov	WORD PTR es:[bx+406],ax
;|***             }
;|***             
;|***           // prep the next selected buffer for use  
;|***           t1->rxbuffer[i][t1->current_rxbuf[i]]->no_bytes = 0;
; Line 1098
					$I1776:
	*** 0019c4	c4 1e 00 00 		les	bx,DWORD PTR ?t1@@3PEVCescc@@E	;t1
	*** 0019c8	8b 76 f8 		mov	si,WORD PTR [bp-8]
	*** 0019cb	26 8b 98 7a 01 		mov	bx,WORD PTR es:[bx+378][si]
	*** 0019d0	c1 e3 02 		shl	bx,2
	*** 0019d3	03 1e 00 00 		add	bx,WORD PTR ?t1@@3PEVCescc@@E	;t1
	*** 0019d7	8b 76 ec 		mov	si,WORD PTR [bp-20]	;msb
	*** 0019da	26 c4 58 7a 		les	bx,DWORD PTR es:[bx+122][si]
	*** 0019de	26 c7 47 02 00 00 	mov	WORD PTR es:[bx+2],0
;|***           t1->rxbuffer[i][t1->current_rxbuf[i]]->valid = 0;
; Line 1099
	*** 0019e4	c4 1e 00 00 		les	bx,DWORD PTR ?t1@@3PEVCescc@@E	;t1
	*** 0019e8	8b 76 f8 		mov	si,WORD PTR [bp-8]
	*** 0019eb	26 8b b0 7a 01 		mov	si,WORD PTR es:[bx+378][si]
	*** 0019f0	03 76 ea 		add	si,WORD PTR [bp-22]
	*** 0019f3	c1 e6 02 		shl	si,2
	*** 0019f6	26 c4 58 7a 		les	bx,DWORD PTR es:[bx+122][si]
	*** 0019fa	26 c7 07 00 00 		mov	WORD PTR es:[bx],0
	*** 0019ff	8b 76 f8 		mov	si,WORD PTR [bp-8]
	*** 001a02	e9 4d fe 		jmp	$L2253
	*** 001a05	90 			nop	
					$L2275:
	*** 001a06	89 76 f8 		mov	WORD PTR [bp-8],si
	*** 001a09	e9 c2 fe 		jmp	$FB1772
;|***             }
; Line 1054
					$I1767:
	*** 001a0c	8b 7e ec 		mov	di,WORD PTR [bp-20]	;msb
;|***             
;|***           outp(t1->port_list[i]+CMDR,RMC);// release fifo
;|***           irxbuf->valid = 1;              // validate the rbuf we just used
;|***           irxbuf->no_bytes = k;           // update the total number of bytes received
;|***           
;|***           // new code specific to receiving ln200 messages in the autonomous model
;|***           // added 3/25/2004 jtm
;|***           if(k==33)
;|***             {
;|***             if(odd) // keep only every other ln200 message since they are 
;|***               {     // coming in at 200 Hz
;|***               ln200_rx_num++;
;|***               
;|***               _fmemcpy(ln200_buffer, irxbuf->frame, k);  // copy message to app buffer
;|***               ln200_new_data = 1;                      // flag new data available
;|***               ln200_data_frame = frame;                     // record frame number
;|***               time_stamp(&ln200_time);
;|***               }
;|***             odd = !odd;  
;|***             }  
;|***           irxbuf->valid = 0;                       // release the escc buffer to be used again  
;|***           irxbuf->no_bytes = 0;
;|***           // end autonomous-specific code
;|*** 
;|***                                  
;|***           // select the next buffer for the next reception
;|***           t1->current_rxbuf[i]++;
;|***           // rollover to the first buffer if we've reached the end of available buffers
;|***           if(t1->current_rxbuf[i]==t1->max_rxbuf[i]) 
;|***             {
;|***             t1->current_rxbuf[i]=0;
;|***             }
;|***           
;|***           // make sure the next selected buffer is not in use (an error condition)
;|***           if(t1->rxbuffer[i][t1->current_rxbuf[i]]->valid ==1) 
;|***             {
;|***             // An error occured and the main program isn't done with 
;|***             // the frame that is about to be used for received data.
;|***             // Set the receive buffers overflowed bit of the status word for this port here.
;|***             t1->port_status[i] = t1->port_status[i] | RX_BUFFER_OVERFLOW;
;|***             }
;|***             
;|***           // prep the next selected buffer for use  
;|***           t1->rxbuffer[i][t1->current_rxbuf[i]]->no_bytes = 0;
;|***           t1->rxbuffer[i][t1->current_rxbuf[i]]->valid = 0;
;|***           
;|***           // flag this port as holding a received message
;|***           //t1->port_status[i] = t1->port_status[i] | RX_READY; // jtm 3/31/2004
;|***           }  
;|***         else
;|***           {
;|***           //this is the DMA code for RME interrupt
;|***           //if we are here then the DMA reception has gone to completion
;|***           //(we have a complete frame)
;|***           //get the number of bytes received (total)
;|***           k = ((inp(t1->port_list[i]+RBCH)&0x0f)<<8)+inp(t1->port_list[i]+RBCL);
; Line 1110
	*** 001a0f	26 8b 10 		mov	dx,WORD PTR es:[bx][si]
	*** 001a12	8b c2 			mov	ax,dx
	*** 001a14	83 c2 0b 		add	dx,11	;000bH
	*** 001a17	8b c8 			mov	cx,ax
	*** 001a19	8b c2 			mov	ax,dx
	*** 001a1b	8b d1 			mov	dx,cx
	*** 001a1d	83 c2 0a 		add	dx,10	;000aH
	*** 001a20	8b c8 			mov	cx,ax
	*** 001a22	ec 			in	al,dx
	*** 001a23	2a e4 			sub	ah,ah
	*** 001a25	8b d1 			mov	dx,cx
	*** 001a27	8b c8 			mov	cx,ax
	*** 001a29	ec 			in	al,dx
	*** 001a2a	8a e0 			mov	ah,al
	*** 001a2c	25 00 0f 		and	ax,3840	;0f00H
	*** 001a2f	03 c8 			add	cx,ax
;|***     
;|***           t1->rxbuffer[i][t1->current_rxbuf[i]]->valid = 1;         //validate the frame buffer
; Line 1112
	*** 001a31	03 de 			add	bx,si
	*** 001a33	26 8b 9f 7a 01 		mov	bx,WORD PTR es:[bx+378]
	*** 001a38	03 5e ea 		add	bx,WORD PTR [bp-22]
	*** 001a3b	c1 e3 02 		shl	bx,2
	*** 001a3e	03 1e 00 00 		add	bx,WORD PTR ?t1@@3PEVCescc@@E	;t1
	*** 001a42	26 c4 5f 7a 		les	bx,DWORD PTR es:[bx+122]
	*** 001a46	26 c7 07 01 00 		mov	WORD PTR es:[bx],1
;|***           t1->rxbuffer[i][t1->current_rxbuf[i]]->no_bytes = k;      //indicate the number of bytes received
; Line 1113
	*** 001a4b	c4 1e 00 00 		les	bx,DWORD PTR ?t1@@3PEVCescc@@E	;t1
	*** 001a4f	26 8b 98 7a 01 		mov	bx,WORD PTR es:[bx+378][si]
	*** 001a54	c1 e3 02 		shl	bx,2
	*** 001a57	03 1e 00 00 		add	bx,WORD PTR ?t1@@3PEVCescc@@E	;t1
	*** 001a5b	26 c4 59 7a 		les	bx,DWORD PTR es:[bx+122][di]
	*** 001a5f	26 89 4f 02 		mov	WORD PTR es:[bx+2],cx
;|***           t1->current_rxbuf[i]++;
; Line 1114
	*** 001a63	c4 1e 00 00 		les	bx,DWORD PTR ?t1@@3PEVCescc@@E	;t1
	*** 001a67	26 8b 80 7a 01 		mov	ax,WORD PTR es:[bx+378][si]
	*** 001a6c	40 			inc	ax
	*** 001a6d	26 89 80 7a 01 		mov	WORD PTR es:[bx+378][si],ax
;|***           if(t1->current_rxbuf[i]==t1->max_rxbuf[i]) t1->current_rxbuf[i] = 0;
; Line 1115
	*** 001a72	c4 1e 00 00 		les	bx,DWORD PTR ?t1@@3PEVCescc@@E	;t1
	*** 001a76	03 de 			add	bx,si
	*** 001a78	26 8b 87 82 01 		mov	ax,WORD PTR es:[bx+386]
	*** 001a7d	26 39 87 7a 01 		cmp	WORD PTR es:[bx+378],ax
	*** 001a82	75 0d 			jne	$I1778
	*** 001a84	8b 1e 00 00 		mov	bx,WORD PTR ?t1@@3PEVCescc@@E	;t1
	*** 001a88	03 de 			add	bx,si
	*** 001a8a	26 c7 87 7a 01 00 00 	mov	WORD PTR es:[bx+378],0
;|***           if(t1->rxbuffer[i][t1->current_rxbuf[i]]->valid ==1) 
; Line 1116
					$I1778:
	*** 001a91	c4 1e 00 00 		les	bx,DWORD PTR ?t1@@3PEVCescc@@E	;t1
	*** 001a95	03 de 			add	bx,si
	*** 001a97	26 8b 9f 7a 01 		mov	bx,WORD PTR es:[bx+378]
	*** 001a9c	03 5e ea 		add	bx,WORD PTR [bp-22]
	*** 001a9f	c1 e3 02 		shl	bx,2
	*** 001aa2	03 1e 00 00 		add	bx,WORD PTR ?t1@@3PEVCescc@@E	;t1
	*** 001aa6	26 c4 5f 7a 		les	bx,DWORD PTR es:[bx+122]
	*** 001aaa	26 83 3f 01 		cmp	WORD PTR es:[bx],1
	*** 001aae	75 12 			jne	$I1779
;|***             {
;|***             //   an error occured and the 
;|***             //   main program isn't done with 
;|***             //   the frame that is about
;|***             //   to be used for received data
;|***             t1->port_status[i] = t1->port_status[i] | RX_BUFFER_OVERFLOW;
; Line 1122
	*** 001ab0	c4 1e 00 00 		les	bx,DWORD PTR ?t1@@3PEVCescc@@E	;t1
	*** 001ab4	26 8b 80 96 01 		mov	ax,WORD PTR es:[bx+406][si]
	*** 001ab9	03 de 			add	bx,si
	*** 001abb	0c 40 			or	al,64	;0040H
	*** 001abd	26 89 87 96 01 		mov	WORD PTR es:[bx+406],ax
;|***             }
;|***           t1->rxbuffer[i][t1->current_rxbuf[i]]->no_bytes = 0;  //prep buf for use
; Line 1124
					$I1779:
	*** 001ac2	c4 1e 00 00 		les	bx,DWORD PTR ?t1@@3PEVCescc@@E	;t1
	*** 001ac6	26 8b 98 7a 01 		mov	bx,WORD PTR es:[bx+378][si]
	*** 001acb	c1 e3 02 		shl	bx,2
	*** 001ace	03 1e 00 00 		add	bx,WORD PTR ?t1@@3PEVCescc@@E	;t1
	*** 001ad2	26 c4 59 7a 		les	bx,DWORD PTR es:[bx+122][di]
	*** 001ad6	26 c7 47 02 00 00 	mov	WORD PTR es:[bx+2],0
;|***           t1->rxbuffer[i][t1->current_rxbuf[i]]->valid = 0;    //invalidate it for use
; Line 1125
	*** 001adc	c4 1e 00 00 		les	bx,DWORD PTR ?t1@@3PEVCescc@@E	;t1
	*** 001ae0	26 8b 98 7a 01 		mov	bx,WORD PTR es:[bx+378][si]
	*** 001ae5	03 5e ea 		add	bx,WORD PTR [bp-22]
	*** 001ae8	c1 e3 02 		shl	bx,2
	*** 001aeb	03 1e 00 00 		add	bx,WORD PTR ?t1@@3PEVCescc@@E	;t1
	*** 001aef	26 c4 5f 7a 		les	bx,DWORD PTR es:[bx+122]
	*** 001af3	26 c7 07 00 00 		mov	WORD PTR es:[bx],0
;|***           setupdmar(i,t1->rxbuffer[i][t1->current_rxbuf[i]]->frame); //sets address of rbuf.frame[] to dma channel and enables it
; Line 1126
	*** 001af8	ff 76 e8 		push	WORD PTR [bp-24]	;i
	*** 001afb	c4 1e 00 00 		les	bx,DWORD PTR ?t1@@3PEVCescc@@E	;t1
	*** 001aff	26 8b 98 7a 01 		mov	bx,WORD PTR es:[bx+378][si]
	*** 001b04	03 5e ea 		add	bx,WORD PTR [bp-22]
	*** 001b07	c1 e3 02 		shl	bx,2
	*** 001b0a	03 1e 00 00 		add	bx,WORD PTR ?t1@@3PEVCescc@@E	;t1
	*** 001b0e	26 8b 47 7a 		mov	ax,WORD PTR es:[bx+122]
	*** 001b12	26 8b 57 7c 		mov	dx,WORD PTR es:[bx+124]
	*** 001b16	05 06 00 		add	ax,6
	*** 001b19	52 			push	dx
	*** 001b1a	50 			push	ax
	*** 001b1b	ff 76 02 		push	WORD PTR [bp+2]
	*** 001b1e	ff 76 00 		push	WORD PTR [bp]	;this
	*** 001b21	0e 			push	cs
	*** 001b22	e8 00 00 		call	NEAR PTR ?setupdmar@Cescc@@JECXIPEX@Z	; Cescc::setupdmar
;|***           outp(t1->port_list[i]+CMDR,RMC);     //release the FIFO
; Line 1127
	*** 001b25	c4 1e 00 00 		les	bx,DWORD PTR ?t1@@3PEVCescc@@E	;t1
	*** 001b29	b8 80 00 		mov	ax,128	;0080H
	*** 001b2c	26 8b 10 		mov	dx,WORD PTR es:[bx][si]
	*** 001b2f	ee 			out	dx, al

;|***           t1->port_status[i] = t1->port_status[i] | RX_READY;
; Line 1128
	*** 001b30	26 8b 80 96 01 		mov	ax,WORD PTR es:[bx+406][si]
	*** 001b35	03 de 			add	bx,si
	*** 001b37	80 cc 02 		or	ah,2
	*** 001b3a	26 89 87 96 01 		mov	WORD PTR es:[bx+406],ax
;|***           }
;|***         }
;|***     
;|***       if(t1->eopmode[i]==OPMODE_ASYNC)
; Line 1132
					$I1766:
	*** 001b3f	c4 1e 00 00 		les	bx,DWORD PTR ?t1@@3PEVCescc@@E	;t1
	*** 001b43	03 de 			add	bx,si
	*** 001b45	26 83 bf 9e 01 01 	cmp	WORD PTR es:[bx+414],1
	*** 001b4b	74 03 			je	$JCC6987
	*** 001b4d	e9 75 02 		jmp	$I1780
					$JCC6987:
;|***         {
;|***         //TCD interrupt
;|***         //do check for dma..in which case we don't need to get any data here...just need to figure out
;|***         //how many bytes are in the buffer        
;|***         if(t1->port_dmar_list[i]==0)  // no DMA
; Line 1137
	*** 001b50	8b 1e 00 00 		mov	bx,WORD PTR ?t1@@3PEVCescc@@E	;t1
	*** 001b54	26 83 78 10 00 		cmp	WORD PTR es:[bx+16][si],0
	*** 001b59	74 03 			je	$JCC7001
	*** 001b5b	e9 3e 01 		jmp	$I1781
					$JCC7001:
;|***           {
;|***           k = inp(t1->port_list[i]+RBCL);//get num bytes in fifo
; Line 1139
	*** 001b5e	26 8b 10 		mov	dx,WORD PTR es:[bx][si]
	*** 001b61	83 c2 0a 		add	dx,10	;000aH
	*** 001b64	ec 			in	al,dx
	*** 001b65	8a c8 			mov	cl,al
	*** 001b67	2a ed 			sub	ch,ch
;|***           k = k&0x1f;
;|***           if(k==0) k=32;
; Line 1141
	*** 001b69	83 e1 1f 		and	cx,31	;001fH
	*** 001b6c	75 03 			jne	$I1782
	*** 001b6e	b9 20 00 		mov	cx,32	;0020H
;|***         
;|***           //assumes that k is allways a multiple of 2 (status byte included mode)
;|***           irxbuf = (t1->rxbuffer[i][t1->current_rxbuf[i]]);     
; Line 1144
					$I1782:
	*** 001b71	26 8b 98 7a 01 		mov	bx,WORD PTR es:[bx+378][si]
	*** 001b76	c1 e3 02 		shl	bx,2
	*** 001b79	03 1e 00 00 		add	bx,WORD PTR ?t1@@3PEVCescc@@E	;t1
	*** 001b7d	26 8b 41 7a 		mov	ax,WORD PTR es:[bx+122][di]
	*** 001b81	26 8b 51 7c 		mov	dx,WORD PTR es:[bx+124][di]
	*** 001b85	89 46 f2 		mov	WORD PTR [bp-14],ax	;irxbuf
	*** 001b88	89 56 f4 		mov	WORD PTR [bp-12],dx
;|***           //bloc = (unsigned far *)irxbuf->frame;
;|***           for(j=irxbuf->no_bytes;j<irxbuf->no_bytes+k;j++)  irxbuf->frame[j] = inp(t1->port_list[i]+FIFO);  //******inpw?
; Line 1146
	*** 001b8b	8b d8 			mov	bx,ax
	*** 001b8d	8e c2 			mov	es,dx
	*** 001b8f	26 8b 47 02 		mov	ax,WORD PTR es:[bx+2]
	*** 001b93	89 46 f6 		mov	WORD PTR [bp-10],ax	;j
	*** 001b96	89 4e fa 		mov	WORD PTR [bp-6],cx	;k
	*** 001b99	8b d0 			mov	dx,ax
	*** 001b9b	03 c1 			add	ax,cx
	*** 001b9d	3b c2 			cmp	ax,dx
	*** 001b9f	77 03 			ja	$JCC7071
	*** 001ba1	e9 f2 00 		jmp	$L2256
					$JCC7071:
	*** 001ba4	8b da 			mov	bx,dx
	*** 001ba6	8b 4e f2 		mov	cx,WORD PTR [bp-14]	;irxbuf
	*** 001ba9	89 76 f8 		mov	WORD PTR [bp-8],si
					$F1783:
	*** 001bac	c4 3e 00 00 		les	di,DWORD PTR ?t1@@3PEVCescc@@E	;t1
	*** 001bb0	03 fe 			add	di,si
	*** 001bb2	26 8b 15 		mov	dx,WORD PTR es:[di]
	*** 001bb5	83 c2 20 		add	dx,32	;0020H
	*** 001bb8	ec 			in	al,dx
	*** 001bb9	8b f9 			mov	di,cx
	*** 001bbb	8e 46 f4 		mov	es,WORD PTR [bp-12]
	*** 001bbe	26 88 41 06 		mov	BYTE PTR es:[bx+6][di],al
	*** 001bc2	26 8b 45 02 		mov	ax,WORD PTR es:[di+2]
	*** 001bc6	03 46 fa 		add	ax,WORD PTR [bp-6]	;k
	*** 001bc9	43 			inc	bx
	*** 001bca	3b c3 			cmp	ax,bx
	*** 001bcc	77 de 			ja	$F1783
					$FB1785:
;|***         
;|***           outp(t1->port_list[i]+CMDR,RMC);     //release fifo
; Line 1148
	*** 001bce	b8 80 00 		mov	ax,128	;0080H
	*** 001bd1	c4 1e 00 00 		les	bx,DWORD PTR ?t1@@3PEVCescc@@E	;t1
	*** 001bd5	26 8b 10 		mov	dx,WORD PTR es:[bx][si]
	*** 001bd8	ee 			out	dx, al

;|***           //could move this stuff elsewhere (such that the buffers get more than 32 bytes in em)
;|***           irxbuf->valid = 1;//validate rbuf
; Line 1150
	*** 001bd9	8b d9 			mov	bx,cx
	*** 001bdb	8e 46 f4 		mov	es,WORD PTR [bp-12]
	*** 001bde	26 c7 07 01 00 		mov	WORD PTR es:[bx],1
;|***           irxbuf->no_bytes = irxbuf->no_bytes + k; //number of bytes received in rbuf
; Line 1151
	*** 001be3	8b 46 fa 		mov	ax,WORD PTR [bp-6]	;k
	*** 001be6	26 01 47 02 		add	WORD PTR es:[bx+2],ax
;|***           t1->current_rxbuf[i]++;  
; Line 1152
	*** 001bea	c4 1e 00 00 		les	bx,DWORD PTR ?t1@@3PEVCescc@@E	;t1
	*** 001bee	26 8b 80 7a 01 		mov	ax,WORD PTR es:[bx+378][si]
	*** 001bf3	40 			inc	ax
	*** 001bf4	26 89 80 7a 01 		mov	WORD PTR es:[bx+378][si],ax
;|***           //irxbuf is no longer valid
;|***           if(t1->current_rxbuf[i]==t1->max_rxbuf[i]) t1->current_rxbuf[i]=0;                
; Line 1154
	*** 001bf9	c4 1e 00 00 		les	bx,DWORD PTR ?t1@@3PEVCescc@@E	;t1
	*** 001bfd	03 de 			add	bx,si
	*** 001bff	26 8b 87 82 01 		mov	ax,WORD PTR es:[bx+386]
	*** 001c04	26 39 87 7a 01 		cmp	WORD PTR es:[bx+378],ax
	*** 001c09	75 0d 			jne	$I1786
	*** 001c0b	8b 1e 00 00 		mov	bx,WORD PTR ?t1@@3PEVCescc@@E	;t1
	*** 001c0f	03 de 			add	bx,si
	*** 001c11	26 c7 87 7a 01 00 00 	mov	WORD PTR es:[bx+378],0
;|***           if(t1->rxbuffer[i][t1->current_rxbuf[i]]->valid ==1) 
; Line 1155
					$I1786:
	*** 001c18	c4 1e 00 00 		les	bx,DWORD PTR ?t1@@3PEVCescc@@E	;t1
	*** 001c1c	03 de 			add	bx,si
	*** 001c1e	26 8b bf 7a 01 		mov	di,WORD PTR es:[bx+378]
	*** 001c23	03 7e ea 		add	di,WORD PTR [bp-22]
	*** 001c26	c1 e7 02 		shl	di,2
	*** 001c29	8b 1e 00 00 		mov	bx,WORD PTR ?t1@@3PEVCescc@@E	;t1
	*** 001c2d	26 c4 59 7a 		les	bx,DWORD PTR es:[bx+122][di]
	*** 001c31	26 83 3f 01 		cmp	WORD PTR es:[bx],1
	*** 001c35	75 12 			jne	$I1787
;|***             {
;|***             // an error occured and the 
;|***             //   main program isn't done with 
;|***             //   the frame that is about
;|***             //   to be used for received data
;|***             // set the receive buffers overflowed bit of the status word for this port here
;|***             t1->port_status[i] = t1->port_status[i] | RX_BUFFER_OVERFLOW;
; Line 1162
	*** 001c37	c4 1e 00 00 		les	bx,DWORD PTR ?t1@@3PEVCescc@@E	;t1
	*** 001c3b	26 8b 80 96 01 		mov	ax,WORD PTR es:[bx+406][si]
	*** 001c40	0c 40 			or	al,64	;0040H
	*** 001c42	03 de 			add	bx,si
	*** 001c44	26 89 87 96 01 		mov	WORD PTR es:[bx+406],ax
;|***             }
;|***           t1->rxbuffer[i][t1->current_rxbuf[i]]->no_bytes = 0;  //prep buf for use
; Line 1164
					$I1787:
	*** 001c49	c4 1e 00 00 		les	bx,DWORD PTR ?t1@@3PEVCescc@@E	;t1
	*** 001c4d	26 8b 98 7a 01 		mov	bx,WORD PTR es:[bx+378][si]
	*** 001c52	c1 e3 02 		shl	bx,2
	*** 001c55	03 1e 00 00 		add	bx,WORD PTR ?t1@@3PEVCescc@@E	;t1
	*** 001c59	8b 7e ec 		mov	di,WORD PTR [bp-20]	;msb
	*** 001c5c	26 c4 59 7a 		les	bx,DWORD PTR es:[bx+122][di]
	*** 001c60	26 c7 47 02 00 00 	mov	WORD PTR es:[bx+2],0
;|***           t1->rxbuffer[i][t1->current_rxbuf[i]]->valid = 0;    //invalidate it for use
; Line 1165
	*** 001c66	c4 1e 00 00 		les	bx,DWORD PTR ?t1@@3PEVCescc@@E	;t1
	*** 001c6a	26 8b b8 7a 01 		mov	di,WORD PTR es:[bx+378][si]
	*** 001c6f	03 7e ea 		add	di,WORD PTR [bp-22]
	*** 001c72	c1 e7 02 		shl	di,2
	*** 001c75	26 c4 59 7a 		les	bx,DWORD PTR es:[bx+122][di]
	*** 001c79	26 c7 07 00 00 		mov	WORD PTR es:[bx],0
;|***           t1->port_status[i] = t1->port_status[i] | RX_READY;
; Line 1166
	*** 001c7e	c4 1e 00 00 		les	bx,DWORD PTR ?t1@@3PEVCescc@@E	;t1
	*** 001c82	26 8b 80 96 01 		mov	ax,WORD PTR es:[bx+406][si]
	*** 001c87	80 cc 02 		or	ah,2
	*** 001c8a	26 89 80 96 01 		mov	WORD PTR es:[bx+406][si],ax
	*** 001c8f	8b 7e ec 		mov	di,WORD PTR [bp-20]	;msb
;|***           }                                                 
;|***         else  // use DMA
; Line 1168
	*** 001c92	e9 30 01 		jmp	$I1780
	*** 001c95	90 			nop	
					$L2256:
	*** 001c96	8b cb 			mov	cx,bx
	*** 001c98	e9 33 ff 		jmp	$FB1785
	*** 001c9b	90 			nop	
					$I1781:
;|***           {
;|***           //get dmar count here and make buffer valid
;|***           k = getdmarcount(i);
; Line 1171
	*** 001c9c	ff 76 e8 		push	WORD PTR [bp-24]	;i
	*** 001c9f	ff 76 02 		push	WORD PTR [bp+2]
	*** 001ca2	ff 76 00 		push	WORD PTR [bp]	;this
	*** 001ca5	0e 			push	cs
	*** 001ca6	e8 00 00 		call	NEAR PTR ?getdmarcount@Cescc@@JECII@Z	; Cescc::getdmarcount
	*** 001ca9	89 46 fa 		mov	WORD PTR [bp-6],ax	;k
;|***           //assumes that the number of bytes transfered(dma) = number of bytes received
;|***           //this isn't allways the case...
;|***     
;|***           //assumes that k is allways a multiple of 2 (status byte included mode)
;|***           irxbuf = (t1->rxbuffer[i][t1->current_rxbuf[i]]);     
; Line 1176
	*** 001cac	c4 1e 00 00 		les	bx,DWORD PTR ?t1@@3PEVCescc@@E	;t1
	*** 001cb0	26 8b 98 7a 01 		mov	bx,WORD PTR es:[bx+378][si]
	*** 001cb5	c1 e3 02 		shl	bx,2
	*** 001cb8	03 1e 00 00 		add	bx,WORD PTR ?t1@@3PEVCescc@@E	;t1
	*** 001cbc	26 8b 41 7a 		mov	ax,WORD PTR es:[bx+122][di]
	*** 001cc0	26 8b 51 7c 		mov	dx,WORD PTR es:[bx+124][di]
	*** 001cc4	89 46 f2 		mov	WORD PTR [bp-14],ax	;irxbuf
	*** 001cc7	89 56 f4 		mov	WORD PTR [bp-12],dx
;|***           irxbuf->valid = 1;//validate rbuf
; Line 1177
	*** 001cca	8b d8 			mov	bx,ax
	*** 001ccc	8e c2 			mov	es,dx
	*** 001cce	26 c7 07 01 00 		mov	WORD PTR es:[bx],1
;|***           irxbuf->no_bytes = k; //number of bytes received in rbuf
; Line 1178
	*** 001cd3	8b 46 fa 		mov	ax,WORD PTR [bp-6]	;k
	*** 001cd6	c4 5e f2 		les	bx,DWORD PTR [bp-14]	;irxbuf
	*** 001cd9	26 89 47 02 		mov	WORD PTR es:[bx+2],ax
;|***           t1->current_rxbuf[i]++;  
; Line 1179
	*** 001cdd	c4 1e 00 00 		les	bx,DWORD PTR ?t1@@3PEVCescc@@E	;t1
	*** 001ce1	26 8b 80 7a 01 		mov	ax,WORD PTR es:[bx+378][si]
	*** 001ce6	40 			inc	ax
	*** 001ce7	26 89 80 7a 01 		mov	WORD PTR es:[bx+378][si],ax
;|***           //irxbuf is no longer valid
;|***           if(t1->current_rxbuf[i]==t1->max_rxbuf[i]) t1->current_rxbuf[i]=0;                
; Line 1181
	*** 001cec	c4 1e 00 00 		les	bx,DWORD PTR ?t1@@3PEVCescc@@E	;t1
	*** 001cf0	03 de 			add	bx,si
	*** 001cf2	26 8b 87 82 01 		mov	ax,WORD PTR es:[bx+386]
	*** 001cf7	26 39 87 7a 01 		cmp	WORD PTR es:[bx+378],ax
	*** 001cfc	75 0d 			jne	$I1789
	*** 001cfe	8b 1e 00 00 		mov	bx,WORD PTR ?t1@@3PEVCescc@@E	;t1
	*** 001d02	03 de 			add	bx,si
	*** 001d04	26 c7 87 7a 01 00 00 	mov	WORD PTR es:[bx+378],0
;|***           if(t1->rxbuffer[i][t1->current_rxbuf[i]]->valid ==1) 
; Line 1182
					$I1789:
	*** 001d0b	c4 1e 00 00 		les	bx,DWORD PTR ?t1@@3PEVCescc@@E	;t1
	*** 001d0f	03 de 			add	bx,si
	*** 001d11	26 8b 9f 7a 01 		mov	bx,WORD PTR es:[bx+378]
	*** 001d16	03 5e ea 		add	bx,WORD PTR [bp-22]
	*** 001d19	c1 e3 02 		shl	bx,2
	*** 001d1c	03 1e 00 00 		add	bx,WORD PTR ?t1@@3PEVCescc@@E	;t1
	*** 001d20	26 c4 5f 7a 		les	bx,DWORD PTR es:[bx+122]
	*** 001d24	26 83 3f 01 		cmp	WORD PTR es:[bx],1
	*** 001d28	75 12 			jne	$I1790
;|***             {
;|***             // an error occured and the 
;|***             //   main program isn't done with 
;|***             //   the frame that is about
;|***             //   to be used for received data
;|***             //set the receive buffers overflowed bit of the status word for this port here
;|***             t1->port_status[i] = t1->port_status[i] | RX_BUFFER_OVERFLOW;
; Line 1189
	*** 001d2a	c4 1e 00 00 		les	bx,DWORD PTR ?t1@@3PEVCescc@@E	;t1
	*** 001d2e	26 8b 80 96 01 		mov	ax,WORD PTR es:[bx+406][si]
	*** 001d33	03 de 			add	bx,si
	*** 001d35	0c 40 			or	al,64	;0040H
	*** 001d37	26 89 87 96 01 		mov	WORD PTR es:[bx+406],ax
;|***             }
;|***           t1->rxbuffer[i][t1->current_rxbuf[i]]->no_bytes = 0;  //prep buf for use
; Line 1191
					$I1790:
	*** 001d3c	c4 1e 00 00 		les	bx,DWORD PTR ?t1@@3PEVCescc@@E	;t1
	*** 001d40	26 8b 98 7a 01 		mov	bx,WORD PTR es:[bx+378][si]
	*** 001d45	c1 e3 02 		shl	bx,2
	*** 001d48	03 1e 00 00 		add	bx,WORD PTR ?t1@@3PEVCescc@@E	;t1
	*** 001d4c	26 c4 59 7a 		les	bx,DWORD PTR es:[bx+122][di]
	*** 001d50	26 c7 47 02 00 00 	mov	WORD PTR es:[bx+2],0
;|***           t1->rxbuffer[i][t1->current_rxbuf[i]]->valid = 0;    //invalidate it for use
; Line 1192
	*** 001d56	c4 1e 00 00 		les	bx,DWORD PTR ?t1@@3PEVCescc@@E	;t1
	*** 001d5a	26 8b 98 7a 01 		mov	bx,WORD PTR es:[bx+378][si]
	*** 001d5f	03 5e ea 		add	bx,WORD PTR [bp-22]
	*** 001d62	c1 e3 02 		shl	bx,2
	*** 001d65	03 1e 00 00 		add	bx,WORD PTR ?t1@@3PEVCescc@@E	;t1
	*** 001d69	26 c4 5f 7a 		les	bx,DWORD PTR es:[bx+122]
	*** 001d6d	26 c7 07 00 00 		mov	WORD PTR es:[bx],0
;|***           t1->port_status[i] = t1->port_status[i] | RX_READY;
; Line 1193
	*** 001d72	c4 1e 00 00 		les	bx,DWORD PTR ?t1@@3PEVCescc@@E	;t1
	*** 001d76	26 8b 80 96 01 		mov	ax,WORD PTR es:[bx+406][si]
	*** 001d7b	80 cc 02 		or	ah,2
	*** 001d7e	26 89 80 96 01 		mov	WORD PTR es:[bx+406][si],ax
;|***           setupdmar(i,t1->rxbuffer[i][t1->current_rxbuf[i]]->frame);
; Line 1194
	*** 001d83	ff 76 e8 		push	WORD PTR [bp-24]	;i
	*** 001d86	c4 1e 00 00 		les	bx,DWORD PTR ?t1@@3PEVCescc@@E	;t1
	*** 001d8a	26 8b 98 7a 01 		mov	bx,WORD PTR es:[bx+378][si]
	*** 001d8f	03 5e ea 		add	bx,WORD PTR [bp-22]
	*** 001d92	c1 e3 02 		shl	bx,2
	*** 001d95	03 1e 00 00 		add	bx,WORD PTR ?t1@@3PEVCescc@@E	;t1
	*** 001d99	26 8b 47 7a 		mov	ax,WORD PTR es:[bx+122]
	*** 001d9d	26 8b 57 7c 		mov	dx,WORD PTR es:[bx+124]
	*** 001da1	05 06 00 		add	ax,6
	*** 001da4	52 			push	dx
	*** 001da5	50 			push	ax
	*** 001da6	ff 76 02 		push	WORD PTR [bp+2]
	*** 001da9	ff 76 00 		push	WORD PTR [bp]	;this
	*** 001dac	0e 			push	cs
	*** 001dad	e8 00 00 		call	NEAR PTR ?setupdmar@Cescc@@JECXIPEX@Z	; Cescc::setupdmar
;|***           inp(t1->port_list[i]+RBCL);
; Line 1195
	*** 001db0	c4 1e 00 00 		les	bx,DWORD PTR ?t1@@3PEVCescc@@E	;t1
	*** 001db4	26 8b 10 		mov	dx,WORD PTR es:[bx][si]
	*** 001db7	8b c2 			mov	ax,dx
	*** 001db9	83 c2 0a 		add	dx,10	;000aH
	*** 001dbc	8b c8 			mov	cx,ax
	*** 001dbe	ec 			in	al,dx
;|***           outp(t1->port_list[i]+CMDR,RMC);     //release fifo
; Line 1196
	*** 001dbf	b8 80 00 		mov	ax,128	;0080H
	*** 001dc2	8b d1 			mov	dx,cx
	*** 001dc4	ee 			out	dx, al

;|***           }   // end use DMA
;|***         } // end ASYNC
;|*** 
;|***       if(t1->eopmode[i]==OPMODE_BISYNC)
; Line 1200
					$I1780:
	*** 001dc5	c4 1e 00 00 		les	bx,DWORD PTR ?t1@@3PEVCescc@@E	;t1
	*** 001dc9	03 de 			add	bx,si
	*** 001dcb	26 83 bf 9e 01 02 	cmp	WORD PTR es:[bx+414],2
	*** 001dd1	74 03 			je	$JCC7633
	*** 001dd3	e9 74 01 		jmp	$I1765
					$JCC7633:
;|***         {
;|***         //TCD interrupt
;|***         
;|***         k = inp(t1->port_list[i]+RBCL);//get num bytes in fifo
; Line 1204
	*** 001dd6	8b 1e 00 00 		mov	bx,WORD PTR ?t1@@3PEVCescc@@E	;t1
	*** 001dda	26 8b 10 		mov	dx,WORD PTR es:[bx][si]
	*** 001ddd	83 c2 0a 		add	dx,10	;000aH
	*** 001de0	ec 			in	al,dx
	*** 001de1	8a c8 			mov	cl,al
	*** 001de3	2a ed 			sub	ch,ch
;|***         k = k&0x1f;
;|***         if(k==0) k=32;
; Line 1206
	*** 001de5	83 e1 1f 		and	cx,31	;001fH
	*** 001de8	75 03 			jne	$I1792
	*** 001dea	b9 20 00 		mov	cx,32	;0020H
;|***         
;|***         //assumes that k is allways a multiple of 2 (status byte included mode)
;|***         irxbuf = (t1->rxbuffer[i][t1->current_rxbuf[i]]);     
; Line 1209
					$I1792:
	*** 001ded	26 8b 98 7a 01 		mov	bx,WORD PTR es:[bx+378][si]
	*** 001df2	c1 e3 02 		shl	bx,2
	*** 001df5	03 1e 00 00 		add	bx,WORD PTR ?t1@@3PEVCescc@@E	;t1
	*** 001df9	26 8b 41 7a 		mov	ax,WORD PTR es:[bx+122][di]
	*** 001dfd	26 8b 51 7c 		mov	dx,WORD PTR es:[bx+124][di]
	*** 001e01	89 46 f2 		mov	WORD PTR [bp-14],ax	;irxbuf
	*** 001e04	89 56 f4 		mov	WORD PTR [bp-12],dx
;|***         //bloc = (unsigned far *)irxbuf->frame;
;|***         for(j=irxbuf->no_bytes;j<irxbuf->no_bytes+k;j++)
; Line 1211
	*** 001e07	8b d8 			mov	bx,ax
	*** 001e09	8e c2 			mov	es,dx
	*** 001e0b	26 8b 47 02 		mov	ax,WORD PTR es:[bx+2]
	*** 001e0f	89 46 f6 		mov	WORD PTR [bp-10],ax	;j
	*** 001e12	89 4e fa 		mov	WORD PTR [bp-6],cx	;k
	*** 001e15	8b d0 			mov	dx,ax
	*** 001e17	03 c1 			add	ax,cx
	*** 001e19	3b c2 			cmp	ax,dx
	*** 001e1b	77 03 			ja	$JCC7707
	*** 001e1d	e9 90 01 		jmp	$L2266
					$JCC7707:
	*** 001e20	8b da 			mov	bx,dx
	*** 001e22	8b 4e f2 		mov	cx,WORD PTR [bp-14]	;irxbuf
	*** 001e25	89 76 f8 		mov	WORD PTR [bp-8],si
					$F1793:
;|***           irxbuf->frame[j] = inp(t1->port_list[i]+FIFO); //****inpw?
; Line 1212
	*** 001e28	c4 3e 00 00 		les	di,DWORD PTR ?t1@@3PEVCescc@@E	;t1
	*** 001e2c	03 fe 			add	di,si
	*** 001e2e	26 8b 15 		mov	dx,WORD PTR es:[di]
	*** 001e31	83 c2 20 		add	dx,32	;0020H
	*** 001e34	ec 			in	al,dx
	*** 001e35	8b f9 			mov	di,cx
	*** 001e37	8e 46 f4 		mov	es,WORD PTR [bp-12]
	*** 001e3a	26 88 41 06 		mov	BYTE PTR es:[bx+6][di],al
	*** 001e3e	26 8b 45 02 		mov	ax,WORD PTR es:[di+2]
	*** 001e42	03 46 fa 		add	ax,WORD PTR [bp-6]	;k
	*** 001e45	43 			inc	bx
	*** 001e46	3b c3 			cmp	ax,bx
	*** 001e48	77 de 			ja	$F1793
					$L2218:
	*** 001e4a	c4 1e 00 00 		les	bx,DWORD PTR ?t1@@3PEVCescc@@E	;t1
;|***         while((inp(t1->port_list[i]+STAR)&CEC)==CEC);
; Line 1213
					$FC1797:
	*** 001e4e	8b 76 f8 		mov	si,WORD PTR [bp-8]
	*** 001e51	26 8b 10 		mov	dx,WORD PTR es:[bx][si]
	*** 001e54	ec 			in	al,dx
	*** 001e55	24 04 			and	al,4
	*** 001e57	3c 04 			cmp	al,4
	*** 001e59	74 f3 			je	$FC1797
;|***         outp(t1->port_list[i]+CMDR,RMC);     //release fifo
; Line 1214
	*** 001e5b	b8 80 00 		mov	ax,128	;0080H
	*** 001e5e	ee 			out	dx, al

	*** 001e5f	8b 4e f2 		mov	cx,WORD PTR [bp-14]	;irxbuf
;|***         //could move this stuff elsewhere (such that the buffers get more than 32 bytes in em)
;|***         irxbuf->valid = 1;//validate rbuf
; Line 1216
	*** 001e62	8b d9 			mov	bx,cx
	*** 001e64	8e 46 f4 		mov	es,WORD PTR [bp-12]
	*** 001e67	26 c7 07 01 00 		mov	WORD PTR es:[bx],1
;|***         irxbuf->no_bytes = irxbuf->no_bytes + k; //number of bytes received in rbuf
; Line 1217
	*** 001e6c	8b 46 fa 		mov	ax,WORD PTR [bp-6]	;k
	*** 001e6f	26 01 47 02 		add	WORD PTR es:[bx+2],ax
;|***         t1->current_rxbuf[i]++;  
; Line 1218
	*** 001e73	c4 1e 00 00 		les	bx,DWORD PTR ?t1@@3PEVCescc@@E	;t1
	*** 001e77	26 8b 80 7a 01 		mov	ax,WORD PTR es:[bx+378][si]
	*** 001e7c	40 			inc	ax
	*** 001e7d	26 89 80 7a 01 		mov	WORD PTR es:[bx+378][si],ax
;|***         //irxbuf is no longer valid
;|***         if(t1->current_rxbuf[i]==t1->max_rxbuf[i]) t1->current_rxbuf[i]=0;                
; Line 1220
	*** 001e82	c4 1e 00 00 		les	bx,DWORD PTR ?t1@@3PEVCescc@@E	;t1
	*** 001e86	03 de 			add	bx,si
	*** 001e88	26 8b 87 82 01 		mov	ax,WORD PTR es:[bx+386]
	*** 001e8d	26 39 87 7a 01 		cmp	WORD PTR es:[bx+378],ax
	*** 001e92	75 0d 			jne	$I1799
	*** 001e94	8b 1e 00 00 		mov	bx,WORD PTR ?t1@@3PEVCescc@@E	;t1
	*** 001e98	03 de 			add	bx,si
	*** 001e9a	26 c7 87 7a 01 00 00 	mov	WORD PTR es:[bx+378],0
;|***         if(t1->rxbuffer[i][t1->current_rxbuf[i]]->valid ==1) 
; Line 1221
					$I1799:
	*** 001ea1	8b 5e ea 		mov	bx,WORD PTR [bp-22]
	*** 001ea4	c4 3e 00 00 		les	di,DWORD PTR ?t1@@3PEVCescc@@E	;t1
	*** 001ea8	03 fe 			add	di,si
	*** 001eaa	26 8b bd 7a 01 		mov	di,WORD PTR es:[di+378]
	*** 001eaf	03 fb 			add	di,bx
	*** 001eb1	c1 e7 02 		shl	di,2
	*** 001eb4	03 3e 00 00 		add	di,WORD PTR ?t1@@3PEVCescc@@E	;t1
	*** 001eb8	26 c4 7d 7a 		les	di,DWORD PTR es:[di+122]
	*** 001ebc	26 83 3d 01 		cmp	WORD PTR es:[di],1
	*** 001ec0	75 18 			jne	$I1800
;|***           {
;|***           // an error occured and the 
;|***           //   main program isn't done with 
;|***           //   the frame that is about
;|***           //   to be used for received data
;|***           // set the receive buffers overflowed bit of the status word for this port here
;|***           t1->port_status[i] = t1->port_status[i] | RX_BUFFER_OVERFLOW;
; Line 1228
	*** 001ec2	c4 3e 00 00 		les	di,DWORD PTR ?t1@@3PEVCescc@@E	;t1
	*** 001ec6	03 fe 			add	di,si
	*** 001ec8	26 8b 85 96 01 		mov	ax,WORD PTR es:[di+406]
	*** 001ecd	0c 40 			or	al,64	;0040H
	*** 001ecf	8b 3e 00 00 		mov	di,WORD PTR ?t1@@3PEVCescc@@E	;t1
	*** 001ed3	03 fe 			add	di,si
	*** 001ed5	26 89 85 96 01 		mov	WORD PTR es:[di+406],ax
;|***           }
;|***         t1->rxbuffer[i][t1->current_rxbuf[i]]->no_bytes = 0;  //prep buf for use
; Line 1230
					$I1800:
	*** 001eda	c4 3e 00 00 		les	di,DWORD PTR ?t1@@3PEVCescc@@E	;t1
	*** 001ede	03 fe 			add	di,si
	*** 001ee0	26 8b bd 7a 01 		mov	di,WORD PTR es:[di+378]
	*** 001ee5	c1 e7 02 		shl	di,2
	*** 001ee8	03 3e 00 00 		add	di,WORD PTR ?t1@@3PEVCescc@@E	;t1
	*** 001eec	03 7e ec 		add	di,WORD PTR [bp-20]	;msb
	*** 001eef	26 c4 7d 7a 		les	di,DWORD PTR es:[di+122]
	*** 001ef3	26 c7 45 02 00 00 	mov	WORD PTR es:[di+2],0
;|***         t1->rxbuffer[i][t1->current_rxbuf[i]]->valid = 0;    //invalidate it for use
; Line 1231
	*** 001ef9	c4 3e 00 00 		les	di,DWORD PTR ?t1@@3PEVCescc@@E	;t1
	*** 001efd	03 fe 			add	di,si
	*** 001eff	26 8b bd 7a 01 		mov	di,WORD PTR es:[di+378]
	*** 001f04	03 fb 			add	di,bx
	*** 001f06	c1 e7 02 		shl	di,2
	*** 001f09	03 3e 00 00 		add	di,WORD PTR ?t1@@3PEVCescc@@E	;t1
	*** 001f0d	26 c4 7d 7a 		les	di,DWORD PTR es:[di+122]
	*** 001f11	26 c7 05 00 00 		mov	WORD PTR es:[di],0
;|***         t1->port_status[i] = t1->port_status[i] | RX_READY;
; Line 1232
	*** 001f16	c4 3e 00 00 		les	di,DWORD PTR ?t1@@3PEVCescc@@E	;t1
	*** 001f1a	03 fe 			add	di,si
	*** 001f1c	26 8b 85 96 01 		mov	ax,WORD PTR es:[di+406]
	*** 001f21	80 cc 02 		or	ah,2
	*** 001f24	8b 3e 00 00 		mov	di,WORD PTR ?t1@@3PEVCescc@@E	;t1
	*** 001f28	03 fe 			add	di,si
	*** 001f2a	26 89 85 96 01 		mov	WORD PTR es:[di+406],ax
	*** 001f2f	c4 3e 00 00 		les	di,DWORD PTR ?t1@@3PEVCescc@@E	;t1
	*** 001f33	03 fe 			add	di,si
;|***         while((inp(t1->port_list[i]+STAR)&CEC)==CEC);
; Line 1233
					$FC1802:
	*** 001f35	8b 1e 00 00 		mov	bx,WORD PTR ?t1@@3PEVCescc@@E	;t1
	*** 001f39	8b 76 f8 		mov	si,WORD PTR [bp-8]
	*** 001f3c	26 8b 10 		mov	dx,WORD PTR es:[bx][si]
	*** 001f3f	ec 			in	al,dx
	*** 001f40	24 04 			and	al,4
	*** 001f42	3c 04 			cmp	al,4
	*** 001f44	74 ef 			je	$FC1802
;|***         outp(t1->port_list[i]+CMDR,HUNT);     //go back to hunt mode
; Line 1234
	*** 001f46	b8 04 00 		mov	ax,4
	*** 001f49	ee 			out	dx, al

;|***         }  //  end BISYNC                                                 
;|***       } // end RME
;|***       
;|***     
;|***     if((isr0&RFS)==RFS)   //  RFS Receive Frame Start
; Line 1239
					$I1765:
	*** 001f4a	8b 5e fe 		mov	bx,WORD PTR [bp-2]	;isr0
	*** 001f4d	8a c3 			mov	al,bl
	*** 001f4f	24 40 			and	al,64	;0040H
	*** 001f51	3c 40 			cmp	al,64	;0040H
	*** 001f53	74 03 			je	$JCC8019
	*** 001f55	e9 58 01 		jmp	$I1804
					$JCC8019:
;|***       {
;|***       if(t1->eopmode[i]==OPMODE_HDLC)
; Line 1241
	*** 001f58	8b 3e 00 00 		mov	di,WORD PTR ?t1@@3PEVCescc@@E	;t1
	*** 001f5c	03 fe 			add	di,si
	*** 001f5e	26 83 bd 9e 01 00 	cmp	WORD PTR es:[di+414],0
	*** 001f64	75 18 			jne	$I1805
;|***         {     
;|***         //RFS interrupt time to start the coffee
;|***         t1->port_status[i] = t1->port_status[i] | RFS_INTERRUPT;
; Line 1244
	*** 001f66	8b 3e 00 00 		mov	di,WORD PTR ?t1@@3PEVCescc@@E	;t1
	*** 001f6a	03 fe 			add	di,si
	*** 001f6c	26 8b 85 96 01 		mov	ax,WORD PTR es:[di+406]
	*** 001f71	0c 20 			or	al,32	;0020H
	*** 001f73	8b 3e 00 00 		mov	di,WORD PTR ?t1@@3PEVCescc@@E	;t1
	*** 001f77	03 fe 			add	di,si
	*** 001f79	26 89 85 96 01 		mov	WORD PTR es:[di+406],ax
;|***         }
;|***         
;|***       if(t1->eopmode[i]==OPMODE_ASYNC)
; Line 1247
					$I1805:
	*** 001f7e	c4 3e 00 00 		les	di,DWORD PTR ?t1@@3PEVCescc@@E	;t1
	*** 001f82	03 fe 			add	di,si
	*** 001f84	26 83 bd 9e 01 01 	cmp	WORD PTR es:[di+414],1
	*** 001f8a	74 03 			je	$JCC8074
	*** 001f8c	e9 21 01 		jmp	$I1804
					$JCC8074:
;|***         {
;|***         //TIME out interrupt
;|***         //I think this would be a good time to pull the data from the fifo, issuing a 
;|***         //RFRD command (0x20) to force the fifo open, the book says that it will force
;|***         //a TCD interrupt which will collect the data
;|***         
;|***         if((inp(t1->port_list[i]+STAR)&0x20)==0x20) outp(t1->port_list[i]+CMDR,0x20);
; Line 1254
	*** 001f8f	8b 3e 00 00 		mov	di,WORD PTR ?t1@@3PEVCescc@@E	;t1
	*** 001f93	03 fe 			add	di,si
	*** 001f95	26 8b 15 		mov	dx,WORD PTR es:[di]
	*** 001f98	ec 			in	al,dx
	*** 001f99	24 20 			and	al,32	;0020H
	*** 001f9b	3c 20 			cmp	al,32	;0020H
	*** 001f9d	75 17 			jne	$I1807
	*** 001f9f	b8 20 00 		mov	ax,32	;0020H
	*** 001fa2	8b 3e 00 00 		mov	di,WORD PTR ?t1@@3PEVCescc@@E	;t1
	*** 001fa6	03 fe 			add	di,si
	*** 001fa8	26 8b 15 		mov	dx,WORD PTR es:[di]
	*** 001fab	ee 			out	dx, al

;|***         else
; Line 1255
	*** 001fac	e9 e8 00 		jmp	$I1808
	*** 001faf	90 			nop	
					$L2266:
	*** 001fb0	89 76 f8 		mov	WORD PTR [bp-8],si
	*** 001fb3	e9 94 fe 		jmp	$L2218
					$I1807:
;|***           {
;|***           //here would be a good time to close out the current rxbuf and
;|***           //start in on a new one...sending rxready...no more data is 
;|***           //currently coming in so pass what we have on.
;|***           irxbuf = (t1->rxbuffer[i][t1->current_rxbuf[i]]);     
;|***           irxbuf->valid = 1;//validate rbuf
; Line 1261
	*** 001fb6	8b 3e 00 00 		mov	di,WORD PTR ?t1@@3PEVCescc@@E	;t1
	*** 001fba	03 fe 			add	di,si
	*** 001fbc	26 8b bd 7a 01 		mov	di,WORD PTR es:[di+378]
	*** 001fc1	c1 e7 02 		shl	di,2
	*** 001fc4	03 3e 00 00 		add	di,WORD PTR ?t1@@3PEVCescc@@E	;t1
	*** 001fc8	03 7e ec 		add	di,WORD PTR [bp-20]	;msb
	*** 001fcb	26 c4 7d 7a 		les	di,DWORD PTR es:[di+122]
	*** 001fcf	26 c7 05 01 00 		mov	WORD PTR es:[di],1
;|***           t1->current_rxbuf[i]++;  
; Line 1262
	*** 001fd4	c4 3e 00 00 		les	di,DWORD PTR ?t1@@3PEVCescc@@E	;t1
	*** 001fd8	03 fe 			add	di,si
	*** 001fda	26 8b 85 7a 01 		mov	ax,WORD PTR es:[di+378]
	*** 001fdf	40 			inc	ax
	*** 001fe0	8b 3e 00 00 		mov	di,WORD PTR ?t1@@3PEVCescc@@E	;t1
	*** 001fe4	03 fe 			add	di,si
	*** 001fe6	26 89 85 7a 01 		mov	WORD PTR es:[di+378],ax
;|***           //irxbuf is no longer valid
;|***           if(t1->current_rxbuf[i]==t1->max_rxbuf[i]) t1->current_rxbuf[i]=0;                
; Line 1264
	*** 001feb	c4 3e 00 00 		les	di,DWORD PTR ?t1@@3PEVCescc@@E	;t1
	*** 001fef	03 fe 			add	di,si
	*** 001ff1	26 8b 85 82 01 		mov	ax,WORD PTR es:[di+386]
	*** 001ff6	26 39 85 7a 01 		cmp	WORD PTR es:[di+378],ax
	*** 001ffb	75 0d 			jne	$I1809
	*** 001ffd	8b 3e 00 00 		mov	di,WORD PTR ?t1@@3PEVCescc@@E	;t1
	*** 002001	03 fe 			add	di,si
	*** 002003	26 c7 85 7a 01 00 00 	mov	WORD PTR es:[di+378],0
;|***           if(t1->rxbuffer[i][t1->current_rxbuf[i]]->valid ==1) 
; Line 1265
					$I1809:
	*** 00200a	c4 3e 00 00 		les	di,DWORD PTR ?t1@@3PEVCescc@@E	;t1
	*** 00200e	03 fe 			add	di,si
	*** 002010	26 8b bd 7a 01 		mov	di,WORD PTR es:[di+378]
	*** 002015	03 7e ea 		add	di,WORD PTR [bp-22]
	*** 002018	c1 e7 02 		shl	di,2
	*** 00201b	03 3e 00 00 		add	di,WORD PTR ?t1@@3PEVCescc@@E	;t1
	*** 00201f	26 c4 7d 7a 		les	di,DWORD PTR es:[di+122]
	*** 002023	26 83 3d 01 		cmp	WORD PTR es:[di],1
	*** 002027	75 18 			jne	$I1810
;|***             {
;|***             // an error occured and the 
;|***             // main program isn't done with 
;|***             // the frame that is about
;|***             // to be used for received data
;|***             // set the receive buffers overflowed bit of the status word for this port here
;|***             t1->port_status[i] = t1->port_status[i] | RX_BUFFER_OVERFLOW;
; Line 1272
	*** 002029	c4 3e 00 00 		les	di,DWORD PTR ?t1@@3PEVCescc@@E	;t1
	*** 00202d	03 fe 			add	di,si
	*** 00202f	26 8b 85 96 01 		mov	ax,WORD PTR es:[di+406]
	*** 002034	0c 40 			or	al,64	;0040H
	*** 002036	8b 3e 00 00 		mov	di,WORD PTR ?t1@@3PEVCescc@@E	;t1
	*** 00203a	03 fe 			add	di,si
	*** 00203c	26 89 85 96 01 		mov	WORD PTR es:[di+406],ax
;|***             }
;|***             
;|***           t1->rxbuffer[i][t1->current_rxbuf[i]]->no_bytes = 0;  //prep buf for use
; Line 1275
					$I1810:
	*** 002041	c4 3e 00 00 		les	di,DWORD PTR ?t1@@3PEVCescc@@E	;t1
	*** 002045	03 fe 			add	di,si
	*** 002047	26 8b bd 7a 01 		mov	di,WORD PTR es:[di+378]
	*** 00204c	c1 e7 02 		shl	di,2
	*** 00204f	03 3e 00 00 		add	di,WORD PTR ?t1@@3PEVCescc@@E	;t1
	*** 002053	03 7e ec 		add	di,WORD PTR [bp-20]	;msb
	*** 002056	26 c4 7d 7a 		les	di,DWORD PTR es:[di+122]
	*** 00205a	26 c7 45 02 00 00 	mov	WORD PTR es:[di+2],0
;|***           t1->rxbuffer[i][t1->current_rxbuf[i]]->valid = 0;    //invalidate it for use
; Line 1276
	*** 002060	c4 3e 00 00 		les	di,DWORD PTR ?t1@@3PEVCescc@@E	;t1
	*** 002064	03 fe 			add	di,si
	*** 002066	26 8b bd 7a 01 		mov	di,WORD PTR es:[di+378]
	*** 00206b	03 7e ea 		add	di,WORD PTR [bp-22]
	*** 00206e	c1 e7 02 		shl	di,2
	*** 002071	03 3e 00 00 		add	di,WORD PTR ?t1@@3PEVCescc@@E	;t1
	*** 002075	26 c4 7d 7a 		les	di,DWORD PTR es:[di+122]
	*** 002079	26 c7 05 00 00 		mov	WORD PTR es:[di],0
;|***           t1->port_status[i] = t1->port_status[i] | RX_READY;
; Line 1277
	*** 00207e	c4 3e 00 00 		les	di,DWORD PTR ?t1@@3PEVCescc@@E	;t1
	*** 002082	03 fe 			add	di,si
	*** 002084	26 8b 85 96 01 		mov	ax,WORD PTR es:[di+406]
	*** 002089	80 cc 02 		or	ah,2
	*** 00208c	8b 3e 00 00 		mov	di,WORD PTR ?t1@@3PEVCescc@@E	;t1
	*** 002090	03 fe 			add	di,si
	*** 002092	26 89 85 96 01 		mov	WORD PTR es:[di+406],ax
;|***           }
; Line 1278
					$I1808:
;|***           
;|***         t1->port_status[i] = t1->port_status[i] | REC_TIMEOUT;
; Line 1280
	*** 002097	c4 3e 00 00 		les	di,DWORD PTR ?t1@@3PEVCescc@@E	;t1
	*** 00209b	03 fe 			add	di,si
	*** 00209d	26 8b 85 96 01 		mov	ax,WORD PTR es:[di+406]
	*** 0020a2	80 cc 80 		or	ah,128	;0080H
	*** 0020a5	8b 3e 00 00 		mov	di,WORD PTR ?t1@@3PEVCescc@@E	;t1
	*** 0020a9	03 fe 			add	di,si
	*** 0020ab	26 89 85 96 01 		mov	WORD PTR es:[di+406],ax
;|***         }  // end ASYNC                             
;|***         //shouldn't happen in bisync mode
;|***       } // end RFS
;|***       
;|***     
;|***     if((isr0&RSC)==RSC)     //  RSC Receive Status Change.  Significant in auto-mode only.
; Line 1286
					$I1804:
	*** 0020b0	8a c3 			mov	al,bl
	*** 0020b2	24 20 			and	al,32	;0020H
	*** 0020b4	3c 20 			cmp	al,32	;0020H
	*** 0020b6	75 74 			jne	$I1811
;|***       {
;|***       if(t1->eopmode[i]==OPMODE_HDLC)
; Line 1288
	*** 0020b8	c4 3e 00 00 		les	di,DWORD PTR ?t1@@3PEVCescc@@E	;t1
	*** 0020bc	03 fe 			add	di,si
	*** 0020be	26 83 bd 9e 01 00 	cmp	WORD PTR es:[di+414],0
	*** 0020c4	75 18 			jne	$I1812
;|***         {     
;|***         //RSC interrupt (either got a RR or a RNR from HDLC link in auto mode
;|***         t1->port_status[i] = t1->port_status[i] | RSC_INTERRUPT;
; Line 1291
	*** 0020c6	8b 3e 00 00 		mov	di,WORD PTR ?t1@@3PEVCescc@@E	;t1
	*** 0020ca	03 fe 			add	di,si
	*** 0020cc	26 8b 85 96 01 		mov	ax,WORD PTR es:[di+406]
	*** 0020d1	0c 80 			or	al,128	;0080H
	*** 0020d3	8b 3e 00 00 		mov	di,WORD PTR ?t1@@3PEVCescc@@E	;t1
	*** 0020d7	03 fe 			add	di,si
	*** 0020d9	26 89 85 96 01 		mov	WORD PTR es:[di+406],ax
;|***         }
;|***         
;|***       if(t1->eopmode[i]==OPMODE_ASYNC)
; Line 1294
					$I1812:
	*** 0020de	c4 3e 00 00 		les	di,DWORD PTR ?t1@@3PEVCescc@@E	;t1
	*** 0020e2	03 fe 			add	di,si
	*** 0020e4	26 83 bd 9e 01 01 	cmp	WORD PTR es:[di+414],1
	*** 0020ea	75 19 			jne	$I1813
;|***         {
;|***         //parrity error interrupt         
;|***         t1->port_status[i] = t1->port_status[i] | PARITY_ERROR;
; Line 1297
	*** 0020ec	8b 3e 00 00 		mov	di,WORD PTR ?t1@@3PEVCescc@@E	;t1
	*** 0020f0	03 fe 			add	di,si
	*** 0020f2	26 8b 85 96 01 		mov	ax,WORD PTR es:[di+406]
	*** 0020f7	80 cc 04 		or	ah,4
	*** 0020fa	8b 3e 00 00 		mov	di,WORD PTR ?t1@@3PEVCescc@@E	;t1
	*** 0020fe	03 fe 			add	di,si
	*** 002100	26 89 85 96 01 		mov	WORD PTR es:[di+406],ax
;|***         }
;|***           
;|***       if(t1->eopmode[i]==OPMODE_BISYNC)
; Line 1300
					$I1813:
	*** 002105	c4 3e 00 00 		les	di,DWORD PTR ?t1@@3PEVCescc@@E	;t1
	*** 002109	03 fe 			add	di,si
	*** 00210b	26 83 bd 9e 01 02 	cmp	WORD PTR es:[di+414],2
	*** 002111	75 19 			jne	$I1811
;|***         {
;|***         //parrity error interrupt         
;|***         t1->port_status[i] = t1->port_status[i] | PARITY_ERROR;
; Line 1303
	*** 002113	8b 3e 00 00 		mov	di,WORD PTR ?t1@@3PEVCescc@@E	;t1
	*** 002117	03 fe 			add	di,si
	*** 002119	26 8b 85 96 01 		mov	ax,WORD PTR es:[di+406]
	*** 00211e	80 cc 04 		or	ah,4
	*** 002121	8b 3e 00 00 		mov	di,WORD PTR ?t1@@3PEVCescc@@E	;t1
	*** 002125	03 fe 			add	di,si
	*** 002127	26 89 85 96 01 		mov	WORD PTR es:[di+406],ax
;|***         }
;|***       }  // end RSC
;|***       
;|***     
;|***     if((isr0&PCE)==PCE)  //  PCE Protocol Error.  Significant in auto-mode only.
; Line 1308
					$I1811:
	*** 00212c	8a c3 			mov	al,bl
	*** 00212e	24 10 			and	al,16	;0010H
	*** 002130	3c 10 			cmp	al,16	;0010H
	*** 002132	75 74 			jne	$I1815
;|***       {
;|***       if(t1->eopmode[i]==OPMODE_HDLC)
; Line 1310
	*** 002134	c4 3e 00 00 		les	di,DWORD PTR ?t1@@3PEVCescc@@E	;t1
	*** 002138	03 fe 			add	di,si
	*** 00213a	26 83 bd 9e 01 00 	cmp	WORD PTR es:[di+414],0
	*** 002140	75 18 			jne	$I1816
;|***         {     
;|***         //protocol error (auto mode only)            
;|***         t1->port_status[i] = t1->port_status[i] | PCE_INTERRUPT;
; Line 1313
	*** 002142	8b 3e 00 00 		mov	di,WORD PTR ?t1@@3PEVCescc@@E	;t1
	*** 002146	03 fe 			add	di,si
	*** 002148	26 8b 85 96 01 		mov	ax,WORD PTR es:[di+406]
	*** 00214d	0c 04 			or	al,4
	*** 00214f	8b 3e 00 00 		mov	di,WORD PTR ?t1@@3PEVCescc@@E	;t1
	*** 002153	03 fe 			add	di,si
	*** 002155	26 89 85 96 01 		mov	WORD PTR es:[di+406],ax
;|***         }
;|***         
;|***       if(t1->eopmode[i]==OPMODE_ASYNC)
; Line 1316
					$I1816:
	*** 00215a	c4 3e 00 00 		les	di,DWORD PTR ?t1@@3PEVCescc@@E	;t1
	*** 00215e	03 fe 			add	di,si
	*** 002160	26 83 bd 9e 01 01 	cmp	WORD PTR es:[di+414],1
	*** 002166	75 19 			jne	$I1817
;|***         {
;|***         //framing error interrupt                         
;|***         t1->port_status[i] = t1->port_status[i] | FRAMING_ERROR;
; Line 1319
	*** 002168	8b 3e 00 00 		mov	di,WORD PTR ?t1@@3PEVCescc@@E	;t1
	*** 00216c	03 fe 			add	di,si
	*** 00216e	26 8b 85 96 01 		mov	ax,WORD PTR es:[di+406]
	*** 002173	80 cc 08 		or	ah,8
	*** 002176	8b 3e 00 00 		mov	di,WORD PTR ?t1@@3PEVCescc@@E	;t1
	*** 00217a	03 fe 			add	di,si
	*** 00217c	26 89 85 96 01 		mov	WORD PTR es:[di+406],ax
;|***         } 
;|***         
;|***       if(t1->eopmode[i]==OPMODE_BISYNC)
; Line 1322
					$I1817:
	*** 002181	c4 3e 00 00 		les	di,DWORD PTR ?t1@@3PEVCescc@@E	;t1
	*** 002185	03 fe 			add	di,si
	*** 002187	26 83 bd 9e 01 02 	cmp	WORD PTR es:[di+414],2
	*** 00218d	75 19 			jne	$I1815
;|***         {
;|***         //SYN detected
;|***         t1->port_status[i] = t1->port_status[i] | SYN_DETECTED;
; Line 1325
	*** 00218f	8b 3e 00 00 		mov	di,WORD PTR ?t1@@3PEVCescc@@E	;t1
	*** 002193	03 fe 			add	di,si
	*** 002195	26 8b 85 96 01 		mov	ax,WORD PTR es:[di+406]
	*** 00219a	80 cc 08 		or	ah,8
	*** 00219d	8b 3e 00 00 		mov	di,WORD PTR ?t1@@3PEVCescc@@E	;t1
	*** 0021a1	03 fe 			add	di,si
	*** 0021a3	26 89 85 96 01 		mov	WORD PTR es:[di+406],ax
;|***         } 
;|***       } // end PCE
;|***       
;|***     
;|***     if((isr0&PLLA)==PLLA)  //  PLLA DPLL Asynchronous.
; Line 1330
					$I1815:
;|***       {
;|***       if(t1->eopmode[i]==OPMODE_HDLC)
;|***         {
;|***         //DPLL async interrupt (lost clock sync)
;|***         }
;|***         
;|***       if(t1->eopmode[i]==OPMODE_ASYNC)
;|***         {
;|***         //DPLL async interrupt (lost clock sync)
;|***         }
;|***         
;|***       if(t1->eopmode[i]==OPMODE_BISYNC)
;|***         {
;|***         //DPLL async interrupt (lost clock sync)
;|***         }
;|***       } // end PLLA
;|***       
;|***     
;|***     if((isr0&CDSC)==CDSC)  //  CDSC  Carrier Detect Status Change.
;|***       {
;|***       if(t1->eopmode[i]==OPMODE_HDLC)
;|***         {
;|***         //carrier detect changed state
;|***         }
;|***         
;|***       if(t1->eopmode[i]==OPMODE_ASYNC)
;|***         {
;|***         //carrier detect changed state
;|***         }
;|***         
;|***       if(t1->eopmode[i]==OPMODE_BISYNC)
;|***         {
;|***         //carrier detect changed state
;|***         }
;|***       }  // end CDSC
;|***         
;|***     
;|***     if((isr0&RFO)==RFO)  //  RFO Receive Frame Overflow.
; Line 1368
	*** 0021a8	8a c3 			mov	al,bl
	*** 0021aa	24 02 			and	al,2
	*** 0021ac	3c 02 			cmp	al,2
	*** 0021ae	75 7f 			jne	$I1827
;|***       {
;|***       if(t1->eopmode[i]==OPMODE_HDLC)
; Line 1370
	*** 0021b0	c4 3e 00 00 		les	di,DWORD PTR ?t1@@3PEVCescc@@E	;t1
	*** 0021b4	03 fe 			add	di,si
	*** 0021b6	26 83 bd 9e 01 00 	cmp	WORD PTR es:[di+414],0
	*** 0021bc	75 25 			jne	$I1828
;|***         {
;|***         //RFO interrupt                              
;|***         t1->port_status[i] = t1->port_status[i] | RFO_INTERRUPT;
; Line 1373
	*** 0021be	8b 3e 00 00 		mov	di,WORD PTR ?t1@@3PEVCescc@@E	;t1
	*** 0021c2	03 fe 			add	di,si
	*** 0021c4	26 8b 85 96 01 		mov	ax,WORD PTR es:[di+406]
	*** 0021c9	0c 08 			or	al,8
	*** 0021cb	8b 3e 00 00 		mov	di,WORD PTR ?t1@@3PEVCescc@@E	;t1
	*** 0021cf	03 fe 			add	di,si
	*** 0021d1	26 89 85 96 01 		mov	WORD PTR es:[di+406],ax
;|***         outp(t1->port_list[i]+CMDR,RHR); // reset the HDLC receiver and RFIFO
; Line 1374
	*** 0021d6	b8 40 00 		mov	ax,64	;0040H
	*** 0021d9	c4 3e 00 00 		les	di,DWORD PTR ?t1@@3PEVCescc@@E	;t1
	*** 0021dd	03 fe 			add	di,si
	*** 0021df	26 8b 15 		mov	dx,WORD PTR es:[di]
	*** 0021e2	ee 			out	dx, al

;|***         }
;|***           
;|***       if(t1->eopmode[i]==OPMODE_ASYNC)
; Line 1377
					$I1828:
	*** 0021e3	8b 3e 00 00 		mov	di,WORD PTR ?t1@@3PEVCescc@@E	;t1
	*** 0021e7	03 fe 			add	di,si
	*** 0021e9	26 83 bd 9e 01 01 	cmp	WORD PTR es:[di+414],1
	*** 0021ef	75 18 			jne	$I1829
;|***         {
;|***         //receive overflow                                      
;|***         t1->port_status[i] = t1->port_status[i] | RFO_INTERRUPT;
; Line 1380
	*** 0021f1	8b 3e 00 00 		mov	di,WORD PTR ?t1@@3PEVCescc@@E	;t1
	*** 0021f5	03 fe 			add	di,si
	*** 0021f7	26 8b 85 96 01 		mov	ax,WORD PTR es:[di+406]
	*** 0021fc	0c 08 			or	al,8
	*** 0021fe	8b 3e 00 00 		mov	di,WORD PTR ?t1@@3PEVCescc@@E	;t1
	*** 002202	03 fe 			add	di,si
	*** 002204	26 89 85 96 01 		mov	WORD PTR es:[di+406],ax
;|***         //must be reset here or will be locked forever
;|***         }
;|***         
;|***       if(t1->eopmode[i]==OPMODE_BISYNC)
; Line 1384
					$I1829:
	*** 002209	c4 3e 00 00 		les	di,DWORD PTR ?t1@@3PEVCescc@@E	;t1
	*** 00220d	03 fe 			add	di,si
	*** 00220f	26 83 bd 9e 01 02 	cmp	WORD PTR es:[di+414],2
	*** 002215	75 18 			jne	$I1827
;|***         {
;|***         //receive overflow                                      
;|***         t1->port_status[i] = t1->port_status[i] | RFO_INTERRUPT;
; Line 1387
	*** 002217	8b 3e 00 00 		mov	di,WORD PTR ?t1@@3PEVCescc@@E	;t1
	*** 00221b	03 fe 			add	di,si
	*** 00221d	26 8b 85 96 01 		mov	ax,WORD PTR es:[di+406]
	*** 002222	0c 08 			or	al,8
	*** 002224	8b 3e 00 00 		mov	di,WORD PTR ?t1@@3PEVCescc@@E	;t1
	*** 002228	03 fe 			add	di,si
	*** 00222a	26 89 85 96 01 		mov	WORD PTR es:[di+406],ax
;|***         //must be reset here or will be locked forever
;|***         }
;|***       }  // end RFO
;|***       
;|***       
;|***     if((isr0&RPF)==RPF)  //  RPF Receive Pool Full.  Interrupt mode only.
; Line 1393
					$I1827:
	*** 00222f	8a c3 			mov	al,bl
	*** 002231	24 01 			and	al,1
	*** 002233	3c 01 			cmp	al,1
	*** 002235	74 03 			je	$JCC8757
	*** 002237	e9 91 03 		jmp	$I1831
					$JCC8757:
;|***       {
;|***       if(t1->eopmode[i]==OPMODE_HDLC)
; Line 1395
	*** 00223a	c4 1e 00 00 		les	bx,DWORD PTR ?t1@@3PEVCescc@@E	;t1
	*** 00223e	26 83 b8 9e 01 00 	cmp	WORD PTR es:[bx+414][si],0
	*** 002244	74 03 			je	$JCC8772
	*** 002246	e9 8f 00 		jmp	$I1832
					$JCC8772:
;|***         {                                                            
;|***         //RPF interrupt, exactly 32 bytes are ready
;|***         //do this for all but DMA (we shouldn't get here in DMA mode)
;|***         irxbuf = (t1->rxbuffer[i][t1->current_rxbuf[i]]);
; Line 1399
	*** 002249	26 8b 98 7a 01 		mov	bx,WORD PTR es:[bx+378][si]
	*** 00224e	c1 e3 02 		shl	bx,2
	*** 002251	03 1e 00 00 		add	bx,WORD PTR ?t1@@3PEVCescc@@E	;t1
	*** 002255	8b 7e ec 		mov	di,WORD PTR [bp-20]	;msb
	*** 002258	26 8b 41 7a 		mov	ax,WORD PTR es:[bx+122][di]
	*** 00225c	26 8b 51 7c 		mov	dx,WORD PTR es:[bx+124][di]
	*** 002260	89 46 f2 		mov	WORD PTR [bp-14],ax	;irxbuf
	*** 002263	89 56 f4 		mov	WORD PTR [bp-12],dx
;|***         bloc = (unsigned far *)irxbuf->frame;
; Line 1400
	*** 002266	8b c8 			mov	cx,ax
	*** 002268	05 06 00 		add	ax,6
	*** 00226b	89 46 ee 		mov	WORD PTR [bp-18],ax	;lsb
	*** 00226e	89 56 f0 		mov	WORD PTR [bp-16],dx
	*** 002271	8b c1 			mov	ax,cx
;|***         for(j=(irxbuf->no_bytes>>1);j<(irxbuf->no_bytes>>1)+16;j++)
; Line 1401
	*** 002273	8b d8 			mov	bx,ax
	*** 002275	8e c2 			mov	es,dx
	*** 002277	26 8b 47 02 		mov	ax,WORD PTR es:[bx+2]
	*** 00227b	d1 e8 			shr	ax,1
	*** 00227d	8b c8 			mov	cx,ax
	*** 00227f	8b d0 			mov	dx,ax
	*** 002281	05 10 00 		add	ax,16	;0010H
	*** 002284	3b c2 			cmp	ax,dx
	*** 002286	76 3d 			jbe	$FB1836
	*** 002288	8b 46 ee 		mov	ax,WORD PTR [bp-18]	;lsb
	*** 00228b	8b d9 			mov	bx,cx
	*** 00228d	03 d9 			add	bx,cx
	*** 00228f	03 c3 			add	ax,bx
	*** 002291	89 46 fc 		mov	WORD PTR [bp-4],ax
	*** 002294	8c 46 fe 		mov	WORD PTR [bp-2],es	;isr0
	*** 002297	89 76 f8 		mov	WORD PTR [bp-8],si
	*** 00229a	8b d8 			mov	bx,ax
					$F1834:
;|***           {
;|***           bloc[j] = inpw(t1->port_list[i]+FIFO);
; Line 1403
	*** 00229c	c4 3e 00 00 		les	di,DWORD PTR ?t1@@3PEVCescc@@E	;t1
	*** 0022a0	03 fe 			add	di,si
	*** 0022a2	26 8b 15 		mov	dx,WORD PTR es:[di]
	*** 0022a5	83 c2 20 		add	dx,32	;0020H
	*** 0022a8	ed 			in	ax,dx
	*** 0022a9	8e 46 fe 		mov	es,WORD PTR [bp-2]	;isr0
	*** 0022ac	8b fb 			mov	di,bx
	*** 0022ae	83 c3 02 		add	bx,2
	*** 0022b1	26 89 05 		mov	WORD PTR es:[di],ax
	*** 0022b4	c4 7e f2 		les	di,DWORD PTR [bp-14]	;irxbuf
	*** 0022b7	26 8b 45 02 		mov	ax,WORD PTR es:[di+2]
	*** 0022bb	d1 e8 			shr	ax,1
	*** 0022bd	05 10 00 		add	ax,16	;0010H
	*** 0022c0	41 			inc	cx
	*** 0022c1	3b c1 			cmp	ax,cx
	*** 0022c3	77 d7 			ja	$F1834
;|***           }
; Line 1404
					$FB1836:
;|***           
;|***         outp(t1->port_list[i]+CMDR,RMC);     //release rfifo
; Line 1406
	*** 0022c5	b8 80 00 		mov	ax,128	;0080H
	*** 0022c8	c4 1e 00 00 		les	bx,DWORD PTR ?t1@@3PEVCescc@@E	;t1
	*** 0022cc	26 8b 10 		mov	dx,WORD PTR es:[bx][si]
	*** 0022cf	ee 			out	dx, al

;|***         irxbuf->no_bytes += 32;
; Line 1407
	*** 0022d0	c4 5e f2 		les	bx,DWORD PTR [bp-14]	;irxbuf
	*** 0022d3	26 83 47 02 20 		add	WORD PTR es:[bx+2],32	;0020H
;|***         } 
;|***       
;|***       if(t1->eopmode[i]==OPMODE_ASYNC)
; Line 1410
					$I1832:
	*** 0022d8	8b 7e ec 		mov	di,WORD PTR [bp-20]	;msb
	*** 0022db	c4 1e 00 00 		les	bx,DWORD PTR ?t1@@3PEVCescc@@E	;t1
	*** 0022df	03 de 			add	bx,si
	*** 0022e1	26 83 bf 9e 01 01 	cmp	WORD PTR es:[bx+414],1
	*** 0022e7	74 03 			je	$JCC8935
	*** 0022e9	e9 69 01 		jmp	$I1837
					$JCC8935:
;|***         {
;|***         //DATA IS READY                                             
;|***         k = inp(t1->port_list[i]+RBCL);//get num bytes in fifo
; Line 1413
	*** 0022ec	8b 1e 00 00 		mov	bx,WORD PTR ?t1@@3PEVCescc@@E	;t1
	*** 0022f0	26 8b 10 		mov	dx,WORD PTR es:[bx][si]
	*** 0022f3	83 c2 0a 		add	dx,10	;000aH
	*** 0022f6	ec 			in	al,dx
	*** 0022f7	8a c8 			mov	cl,al
	*** 0022f9	2a ed 			sub	ch,ch
;|***         k = k&0x1f;
;|***         if(k==0) k=32;
; Line 1415
	*** 0022fb	83 e1 1f 		and	cx,31	;001fH
	*** 0022fe	75 03 			jne	$I1838
	*** 002300	b9 20 00 		mov	cx,32	;0020H
;|***         //assumes that k is allways a multiple of 2 (status byte included mode)
;|***         irxbuf = (t1->rxbuffer[i][t1->current_rxbuf[i]]);     
; Line 1417
					$I1838:
	*** 002303	26 8b 98 7a 01 		mov	bx,WORD PTR es:[bx+378][si]
	*** 002308	c1 e3 02 		shl	bx,2
	*** 00230b	03 1e 00 00 		add	bx,WORD PTR ?t1@@3PEVCescc@@E	;t1
	*** 00230f	26 8b 41 7a 		mov	ax,WORD PTR es:[bx+122][di]
	*** 002313	26 8b 51 7c 		mov	dx,WORD PTR es:[bx+124][di]
	*** 002317	89 46 f2 		mov	WORD PTR [bp-14],ax	;irxbuf
	*** 00231a	89 56 f4 		mov	WORD PTR [bp-12],dx
;|***         bloc = (unsigned far *)irxbuf->frame;
; Line 1418
	*** 00231d	89 46 da 		mov	WORD PTR [bp-38],ax
	*** 002320	89 56 dc 		mov	WORD PTR [bp-36],dx
	*** 002323	05 06 00 		add	ax,6
	*** 002326	89 46 ee 		mov	WORD PTR [bp-18],ax	;lsb
	*** 002329	89 56 f0 		mov	WORD PTR [bp-16],dx
;|***         for(j=irxbuf->no_bytes>>1;j<(irxbuf->no_bytes+k)>>1;j++)  bloc[j] = inpw(t1->port_list[i]+FIFO);
; Line 1419
	*** 00232c	c4 5e da 		les	bx,DWORD PTR [bp-38]
	*** 00232f	26 8b 47 02 		mov	ax,WORD PTR es:[bx+2]
	*** 002333	8b d0 			mov	dx,ax
	*** 002335	d1 e8 			shr	ax,1
	*** 002337	89 46 f6 		mov	WORD PTR [bp-10],ax	;j
	*** 00233a	89 4e fa 		mov	WORD PTR [bp-6],cx	;k
	*** 00233d	03 d1 			add	dx,cx
	*** 00233f	d1 ea 			shr	dx,1
	*** 002341	3b d0 			cmp	dx,ax
	*** 002343	76 42 			jbe	$FB1842
	*** 002345	03 c0 			add	ax,ax
	*** 002347	03 46 ee 		add	ax,WORD PTR [bp-18]	;lsb
	*** 00234a	8b 56 f0 		mov	dx,WORD PTR [bp-16]
	*** 00234d	89 46 fc 		mov	WORD PTR [bp-4],ax
	*** 002350	89 56 fe 		mov	WORD PTR [bp-2],dx	;isr0
	*** 002353	89 76 f8 		mov	WORD PTR [bp-8],si
	*** 002356	8b d8 			mov	bx,ax
	*** 002358	8b 4e f6 		mov	cx,WORD PTR [bp-10]	;j
					$F1840:
	*** 00235b	c4 3e 00 00 		les	di,DWORD PTR ?t1@@3PEVCescc@@E	;t1
	*** 00235f	03 fe 			add	di,si
	*** 002361	26 8b 15 		mov	dx,WORD PTR es:[di]
	*** 002364	83 c2 20 		add	dx,32	;0020H
	*** 002367	ed 			in	ax,dx
	*** 002368	8e 46 fe 		mov	es,WORD PTR [bp-2]	;isr0
	*** 00236b	8b fb 			mov	di,bx
	*** 00236d	83 c3 02 		add	bx,2
	*** 002370	26 89 05 		mov	WORD PTR es:[di],ax
	*** 002373	c4 7e f2 		les	di,DWORD PTR [bp-14]	;irxbuf
	*** 002376	26 8b 45 02 		mov	ax,WORD PTR es:[di+2]
	*** 00237a	03 46 fa 		add	ax,WORD PTR [bp-6]	;k
	*** 00237d	d1 e8 			shr	ax,1
	*** 00237f	41 			inc	cx
	*** 002380	3b c1 			cmp	ax,cx
	*** 002382	77 d7 			ja	$F1840
	*** 002384	8b 7e ec 		mov	di,WORD PTR [bp-20]	;msb
					$FB1842:
;|***         outp(t1->port_list[i]+CMDR,RMC);     //release fifo
; Line 1420
	*** 002387	c4 1e 00 00 		les	bx,DWORD PTR ?t1@@3PEVCescc@@E	;t1
	*** 00238b	b8 80 00 		mov	ax,128	;0080H
	*** 00238e	26 8b 10 		mov	dx,WORD PTR es:[bx][si]
	*** 002391	ee 			out	dx, al

;|***         //could move this stuff elsewhere (such that the buffers get more than 32 bytes in em)
;|***         irxbuf->no_bytes = irxbuf->no_bytes + k; //number of bytes received in rbuf
;|***         if(irxbuf->no_bytes >= (FRAME_SIZE - 32))
; Line 1423
	*** 002392	8b 46 fa 		mov	ax,WORD PTR [bp-6]	;k
	*** 002395	c4 5e f2 		les	bx,DWORD PTR [bp-14]	;irxbuf
	*** 002398	26 01 47 02 		add	WORD PTR es:[bx+2],ax
	*** 00239c	26 81 7f 02 e0 03 	cmp	WORD PTR es:[bx+2],992	;03e0H
	*** 0023a2	73 03 			jae	$JCC9122
	*** 0023a4	e9 ae 00 		jmp	$I1837
					$JCC9122:
;|***           {
;|***           irxbuf->valid = 1;//validate rbuf
; Line 1425
	*** 0023a7	c4 5e f2 		les	bx,DWORD PTR [bp-14]	;irxbuf
	*** 0023aa	26 c7 07 01 00 		mov	WORD PTR es:[bx],1
;|***           t1->current_rxbuf[i]++;  
; Line 1426
	*** 0023af	c4 1e 00 00 		les	bx,DWORD PTR ?t1@@3PEVCescc@@E	;t1
	*** 0023b3	26 8b 80 7a 01 		mov	ax,WORD PTR es:[bx+378][si]
	*** 0023b8	40 			inc	ax
	*** 0023b9	26 89 80 7a 01 		mov	WORD PTR es:[bx+378][si],ax
;|***           //irxbuf is no longer valid
;|***           if(t1->current_rxbuf[i]==t1->max_rxbuf[i]) t1->current_rxbuf[i]=0;                
; Line 1428
	*** 0023be	c4 1e 00 00 		les	bx,DWORD PTR ?t1@@3PEVCescc@@E	;t1
	*** 0023c2	03 de 			add	bx,si
	*** 0023c4	26 8b 87 82 01 		mov	ax,WORD PTR es:[bx+386]
	*** 0023c9	26 39 87 7a 01 		cmp	WORD PTR es:[bx+378],ax
	*** 0023ce	75 0d 			jne	$I1844
	*** 0023d0	8b 1e 00 00 		mov	bx,WORD PTR ?t1@@3PEVCescc@@E	;t1
	*** 0023d4	03 de 			add	bx,si
	*** 0023d6	26 c7 87 7a 01 00 00 	mov	WORD PTR es:[bx+378],0
;|***           if(t1->rxbuffer[i][t1->current_rxbuf[i]]->valid ==1) 
; Line 1429
					$I1844:
	*** 0023dd	c4 1e 00 00 		les	bx,DWORD PTR ?t1@@3PEVCescc@@E	;t1
	*** 0023e1	03 de 			add	bx,si
	*** 0023e3	26 8b 9f 7a 01 		mov	bx,WORD PTR es:[bx+378]
	*** 0023e8	03 5e ea 		add	bx,WORD PTR [bp-22]
	*** 0023eb	c1 e3 02 		shl	bx,2
	*** 0023ee	03 1e 00 00 		add	bx,WORD PTR ?t1@@3PEVCescc@@E	;t1
	*** 0023f2	26 c4 5f 7a 		les	bx,DWORD PTR es:[bx+122]
	*** 0023f6	26 83 3f 01 		cmp	WORD PTR es:[bx],1
	*** 0023fa	75 12 			jne	$I1845
;|***             {
;|***             // an error occured and the 
;|***             //   main program isn't done with 
;|***             //   the frame that is about
;|***             //   to be used for received data
;|***             //set the receive buffers overflowed bit of the status word for this port here
;|***             t1->port_status[i] = t1->port_status[i] | RX_BUFFER_OVERFLOW;
; Line 1436
	*** 0023fc	c4 1e 00 00 		les	bx,DWORD PTR ?t1@@3PEVCescc@@E	;t1
	*** 002400	26 8b 80 96 01 		mov	ax,WORD PTR es:[bx+406][si]
	*** 002405	03 de 			add	bx,si
	*** 002407	0c 40 			or	al,64	;0040H
	*** 002409	26 89 87 96 01 		mov	WORD PTR es:[bx+406],ax
;|***             }
;|***             
;|***           t1->rxbuffer[i][t1->current_rxbuf[i]]->no_bytes = 0;  //prep buf for use
; Line 1439
					$I1845:
	*** 00240e	c4 1e 00 00 		les	bx,DWORD PTR ?t1@@3PEVCescc@@E	;t1
	*** 002412	26 8b 98 7a 01 		mov	bx,WORD PTR es:[bx+378][si]
	*** 002417	c1 e3 02 		shl	bx,2
	*** 00241a	03 1e 00 00 		add	bx,WORD PTR ?t1@@3PEVCescc@@E	;t1
	*** 00241e	26 c4 59 7a 		les	bx,DWORD PTR es:[bx+122][di]
	*** 002422	26 c7 47 02 00 00 	mov	WORD PTR es:[bx+2],0
;|***           t1->rxbuffer[i][t1->current_rxbuf[i]]->valid = 0;    //invalidate it for use
; Line 1440
	*** 002428	c4 1e 00 00 		les	bx,DWORD PTR ?t1@@3PEVCescc@@E	;t1
	*** 00242c	26 8b 98 7a 01 		mov	bx,WORD PTR es:[bx+378][si]
	*** 002431	03 5e ea 		add	bx,WORD PTR [bp-22]
	*** 002434	c1 e3 02 		shl	bx,2
	*** 002437	03 1e 00 00 		add	bx,WORD PTR ?t1@@3PEVCescc@@E	;t1
	*** 00243b	26 c4 5f 7a 		les	bx,DWORD PTR es:[bx+122]
	*** 00243f	26 c7 07 00 00 		mov	WORD PTR es:[bx],0
;|***           t1->port_status[i] = t1->port_status[i] | RX_READY;
; Line 1441
	*** 002444	c4 1e 00 00 		les	bx,DWORD PTR ?t1@@3PEVCescc@@E	;t1
	*** 002448	26 8b 80 96 01 		mov	ax,WORD PTR es:[bx+406][si]
	*** 00244d	80 cc 02 		or	ah,2
	*** 002450	26 89 80 96 01 		mov	WORD PTR es:[bx+406][si],ax
;|***           }
;|***         }     
;|***       
;|***       if(t1->eopmode[i]==OPMODE_BISYNC)
; Line 1445
					$I1837:
	*** 002455	c4 1e 00 00 		les	bx,DWORD PTR ?t1@@3PEVCescc@@E	;t1
	*** 002459	03 de 			add	bx,si
	*** 00245b	26 83 bf 9e 01 02 	cmp	WORD PTR es:[bx+414],2
	*** 002461	74 03 			je	$JCC9313
	*** 002463	e9 65 01 		jmp	$I1831
					$JCC9313:
;|***         {
;|***         //DATA IS READY                                             
;|***         k = inp(t1->port_list[i]+RBCL);//get num bytes in fifo
; Line 1448
	*** 002466	8b 1e 00 00 		mov	bx,WORD PTR ?t1@@3PEVCescc@@E	;t1
	*** 00246a	26 8b 10 		mov	dx,WORD PTR es:[bx][si]
	*** 00246d	83 c2 0a 		add	dx,10	;000aH
	*** 002470	ec 			in	al,dx
	*** 002471	8a c8 			mov	cl,al
	*** 002473	2a ed 			sub	ch,ch
;|***         k = k&0x1f;
;|***         if(k==0) k=32;
; Line 1450
	*** 002475	83 e1 1f 		and	cx,31	;001fH
	*** 002478	75 03 			jne	$I1847
	*** 00247a	b9 20 00 		mov	cx,32	;0020H
;|***         
;|***         //assumes that k is allways a multiple of 2 (status byte included mode)
;|***         //this will hold true unless the programmed threshold = 1 in non parity store mode
;|***         //ie this code will not work for threshold level 1, in no parity store mode!!!!!
;|***         irxbuf = (t1->rxbuffer[i][t1->current_rxbuf[i]]);     
; Line 1455
					$I1847:
	*** 00247d	26 8b 98 7a 01 		mov	bx,WORD PTR es:[bx+378][si]
	*** 002482	c1 e3 02 		shl	bx,2
	*** 002485	03 1e 00 00 		add	bx,WORD PTR ?t1@@3PEVCescc@@E	;t1
	*** 002489	26 8b 41 7a 		mov	ax,WORD PTR es:[bx+122][di]
	*** 00248d	26 8b 51 7c 		mov	dx,WORD PTR es:[bx+124][di]
	*** 002491	89 46 f2 		mov	WORD PTR [bp-14],ax	;irxbuf
	*** 002494	89 56 f4 		mov	WORD PTR [bp-12],dx
;|***         bloc = (unsigned far *)irxbuf->frame;
; Line 1456
	*** 002497	89 46 d6 		mov	WORD PTR [bp-42],ax
	*** 00249a	89 56 d8 		mov	WORD PTR [bp-40],dx
	*** 00249d	05 06 00 		add	ax,6
	*** 0024a0	89 46 ee 		mov	WORD PTR [bp-18],ax	;lsb
	*** 0024a3	89 56 f0 		mov	WORD PTR [bp-16],dx
;|***         for(j=irxbuf->no_bytes>>1;j<(irxbuf->no_bytes+k)>>1;j++)
; Line 1457
	*** 0024a6	c4 5e d6 		les	bx,DWORD PTR [bp-42]
	*** 0024a9	26 8b 47 02 		mov	ax,WORD PTR es:[bx+2]
	*** 0024ad	8b d0 			mov	dx,ax
	*** 0024af	d1 e8 			shr	ax,1
	*** 0024b1	89 46 f6 		mov	WORD PTR [bp-10],ax	;j
	*** 0024b4	89 4e fa 		mov	WORD PTR [bp-6],cx	;k
	*** 0024b7	03 d1 			add	dx,cx
	*** 0024b9	d1 ea 			shr	dx,1
	*** 0024bb	3b d0 			cmp	dx,ax
	*** 0024bd	76 3f 			jbe	$FB1851
	*** 0024bf	03 c0 			add	ax,ax
	*** 0024c1	03 46 ee 		add	ax,WORD PTR [bp-18]	;lsb
	*** 0024c4	8b 56 f0 		mov	dx,WORD PTR [bp-16]
	*** 0024c7	89 46 fc 		mov	WORD PTR [bp-4],ax
	*** 0024ca	89 56 fe 		mov	WORD PTR [bp-2],dx	;isr0
	*** 0024cd	89 76 f8 		mov	WORD PTR [bp-8],si
	*** 0024d0	8b d8 			mov	bx,ax
	*** 0024d2	8b 4e f6 		mov	cx,WORD PTR [bp-10]	;j
					$F1849:
;|***           {
;|***           bloc[j] = inpw(t1->port_list[i]+FIFO);
; Line 1459
	*** 0024d5	c4 3e 00 00 		les	di,DWORD PTR ?t1@@3PEVCescc@@E	;t1
	*** 0024d9	03 fe 			add	di,si
	*** 0024db	26 8b 15 		mov	dx,WORD PTR es:[di]
	*** 0024de	83 c2 20 		add	dx,32	;0020H
	*** 0024e1	ed 			in	ax,dx
	*** 0024e2	8e 46 fe 		mov	es,WORD PTR [bp-2]	;isr0
	*** 0024e5	8b fb 			mov	di,bx
	*** 0024e7	83 c3 02 		add	bx,2
	*** 0024ea	26 89 05 		mov	WORD PTR es:[di],ax
	*** 0024ed	c4 7e f2 		les	di,DWORD PTR [bp-14]	;irxbuf
	*** 0024f0	26 8b 45 02 		mov	ax,WORD PTR es:[di+2]
	*** 0024f4	03 46 fa 		add	ax,WORD PTR [bp-6]	;k
	*** 0024f7	d1 e8 			shr	ax,1
	*** 0024f9	41 			inc	cx
	*** 0024fa	3b c1 			cmp	ax,cx
	*** 0024fc	77 d7 			ja	$F1849
;|***           }
; Line 1460
					$FB1851:
;|***           
;|***         outp(t1->port_list[i]+CMDR,RMC);     //release fifo
; Line 1462
	*** 0024fe	b8 80 00 		mov	ax,128	;0080H
	*** 002501	c4 1e 00 00 		les	bx,DWORD PTR ?t1@@3PEVCescc@@E	;t1
	*** 002505	26 8b 10 		mov	dx,WORD PTR es:[bx][si]
	*** 002508	ee 			out	dx, al

;|***         //could move this stuff elsewhere (such that the buffers get more than 32 bytes in em)
;|***         irxbuf->no_bytes = irxbuf->no_bytes + k; //number of bytes received in rbuf
;|***         if(irxbuf->no_bytes >=( FRAME_SIZE - 32))
; Line 1465
	*** 002509	8b 46 fa 		mov	ax,WORD PTR [bp-6]	;k
	*** 00250c	c4 5e f2 		les	bx,DWORD PTR [bp-14]	;irxbuf
	*** 00250f	26 01 47 02 		add	WORD PTR es:[bx+2],ax
	*** 002513	26 81 7f 02 e0 03 	cmp	WORD PTR es:[bx+2],992	;03e0H
	*** 002519	73 03 			jae	$JCC9497
	*** 00251b	e9 ad 00 		jmp	$I1831
					$JCC9497:
;|***           {
;|***           irxbuf->valid = 1;//validate rbuf
; Line 1467
	*** 00251e	c4 5e f2 		les	bx,DWORD PTR [bp-14]	;irxbuf
	*** 002521	26 c7 07 01 00 		mov	WORD PTR es:[bx],1
;|***           t1->current_rxbuf[i]++;  
; Line 1468
	*** 002526	c4 1e 00 00 		les	bx,DWORD PTR ?t1@@3PEVCescc@@E	;t1
	*** 00252a	26 8b 80 7a 01 		mov	ax,WORD PTR es:[bx+378][si]
	*** 00252f	40 			inc	ax
	*** 002530	26 89 80 7a 01 		mov	WORD PTR es:[bx+378][si],ax
;|***           //irxbuf is no longer valid
;|***           if(t1->current_rxbuf[i]==t1->max_rxbuf[i]) t1->current_rxbuf[i]=0;                
; Line 1470
	*** 002535	c4 1e 00 00 		les	bx,DWORD PTR ?t1@@3PEVCescc@@E	;t1
	*** 002539	03 de 			add	bx,si
	*** 00253b	26 8b 87 82 01 		mov	ax,WORD PTR es:[bx+386]
	*** 002540	26 39 87 7a 01 		cmp	WORD PTR es:[bx+378],ax
	*** 002545	75 0d 			jne	$I1853
	*** 002547	8b 1e 00 00 		mov	bx,WORD PTR ?t1@@3PEVCescc@@E	;t1
	*** 00254b	03 de 			add	bx,si
	*** 00254d	26 c7 87 7a 01 00 00 	mov	WORD PTR es:[bx+378],0
;|***           if(t1->rxbuffer[i][t1->current_rxbuf[i]]->valid ==1) 
; Line 1471
					$I1853:
	*** 002554	c4 1e 00 00 		les	bx,DWORD PTR ?t1@@3PEVCescc@@E	;t1
	*** 002558	03 de 			add	bx,si
	*** 00255a	26 8b bf 7a 01 		mov	di,WORD PTR es:[bx+378]
	*** 00255f	03 7e ea 		add	di,WORD PTR [bp-22]
	*** 002562	c1 e7 02 		shl	di,2
	*** 002565	8b 1e 00 00 		mov	bx,WORD PTR ?t1@@3PEVCescc@@E	;t1
	*** 002569	26 c4 59 7a 		les	bx,DWORD PTR es:[bx+122][di]
	*** 00256d	26 83 3f 01 		cmp	WORD PTR es:[bx],1
	*** 002571	75 12 			jne	$I1854
;|***             {
;|***             // an error occured and the 
;|***             //   main program isn't done with 
;|***             //   the frame that is about
;|***             //   to be used for received data
;|***             //set the receive buffers overflowed bit of the status word for this port here
;|***             t1->port_status[i] = t1->port_status[i] | RX_BUFFER_OVERFLOW;
; Line 1478
	*** 002573	c4 1e 00 00 		les	bx,DWORD PTR ?t1@@3PEVCescc@@E	;t1
	*** 002577	26 8b 80 96 01 		mov	ax,WORD PTR es:[bx+406][si]
	*** 00257c	0c 40 			or	al,64	;0040H
	*** 00257e	03 de 			add	bx,si
	*** 002580	26 89 87 96 01 		mov	WORD PTR es:[bx+406],ax
;|***             }
;|***             
;|***           t1->rxbuffer[i][t1->current_rxbuf[i]]->no_bytes = 0;  //prep buf for use
; Line 1481
					$I1854:
	*** 002585	c4 1e 00 00 		les	bx,DWORD PTR ?t1@@3PEVCescc@@E	;t1
	*** 002589	26 8b 98 7a 01 		mov	bx,WORD PTR es:[bx+378][si]
	*** 00258e	c1 e3 02 		shl	bx,2
	*** 002591	03 1e 00 00 		add	bx,WORD PTR ?t1@@3PEVCescc@@E	;t1
	*** 002595	8b 7e ec 		mov	di,WORD PTR [bp-20]	;msb
	*** 002598	26 c4 59 7a 		les	bx,DWORD PTR es:[bx+122][di]
	*** 00259c	26 c7 47 02 00 00 	mov	WORD PTR es:[bx+2],0
;|***           t1->rxbuffer[i][t1->current_rxbuf[i]]->valid = 0;    //invalidate it for use
; Line 1482
	*** 0025a2	c4 1e 00 00 		les	bx,DWORD PTR ?t1@@3PEVCescc@@E	;t1
	*** 0025a6	26 8b b8 7a 01 		mov	di,WORD PTR es:[bx+378][si]
	*** 0025ab	03 7e ea 		add	di,WORD PTR [bp-22]
	*** 0025ae	c1 e7 02 		shl	di,2
	*** 0025b1	26 c4 59 7a 		les	bx,DWORD PTR es:[bx+122][di]
	*** 0025b5	26 c7 07 00 00 		mov	WORD PTR es:[bx],0
;|***           t1->port_status[i] = t1->port_status[i] | RX_READY;
; Line 1483
	*** 0025ba	c4 1e 00 00 		les	bx,DWORD PTR ?t1@@3PEVCescc@@E	;t1
	*** 0025be	26 8b 80 96 01 		mov	ax,WORD PTR es:[bx+406][si]
	*** 0025c3	80 cc 02 		or	ah,2
	*** 0025c6	26 89 80 96 01 		mov	WORD PTR es:[bx+406][si],ax
;|***           }
;|***         }     
;|***       } // end RPF
;|***     
;|***     
;|***     
;|***     //check ISR1 next  
;|***     if((isr1&EOP)==EOP)  //EOP End of Poll Sequence Detected.  Valid only in SLDC Loop mode.
; Line 1491
					$I1831:
	*** 0025cb	8b 5e e6 		mov	bx,WORD PTR [bp-26]	;isr1
	*** 0025ce	8a c3 			mov	al,bl
	*** 0025d0	24 80 			and	al,128	;0080H
	*** 0025d2	3c 80 			cmp	al,128	;0080H
	*** 0025d4	75 27 			jne	$I1855
;|***       { 
;|***       if(t1->eopmode[i]==OPMODE_HDLC)
;|***         {
;|***         //end of poll
;|***         }            
;|***         
;|***       if(t1->eopmode[i]==OPMODE_ASYNC)
; Line 1498
	*** 0025d6	c4 3e 00 00 		les	di,DWORD PTR ?t1@@3PEVCescc@@E	;t1
	*** 0025da	03 fe 			add	di,si
	*** 0025dc	26 83 bd 9e 01 01 	cmp	WORD PTR es:[di+414],1
	*** 0025e2	75 19 			jne	$I1855
;|***         {
;|***         //break detect interrupt                                  
;|***         t1->port_status[i] = t1->port_status[i] | BREAK_DETECTED;
; Line 1501
	*** 0025e4	8b 3e 00 00 		mov	di,WORD PTR ?t1@@3PEVCescc@@E	;t1
	*** 0025e8	03 fe 			add	di,si
	*** 0025ea	26 8b 85 96 01 		mov	ax,WORD PTR es:[di+406]
	*** 0025ef	80 cc 10 		or	ah,16	;0010H
	*** 0025f2	8b 3e 00 00 		mov	di,WORD PTR ?t1@@3PEVCescc@@E	;t1
	*** 0025f6	03 fe 			add	di,si
	*** 0025f8	26 89 85 96 01 		mov	WORD PTR es:[di+406],ax
;|***         }       
;|***       }  // end EOP
;|***       
;|***     
;|***     
;|***     if((isr1&0x40)==0x40) // OLP/RDO On Loop(SDLC Loop mode) / Receive Data Overflow(n/a in SDLC Loop)
; Line 1507
					$I1855:
	*** 0025fd	8a c3 			mov	al,bl
	*** 0025ff	24 40 			and	al,64	;0040H
	*** 002601	3c 40 			cmp	al,64	;0040H
	*** 002603	75 27 			jne	$I1858
;|***       {               
;|***       if(t1->eopmode[i]==OPMODE_HDLC)  //  OLP
;|***         {
;|***         //on loop interrupt
;|***         }
;|***       if(t1->eopmode[i]==OPMODE_ASYNC)  //  RDO
; Line 1513
	*** 002605	c4 3e 00 00 		les	di,DWORD PTR ?t1@@3PEVCescc@@E	;t1
	*** 002609	03 fe 			add	di,si
	*** 00260b	26 83 bd 9e 01 01 	cmp	WORD PTR es:[di+414],1
	*** 002611	75 19 			jne	$I1858
;|***         {                  
;|***         //break terminated interrupt
;|***         t1->port_status[i] = t1->port_status[i] | BREAK_TERMINATED;
; Line 1516
	*** 002613	8b 3e 00 00 		mov	di,WORD PTR ?t1@@3PEVCescc@@E	;t1
	*** 002617	03 fe 			add	di,si
	*** 002619	26 8b 85 96 01 		mov	ax,WORD PTR es:[di+406]
	*** 00261e	80 cc 20 		or	ah,32	;0020H
	*** 002621	8b 3e 00 00 		mov	di,WORD PTR ?t1@@3PEVCescc@@E	;t1
	*** 002625	03 fe 			add	di,si
	*** 002627	26 89 85 96 01 		mov	WORD PTR es:[di+406],ax
;|***         }                  
;|***       }  // end OLP/RDO
;|***       
;|***     
;|***     if((isr1&0x20)==0x20)  //  AOLP/ALLS Active On Loop(SDLC Loop mode) / All Sent(non-SDLC Loop)
; Line 1521
					$I1858:
	*** 00262c	8a c3 			mov	al,bl
	*** 00262e	24 20 			and	al,32	;0020H
	*** 002630	3c 20 			cmp	al,32	;0020H
	*** 002632	75 4e 			jne	$I1861
;|***       {               
;|***       if(t1->eopmode[i]==OPMODE_HDLC)
;|***         {
;|***         //all sent interrupt (tx machine is empty)
;|***         }                                         
;|***         
;|***       if(t1->eopmode[i]==OPMODE_ASYNC)
; Line 1528
	*** 002634	c4 3e 00 00 		les	di,DWORD PTR ?t1@@3PEVCescc@@E	;t1
	*** 002638	03 fe 			add	di,si
	*** 00263a	26 83 bd 9e 01 01 	cmp	WORD PTR es:[di+414],1
	*** 002640	75 19 			jne	$I1863
;|***         {
;|***         //all characters are sent out the fifo and out the txd pin
;|***         t1->port_status[i] = t1->port_status[i] | ALLSENT_INTERRUPT;
; Line 1531
	*** 002642	8b 3e 00 00 		mov	di,WORD PTR ?t1@@3PEVCescc@@E	;t1
	*** 002646	03 fe 			add	di,si
	*** 002648	26 8b 85 96 01 		mov	ax,WORD PTR es:[di+406]
	*** 00264d	80 cc 40 		or	ah,64	;0040H
	*** 002650	8b 3e 00 00 		mov	di,WORD PTR ?t1@@3PEVCescc@@E	;t1
	*** 002654	03 fe 			add	di,si
	*** 002656	26 89 85 96 01 		mov	WORD PTR es:[di+406],ax
;|***         }
;|***         
;|***       if(t1->eopmode[i]==OPMODE_BISYNC)
; Line 1534
					$I1863:
	*** 00265b	c4 3e 00 00 		les	di,DWORD PTR ?t1@@3PEVCescc@@E	;t1
	*** 00265f	03 fe 			add	di,si
	*** 002661	26 83 bd 9e 01 02 	cmp	WORD PTR es:[di+414],2
	*** 002667	75 19 			jne	$I1861
;|***         {
;|***         //all characters are sent out the fifo and out the txd pin
;|***         t1->port_status[i] = t1->port_status[i] | ALLSENT_INTERRUPT;
; Line 1537
	*** 002669	8b 3e 00 00 		mov	di,WORD PTR ?t1@@3PEVCescc@@E	;t1
	*** 00266d	03 fe 			add	di,si
	*** 00266f	26 8b 85 96 01 		mov	ax,WORD PTR es:[di+406]
	*** 002674	80 cc 40 		or	ah,64	;0040H
	*** 002677	8b 3e 00 00 		mov	di,WORD PTR ?t1@@3PEVCescc@@E	;t1
	*** 00267b	03 fe 			add	di,si
	*** 00267d	26 89 85 96 01 		mov	WORD PTR es:[di+406],ax
;|***         }
;|***       } // end AOLP/ALLS
;|***       
;|***     
;|***     if((isr1&0x10)==0x10) //  XDU/EXE Transmit Data Underrun/Extended Transmission End
; Line 1542
					$I1861:
	*** 002682	8a c3 			mov	al,bl
	*** 002684	24 10 			and	al,16	;0010H
	*** 002686	3c 10 			cmp	al,16	;0010H
	*** 002688	75 4c 			jne	$I1865
;|***       {
;|***       if(t1->eopmode[i]==OPMODE_HDLC)
; Line 1544
	*** 00268a	c4 3e 00 00 		les	di,DWORD PTR ?t1@@3PEVCescc@@E	;t1
	*** 00268e	03 fe 			add	di,si
	*** 002690	26 83 bd 9e 01 00 	cmp	WORD PTR es:[di+414],0
	*** 002696	75 18 			jne	$I1866
;|***         {
;|***         //EXE interupt                               
;|***         t1->port_status[i] = t1->port_status[i] | EXE_INTERRUPT;
; Line 1547
	*** 002698	8b 3e 00 00 		mov	di,WORD PTR ?t1@@3PEVCescc@@E	;t1
	*** 00269c	03 fe 			add	di,si
	*** 00269e	26 8b 85 96 01 		mov	ax,WORD PTR es:[di+406]
	*** 0026a3	0c 02 			or	al,2
	*** 0026a5	8b 3e 00 00 		mov	di,WORD PTR ?t1@@3PEVCescc@@E	;t1
	*** 0026a9	03 fe 			add	di,si
	*** 0026ab	26 89 85 96 01 		mov	WORD PTR es:[di+406],ax
;|***         //outp(t1->port_list[i]+CMDR,XRES);
;|***         //need something here to reset the dma channel if operating in Extended trasparent mode
;|***         //as this is the normal transmit end message for that mode
;|***         }
;|***           
;|***       if(t1->eopmode[i]==OPMODE_BISYNC)
; Line 1553
					$I1866:
	*** 0026b0	c4 3e 00 00 		les	di,DWORD PTR ?t1@@3PEVCescc@@E	;t1
	*** 0026b4	03 fe 			add	di,si
	*** 0026b6	26 83 bd 9e 01 02 	cmp	WORD PTR es:[di+414],2
	*** 0026bc	75 18 			jne	$I1865
;|***         {
;|***         //EXE interupt                               
;|***         t1->port_status[i] = t1->port_status[i] | EXE_INTERRUPT;
; Line 1556
	*** 0026be	8b 3e 00 00 		mov	di,WORD PTR ?t1@@3PEVCescc@@E	;t1
	*** 0026c2	03 fe 			add	di,si
	*** 0026c4	26 8b 85 96 01 		mov	ax,WORD PTR es:[di+406]
	*** 0026c9	0c 02 			or	al,2
	*** 0026cb	8b 3e 00 00 		mov	di,WORD PTR ?t1@@3PEVCescc@@E	;t1
	*** 0026cf	03 fe 			add	di,si
	*** 0026d1	26 89 85 96 01 		mov	WORD PTR es:[di+406],ax
;|***         }
;|***       } // end XDU/EXE
;|*** 
;|***         
;|***     if((isr1&TIN)==TIN)  // Timer Interrupt
; Line 1561
					$I1865:
	*** 0026d6	8a c3 			mov	al,bl
	*** 0026d8	24 08 			and	al,8
	*** 0026da	3c 08 			cmp	al,8
	*** 0026dc	74 03 			je	$JCC9948
	*** 0026de	e9 9c 00 		jmp	$I1868
					$JCC9948:
;|***       {
;|***       if(t1->eopmode[i]==OPMODE_HDLC)
; Line 1563
	*** 0026e1	c4 3e 00 00 		les	di,DWORD PTR ?t1@@3PEVCescc@@E	;t1
	*** 0026e5	03 fe 			add	di,si
	*** 0026e7	26 83 bd 9e 01 00 	cmp	WORD PTR es:[di+414],0
	*** 0026ed	75 26 			jne	$I1869
;|***         {        
;|***         if(i==1)
;|***           {
;|***           //frame++;  // jtm used for frame timing in cb2000
;|***           }
;|*** 
;|***         t1->port_status[i] = t1->port_status[i] | TIMER_INTERRUPT;
; Line 1570
	*** 0026ef	8b 3e 00 00 		mov	di,WORD PTR ?t1@@3PEVCescc@@E	;t1
	*** 0026f3	03 fe 			add	di,si
	*** 0026f5	26 8b 85 96 01 		mov	ax,WORD PTR es:[di+406]
	*** 0026fa	80 cc 01 		or	ah,1
	*** 0026fd	8b 3e 00 00 		mov	di,WORD PTR ?t1@@3PEVCescc@@E	;t1
	*** 002701	03 fe 			add	di,si
	*** 002703	26 89 85 96 01 		mov	WORD PTR es:[di+406],ax
;|***         t1->timer_status[i] = 1;
; Line 1571
	*** 002708	c4 3e 00 00 		les	di,DWORD PTR ?t1@@3PEVCescc@@E	;t1
	*** 00270c	03 fe 			add	di,si
	*** 00270e	26 c7 85 8a 01 01 00 	mov	WORD PTR es:[di+394],1
;|***         
;|***         //outp(t1->port_list[i]+TIMR,inp(t1->port_list[i]+TIMR));//stops timer    
;|***         }
;|***         
;|***       if(t1->eopmode[i]==OPMODE_ASYNC)
; Line 1576
					$I1869:
	*** 002715	c4 3e 00 00 		les	di,DWORD PTR ?t1@@3PEVCescc@@E	;t1
	*** 002719	03 fe 			add	di,si
	*** 00271b	26 83 bd 9e 01 01 	cmp	WORD PTR es:[di+414],1
	*** 002721	75 26 			jne	$I1871
;|***         {
;|***         t1->port_status[i] = t1->port_status[i] | TIMER_INTERRUPT;
; Line 1578
	*** 002723	8b 3e 00 00 		mov	di,WORD PTR ?t1@@3PEVCescc@@E	;t1
	*** 002727	03 fe 			add	di,si
	*** 002729	26 8b 85 96 01 		mov	ax,WORD PTR es:[di+406]
	*** 00272e	80 cc 01 		or	ah,1
	*** 002731	8b 3e 00 00 		mov	di,WORD PTR ?t1@@3PEVCescc@@E	;t1
	*** 002735	03 fe 			add	di,si
	*** 002737	26 89 85 96 01 		mov	WORD PTR es:[di+406],ax
;|***         t1->timer_status[i] = 1;
; Line 1579
	*** 00273c	c4 3e 00 00 		les	di,DWORD PTR ?t1@@3PEVCescc@@E	;t1
	*** 002740	03 fe 			add	di,si
	*** 002742	26 c7 85 8a 01 01 00 	mov	WORD PTR es:[di+394],1
;|***         }
;|***     
;|***       if(t1->eopmode[i]==OPMODE_BISYNC)
; Line 1582
					$I1871:
	*** 002749	c4 3e 00 00 		les	di,DWORD PTR ?t1@@3PEVCescc@@E	;t1
	*** 00274d	03 fe 			add	di,si
	*** 00274f	26 83 bd 9e 01 02 	cmp	WORD PTR es:[di+414],2
	*** 002755	75 26 			jne	$I1868
;|***         {
;|***         t1->port_status[i] = t1->port_status[i] | TIMER_INTERRUPT;
; Line 1584
	*** 002757	8b 3e 00 00 		mov	di,WORD PTR ?t1@@3PEVCescc@@E	;t1
	*** 00275b	03 fe 			add	di,si
	*** 00275d	26 8b 85 96 01 		mov	ax,WORD PTR es:[di+406]
	*** 002762	80 cc 01 		or	ah,1
	*** 002765	8b 3e 00 00 		mov	di,WORD PTR ?t1@@3PEVCescc@@E	;t1
	*** 002769	03 fe 			add	di,si
	*** 00276b	26 89 85 96 01 		mov	WORD PTR es:[di+406],ax
;|***         t1->timer_status[i] = 1;
; Line 1585
	*** 002770	c4 3e 00 00 		les	di,DWORD PTR ?t1@@3PEVCescc@@E	;t1
	*** 002774	03 fe 			add	di,si
	*** 002776	26 c7 85 8a 01 01 00 	mov	WORD PTR es:[di+394],1
;|***         }
;|***       } // end TIN
;|***       
;|***       
;|***     if((isr1&CSC)==CSC)  // Clear to Send Status Change
; Line 1590
					$I1868:
	*** 00277d	8a c3 			mov	al,bl
	*** 00277f	24 04 			and	al,4
	*** 002781	3c 04 			cmp	al,4
	*** 002783	75 72 			jne	$I1873
;|***       {
;|***       if(t1->eopmode[i]==OPMODE_HDLC)
; Line 1592
	*** 002785	c4 3e 00 00 		les	di,DWORD PTR ?t1@@3PEVCescc@@E	;t1
	*** 002789	03 fe 			add	di,si
	*** 00278b	26 83 bd 9e 01 00 	cmp	WORD PTR es:[di+414],0
	*** 002791	75 18 			jne	$I1874
;|***         {     
;|***         //cts status change                                    
;|***         t1->port_status[i] = t1->port_status[i] | CTS_INTERRUPT;
; Line 1595
	*** 002793	8b 3e 00 00 		mov	di,WORD PTR ?t1@@3PEVCescc@@E	;t1
	*** 002797	03 fe 			add	di,si
	*** 002799	26 8b 85 96 01 		mov	ax,WORD PTR es:[di+406]
	*** 00279e	0c 10 			or	al,16	;0010H
	*** 0027a0	8b 3e 00 00 		mov	di,WORD PTR ?t1@@3PEVCescc@@E	;t1
	*** 0027a4	03 fe 			add	di,si
	*** 0027a6	26 89 85 96 01 		mov	WORD PTR es:[di+406],ax
;|***         }
;|***         
;|***       if(t1->eopmode[i]==OPMODE_ASYNC)
; Line 1598
					$I1874:
	*** 0027ab	c4 3e 00 00 		les	di,DWORD PTR ?t1@@3PEVCescc@@E	;t1
	*** 0027af	03 fe 			add	di,si
	*** 0027b1	26 83 bd 9e 01 01 	cmp	WORD PTR es:[di+414],1
	*** 0027b7	75 18 			jne	$I1875
;|***         {
;|***         //CTS changed state
;|***         t1->port_status[i] = t1->port_status[i] | CTS_INTERRUPT;
; Line 1601
	*** 0027b9	8b 3e 00 00 		mov	di,WORD PTR ?t1@@3PEVCescc@@E	;t1
	*** 0027bd	03 fe 			add	di,si
	*** 0027bf	26 8b 85 96 01 		mov	ax,WORD PTR es:[di+406]
	*** 0027c4	0c 10 			or	al,16	;0010H
	*** 0027c6	8b 3e 00 00 		mov	di,WORD PTR ?t1@@3PEVCescc@@E	;t1
	*** 0027ca	03 fe 			add	di,si
	*** 0027cc	26 89 85 96 01 		mov	WORD PTR es:[di+406],ax
;|***         }
;|***         
;|***       if(t1->eopmode[i]==OPMODE_BISYNC)
; Line 1604
					$I1875:
	*** 0027d1	c4 3e 00 00 		les	di,DWORD PTR ?t1@@3PEVCescc@@E	;t1
	*** 0027d5	03 fe 			add	di,si
	*** 0027d7	26 83 bd 9e 01 02 	cmp	WORD PTR es:[di+414],2
	*** 0027dd	75 18 			jne	$I1873
;|***         {
;|***         //CTS changed state
;|***         t1->port_status[i] = t1->port_status[i] | CTS_INTERRUPT;
; Line 1607
	*** 0027df	8b 3e 00 00 		mov	di,WORD PTR ?t1@@3PEVCescc@@E	;t1
	*** 0027e3	03 fe 			add	di,si
	*** 0027e5	26 8b 85 96 01 		mov	ax,WORD PTR es:[di+406]
	*** 0027ea	0c 10 			or	al,16	;0010H
	*** 0027ec	8b 3e 00 00 		mov	di,WORD PTR ?t1@@3PEVCescc@@E	;t1
	*** 0027f0	03 fe 			add	di,si
	*** 0027f2	26 89 85 96 01 		mov	WORD PTR es:[di+406],ax
;|***         }
;|***       } // end CSC
;|***       
;|***     
;|***     if((isr1&0x02)==0x02)  // XMR  Transmit Message Repeat
; Line 1612
					$I1873:
	*** 0027f7	8a c3 			mov	al,bl
	*** 0027f9	24 02 			and	al,2
	*** 0027fb	3c 02 			cmp	al,2
	*** 0027fd	75 4c 			jne	$I1877
;|***       {
;|***       if(t1->eopmode[i]==OPMODE_HDLC)
; Line 1614
	*** 0027ff	c4 3e 00 00 		les	di,DWORD PTR ?t1@@3PEVCescc@@E	;t1
	*** 002803	03 fe 			add	di,si
	*** 002805	26 83 bd 9e 01 00 	cmp	WORD PTR es:[di+414],0
	*** 00280b	75 18 			jne	$I1878
;|***         {       
;|***         //XMR interrupt
;|***         t1->port_status[i] = t1->port_status[i] | XMR_INTERRUPT;
; Line 1617
	*** 00280d	8b 3e 00 00 		mov	di,WORD PTR ?t1@@3PEVCescc@@E	;t1
	*** 002811	03 fe 			add	di,si
	*** 002813	26 8b 85 96 01 		mov	ax,WORD PTR es:[di+406]
	*** 002818	0c 01 			or	al,1
	*** 00281a	8b 3e 00 00 		mov	di,WORD PTR ?t1@@3PEVCescc@@E	;t1
	*** 00281e	03 fe 			add	di,si
	*** 002820	26 89 85 96 01 		mov	WORD PTR es:[di+406],ax
;|***         //could do an auto resend here ...possibly (indicates transmit message repeat)
;|***         }
;|***     
;|***       if(t1->eopmode[i]==OPMODE_BISYNC)
; Line 1621
					$I1878:
	*** 002825	c4 3e 00 00 		les	di,DWORD PTR ?t1@@3PEVCescc@@E	;t1
	*** 002829	03 fe 			add	di,si
	*** 00282b	26 83 bd 9e 01 02 	cmp	WORD PTR es:[di+414],2
	*** 002831	75 18 			jne	$I1877
;|***         {       
;|***         //XMR interrupt
;|***         t1->port_status[i] = t1->port_status[i] | XMR_INTERRUPT;
; Line 1624
	*** 002833	8b 3e 00 00 		mov	di,WORD PTR ?t1@@3PEVCescc@@E	;t1
	*** 002837	03 fe 			add	di,si
	*** 002839	26 8b 85 96 01 		mov	ax,WORD PTR es:[di+406]
	*** 00283e	0c 01 			or	al,1
	*** 002840	8b 3e 00 00 		mov	di,WORD PTR ?t1@@3PEVCescc@@E	;t1
	*** 002844	03 fe 			add	di,si
	*** 002846	26 89 85 96 01 		mov	WORD PTR es:[di+406],ax
;|***         //could do an auto resend here ...possibly (indicates transmit message repeat)
;|***         }
;|***       } // end XMR
;|***       
;|***   
;|***     if((isr1&XPR)==XPR)  //  Transmit Pool Ready
; Line 1630
					$I1877:
	*** 00284b	8a c3 			mov	al,bl
	*** 00284d	24 01 			and	al,1
	*** 00284f	3c 01 			cmp	al,1
	*** 002851	74 03 			je	$JCC10321
	*** 002853	e9 ad 04 		jmp	$I1880
					$JCC10321:
;|***       {
;|***       if((t1->eopmode[i]==OPMODE_HDLC)||(t1->eopmode[i]==OPMODE_BISYNC))
; Line 1632
	*** 002856	c4 1e 00 00 		les	bx,DWORD PTR ?t1@@3PEVCescc@@E	;t1
	*** 00285a	26 83 b8 9e 01 00 	cmp	WORD PTR es:[bx+414][si],0
	*** 002860	74 0b 			je	$I1882
	*** 002862	26 83 b8 9e 01 02 	cmp	WORD PTR es:[bx+414][si],2
	*** 002868	74 03 			je	$JCC10344
	*** 00286a	e9 46 02 		jmp	$I1881
					$JCC10344:
					$I1882:
;|***         {
;|***         //XPR interrupt (time to send the bytes out)            
;|***         if(t1->port_dmat_list[i]==0)  // no dma, so do interrupt xpr here  
; Line 1635
	*** 00286d	26 83 78 0c 00 		cmp	WORD PTR es:[bx+12][si],0
	*** 002872	74 03 			je	$JCC10354
	*** 002874	e9 6f 01 		jmp	$I1883
					$JCC10354:
;|***           {
;|***           //try_again_tx:                                
;|***           itxbuf = (t1->txbuffer[i][t1->current_txbuf[i]]);
; Line 1638
	*** 002877	26 8b 98 7e 01 		mov	bx,WORD PTR es:[bx+382][si]
	*** 00287c	c1 e3 02 		shl	bx,2
	*** 00287f	03 1e 00 00 		add	bx,WORD PTR ?t1@@3PEVCescc@@E	;t1
	*** 002883	8b 7e ec 		mov	di,WORD PTR [bp-20]	;msb
	*** 002886	26 8b 81 fa 00 		mov	ax,WORD PTR es:[bx+250][di]
	*** 00288b	26 8b 91 fc 00 		mov	dx,WORD PTR es:[bx+252][di]
	*** 002890	8b c8 			mov	cx,ax
	*** 002892	89 56 f4 		mov	WORD PTR [bp-12],dx
;|***           bloc = (unsigned far *)itxbuf->frame;
; Line 1639
	*** 002895	8b d8 			mov	bx,ax
	*** 002897	8b fa 			mov	di,dx
	*** 002899	05 06 00 		add	ax,6
	*** 00289c	89 46 ee 		mov	WORD PTR [bp-18],ax	;lsb
	*** 00289f	89 56 f0 		mov	WORD PTR [bp-16],dx
;|***           
;|***           if(itxbuf->valid==1)
; Line 1641
	*** 0028a2	8e c2 			mov	es,dx
	*** 0028a4	26 83 3f 01 		cmp	WORD PTR es:[bx],1
	*** 0028a8	74 03 			je	$JCC10408
	*** 0028aa	e9 25 01 		jmp	$L2260
					$JCC10408:
;|***             {  // note: ->max is the total num bytes in frame
;|***                //       ->no_bytes is num bytes already sent
;|***             if((itxbuf->max - itxbuf->no_bytes) > 32)
; Line 1644
	*** 0028ad	26 8b 47 04 		mov	ax,WORD PTR es:[bx+4]
	*** 0028b1	26 2b 47 02 		sub	ax,WORD PTR es:[bx+2]
	*** 0028b5	3d 20 00 		cmp	ax,32	;0020H
	*** 0028b8	77 03 			ja	$JCC10424
	*** 0028ba	e9 89 00 		jmp	$L2261
					$JCC10424:
;|***               { // if more than 32 bytes still to be sent
;|***                 // this is somewhere in the middle of the frame
;|***                 // load exactly 32 bytes into TFIFO (word writes since even number bytes)
;|***               for(j=(itxbuf->no_bytes)>>1;j<(itxbuf->no_bytes>>1)+16;j++)
; Line 1648
	*** 0028bd	26 8b 5f 02 		mov	bx,WORD PTR es:[bx+2]
	*** 0028c1	d1 eb 			shr	bx,1
	*** 0028c3	8d 47 10 		lea	ax,WORD PTR [bx+16]
	*** 0028c6	3b c3 			cmp	ax,bx
	*** 0028c8	76 76 			jbe	$L2262
	*** 0028ca	8b 46 ee 		mov	ax,WORD PTR [bp-18]	;lsb
	*** 0028cd	8b fb 			mov	di,bx
	*** 0028cf	03 fb 			add	di,bx
	*** 0028d1	03 c7 			add	ax,di
	*** 0028d3	89 46 fc 		mov	WORD PTR [bp-4],ax
	*** 0028d6	8b f9 			mov	di,cx
	*** 0028d8	89 56 fe 		mov	WORD PTR [bp-2],dx	;isr0
	*** 0028db	26 8b 45 02 		mov	ax,WORD PTR es:[di+2]
	*** 0028df	d1 e8 			shr	ax,1
	*** 0028e1	2b c3 			sub	ax,bx
	*** 0028e3	05 10 00 		add	ax,16	;0010H
	*** 0028e6	89 46 fa 		mov	WORD PTR [bp-6],ax	;k
	*** 0028e9	89 5e f6 		mov	WORD PTR [bp-10],bx	;j
	*** 0028ec	89 4e f2 		mov	WORD PTR [bp-14],cx	;irxbuf
	*** 0028ef	89 76 f8 		mov	WORD PTR [bp-8],si
	*** 0028f2	8b 5e fc 		mov	bx,WORD PTR [bp-4]
	*** 0028f5	8b c8 			mov	cx,ax
					$F1887:
;|***                 {
;|***                 outpw(t1->port_list[i]+FIFO,bloc[j]);      // load the fifo 
; Line 1650
	*** 0028f7	8e 46 fe 		mov	es,WORD PTR [bp-2]	;isr0
	*** 0028fa	26 8b 07 		mov	ax,WORD PTR es:[bx]
	*** 0028fd	c4 3e 00 00 		les	di,DWORD PTR ?t1@@3PEVCescc@@E	;t1
	*** 002901	03 fe 			add	di,si
	*** 002903	26 8b 15 		mov	dx,WORD PTR es:[di]
	*** 002906	83 c2 20 		add	dx,32	;0020H
	*** 002909	ef 			out	dx, ax

	*** 00290a	83 c3 02 		add	bx,2
	*** 00290d	49 			dec	cx
	*** 00290e	75 e7 			jne	$F1887
	*** 002910	8b 4e f2 		mov	cx,WORD PTR [bp-14]	;irxbuf
					$FB1889:
;|***                 }
;|***                 
;|***               outp(t1->port_list[i]+CMDR,t1->tx_type[i]);  // tx the bytes
; Line 1653
	*** 002913	c4 1e 00 00 		les	bx,DWORD PTR ?t1@@3PEVCescc@@E	;t1
	*** 002917	03 5e f8 		add	bx,WORD PTR [bp-8]
	*** 00291a	26 8b 87 8e 01 		mov	ax,WORD PTR es:[bx+398]
	*** 00291f	26 8b 17 		mov	dx,WORD PTR es:[bx]
	*** 002922	ee 			out	dx, al

;|***               itxbuf->no_bytes += 32;                      // update num bytes sent
; Line 1654
	*** 002923	8b d9 			mov	bx,cx
	*** 002925	8e 46 f4 		mov	es,WORD PTR [bp-12]
	*** 002928	26 83 47 02 20 		add	WORD PTR es:[bx+2],32	;0020H
;|***               t1->istxing[i] = 1;                          // flag that we're still tx'ing
; Line 1655
	*** 00292d	c4 1e 00 00 		les	bx,DWORD PTR ?t1@@3PEVCescc@@E	;t1
	*** 002931	8b 76 f8 		mov	si,WORD PTR [bp-8]
	*** 002934	26 c7 80 92 01 01 00 	mov	WORD PTR es:[bx+402][si],1
	*** 00293b	e9 a2 00 		jmp	$L2244
	*** 00293e	90 			nop	
	*** 00293f	90 			nop	
					$L2262:
	*** 002940	89 76 f8 		mov	WORD PTR [bp-8],si
	*** 002943	eb ce 			jmp	SHORT $FB1889
	*** 002945	90 			nop	
;|***                 }
; Line 1651
					$L2261:
	*** 002946	89 76 f8 		mov	WORD PTR [bp-8],si
;|***                 
;|***               outp(t1->port_list[i]+CMDR,t1->tx_type[i]);  // tx the bytes
;|***               itxbuf->no_bytes += 32;                      // update num bytes sent
;|***               t1->istxing[i] = 1;                          // flag that we're still tx'ing
;|***               }
;|***             else
;|***               { // there are 32 or fewer bytes remaining to tx
;|***                 // this is the end of the frame
;|***                 // load remaining bytes into TFIFO (byte writes since may be odd number)
;|***               for(j=itxbuf->no_bytes;j<itxbuf->max;j++)
; Line 1661
	*** 002949	8e c2 			mov	es,dx
	*** 00294b	26 8b 7f 02 		mov	di,WORD PTR es:[bx+2]
	*** 00294f	26 8b 47 04 		mov	ax,WORD PTR es:[bx+4]
	*** 002953	3b f8 			cmp	di,ax
	*** 002955	73 21 			jae	$FB1893
	*** 002957	89 4e f2 		mov	WORD PTR [bp-14],cx	;irxbuf
					$F1891:
;|***                 {
;|***                 outp(t1->port_list[i]+FIFO,itxbuf->frame[j]);  // load the fifo
; Line 1663
	*** 00295a	83 c3 06 		add	bx,6
	*** 00295d	26 8a 01 		mov	al,BYTE PTR es:[bx][di]
	*** 002960	98 			cbw	
	*** 002961	c4 1e 00 00 		les	bx,DWORD PTR ?t1@@3PEVCescc@@E	;t1
	*** 002965	26 8b 10 		mov	dx,WORD PTR es:[bx][si]
	*** 002968	83 c2 20 		add	dx,32	;0020H
	*** 00296b	ee 			out	dx, al

	*** 00296c	47 			inc	di
	*** 00296d	8b d9 			mov	bx,cx
	*** 00296f	8e 46 f4 		mov	es,WORD PTR [bp-12]
	*** 002972	26 39 7f 04 		cmp	WORD PTR es:[bx+4],di
	*** 002976	77 e2 			ja	$F1891
;|***                 }
; Line 1664
					$FB1893:
;|***               
;|***                 // tell the transmitter to tx the bytes, the crc, and the closing flag
;|***               outp(t1->port_list[i]+CMDR,t1->tx_type[i]+XME);
; Line 1667
	*** 002978	c4 1e 00 00 		les	bx,DWORD PTR ?t1@@3PEVCescc@@E	;t1
	*** 00297c	03 5e f8 		add	bx,WORD PTR [bp-8]
	*** 00297f	26 8b 87 8e 01 		mov	ax,WORD PTR es:[bx+398]
	*** 002984	05 02 00 		add	ax,2
	*** 002987	26 8b 17 		mov	dx,WORD PTR es:[bx]
	*** 00298a	ee 			out	dx, al

;|***               itxbuf->no_bytes = itxbuf->max;    // update num bytes sent
; Line 1668
	*** 00298b	8b d9 			mov	bx,cx
	*** 00298d	8e 46 f4 		mov	es,WORD PTR [bp-12]
	*** 002990	26 8b 47 04 		mov	ax,WORD PTR es:[bx+4]
	*** 002994	26 89 47 02 		mov	WORD PTR es:[bx+2],ax
;|***               itxbuf->valid = 0;                 // mark the buffer as unused
; Line 1669
	*** 002998	26 c7 07 00 00 		mov	WORD PTR es:[bx],0
;|***               t1->current_txbuf[i]++;            // select the next buffer, rollover if necessary
; Line 1670
	*** 00299d	c4 1e 00 00 		les	bx,DWORD PTR ?t1@@3PEVCescc@@E	;t1
	*** 0029a1	8b 76 f8 		mov	si,WORD PTR [bp-8]
	*** 0029a4	26 8b 80 7e 01 		mov	ax,WORD PTR es:[bx+382][si]
	*** 0029a9	40 			inc	ax
	*** 0029aa	26 89 80 7e 01 		mov	WORD PTR es:[bx+382][si],ax
;|***               if(t1->current_txbuf[i]==t1->max_txbuf[i]) t1->current_txbuf[i] = 0;
; Line 1671
	*** 0029af	c4 1e 00 00 		les	bx,DWORD PTR ?t1@@3PEVCescc@@E	;t1
	*** 0029b3	03 5e f8 		add	bx,WORD PTR [bp-8]
	*** 0029b6	26 8b 87 86 01 		mov	ax,WORD PTR es:[bx+390]
	*** 0029bb	26 39 87 7e 01 		cmp	WORD PTR es:[bx+382],ax
	*** 0029c0	75 1e 			jne	$L2244
	*** 0029c2	8b 1e 00 00 		mov	bx,WORD PTR ?t1@@3PEVCescc@@E	;t1
	*** 0029c6	03 5e f8 		add	bx,WORD PTR [bp-8]
	*** 0029c9	26 c7 87 7e 01 00 00 	mov	WORD PTR es:[bx+382],0
	*** 0029d0	eb 0e 			jmp	SHORT $L2244
					$L2260:
	*** 0029d2	89 76 f8 		mov	WORD PTR [bp-8],si
;|***               //goto try_again_tx;
;|***               }
;|***             }
;|***             
;|***           else
;|***             {
;|***             t1->istxing[i] = 0; //no valid frames we are done txing
; Line 1678
	*** 0029d5	c4 1e 00 00 		les	bx,DWORD PTR ?t1@@3PEVCescc@@E	;t1
	*** 0029d9	26 c7 80 92 01 00 00 	mov	WORD PTR es:[bx+402][si],0
					$L2244:
	*** 0029e0	8b 76 f8 		mov	si,WORD PTR [bp-8]
	*** 0029e3	e9 cd 00 		jmp	$I1881
					$I1883:
;|***             }
;|***           } // end interrupt, no DMA
;|***   
;|***         else
;|***           {
;|***           
;|***           //  do DMA xpr here
;|***           if(t1->txbuffer[i][t1->current_txbuf[i]]->valid==1)
; Line 1686
	*** 0029e6	03 de 			add	bx,si
	*** 0029e8	26 8b bf 7e 01 		mov	di,WORD PTR es:[bx+382]
	*** 0029ed	03 7e ea 		add	di,WORD PTR [bp-22]
	*** 0029f0	c1 e7 02 		shl	di,2
	*** 0029f3	8b 1e 00 00 		mov	bx,WORD PTR ?t1@@3PEVCescc@@E	;t1
	*** 0029f7	26 c4 99 fa 00 		les	bx,DWORD PTR es:[bx+250][di]
	*** 0029fc	26 83 3f 01 		cmp	WORD PTR es:[bx],1
	*** 002a00	74 03 			je	$JCC10752
	*** 002a02	e9 ae 00 		jmp	$I1881
					$JCC10752:
;|***             {
;|***             t1->txbuffer[i][t1->current_txbuf[i]]->valid = 0;   
; Line 1688
	*** 002a05	26 c7 07 00 00 		mov	WORD PTR es:[bx],0
;|***             t1->txbuffer[i][t1->current_txbuf[i]]->no_bytes =
;|***                 t1->txbuffer[i][t1->current_txbuf[i]]->max;
; Line 1690
	*** 002a0a	c4 1e 00 00 		les	bx,DWORD PTR ?t1@@3PEVCescc@@E	;t1
	*** 002a0e	26 8b 98 7e 01 		mov	bx,WORD PTR es:[bx+382][si]
	*** 002a13	c1 e3 02 		shl	bx,2
	*** 002a16	03 1e 00 00 		add	bx,WORD PTR ?t1@@3PEVCescc@@E	;t1
	*** 002a1a	8b 7e ec 		mov	di,WORD PTR [bp-20]	;msb
	*** 002a1d	26 c4 99 fa 00 		les	bx,DWORD PTR es:[bx+250][di]
	*** 002a22	26 8b 47 04 		mov	ax,WORD PTR es:[bx+4]
	*** 002a26	26 89 47 02 		mov	WORD PTR es:[bx+2],ax
;|***             t1->istxing[i] = 0;
; Line 1691
	*** 002a2a	c4 1e 00 00 		les	bx,DWORD PTR ?t1@@3PEVCescc@@E	;t1
	*** 002a2e	26 c7 80 92 01 00 00 	mov	WORD PTR es:[bx+402][si],0
;|***             t1->current_txbuf[i]++;
; Line 1692
	*** 002a35	c4 1e 00 00 		les	bx,DWORD PTR ?t1@@3PEVCescc@@E	;t1
	*** 002a39	26 8b 80 7e 01 		mov	ax,WORD PTR es:[bx+382][si]
	*** 002a3e	40 			inc	ax
	*** 002a3f	26 89 80 7e 01 		mov	WORD PTR es:[bx+382][si],ax
;|***             if(t1->current_txbuf[i]==t1->max_txbuf[i])
; Line 1693
	*** 002a44	c4 1e 00 00 		les	bx,DWORD PTR ?t1@@3PEVCescc@@E	;t1
	*** 002a48	03 de 			add	bx,si
	*** 002a4a	26 8b 87 86 01 		mov	ax,WORD PTR es:[bx+390]
	*** 002a4f	26 39 87 7e 01 		cmp	WORD PTR es:[bx+382],ax
	*** 002a54	75 0d 			jne	$I1898
;|***               {
;|***               t1->current_txbuf[i]=0;
; Line 1695
	*** 002a56	8b 1e 00 00 		mov	bx,WORD PTR ?t1@@3PEVCescc@@E	;t1
	*** 002a5a	03 de 			add	bx,si
	*** 002a5c	26 c7 87 7e 01 00 00 	mov	WORD PTR es:[bx+382],0
;|***               }
;|***             if(t1->txbuffer[i][t1->current_txbuf[i]]->valid ==1)
; Line 1697
					$I1898:
	*** 002a63	c4 1e 00 00 		les	bx,DWORD PTR ?t1@@3PEVCescc@@E	;t1
	*** 002a67	03 de 			add	bx,si
	*** 002a69	26 8b bf 7e 01 		mov	di,WORD PTR es:[bx+382]
	*** 002a6e	03 7e ea 		add	di,WORD PTR [bp-22]
	*** 002a71	c1 e7 02 		shl	di,2
	*** 002a74	8b 1e 00 00 		mov	bx,WORD PTR ?t1@@3PEVCescc@@E	;t1
	*** 002a78	26 c4 99 fa 00 		les	bx,DWORD PTR es:[bx+250][di]
	*** 002a7d	26 83 3f 01 		cmp	WORD PTR es:[bx],1
	*** 002a81	75 30 			jne	$I1881
;|***               {
;|***               setupdmat(i,t1->txbuffer[i][t1->current_txbuf[i]]->frame,t1->txbuffer[i][t1->current_txbuf[i]]->max);
; Line 1699
	*** 002a83	ff 76 e8 		push	WORD PTR [bp-24]	;i
	*** 002a86	8d 47 06 		lea	ax,WORD PTR [bx+6]
	*** 002a89	06 			push	es
	*** 002a8a	50 			push	ax
	*** 002a8b	26 ff 77 04 		push	WORD PTR es:[bx+4]
	*** 002a8f	ff 76 02 		push	WORD PTR [bp+2]
	*** 002a92	ff 76 00 		push	WORD PTR [bp]	;this
	*** 002a95	0e 			push	cs
	*** 002a96	e8 00 00 		call	NEAR PTR ?setupdmat@Cescc@@JECXIPEXI@Z	; Cescc::setupdmat
;|***               t1->istxing[i] = 1;
; Line 1700
	*** 002a99	c4 1e 00 00 		les	bx,DWORD PTR ?t1@@3PEVCescc@@E	;t1
	*** 002a9d	26 c7 80 92 01 01 00 	mov	WORD PTR es:[bx+402][si],1
;|***               outp(t1->port_list[i]+CMDR,t1->tx_type[i]);
; Line 1701
	*** 002aa4	c4 1e 00 00 		les	bx,DWORD PTR ?t1@@3PEVCescc@@E	;t1
	*** 002aa8	03 de 			add	bx,si
	*** 002aaa	26 8b 87 8e 01 		mov	ax,WORD PTR es:[bx+398]
	*** 002aaf	26 8b 17 		mov	dx,WORD PTR es:[bx]
	*** 002ab2	ee 			out	dx, al

;|***               }
;|***             }  // end if current_txbuf[] == valid         
;|***           //t1->tx_port(1, pcm, 96);  
;|***           } // end DMA
;|***         }  // end of HDLC
;|***     
;|***     
;|***       if(t1->eopmode[i]==OPMODE_ASYNC)
; Line 1709
					$I1881:
	*** 002ab3	c4 1e 00 00 		les	bx,DWORD PTR ?t1@@3PEVCescc@@E	;t1
	*** 002ab7	03 de 			add	bx,si
	*** 002ab9	26 83 bf 9e 01 01 	cmp	WORD PTR es:[bx+414],1
	*** 002abf	74 03 			je	$JCC10943
	*** 002ac1	e9 3f 02 		jmp	$I1880
					$JCC10943:
;|***         {
;|***         //transmit data ready interrupt
;|***         if(t1->port_dmat_list[i]==0)
; Line 1712
	*** 002ac4	8b 1e 00 00 		mov	bx,WORD PTR ?t1@@3PEVCescc@@E	;t1
	*** 002ac8	26 83 78 0c 00 		cmp	WORD PTR es:[bx+12][si],0
	*** 002acd	74 03 			je	$JCC10957
	*** 002acf	e9 68 01 		jmp	$I1901
					$JCC10957:
;|***           {
;|***           itxbuf = (t1->txbuffer[i][t1->current_txbuf[i]]);
; Line 1714
	*** 002ad2	26 8b 98 7e 01 		mov	bx,WORD PTR es:[bx+382][si]
	*** 002ad7	c1 e3 02 		shl	bx,2
	*** 002ada	03 1e 00 00 		add	bx,WORD PTR ?t1@@3PEVCescc@@E	;t1
	*** 002ade	8b 7e ec 		mov	di,WORD PTR [bp-20]	;msb
	*** 002ae1	26 8b 81 fa 00 		mov	ax,WORD PTR es:[bx+250][di]
	*** 002ae6	26 8b 91 fc 00 		mov	dx,WORD PTR es:[bx+252][di]
	*** 002aeb	8b c8 			mov	cx,ax
	*** 002aed	89 56 f4 		mov	WORD PTR [bp-12],dx
;|***           bloc = (unsigned far *)itxbuf->frame;
; Line 1715
	*** 002af0	8b d8 			mov	bx,ax
	*** 002af2	8b fa 			mov	di,dx
	*** 002af4	05 06 00 		add	ax,6
	*** 002af7	89 46 ee 		mov	WORD PTR [bp-18],ax	;lsb
	*** 002afa	89 56 f0 		mov	WORD PTR [bp-16],dx
;|***           if(itxbuf->valid==1)
; Line 1716
	*** 002afd	8e c2 			mov	es,dx
	*** 002aff	26 83 3f 01 		cmp	WORD PTR es:[bx],1
	*** 002b03	74 03 			je	$JCC11011
	*** 002b05	e9 1c 01 		jmp	$L2268
					$JCC11011:
;|***             {
;|***             if((itxbuf->max - itxbuf->no_bytes) > 32)
; Line 1718
	*** 002b08	26 8b 47 04 		mov	ax,WORD PTR es:[bx+4]
	*** 002b0c	26 2b 47 02 		sub	ax,WORD PTR es:[bx+2]
	*** 002b10	3d 20 00 		cmp	ax,32	;0020H
	*** 002b13	77 03 			ja	$JCC11027
	*** 002b15	e9 84 00 		jmp	$L2269
					$JCC11027:
;|***               {
;|***               //do send 32
;|***               for(j=(itxbuf->no_bytes)>>1;j<(itxbuf->no_bytes>>1)+16;j++)
; Line 1721
	*** 002b18	26 8b 47 02 		mov	ax,WORD PTR es:[bx+2]
	*** 002b1c	d1 e8 			shr	ax,1
	*** 002b1e	89 46 f6 		mov	WORD PTR [bp-10],ax	;j
	*** 002b21	8b d0 			mov	dx,ax
	*** 002b23	05 10 00 		add	ax,16	;0010H
	*** 002b26	3b c2 			cmp	ax,dx
	*** 002b28	76 6c 			jbe	$L2270
	*** 002b2a	8b c2 			mov	ax,dx
	*** 002b2c	03 c2 			add	ax,dx
	*** 002b2e	03 46 ee 		add	ax,WORD PTR [bp-18]	;lsb
	*** 002b31	89 46 fc 		mov	WORD PTR [bp-4],ax
	*** 002b34	89 7e fe 		mov	WORD PTR [bp-2],di	;isr0
	*** 002b37	26 8b 47 02 		mov	ax,WORD PTR es:[bx+2]
	*** 002b3b	d1 e8 			shr	ax,1
	*** 002b3d	2b c2 			sub	ax,dx
	*** 002b3f	05 10 00 		add	ax,16	;0010H
	*** 002b42	89 46 fa 		mov	WORD PTR [bp-6],ax	;k
	*** 002b45	8b 5e fc 		mov	bx,WORD PTR [bp-4]
	*** 002b48	89 4e f2 		mov	WORD PTR [bp-14],cx	;irxbuf
	*** 002b4b	89 76 f8 		mov	WORD PTR [bp-8],si
	*** 002b4e	8b c8 			mov	cx,ax
					$F1905:
;|***               outpw(t1->port_list[i]+FIFO,bloc[j]); 
; Line 1722
	*** 002b50	8e 46 fe 		mov	es,WORD PTR [bp-2]	;isr0
	*** 002b53	26 8b 07 		mov	ax,WORD PTR es:[bx]
	*** 002b56	c4 3e 00 00 		les	di,DWORD PTR ?t1@@3PEVCescc@@E	;t1
	*** 002b5a	03 fe 			add	di,si
	*** 002b5c	26 8b 15 		mov	dx,WORD PTR es:[di]
	*** 002b5f	83 c2 20 		add	dx,32	;0020H
	*** 002b62	ef 			out	dx, ax

	*** 002b63	83 c3 02 		add	bx,2
	*** 002b66	49 			dec	cx
	*** 002b67	75 e7 			jne	$F1905
	*** 002b69	8b 4e f2 		mov	cx,WORD PTR [bp-14]	;irxbuf
					$FB1907:
;|***               outp(t1->port_list[i]+CMDR,0x08);
; Line 1723
	*** 002b6c	b8 08 00 		mov	ax,8
	*** 002b6f	c4 1e 00 00 		les	bx,DWORD PTR ?t1@@3PEVCescc@@E	;t1
	*** 002b73	8b 76 f8 		mov	si,WORD PTR [bp-8]
	*** 002b76	26 8b 10 		mov	dx,WORD PTR es:[bx][si]
	*** 002b79	ee 			out	dx, al

;|***               itxbuf->no_bytes += 32;
; Line 1724
	*** 002b7a	8b d9 			mov	bx,cx
	*** 002b7c	8e 46 f4 		mov	es,WORD PTR [bp-12]
	*** 002b7f	26 83 47 02 20 		add	WORD PTR es:[bx+2],32	;0020H
;|***               t1->istxing[i] = 1;
; Line 1725
	*** 002b84	c4 1e 00 00 		les	bx,DWORD PTR ?t1@@3PEVCescc@@E	;t1
	*** 002b88	8b 76 f8 		mov	si,WORD PTR [bp-8]
	*** 002b8b	26 c7 80 92 01 01 00 	mov	WORD PTR es:[bx+402][si],1
	*** 002b92	e9 9f 00 		jmp	$L2239
	*** 002b95	90 			nop	
					$L2270:
	*** 002b96	89 76 f8 		mov	WORD PTR [bp-8],si
	*** 002b99	eb d1 			jmp	SHORT $FB1907
	*** 002b9b	90 			nop	
					$L2269:
	*** 002b9c	89 76 f8 		mov	WORD PTR [bp-8],si
;|***               }
;|***             else
;|***               {
;|***               //do send <=32 //sending as byte accesses such that odd bytes can go out
;|***               for(j=itxbuf->no_bytes;j<itxbuf->max;j++)
; Line 1730
	*** 002b9f	8e c2 			mov	es,dx
	*** 002ba1	26 8b 7f 02 		mov	di,WORD PTR es:[bx+2]
	*** 002ba5	26 8b 47 04 		mov	ax,WORD PTR es:[bx+4]
	*** 002ba9	3b f8 			cmp	di,ax
	*** 002bab	73 21 			jae	$FB1911
	*** 002bad	89 4e f2 		mov	WORD PTR [bp-14],cx	;irxbuf
					$F1909:
;|***               outp(t1->port_list[i]+FIFO,itxbuf->frame[j]);
; Line 1731
	*** 002bb0	83 c3 06 		add	bx,6
	*** 002bb3	26 8a 01 		mov	al,BYTE PTR es:[bx][di]
	*** 002bb6	98 			cbw	
	*** 002bb7	c4 1e 00 00 		les	bx,DWORD PTR ?t1@@3PEVCescc@@E	;t1
	*** 002bbb	26 8b 10 		mov	dx,WORD PTR es:[bx][si]
	*** 002bbe	83 c2 20 		add	dx,32	;0020H
	*** 002bc1	ee 			out	dx, al

	*** 002bc2	47 			inc	di
	*** 002bc3	8b d9 			mov	bx,cx
	*** 002bc5	8e 46 f4 		mov	es,WORD PTR [bp-12]
	*** 002bc8	26 39 7f 04 		cmp	WORD PTR es:[bx+4],di
	*** 002bcc	77 e2 			ja	$F1909
					$FB1911:
;|***               outp(t1->port_list[i]+CMDR,0x08);
; Line 1732
	*** 002bce	b8 08 00 		mov	ax,8
	*** 002bd1	c4 1e 00 00 		les	bx,DWORD PTR ?t1@@3PEVCescc@@E	;t1
	*** 002bd5	8b 76 f8 		mov	si,WORD PTR [bp-8]
	*** 002bd8	26 8b 10 		mov	dx,WORD PTR es:[bx][si]
	*** 002bdb	ee 			out	dx, al

;|***               itxbuf->no_bytes = itxbuf->max;
; Line 1733
	*** 002bdc	8b d9 			mov	bx,cx
	*** 002bde	8e 46 f4 		mov	es,WORD PTR [bp-12]
	*** 002be1	26 8b 47 04 		mov	ax,WORD PTR es:[bx+4]
	*** 002be5	26 89 47 02 		mov	WORD PTR es:[bx+2],ax
;|***               itxbuf->valid = 0;
; Line 1734
	*** 002be9	26 c7 07 00 00 		mov	WORD PTR es:[bx],0
;|***               t1->current_txbuf[i]++;
; Line 1735
	*** 002bee	c4 1e 00 00 		les	bx,DWORD PTR ?t1@@3PEVCescc@@E	;t1
	*** 002bf2	8b 76 f8 		mov	si,WORD PTR [bp-8]
	*** 002bf5	26 8b 80 7e 01 		mov	ax,WORD PTR es:[bx+382][si]
	*** 002bfa	40 			inc	ax
	*** 002bfb	26 89 80 7e 01 		mov	WORD PTR es:[bx+382][si],ax
;|***               if(t1->current_txbuf[i]==t1->max_txbuf[i])
; Line 1736
	*** 002c00	c4 1e 00 00 		les	bx,DWORD PTR ?t1@@3PEVCescc@@E	;t1
	*** 002c04	03 5e f8 		add	bx,WORD PTR [bp-8]
	*** 002c07	26 8b 87 86 01 		mov	ax,WORD PTR es:[bx+390]
	*** 002c0c	26 39 87 7e 01 		cmp	WORD PTR es:[bx+382],ax
	*** 002c11	75 21 			jne	$L2239
;|***                 t1->current_txbuf[i] = 0;
; Line 1737
	*** 002c13	8b 1e 00 00 		mov	bx,WORD PTR ?t1@@3PEVCescc@@E	;t1
	*** 002c17	03 5e f8 		add	bx,WORD PTR [bp-8]
	*** 002c1a	26 c7 87 7e 01 00 00 	mov	WORD PTR es:[bx+382],0
	*** 002c21	eb 11 			jmp	SHORT $L2239
	*** 002c23	90 			nop	
					$L2268:
	*** 002c24	89 76 f8 		mov	WORD PTR [bp-8],si
;|***               //goto try_again_tx;
;|***               }
;|***             }
;|***           else
;|***             {
;|***             t1->istxing[i] = 0; //no valid frames we are done txing
; Line 1743
	*** 002c27	c4 1e 00 00 		les	bx,DWORD PTR ?t1@@3PEVCescc@@E	;t1
	*** 002c2b	03 de 			add	bx,si
	*** 002c2d	26 c7 87 92 01 00 00 	mov	WORD PTR es:[bx+402],0
					$L2239:
	*** 002c34	8b 76 f8 		mov	si,WORD PTR [bp-8]
	*** 002c37	e9 c9 00 		jmp	$I1880
					$I1901:
;|***             }
;|***           }
;|***         else
;|***           {
;|***           //do DMA xpr here
;|***           if(t1->txbuffer[i][t1->current_txbuf[i]]->valid==1)
; Line 1749
	*** 002c3a	03 de 			add	bx,si
	*** 002c3c	26 8b bf 7e 01 		mov	di,WORD PTR es:[bx+382]
	*** 002c41	03 7e ea 		add	di,WORD PTR [bp-22]
	*** 002c44	c1 e7 02 		shl	di,2
	*** 002c47	8b 1e 00 00 		mov	bx,WORD PTR ?t1@@3PEVCescc@@E	;t1
	*** 002c4b	26 c4 99 fa 00 		les	bx,DWORD PTR es:[bx+250][di]
	*** 002c50	26 83 3f 01 		cmp	WORD PTR es:[bx],1
	*** 002c54	74 03 			je	$JCC11348
	*** 002c56	e9 aa 00 		jmp	$I1880
					$JCC11348:
;|***             {
;|***             t1->txbuffer[i][t1->current_txbuf[i]]->valid = 0;   
; Line 1751
	*** 002c59	26 c7 07 00 00 		mov	WORD PTR es:[bx],0
;|***             t1->txbuffer[i][t1->current_txbuf[i]]->no_bytes = t1->txbuffer[i][t1->current_txbuf[i]]->max;
; Line 1752
	*** 002c5e	c4 1e 00 00 		les	bx,DWORD PTR ?t1@@3PEVCescc@@E	;t1
	*** 002c62	26 8b 98 7e 01 		mov	bx,WORD PTR es:[bx+382][si]
	*** 002c67	c1 e3 02 		shl	bx,2
	*** 002c6a	03 1e 00 00 		add	bx,WORD PTR ?t1@@3PEVCescc@@E	;t1
	*** 002c6e	8b 7e ec 		mov	di,WORD PTR [bp-20]	;msb
	*** 002c71	26 c4 99 fa 00 		les	bx,DWORD PTR es:[bx+250][di]
	*** 002c76	26 8b 47 04 		mov	ax,WORD PTR es:[bx+4]
	*** 002c7a	26 89 47 02 		mov	WORD PTR es:[bx+2],ax
;|***             t1->istxing[i] = 0;
; Line 1753
	*** 002c7e	c4 1e 00 00 		les	bx,DWORD PTR ?t1@@3PEVCescc@@E	;t1
	*** 002c82	26 c7 80 92 01 00 00 	mov	WORD PTR es:[bx+402][si],0
;|***             t1->current_txbuf[i]++;
; Line 1754
	*** 002c89	c4 1e 00 00 		les	bx,DWORD PTR ?t1@@3PEVCescc@@E	;t1
	*** 002c8d	26 8b 80 7e 01 		mov	ax,WORD PTR es:[bx+382][si]
	*** 002c92	40 			inc	ax
	*** 002c93	26 89 80 7e 01 		mov	WORD PTR es:[bx+382][si],ax
;|***             if(t1->current_txbuf[i]==t1->max_txbuf[i]) t1->current_txbuf[i]=0;
; Line 1755
	*** 002c98	c4 1e 00 00 		les	bx,DWORD PTR ?t1@@3PEVCescc@@E	;t1
	*** 002c9c	03 de 			add	bx,si
	*** 002c9e	26 8b 87 86 01 		mov	ax,WORD PTR es:[bx+390]
	*** 002ca3	26 39 87 7e 01 		cmp	WORD PTR es:[bx+382],ax
	*** 002ca8	75 0d 			jne	$I1916
	*** 002caa	8b 1e 00 00 		mov	bx,WORD PTR ?t1@@3PEVCescc@@E	;t1
	*** 002cae	03 de 			add	bx,si
	*** 002cb0	26 c7 87 7e 01 00 00 	mov	WORD PTR es:[bx+382],0
;|***             if(t1->txbuffer[i][t1->current_txbuf[i]]->valid ==1)
; Line 1756
					$I1916:
	*** 002cb7	c4 1e 00 00 		les	bx,DWORD PTR ?t1@@3PEVCescc@@E	;t1
	*** 002cbb	03 de 			add	bx,si
	*** 002cbd	26 8b bf 7e 01 		mov	di,WORD PTR es:[bx+382]
	*** 002cc2	03 7e ea 		add	di,WORD PTR [bp-22]
	*** 002cc5	c1 e7 02 		shl	di,2
	*** 002cc8	8b 1e 00 00 		mov	bx,WORD PTR ?t1@@3PEVCescc@@E	;t1
	*** 002ccc	26 c4 99 fa 00 		les	bx,DWORD PTR es:[bx+250][di]
	*** 002cd1	26 83 3f 01 		cmp	WORD PTR es:[bx],1
	*** 002cd5	75 2c 			jne	$I1880
;|***               {
;|***               setupdmat(i,t1->txbuffer[i][t1->current_txbuf[i]]->frame,t1->txbuffer[i][t1->current_txbuf[i]]->max);
; Line 1758
	*** 002cd7	ff 76 e8 		push	WORD PTR [bp-24]	;i
	*** 002cda	8d 47 06 		lea	ax,WORD PTR [bx+6]
	*** 002cdd	06 			push	es
	*** 002cde	50 			push	ax
	*** 002cdf	26 ff 77 04 		push	WORD PTR es:[bx+4]
	*** 002ce3	ff 76 02 		push	WORD PTR [bp+2]
	*** 002ce6	ff 76 00 		push	WORD PTR [bp]	;this
	*** 002ce9	0e 			push	cs
	*** 002cea	e8 00 00 		call	NEAR PTR ?setupdmat@Cescc@@JECXIPEXI@Z	; Cescc::setupdmat
;|***               t1->istxing[i] = 1;
; Line 1759
	*** 002ced	c4 1e 00 00 		les	bx,DWORD PTR ?t1@@3PEVCescc@@E	;t1
	*** 002cf1	b8 08 00 		mov	ax,8
	*** 002cf4	26 c7 80 92 01 01 00 	mov	WORD PTR es:[bx+402][si],1
;|***               outp(t1->port_list[i]+CMDR,0x08);
; Line 1760
	*** 002cfb	c4 1e 00 00 		les	bx,DWORD PTR ?t1@@3PEVCescc@@E	;t1
	*** 002cff	26 8b 10 		mov	dx,WORD PTR es:[bx][si]
	*** 002d02	ee 			out	dx, al

;|***               }  // end if()
;|***             }  // end if()
;|***           }  // end else do DMA
;|***         } // end do ASYNC
;|***       }  // end XPR
;|***         
;|***     
;|***     if((pis&0x80)==0x80)
; Line 1768
					$I1880:
;|***       {
;|***       //DMA TC reached
;|***       }               
;|***       
;|***     
;|***     if((pis&0x40)==0x40)
; Line 1774
	*** 002d03	8a 46 e2 		mov	al,BYTE PTR [bp-30]	;pis
	*** 002d06	24 40 			and	al,64	;0040H
	*** 002d08	3c 40 			cmp	al,64	;0040H
	*** 002d0a	75 04 			jne	$I1919
;|***       {
;|***       if((_inp(0x240+PVR) & 0x40) == 0x40);
; Line 1776
	*** 002d0c	ba 5c 02 		mov	dx,604	;025cH
	*** 002d0f	ec 			in	al,dx
;|***         //com_request = 1;     //DSR channel 1 changed
;|***       }
;|***     
;|***     
;|***     if((pis&0x20)==0x20)
; Line 1781
					$I1919:
;|***       {
;|***       //DSR channel 0 changed
;|***       }
;|***         
;|***     nextpt:
;|***     
;|***   
;|***     // restore escc ports to channel
;|***     //  that was active when ISR started
;|***     outp(t1->port_list[i]+PVR,(inp(t1->port_list[i]+PVR)&0xfe)+chanstor); //set channel
; Line 1791
	*** 002d10	c4 1e 00 00 		les	bx,DWORD PTR ?t1@@3PEVCescc@@E	;t1
	*** 002d14	26 8b 10 		mov	dx,WORD PTR es:[bx][si]
	*** 002d17	83 c2 1c 		add	dx,28	;001cH
	*** 002d1a	ec 			in	al,dx
	*** 002d1b	25 fe 00 		and	ax,254	;00feH
	*** 002d1e	03 46 e0 		add	ax,WORD PTR [bp-32]	;chanstor
	*** 002d21	ee 			out	dx, al

	*** 002d22	83 46 ea 10 		add	WORD PTR [bp-22],16	;0010H
	*** 002d26	83 46 ec 40 		add	WORD PTR [bp-20],64	;0040H	;msb
	*** 002d2a	83 c6 02 		add	si,2
	*** 002d2d	26 8b 47 74 		mov	ax,WORD PTR es:[bx+116]
	*** 002d31	ff 46 e8 		inc	WORD PTR [bp-24]	;i
	*** 002d34	39 46 e8 		cmp	WORD PTR [bp-24],ax	;i
	*** 002d37	73 03 			jae	$JCC11575
	*** 002d39	e9 91 ea 		jmp	$F1756
					$JCC11575:
;|***     
;|***     }  // end for all open ports
; Line 1793
					$FB1758:
;|***   
;|***   if(inthit==1) goto startisr;
; Line 1795
	*** 002d3c	83 7e e4 01 		cmp	WORD PTR [bp-28],1	;inthit
	*** 002d40	75 03 			jne	$JCC11584
	*** 002d42	e9 66 ea 		jmp	$startisr1755
					$JCC11584:
;|***   
;|***   //_disable();  // rem out 12/08/03
;|***   
;|*** /*
;|***   if(ok_to_tx)
;|***     {
;|***     ok_to_tx = 0;
;|***     t1->tx_port(1, pcm,96);
;|***     }
;|*** */  
;|***   // no more interrupts set
;|***   // do eoi's and leave
;|***   outp(0x20,0x20);
; Line 1808
	*** 002d45	ba 20 00 		mov	dx,32	;0020H
	*** 002d48	8b c2 			mov	ax,dx
	*** 002d4a	ee 			out	dx, al

;|***   if(t1->upper_irq!=0) outp(0xa0,0x20);
; Line 1809
	*** 002d4b	26 83 7f 78 00 		cmp	WORD PTR es:[bx+120],0
	*** 002d50	74 02 			je	$EX1735
	*** 002d52	e6 a0 			out	160	;00a0H, al

;|***   } //  end isr
; Line 1810
					$EX1735:
	*** 002d54	8b e5 			mov	sp,bp
	*** 002d56	07 			pop	es
	*** 002d57	1f 			pop	ds
	ASSUME DS: DGROUP
	*** 002d58	61 			popa
	*** 002d59	cf 			iret	

?escc_isr@Cescc@@JEAXXZ	ENDP
	PUBLIC	?setupdmat@Cescc@@JECXIPEXI@Z	; Cescc::setupdmat
?setupdmat@Cescc@@JECXIPEXI@Z	PROC FAR	; Cescc::setupdmat
;|*** 
;|*** 
;|*** 
;|*** 
;|*** 
;|*** 
;|*** void Cescc::setupdmat(unsigned port, void far *address,unsigned numbytes)
;|***   {
; Line 1818
	*** 002d5a	c8 12 00 00 		enter	18,0
	*** 002d5e	57 			push	di
	*** 002d5f	56 			push	si
;	port = 16
;	address = 12
;	numbytes = 10
;	this = 6
;	i = -2
;	register cx = size
;	linaddress = -8
;	register bx = chanstor
;|***   unsigned i,size;
;|***   unsigned long linaddress;
;|***   unsigned chanstor;
;|***   
;|***   if (numbytes == 0) size = FRAME_SIZE;
; Line 1823
	*** 002d60	83 7e 0a 00 		cmp	WORD PTR [bp+10],0	;numbytes
	*** 002d64	75 06 			jne	$I1933
	*** 002d66	bf 00 04 		mov	di,1024	;0400H
;|***   else size = numbytes;
; Line 1824
	*** 002d69	eb 04 			jmp	SHORT $I1934
	*** 002d6b	90 			nop	
					$I1933:
	*** 002d6c	8b 7e 0a 		mov	di,WORD PTR [bp+10]	;numbytes
					$I1934:
;|***   
;|***   if(t1->port_dmat_list[port]>3)
; Line 1826
	*** 002d6f	c4 1e 00 00 		les	bx,DWORD PTR ?t1@@3PEVCescc@@E	;t1
	*** 002d73	83 c3 0c 		add	bx,12	;000cH
	*** 002d76	8b 76 10 		mov	si,WORD PTR [bp+16]	;port
	*** 002d79	03 f6 			add	si,si
	*** 002d7b	89 76 fe 		mov	WORD PTR [bp-2],si	;i
	*** 002d7e	26 83 38 03 		cmp	WORD PTR es:[bx][si],3
	*** 002d82	76 0e 			jbe	$I1935
;|***     {
;|***     size = (size/2) +(numbytes&1);//word transfers...half the size..add 1 for odd bytelenghts
; Line 1828
	*** 002d84	8a 46 0a 		mov	al,BYTE PTR [bp+10]	;numbytes
	*** 002d87	25 01 00 		and	ax,1
	*** 002d8a	8b cf 			mov	cx,di
	*** 002d8c	d1 e9 			shr	cx,1
	*** 002d8e	03 c1 			add	ax,cx
	*** 002d90	8b f8 			mov	di,ax
;|***     }
;|*** 
;|***   if(t1->port_dmat_list[port]==1)
; Line 1831
					$I1935:
	*** 002d92	8b 5e 0c 		mov	bx,WORD PTR [bp+12]	;address
	*** 002d95	8b 36 00 00 		mov	si,WORD PTR ?t1@@3PEVCescc@@E	;t1
	*** 002d99	83 c6 0c 		add	si,12	;000cH
	*** 002d9c	03 76 fe 		add	si,WORD PTR [bp-2]	;i
	*** 002d9f	26 83 3c 01 		cmp	WORD PTR es:[si],1
	*** 002da3	75 6a 			jne	$I1936
;|***     {
;|***     outp(DMA_COMMAND_LO,4);             //disables 8 bit dma
; Line 1833
	*** 002da5	b8 04 00 		mov	ax,4
	*** 002da8	e6 08 			out	8, al

;|***     outp(DMA_MODE_LO,0x19);             //sets demand xfer on ch1
; Line 1834
	*** 002daa	b8 19 00 		mov	ax,25	;0019H
	*** 002dad	e6 0b 			out	11	;000bH, al

;|***     outp(DMA_CLEAR_FFLO,0);             //reset count hi/lo
; Line 1835
	*** 002daf	33 c0 			xor	ax,ax
	*** 002db1	e6 0c 			out	12	;000cH, al

;|***     outp(DMA_COUNT_CH1,(size-1)&0xff);    //program byte count 
; Line 1836
	*** 002db3	8d 45 ff 		lea	ax,WORD PTR [di-1]
	*** 002db6	2a e4 			sub	ah,ah
	*** 002db8	e6 03 			out	3, al

;|***     outp(DMA_COUNT_CH1,(size-1)>>8);      //controller will do 
; Line 1837
	*** 002dba	8d 45 ff 		lea	ax,WORD PTR [di-1]
	*** 002dbd	8a c4 			mov	al,ah
	*** 002dbf	2a e4 			sub	ah,ah
	*** 002dc1	e6 03 			out	3, al

;|***     linaddress = (((unsigned long)address & 0xffff0000)>>12) + ((unsigned long)address & 0xffff);
;|***     outp(DMA_PAGE_CH1,(char)(linaddress>>16));             //calculate linear address of buffer
; Line 1839
	*** 002dc3	8b d3 			mov	dx,bx
	*** 002dc5	8b 4e 0e 		mov	cx,WORD PTR [bp+14]
	*** 002dc8	80 e6 0f 		and	dh,15	;000fH
	*** 002dcb	03 d2 			add	dx,dx
	*** 002dcd	13 c9 			adc	cx,cx
	*** 002dcf	13 d2 			adc	dx,dx
	*** 002dd1	13 c9 			adc	cx,cx
	*** 002dd3	13 d2 			adc	dx,dx
	*** 002dd5	13 c9 			adc	cx,cx
	*** 002dd7	13 d2 			adc	dx,dx
	*** 002dd9	13 c9 			adc	cx,cx
	*** 002ddb	13 d2 			adc	dx,dx
	*** 002ddd	87 d1 			xchg	dx,cx
	*** 002ddf	83 e1 0f 		and	cx,15	;000fH
	*** 002de2	03 d3 			add	dx,bx
	*** 002de4	83 d1 00 		adc	cx,0
	*** 002de7	8b c1 			mov	ax,cx
	*** 002de9	98 			cbw	
	*** 002dea	e6 83 			out	131	;0083H, al

;|***     outp(DMA_CLEAR_FFLO,0);                     //and store in DMA controller
; Line 1840
	*** 002dec	33 c0 			xor	ax,ax
	*** 002dee	e6 0c 			out	12	;000cH, al

;|***     outp(DMA_ADD_CH1,(char)(linaddress&0xff));
; Line 1841
	*** 002df0	89 56 fa 		mov	WORD PTR [bp-6],dx
	*** 002df3	8a 46 fa 		mov	al,BYTE PTR [bp-6]
	*** 002df6	98 			cbw	
	*** 002df7	e6 02 			out	2, al

;|***     outp(DMA_ADD_CH1,(char)(linaddress>>8));
; Line 1842
	*** 002df9	8b c2 			mov	ax,dx
	*** 002dfb	8b d1 			mov	dx,cx
	*** 002dfd	8a c4 			mov	al,ah
	*** 002dff	8a d6 			mov	dl,dh
	*** 002e01	2a f6 			sub	dh,dh
	*** 002e03	98 			cbw	
	*** 002e04	e6 02 			out	2, al

;|***     outp(DMA_MASK_LO,1);                        //enable ch1 mask
; Line 1843
	*** 002e06	b8 01 00 		mov	ax,1
	*** 002e09	e6 0a 			out	10	;000aH, al

;|***     outp(DMA_COMMAND_LO,0);                     //enable 8bit dma
; Line 1844
	*** 002e0b	33 c0 			xor	ax,ax
	*** 002e0d	e6 08 			out	8, al

;|***     }
;|***   
;|***   if(t1->port_dmat_list[port]==3)
; Line 1847
					$I1936:
	*** 002e0f	8b 36 00 00 		mov	si,WORD PTR ?t1@@3PEVCescc@@E	;t1
	*** 002e13	83 c6 0c 		add	si,12	;000cH
	*** 002e16	03 76 fe 		add	si,WORD PTR [bp-2]	;i
	*** 002e19	26 83 3c 03 		cmp	WORD PTR es:[si],3
	*** 002e1d	75 6a 			jne	$I1942
;|***     {
;|***     outp(DMA_COMMAND_LO,4);
; Line 1849
	*** 002e1f	b8 04 00 		mov	ax,4
	*** 002e22	e6 08 			out	8, al

;|***     outp(DMA_MODE_LO,0x1B);
; Line 1850
	*** 002e24	b8 1b 00 		mov	ax,27	;001bH
	*** 002e27	e6 0b 			out	11	;000bH, al

;|***     outp(DMA_CLEAR_FFLO,0);
; Line 1851
	*** 002e29	33 c0 			xor	ax,ax
	*** 002e2b	e6 0c 			out	12	;000cH, al

;|***     outp(DMA_COUNT_CH3,(size-1)&0xff);
; Line 1852
	*** 002e2d	8d 45 ff 		lea	ax,WORD PTR [di-1]
	*** 002e30	2a e4 			sub	ah,ah
	*** 002e32	e6 07 			out	7, al

;|***     outp(DMA_COUNT_CH3,(size-1)>>8);
; Line 1853
	*** 002e34	8d 45 ff 		lea	ax,WORD PTR [di-1]
	*** 002e37	8a c4 			mov	al,ah
	*** 002e39	2a e4 			sub	ah,ah
	*** 002e3b	e6 07 			out	7, al

;|***     linaddress = (((unsigned long)address & 0xffff0000)>>12) + ((unsigned long)address & 0xffff);
;|***     outp(DMA_PAGE_CH3,(char)(linaddress>>16));
; Line 1855
	*** 002e3d	8b d3 			mov	dx,bx
	*** 002e3f	8b 4e 0e 		mov	cx,WORD PTR [bp+14]
	*** 002e42	80 e6 0f 		and	dh,15	;000fH
	*** 002e45	03 d2 			add	dx,dx
	*** 002e47	13 c9 			adc	cx,cx
	*** 002e49	13 d2 			adc	dx,dx
	*** 002e4b	13 c9 			adc	cx,cx
	*** 002e4d	13 d2 			adc	dx,dx
	*** 002e4f	13 c9 			adc	cx,cx
	*** 002e51	13 d2 			adc	dx,dx
	*** 002e53	13 c9 			adc	cx,cx
	*** 002e55	13 d2 			adc	dx,dx
	*** 002e57	87 d1 			xchg	dx,cx
	*** 002e59	83 e1 0f 		and	cx,15	;000fH
	*** 002e5c	03 d3 			add	dx,bx
	*** 002e5e	83 d1 00 		adc	cx,0
	*** 002e61	8b c1 			mov	ax,cx
	*** 002e63	98 			cbw	
	*** 002e64	e6 82 			out	130	;0082H, al

;|***     outp(DMA_CLEAR_FFLO,0);
; Line 1856
	*** 002e66	33 c0 			xor	ax,ax
	*** 002e68	e6 0c 			out	12	;000cH, al

;|***     outp(DMA_ADD_CH3,(char)(linaddress&0xff));
; Line 1857
	*** 002e6a	89 56 f6 		mov	WORD PTR [bp-10],dx
	*** 002e6d	8a 46 f6 		mov	al,BYTE PTR [bp-10]
	*** 002e70	98 			cbw	
	*** 002e71	e6 06 			out	6, al

;|***     outp(DMA_ADD_CH3,(char)(linaddress>>8));
; Line 1858
	*** 002e73	8b c2 			mov	ax,dx
	*** 002e75	8b d1 			mov	dx,cx
	*** 002e77	8a c4 			mov	al,ah
	*** 002e79	8a d6 			mov	dl,dh
	*** 002e7b	2a f6 			sub	dh,dh
	*** 002e7d	98 			cbw	
	*** 002e7e	e6 06 			out	6, al

;|***     outp(DMA_MASK_LO,3);
; Line 1859
	*** 002e80	b8 03 00 		mov	ax,3
	*** 002e83	e6 0a 			out	10	;000aH, al

;|***     outp(DMA_COMMAND_LO,0);
; Line 1860
	*** 002e85	33 c0 			xor	ax,ax
	*** 002e87	e6 08 			out	8, al

;|***     }
;|***   
;|***   if(t1->port_dmat_list[port]==5)
; Line 1863
					$I1942:
	*** 002e89	8b 36 00 00 		mov	si,WORD PTR ?t1@@3PEVCescc@@E	;t1
	*** 002e8d	83 c6 0c 		add	si,12	;000cH
	*** 002e90	03 76 fe 		add	si,WORD PTR [bp-2]	;i
	*** 002e93	26 83 3c 05 		cmp	WORD PTR es:[si],5
	*** 002e97	75 6c 			jne	$I1948
;|***     {
;|***     outp(DMA_COMMAND_HI,4);     //disable dma
; Line 1865
	*** 002e99	b8 04 00 		mov	ax,4
	*** 002e9c	e6 d0 			out	208	;00d0H, al

;|***     outp(DMA_MODE_HI,0x19);     //demand xfr on ch5
; Line 1866
	*** 002e9e	b8 19 00 		mov	ax,25	;0019H
	*** 002ea1	e6 d6 			out	214	;00d6H, al

;|***     outp(DMA_CLEAR_FFHI,0);     //reset flip-flop
; Line 1867
	*** 002ea3	33 c0 			xor	ax,ax
	*** 002ea5	e6 d8 			out	216	;00d8H, al

;|***     outp(DMA_COUNT_CH5,(size-1)&0xff);
; Line 1868
	*** 002ea7	8d 45 ff 		lea	ax,WORD PTR [di-1]
	*** 002eaa	2a e4 			sub	ah,ah
	*** 002eac	e6 c6 			out	198	;00c6H, al

;|***     outp(DMA_COUNT_CH5,(size-1)>>8);
; Line 1869
	*** 002eae	8d 45 ff 		lea	ax,WORD PTR [di-1]
	*** 002eb1	8a c4 			mov	al,ah
	*** 002eb3	2a e4 			sub	ah,ah
	*** 002eb5	e6 c6 			out	198	;00c6H, al

;|***     linaddress = (((unsigned long)address & 0xffff0000)>>12) + ((unsigned long)address & 0xffff);
;|***     outp(DMA_PAGE_CH5,(char)(linaddress>>16));
; Line 1871
	*** 002eb7	8b d3 			mov	dx,bx
	*** 002eb9	8b 4e 0e 		mov	cx,WORD PTR [bp+14]
	*** 002ebc	80 e6 0f 		and	dh,15	;000fH
	*** 002ebf	03 d2 			add	dx,dx
	*** 002ec1	13 c9 			adc	cx,cx
	*** 002ec3	13 d2 			adc	dx,dx
	*** 002ec5	13 c9 			adc	cx,cx
	*** 002ec7	13 d2 			adc	dx,dx
	*** 002ec9	13 c9 			adc	cx,cx
	*** 002ecb	13 d2 			adc	dx,dx
	*** 002ecd	13 c9 			adc	cx,cx
	*** 002ecf	13 d2 			adc	dx,dx
	*** 002ed1	87 d1 			xchg	dx,cx
	*** 002ed3	83 e1 0f 		and	cx,15	;000fH
	*** 002ed6	03 d3 			add	dx,bx
	*** 002ed8	83 d1 00 		adc	cx,0
	*** 002edb	8b c1 			mov	ax,cx
	*** 002edd	98 			cbw	
	*** 002ede	e6 8b 			out	139	;008bH, al

;|***     linaddress = linaddress>>1; //adjust for 16bit dma
;|***     outp(DMA_CLEAR_FFHI,0);
; Line 1873
	*** 002ee0	33 c0 			xor	ax,ax
	*** 002ee2	e6 d8 			out	216	;00d8H, al

;|***     outp(DMA_ADD_CH5,(char)(linaddress&0xff));
; Line 1874
	*** 002ee4	8b c2 			mov	ax,dx
	*** 002ee6	8b d1 			mov	dx,cx
	*** 002ee8	d1 ea 			shr	dx,1
	*** 002eea	d1 d8 			rcr	ax,1
	*** 002eec	8b c8 			mov	cx,ax
	*** 002eee	98 			cbw	
	*** 002eef	e6 c4 			out	196	;00c4H, al

;|***     outp(DMA_ADD_CH5,(char)(linaddress>>8));
; Line 1875
	*** 002ef1	8b c1 			mov	ax,cx
	*** 002ef3	8a c4 			mov	al,ah
	*** 002ef5	8a d6 			mov	dl,dh
	*** 002ef7	2a f6 			sub	dh,dh
	*** 002ef9	98 			cbw	
	*** 002efa	e6 c4 			out	196	;00c4H, al

;|***     outp(DMA_MASK_HI,1);        //enable chan5
; Line 1876
	*** 002efc	b8 01 00 		mov	ax,1
	*** 002eff	e6 d4 			out	212	;00d4H, al

;|***     outp(DMA_COMMAND_HI,0);     //enable dma
; Line 1877
	*** 002f01	33 c0 			xor	ax,ax
	*** 002f03	e6 d0 			out	208	;00d0H, al

;|***     }
;|*** 
;|***   if(t1->port_dmat_list[port]==7)
; Line 1880
					$I1948:
	*** 002f05	8b 36 00 00 		mov	si,WORD PTR ?t1@@3PEVCescc@@E	;t1
	*** 002f09	83 c6 0c 		add	si,12	;000cH
	*** 002f0c	03 76 fe 		add	si,WORD PTR [bp-2]	;i
	*** 002f0f	26 83 3c 07 		cmp	WORD PTR es:[si],7
	*** 002f13	75 6f 			jne	$I1954
;|***     {
;|***     outp(DMA_COMMAND_HI,4);     //disable dma
; Line 1882
	*** 002f15	b8 04 00 		mov	ax,4
	*** 002f18	e6 d0 			out	208	;00d0H, al

;|***     outp(DMA_MODE_HI,0x1b);     //demand xfr on ch7
; Line 1883
	*** 002f1a	b8 1b 00 		mov	ax,27	;001bH
	*** 002f1d	e6 d6 			out	214	;00d6H, al

;|***     outp(DMA_CLEAR_FFHI,0);     //reset flip-flop
; Line 1884
	*** 002f1f	33 c0 			xor	ax,ax
	*** 002f21	e6 d8 			out	216	;00d8H, al

;|***     outp(DMA_COUNT_CH7,(size-1)&0xff);
; Line 1885
	*** 002f23	8d 45 ff 		lea	ax,WORD PTR [di-1]
	*** 002f26	8b c8 			mov	cx,ax
	*** 002f28	2a e4 			sub	ah,ah
	*** 002f2a	e6 ce 			out	206	;00ceH, al

;|***     outp(DMA_COUNT_CH7,(size-1)>>8);
; Line 1886
	*** 002f2c	8b c1 			mov	ax,cx
	*** 002f2e	8a c4 			mov	al,ah
	*** 002f30	2a e4 			sub	ah,ah
	*** 002f32	e6 ce 			out	206	;00ceH, al

;|***     linaddress = (((unsigned long)address & 0xffff0000)>>12) + ((unsigned long)address & 0xffff);
;|***     outp(DMA_PAGE_CH7,(char)(linaddress>>16));
; Line 1888
	*** 002f34	8b 4e 0e 		mov	cx,WORD PTR [bp+14]
	*** 002f37	89 5e ee 		mov	WORD PTR [bp-18],bx
	*** 002f3a	80 e7 0f 		and	bh,15	;000fH
	*** 002f3d	03 db 			add	bx,bx
	*** 002f3f	13 c9 			adc	cx,cx
	*** 002f41	13 db 			adc	bx,bx
	*** 002f43	13 c9 			adc	cx,cx
	*** 002f45	13 db 			adc	bx,bx
	*** 002f47	13 c9 			adc	cx,cx
	*** 002f49	13 db 			adc	bx,bx
	*** 002f4b	13 c9 			adc	cx,cx
	*** 002f4d	13 db 			adc	bx,bx
	*** 002f4f	87 d9 			xchg	bx,cx
	*** 002f51	83 e1 0f 		and	cx,15	;000fH
	*** 002f54	03 5e ee 		add	bx,WORD PTR [bp-18]
	*** 002f57	83 d1 00 		adc	cx,0
	*** 002f5a	8b c1 			mov	ax,cx
	*** 002f5c	98 			cbw	
	*** 002f5d	e6 8a 			out	138	;008aH, al

;|***     linaddress = linaddress>>1; //adjust for 16bit dma
;|***     outp(DMA_CLEAR_FFHI,0);
; Line 1890
	*** 002f5f	33 c0 			xor	ax,ax
	*** 002f61	e6 d8 			out	216	;00d8H, al

;|***     outp(DMA_ADD_CH7,(char)(linaddress&0xff));
; Line 1891
	*** 002f63	8b c3 			mov	ax,bx
	*** 002f65	8b d1 			mov	dx,cx
	*** 002f67	d1 ea 			shr	dx,1
	*** 002f69	d1 d8 			rcr	ax,1
	*** 002f6b	8b c8 			mov	cx,ax
	*** 002f6d	98 			cbw	
	*** 002f6e	e6 cc 			out	204	;00ccH, al

;|***     outp(DMA_ADD_CH7,(char)(linaddress>>8));
; Line 1892
	*** 002f70	8b c1 			mov	ax,cx
	*** 002f72	8a c4 			mov	al,ah
	*** 002f74	8a d6 			mov	dl,dh
	*** 002f76	2a f6 			sub	dh,dh
	*** 002f78	98 			cbw	
	*** 002f79	e6 cc 			out	204	;00ccH, al

;|***     outp(DMA_MASK_HI,3);        //enable chan7
; Line 1893
	*** 002f7b	b8 03 00 		mov	ax,3
	*** 002f7e	e6 d4 			out	212	;00d4H, al

;|***     outp(DMA_COMMAND_HI,0);     //enable dma
; Line 1894
	*** 002f80	33 c0 			xor	ax,ax
	*** 002f82	e6 d0 			out	208	;00d0H, al

;|***     }
;|*** 
;|***   if(numbytes ==0) size =FRAME_SIZE;
; Line 1897
					$I1954:
	*** 002f84	83 7e 0a 00 		cmp	WORD PTR [bp+10],0	;numbytes
	*** 002f88	75 06 			jne	$I1960
	*** 002f8a	b9 00 04 		mov	cx,1024	;0400H
;|***   else size = numbytes;
; Line 1898
	*** 002f8d	eb 04 			jmp	SHORT $I1961
	*** 002f8f	90 			nop	
					$I1960:
	*** 002f90	8b 4e 0a 		mov	cx,WORD PTR [bp+10]	;numbytes
					$I1961:
;|***   i = size-1;
;|***   i = i&0x0fff;
;|***   i = i|0x8000;
;|***   chanstor = inp(t1->port_list[port]+PVR)&0x1;
; Line 1902
	*** 002f93	8b 5e fe 		mov	bx,WORD PTR [bp-2]	;i
	*** 002f96	03 1e 00 00 		add	bx,WORD PTR ?t1@@3PEVCescc@@E	;t1
	*** 002f9a	26 8b 17 		mov	dx,WORD PTR es:[bx]
	*** 002f9d	8b c2 			mov	ax,dx
	*** 002f9f	83 c2 1c 		add	dx,28	;001cH
	*** 002fa2	8b d8 			mov	bx,ax
	*** 002fa4	ec 			in	al,dx
	*** 002fa5	8b f3 			mov	si,bx
	*** 002fa7	8a d8 			mov	bl,al
	*** 002fa9	83 e3 01 		and	bx,1
;|***   outp(t1->port_list[port]+PVR,(inp(t1->port_list[port]+PVR)&0xfe)+t1->channel[port]); //set channel
; Line 1903
	*** 002fac	ec 			in	al,dx
	*** 002fad	25 fe 00 		and	ax,254	;00feH
	*** 002fb0	8b 3e 00 00 		mov	di,WORD PTR ?t1@@3PEVCescc@@E	;t1
	*** 002fb4	81 c7 9a 01 		add	di,410	;019aH
	*** 002fb8	03 7e fe 		add	di,WORD PTR [bp-2]	;i
	*** 002fbb	26 03 05 		add	ax,WORD PTR es:[di]
	*** 002fbe	ee 			out	dx, al

;|***   outp(t1->port_list[port]+XBCL,i&0xff);
; Line 1904
	*** 002fbf	8b c2 			mov	ax,dx
	*** 002fc1	8d 54 0a 		lea	dx,WORD PTR [si+10]
	*** 002fc4	8b f8 			mov	di,ax
	*** 002fc6	8b c1 			mov	ax,cx
	*** 002fc8	48 			dec	ax
	*** 002fc9	80 e4 0f 		and	ah,15	;000fH
	*** 002fcc	80 cc 80 		or	ah,128	;0080H
	*** 002fcf	8b c8 			mov	cx,ax
	*** 002fd1	2a e4 			sub	ah,ah
	*** 002fd3	ee 			out	dx, al

;|***   outp(t1->port_list[port]+XBCH,i>>8);    //set for dma mode and FRAME_SIZE bytes per frame
; Line 1905
	*** 002fd4	8d 54 0b 		lea	dx,WORD PTR [si+11]
	*** 002fd7	8b c1 			mov	ax,cx
	*** 002fd9	8a c4 			mov	al,ah
	*** 002fdb	2a e4 			sub	ah,ah
	*** 002fdd	ee 			out	dx, al

;|***   outp(t1->port_list[port]+PVR,(inp(t1->port_list[port]+PVR)&0xfe)+chanstor); //set channel
; Line 1906
	*** 002fde	8b d7 			mov	dx,di
	*** 002fe0	ec 			in	al,dx
	*** 002fe1	25 fe 00 		and	ax,254	;00feH
	*** 002fe4	03 c3 			add	ax,bx
	*** 002fe6	ee 			out	dx, al

;|***   
;|***   }
; Line 1908
	*** 002fe7	5e 			pop	si
	*** 002fe8	5f 			pop	di
	*** 002fe9	c9 			leave	
	*** 002fea	ca 0c 00 		ret	12	;0000000cH
	*** 002fed	90 			nop	

?setupdmat@Cescc@@JECXIPEXI@Z	ENDP
	PUBLIC	?setupdmar@Cescc@@JECXIPEX@Z	; Cescc::setupdmar
?setupdmar@Cescc@@JECXIPEX@Z	PROC FAR	; Cescc::setupdmar
;|*** 
;|*** 
;|*** 
;|*** 
;|*** 
;|*** void Cescc::setupdmar(unsigned port,void far *address)
;|***   {
; Line 1915
	*** 002fee	c8 14 00 00 		enter	20,0
	*** 002ff2	57 			push	di
	*** 002ff3	56 			push	si
;	port = 14
;	address = 10
;	this = 6
;	linaddress = -4
;	size = -2
	*** 002ff4	8b 7e 0e 		mov	di,WORD PTR [bp+14]	;port
;|***   unsigned long linaddress;
;|***   unsigned size;
;|*** 
;|***   size = 0;
; Line 1919
	*** 002ff7	8b 5e 0a 		mov	bx,WORD PTR [bp+10]	;address
;|***   //size = 32; //so max received is framesize+32
;|***   //the extra transfers are added to the frame size so if FRAME_SIZE+1 
;|***   //( the +1 is for the status bytes that is pushed into the RXFIFO) is set to 
;|***   //a non multiple of 32 the receive[] array will be valid and not overwritten
;|***   //by the unexpected transfers at the end of a frame. and subsequent frames
;|***   //will be received correctly
;|***   //in other words if a frame size of say 40 is used:
;|***   // frame_size+1 = 41
;|***   // then ther;|***   // 9 bytes will force a 16 byte DMA cycle giving us 7 extra bytes
;|***   // so we add 7 to the frame size to get the total number of cycles in a
;|***   // received frame( the received length will be 48 bytes 41 of which are valid)
;|***   if(t1->port_dmar_list[port]==1)
; Line 1932
	*** 002ffa	8b c7 			mov	ax,di
	*** 002ffc	03 c7 			add	ax,di
	*** 002ffe	c4 36 00 00 		les	si,DWORD PTR ?t1@@3PEVCescc@@E	;t1
	*** 003002	83 c6 10 		add	si,16	;0010H
	*** 003005	03 f0 			add	si,ax
	*** 003007	26 8b 04 		mov	ax,WORD PTR es:[si]
	*** 00300a	89 46 fc 		mov	WORD PTR [bp-4],ax	;linaddress
	*** 00300d	48 			dec	ax
	*** 00300e	75 65 			jne	$I1968
;|***     {
;|***     outp(DMA_COMMAND_LO,4);     //disable dma
; Line 1934
	*** 003010	b8 04 00 		mov	ax,4
	*** 003013	e6 08 			out	8, al

;|***     outp(DMA_MODE_LO,0x15);     //demand xfer ch1
; Line 1935
	*** 003015	b8 15 00 		mov	ax,21	;0015H
	*** 003018	e6 0b 			out	11	;000bH, al

;|***     outp(DMA_CLEAR_FFLO,0);     //clear ctrlr flip flop
; Line 1936
	*** 00301a	33 c0 			xor	ax,ax
	*** 00301c	e6 0c 			out	12	;000cH, al

;|***     outp(DMA_COUNT_CH1,(FRAME_SIZE+size-1)&0xff);//write corrected word count
; Line 1937
	*** 00301e	b8 ff 00 		mov	ax,255	;00ffH
	*** 003021	e6 03 			out	3, al

;|***     outp(DMA_COUNT_CH1,(FRAME_SIZE+size-1)>>8);
; Line 1938
	*** 003023	ba 03 00 		mov	dx,3
	*** 003026	8b c2 			mov	ax,dx
	*** 003028	ee 			out	dx, al

;|***     linaddress = (((unsigned long)address & 0xffff0000)>>12) + ((unsigned long)address & 0xffff);
;|***     outp(DMA_PAGE_CH1,(char)(linaddress>>16));
; Line 1940
	*** 003029	8b d3 			mov	dx,bx
	*** 00302b	8b 4e 0c 		mov	cx,WORD PTR [bp+12]
	*** 00302e	80 e6 0f 		and	dh,15	;000fH
	*** 003031	03 d2 			add	dx,dx
	*** 003033	13 c9 			adc	cx,cx
	*** 003035	13 d2 			adc	dx,dx
	*** 003037	13 c9 			adc	cx,cx
	*** 003039	13 d2 			adc	dx,dx
	*** 00303b	13 c9 			adc	cx,cx
	*** 00303d	13 d2 			adc	dx,dx
	*** 00303f	13 c9 			adc	cx,cx
	*** 003041	13 d2 			adc	dx,dx
	*** 003043	87 d1 			xchg	dx,cx
	*** 003045	83 e1 0f 		and	cx,15	;000fH
	*** 003048	03 d3 			add	dx,bx
	*** 00304a	83 d1 00 		adc	cx,0
	*** 00304d	8b c1 			mov	ax,cx
	*** 00304f	98 			cbw	
	*** 003050	e6 83 			out	131	;0083H, al

;|***     outp(DMA_CLEAR_FFLO,0);
; Line 1941
	*** 003052	33 c0 			xor	ax,ax
	*** 003054	e6 0c 			out	12	;000cH, al

;|***     outp(DMA_ADD_CH1,(char)(linaddress&0xff));     //and store it in the controller
; Line 1942
	*** 003056	89 56 f8 		mov	WORD PTR [bp-8],dx
	*** 003059	8a 46 f8 		mov	al,BYTE PTR [bp-8]
	*** 00305c	98 			cbw	
	*** 00305d	e6 02 			out	2, al

;|***     outp(DMA_ADD_CH1,(char)(linaddress>>8));
; Line 1943
	*** 00305f	8b c2 			mov	ax,dx
	*** 003061	8b d1 			mov	dx,cx
	*** 003063	8a c4 			mov	al,ah
	*** 003065	8a d6 			mov	dl,dh
	*** 003067	2a f6 			sub	dh,dh
	*** 003069	98 			cbw	
	*** 00306a	e6 02 			out	2, al

;|***     outp(DMA_MASK_LO,1);                //unmask ch1
; Line 1944
	*** 00306c	b8 01 00 		mov	ax,1
	*** 00306f	e6 0a 			out	10	;000aH, al

;|***     outp(DMA_COMMAND_LO,0);             //enable DMA
; Line 1945
	*** 003071	33 c0 			xor	ax,ax
	*** 003073	e6 08 			out	8, al

;|***     }
;|***   
;|***   if(t1->port_dmar_list[port]==3)
; Line 1948
					$I1968:
	*** 003075	83 7e fc 03 		cmp	WORD PTR [bp-4],3	;linaddress
	*** 003079	75 64 			jne	$I1974
;|***     {
;|***     outp(DMA_COMMAND_LO,4);
; Line 1950
	*** 00307b	b8 04 00 		mov	ax,4
	*** 00307e	e6 08 			out	8, al

;|***     outp(DMA_MODE_LO,0x17);
; Line 1951
	*** 003080	b8 17 00 		mov	ax,23	;0017H
	*** 003083	e6 0b 			out	11	;000bH, al

;|***     outp(DMA_CLEAR_FFLO,0);
; Line 1952
	*** 003085	33 c0 			xor	ax,ax
	*** 003087	e6 0c 			out	12	;000cH, al

;|***     outp(DMA_COUNT_CH3,(FRAME_SIZE+size-1)&0xff);
; Line 1953
	*** 003089	b8 ff 00 		mov	ax,255	;00ffH
	*** 00308c	e6 07 			out	7, al

;|***     outp(DMA_COUNT_CH3,(FRAME_SIZE+size-1)>>8);
; Line 1954
	*** 00308e	b8 03 00 		mov	ax,3
	*** 003091	e6 07 			out	7, al

;|***     linaddress = (((unsigned long)address & 0xffff0000)>>12) + ((unsigned long)address & 0xffff);
;|***     outp(DMA_PAGE_CH3,(char)(linaddress>>16));
; Line 1956
	*** 003093	8b d3 			mov	dx,bx
	*** 003095	8b 4e 0c 		mov	cx,WORD PTR [bp+12]
	*** 003098	80 e6 0f 		and	dh,15	;000fH
	*** 00309b	03 d2 			add	dx,dx
	*** 00309d	13 c9 			adc	cx,cx
	*** 00309f	13 d2 			adc	dx,dx
	*** 0030a1	13 c9 			adc	cx,cx
	*** 0030a3	13 d2 			adc	dx,dx
	*** 0030a5	13 c9 			adc	cx,cx
	*** 0030a7	13 d2 			adc	dx,dx
	*** 0030a9	13 c9 			adc	cx,cx
	*** 0030ab	13 d2 			adc	dx,dx
	*** 0030ad	87 d1 			xchg	dx,cx
	*** 0030af	83 e1 0f 		and	cx,15	;000fH
	*** 0030b2	03 d3 			add	dx,bx
	*** 0030b4	83 d1 00 		adc	cx,0
	*** 0030b7	8b c1 			mov	ax,cx
	*** 0030b9	98 			cbw	
	*** 0030ba	e6 82 			out	130	;0082H, al

;|***     outp(DMA_CLEAR_FFLO,0);
; Line 1957
	*** 0030bc	33 c0 			xor	ax,ax
	*** 0030be	e6 0c 			out	12	;000cH, al

;|***     outp(DMA_ADD_CH3,(char)(linaddress&0xff));
; Line 1958
	*** 0030c0	89 56 f4 		mov	WORD PTR [bp-12],dx
	*** 0030c3	8a 46 f4 		mov	al,BYTE PTR [bp-12]
	*** 0030c6	98 			cbw	
	*** 0030c7	e6 06 			out	6, al

;|***     outp(DMA_ADD_CH3,(char)(linaddress>>8));
; Line 1959
	*** 0030c9	8b c2 			mov	ax,dx
	*** 0030cb	8b d1 			mov	dx,cx
	*** 0030cd	8a c4 			mov	al,ah
	*** 0030cf	8a d6 			mov	dl,dh
	*** 0030d1	2a f6 			sub	dh,dh
	*** 0030d3	98 			cbw	
	*** 0030d4	e6 06 			out	6, al

;|***     outp(DMA_MASK_LO,3);
; Line 1960
	*** 0030d6	b8 03 00 		mov	ax,3
	*** 0030d9	e6 0a 			out	10	;000aH, al

;|***     outp(DMA_COMMAND_LO,0);
; Line 1961
	*** 0030db	33 c0 			xor	ax,ax
	*** 0030dd	e6 08 			out	8, al

;|***     }
;|***   
;|***   if(t1->port_dmar_list[port]==5)
; Line 1964
					$I1974:
	*** 0030df	83 7e fc 05 		cmp	WORD PTR [bp-4],5	;linaddress
	*** 0030e3	75 66 			jne	$I1980
;|***     {
;|***     outp(DMA_COMMAND_HI,4);     //disable dma
; Line 1966
	*** 0030e5	b8 04 00 		mov	ax,4
	*** 0030e8	e6 d0 			out	208	;00d0H, al

;|***     outp(DMA_MODE_HI,0x15);     //demand xfr on ch5
; Line 1967
	*** 0030ea	b8 15 00 		mov	ax,21	;0015H
	*** 0030ed	e6 d6 			out	214	;00d6H, al

;|***     outp(DMA_CLEAR_FFHI,0);     //reset flip-flop
; Line 1968
	*** 0030ef	33 c0 			xor	ax,ax
	*** 0030f1	e6 d8 			out	216	;00d8H, al

;|***     outp(DMA_COUNT_CH5,(((FRAME_SIZE+size)/2)-1)&0xff);
; Line 1969
	*** 0030f3	b8 ff 00 		mov	ax,255	;00ffH
	*** 0030f6	e6 c6 			out	198	;00c6H, al

;|***     outp(DMA_COUNT_CH5,(((FRAME_SIZE+size)/2)-1)>>8);
; Line 1970
	*** 0030f8	b8 01 00 		mov	ax,1
	*** 0030fb	e6 c6 			out	198	;00c6H, al

;|***     linaddress = (((unsigned long)address & 0xffff0000)>>12) + ((unsigned long)address & 0xffff);
;|***     outp(DMA_PAGE_CH5,(char)(linaddress>>16));
; Line 1972
	*** 0030fd	8b d3 			mov	dx,bx
	*** 0030ff	8b 4e 0c 		mov	cx,WORD PTR [bp+12]
	*** 003102	80 e6 0f 		and	dh,15	;000fH
	*** 003105	03 d2 			add	dx,dx
	*** 003107	13 c9 			adc	cx,cx
	*** 003109	13 d2 			adc	dx,dx
	*** 00310b	13 c9 			adc	cx,cx
	*** 00310d	13 d2 			adc	dx,dx
	*** 00310f	13 c9 			adc	cx,cx
	*** 003111	13 d2 			adc	dx,dx
	*** 003113	13 c9 			adc	cx,cx
	*** 003115	13 d2 			adc	dx,dx
	*** 003117	87 d1 			xchg	dx,cx
	*** 003119	83 e1 0f 		and	cx,15	;000fH
	*** 00311c	03 d3 			add	dx,bx
	*** 00311e	83 d1 00 		adc	cx,0
	*** 003121	8b c1 			mov	ax,cx
	*** 003123	98 			cbw	
	*** 003124	e6 8b 			out	139	;008bH, al

;|***     linaddress = linaddress>>1; //adjust for 16bit dma
;|***     outp(DMA_CLEAR_FFHI,0);
; Line 1974
	*** 003126	33 c0 			xor	ax,ax
	*** 003128	e6 d8 			out	216	;00d8H, al

;|***     outp(DMA_ADD_CH5,(char)(linaddress&0xff));
; Line 1975
	*** 00312a	8b c2 			mov	ax,dx
	*** 00312c	8b d1 			mov	dx,cx
	*** 00312e	d1 ea 			shr	dx,1
	*** 003130	d1 d8 			rcr	ax,1
	*** 003132	8b c8 			mov	cx,ax
	*** 003134	98 			cbw	
	*** 003135	e6 c4 			out	196	;00c4H, al

;|***     outp(DMA_ADD_CH5,(char)(linaddress>>8));
; Line 1976
	*** 003137	8b c1 			mov	ax,cx
	*** 003139	8a c4 			mov	al,ah
	*** 00313b	8a d6 			mov	dl,dh
	*** 00313d	2a f6 			sub	dh,dh
	*** 00313f	98 			cbw	
	*** 003140	e6 c4 			out	196	;00c4H, al

;|***     outp(DMA_MASK_HI,1);        //enable chan5
; Line 1977
	*** 003142	b8 01 00 		mov	ax,1
	*** 003145	e6 d4 			out	212	;00d4H, al

;|***     outp(DMA_COMMAND_HI,0);     //enable dma
; Line 1978
	*** 003147	33 c0 			xor	ax,ax
	*** 003149	e6 d0 			out	208	;00d0H, al

;|***     }
;|***   
;|***   if(t1->port_dmar_list[port]==7)
; Line 1981
					$I1980:
	*** 00314b	83 7e fc 07 		cmp	WORD PTR [bp-4],7	;linaddress
	*** 00314f	75 64 			jne	$EX1965
;|***     {
;|***     outp(DMA_COMMAND_HI,4);     //disable dma
; Line 1983
	*** 003151	b8 04 00 		mov	ax,4
	*** 003154	e6 d0 			out	208	;00d0H, al

;|***     outp(DMA_MODE_HI,0x17);     //demand xfr on ch7
; Line 1984
	*** 003156	b8 17 00 		mov	ax,23	;0017H
	*** 003159	e6 d6 			out	214	;00d6H, al

;|***     outp(DMA_CLEAR_FFHI,0);     //reset flip-flop
; Line 1985
	*** 00315b	33 c0 			xor	ax,ax
	*** 00315d	e6 d8 			out	216	;00d8H, al

;|***     outp(DMA_COUNT_CH7,(((FRAME_SIZE+size)/2)-1)&0xff);
; Line 1986
	*** 00315f	b8 ff 00 		mov	ax,255	;00ffH
	*** 003162	e6 ce 			out	206	;00ceH, al

;|***     outp(DMA_COUNT_CH7,(((FRAME_SIZE+size)/2)-1)>>8);
; Line 1987
	*** 003164	b8 01 00 		mov	ax,1
	*** 003167	e6 ce 			out	206	;00ceH, al

;|***     linaddress = (((unsigned long)address & 0xffff0000)>>12) + ((unsigned long)address & 0xffff);
;|***     outp(DMA_PAGE_CH7,(char)(linaddress>>16));
; Line 1989
	*** 003169	8b 4e 0c 		mov	cx,WORD PTR [bp+12]
	*** 00316c	89 5e ec 		mov	WORD PTR [bp-20],bx
	*** 00316f	80 e7 0f 		and	bh,15	;000fH
	*** 003172	03 db 			add	bx,bx
	*** 003174	13 c9 			adc	cx,cx
	*** 003176	13 db 			adc	bx,bx
	*** 003178	13 c9 			adc	cx,cx
	*** 00317a	13 db 			adc	bx,bx
	*** 00317c	13 c9 			adc	cx,cx
	*** 00317e	13 db 			adc	bx,bx
	*** 003180	13 c9 			adc	cx,cx
	*** 003182	13 db 			adc	bx,bx
	*** 003184	87 d9 			xchg	bx,cx
	*** 003186	83 e1 0f 		and	cx,15	;000fH
	*** 003189	03 5e ec 		add	bx,WORD PTR [bp-20]
	*** 00318c	83 d1 00 		adc	cx,0
	*** 00318f	8b c1 			mov	ax,cx
	*** 003191	98 			cbw	
	*** 003192	e6 8a 			out	138	;008aH, al

;|***     linaddress = linaddress>>1; //adjust for 16bit dma
;|***     outp(DMA_CLEAR_FFHI,0);
; Line 1991
	*** 003194	33 c0 			xor	ax,ax
	*** 003196	e6 d8 			out	216	;00d8H, al

;|***     outp(DMA_ADD_CH7,(char)(linaddress&0xff));
; Line 1992
	*** 003198	8b c3 			mov	ax,bx
	*** 00319a	8b d1 			mov	dx,cx
	*** 00319c	d1 ea 			shr	dx,1
	*** 00319e	d1 d8 			rcr	ax,1
	*** 0031a0	8b c8 			mov	cx,ax
	*** 0031a2	98 			cbw	
	*** 0031a3	e6 cc 			out	204	;00ccH, al

;|***     outp(DMA_ADD_CH7,(char)(linaddress>>8));
; Line 1993
	*** 0031a5	8b c1 			mov	ax,cx
	*** 0031a7	8a c4 			mov	al,ah
	*** 0031a9	98 			cbw	
	*** 0031aa	e6 cc 			out	204	;00ccH, al

;|***     outp(DMA_MASK_HI,3);        //enable chan7
; Line 1994
	*** 0031ac	b8 03 00 		mov	ax,3
	*** 0031af	e6 d4 			out	212	;00d4H, al

;|***     outp(DMA_COMMAND_HI,0);     //enable dma
; Line 1995
	*** 0031b1	33 c0 			xor	ax,ax
	*** 0031b3	e6 d0 			out	208	;00d0H, al

;|***     }
;|***   
;|***   //this really isn't necessary except for the DMA bit of XBCH
;|***   //but the transmit count is programmed in setup_dmat()
;|***   //so make sure that setup_dmar() is called before setup_dmat() if an
;|***   //odd size frame is being sent..or you won't get what you expect
;|***   //i = FRAME_SIZE-1;       //transmit XBCH:XBCL +1 bytes so set XBCH:XBCL to framesize-1
;|***   //i = i&0x0fff;
;|***   //i = i|0x8000;
;|***   //outp(XBCL,i&0xff);
;|***   //outp(XBCH,i>>8);    //set for dma mode and FRAME_SIZE bytes per frame
;|***   //!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!
;|***   //SETUPDMAT must be called before the receive section will work, preferably in init!!!
;|***   //!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!
;|***   //this is the only way to set the dma bit of XBCH without knowing the transmitted size
;|***   }
; Line 2011
					$EX1965:
	*** 0031b5	5e 			pop	si
	*** 0031b6	5f 			pop	di
	*** 0031b7	c9 			leave	
	*** 0031b8	ca 0a 00 		ret	10	;0000000aH
	*** 0031bb	90 			nop	

?setupdmar@Cescc@@JECXIPEX@Z	ENDP
	PUBLIC	?getdmarcount@Cescc@@JECII@Z	; Cescc::getdmarcount
?getdmarcount@Cescc@@JECII@Z	PROC FAR	; Cescc::getdmarcount
;|*** 
;|*** 
;|*** 
;|*** 
;|*** 
;|*** unsigned Cescc::getdmarcount(unsigned port)
;|***   {
; Line 2018
	*** 0031bc	c8 02 00 00 		enter	2,0
	*** 0031c0	57 			push	di
	*** 0031c1	56 			push	si
;	port = 10
;	this = 6
;	register cx = size
;	register bx = lo
;	hi = -6
	*** 0031c2	8b 7e 0a 		mov	di,WORD PTR [bp+10]	;port
;|***   unsigned size;
;|***   unsigned lo,hi;
;|***   size = 0;
; Line 2021
	*** 0031c5	33 c9 			xor	cx,cx
;|***   if(t1->port_dmar_list[port]==1)
; Line 2022
	*** 0031c7	8b f7 			mov	si,di
	*** 0031c9	03 f7 			add	si,di
	*** 0031cb	c4 1e 00 00 		les	bx,DWORD PTR ?t1@@3PEVCescc@@E	;t1
	*** 0031cf	83 c3 10 		add	bx,16	;0010H
	*** 0031d2	26 8b 00 		mov	ax,WORD PTR es:[bx][si]
	*** 0031d5	89 46 fe 		mov	WORD PTR [bp-2],ax
	*** 0031d8	48 			dec	ax
	*** 0031d9	75 17 			jne	$I1998
;|***     {
;|***     outp(DMA_CLEAR_FFLO,0);     //clear ctrlr flip flop
; Line 2024
	*** 0031db	33 c0 			xor	ax,ax
	*** 0031dd	e6 0c 			out	12	;000cH, al

;|***     lo = inp(DMA_COUNT_CH1);
; Line 2025
	*** 0031df	e4 03 			in	al,3
	*** 0031e1	8a d8 			mov	bl,al
	*** 0031e3	2a ff 			sub	bh,bh
;|***     hi = inp(DMA_COUNT_CH1);
;|***     size = (hi<<8) + lo;
;|***     size = size +1;
;|***     size = FRAME_SIZE - size;
; Line 2029
	*** 0031e5	b9 ff 03 		mov	cx,1023	;03ffH
	*** 0031e8	e4 03 			in	al,3
	*** 0031ea	8a e0 			mov	ah,al
	*** 0031ec	2a c0 			sub	al,al
	*** 0031ee	2b c8 			sub	cx,ax
	*** 0031f0	2b cb 			sub	cx,bx
;|***     }
;|*** 
;|***   if(t1->port_dmar_list[port]==3)
; Line 2032
					$I1998:
	*** 0031f2	83 7e fe 03 		cmp	WORD PTR [bp-2],3
	*** 0031f6	75 17 			jne	$I1999
;|***     {
;|***     outp(DMA_CLEAR_FFLO,0);
; Line 2034
	*** 0031f8	33 c0 			xor	ax,ax
	*** 0031fa	e6 0c 			out	12	;000cH, al

;|***     lo = inp(DMA_COUNT_CH3);
; Line 2035
	*** 0031fc	e4 07 			in	al,7
	*** 0031fe	8a d8 			mov	bl,al
	*** 003200	2a ff 			sub	bh,bh
;|***     hi = inp(DMA_COUNT_CH3);
;|***     size = (hi<<8) + lo;
;|***     size = size +1;
;|***     size = FRAME_SIZE - size;
; Line 2039
	*** 003202	b9 ff 03 		mov	cx,1023	;03ffH
	*** 003205	e4 07 			in	al,7
	*** 003207	8a e0 			mov	ah,al
	*** 003209	2a c0 			sub	al,al
	*** 00320b	2b c8 			sub	cx,ax
	*** 00320d	2b cb 			sub	cx,bx
;|***     }
;|*** 
;|***   if(t1->port_dmar_list[port]==5)
; Line 2042
					$I1999:
	*** 00320f	83 7e fe 05 		cmp	WORD PTR [bp-2],5
	*** 003213	75 19 			jne	$I2000
;|***     {
;|***     outp(DMA_CLEAR_FFHI,0);     //reset flip-flop
; Line 2044
	*** 003215	33 c0 			xor	ax,ax
	*** 003217	e6 d8 			out	216	;00d8H, al

;|***     lo = inp(DMA_COUNT_CH5);
; Line 2045
	*** 003219	e4 c6 			in	al,198	;00c6H
	*** 00321b	8a d8 			mov	bl,al
	*** 00321d	2a ff 			sub	bh,bh
;|***     hi = inp(DMA_COUNT_CH5);
;|***     size = (hi<<8) + lo;
;|***     size = size +1;
;|***     size = size <<1;
;|***     size = FRAME_SIZE - size;
; Line 2050
	*** 00321f	b9 ff 01 		mov	cx,511	;01ffH
	*** 003222	e4 c6 			in	al,198	;00c6H
	*** 003224	8a e0 			mov	ah,al
	*** 003226	2a c0 			sub	al,al
	*** 003228	2b c8 			sub	cx,ax
	*** 00322a	2b cb 			sub	cx,bx
	*** 00322c	03 c9 			add	cx,cx
;|***     }
;|*** 
;|***   if(t1->port_dmar_list[port]==7)
; Line 2053
					$I2000:
	*** 00322e	83 7e fe 07 		cmp	WORD PTR [bp-2],7
	*** 003232	75 19 			jne	$I2001
;|***     {
;|***     outp(DMA_CLEAR_FFHI,0);     //reset flip-flop
; Line 2055
	*** 003234	33 c0 			xor	ax,ax
	*** 003236	e6 d8 			out	216	;00d8H, al

;|***     lo = inp(DMA_COUNT_CH7);
; Line 2056
	*** 003238	e4 ce 			in	al,206	;00ceH
	*** 00323a	8a d8 			mov	bl,al
	*** 00323c	2a ff 			sub	bh,bh
;|***     hi = inp(DMA_COUNT_CH7);
;|***     size = (hi<<8) + lo;
;|***     size = size +1;
;|***     size = size <<1;
;|***     size = FRAME_SIZE - size;
; Line 2061
	*** 00323e	b9 ff 01 		mov	cx,511	;01ffH
	*** 003241	e4 ce 			in	al,206	;00ceH
	*** 003243	8a e0 			mov	ah,al
	*** 003245	2a c0 			sub	al,al
	*** 003247	2b c8 			sub	cx,ax
	*** 003249	2b cb 			sub	cx,bx
	*** 00324b	03 c9 			add	cx,cx
;|***     }
;|*** 
;|***   return size;
; Line 2064
					$I2001:
	*** 00324d	8b c1 			mov	ax,cx
;|***   }
; Line 2065
	*** 00324f	5e 			pop	si
	*** 003250	5f 			pop	di
	*** 003251	c9 			leave	
	*** 003252	ca 06 00 		ret	6
	*** 003255	90 			nop	

?getdmarcount@Cescc@@JECII@Z	ENDP
	PUBLIC	?set_clock_generator@Cescc@@RECXIKI@Z	; Cescc::set_clock_generator
?set_clock_generator@Cescc@@RECXIKI@Z	PROC FAR	; Cescc::set_clock_generator
;|*** 
;|*** 
;|*** 
;|*** 
;|*** 
;|*** 
;|*** //sets the onboard Cypress ICD2053B Programmable Clock Generator
;|*** //to divide the 18.432 MHz system oscillator to your desired oscillator speed
;|*** //see data sheet at Cypress Web site, and Cypress' BitCalc program.
;|*** void Cescc::set_clock_generator(unsigned port, unsigned long hval,unsigned nmbits)
;|***   {
; Line 2076
	*** 003256	c8 08 00 00 		enter	8,0
	*** 00325a	57 			push	di
	*** 00325b	56 			push	si
;	port = 16
;	hval = 12
;	nmbits = 10
;	this = 6
;	base = -6
;	curval = -4
;	tempval = -4
;	i = -8
	*** 00325c	8e 46 08 		mov	es,WORD PTR [bp+8]
;|***   unsigned base;
;|***   unsigned curval;
;|***   unsigned long tempval;
;|***   unsigned i;
;|*** 
;|***   base = port_list[port];
; Line 2082
	*** 00325f	8b 5e 10 		mov	bx,WORD PTR [bp+16]	;port
	*** 003262	03 db 			add	bx,bx
	*** 003264	03 5e 06 		add	bx,WORD PTR [bp+6]	;this
	*** 003267	33 c0 			xor	ax,ax
	*** 003269	26 8b 17 		mov	dx,WORD PTR es:[bx]
	*** 00326c	8b f2 			mov	si,dx
;|***   curval = 0;
;|***   //curval bit 2 = data bit      (DATA on ICD2053B, parallel port bit2 on ESCC)
;|***   //curval bit 1 = clock toggle  (SCLK on ICD2053B, parallel port bit1 on ESCC)
;|***   outp(base+PVR,curval);   //writing to PVR (0x1c) writes to ESCC universal port (parallel port)
; Line 2086
	*** 00326e	83 c2 1c 		add	dx,28	;001cH
	*** 003271	ee 			out	dx, al

;|*** 
;|***   tempval = STARTWRD;      //0x1e05
; Line 2088
	*** 003272	c7 46 fc 05 1e 		mov	WORD PTR [bp-4],7685	;1e05H	;curval
	*** 003277	89 46 fe 		mov	WORD PTR [bp-2],ax
	*** 00327a	bf 0e 00 		mov	di,14	;000eH
	*** 00327d	89 76 fa 		mov	WORD PTR [bp-6],si	;base
;|***   for(i=0;i<14;i++)        //writes 14 LSBs of STARTWRD into ICD2053 one bit at a time, LSB first
; Line 2089
					$F2011:
;|***     {
;|***     curval = 0;
;|***     curval = (char)(tempval&0x1)<<2;  //select LSB and rotate up to bit2 position (DATA)
;|***     outp(base+PVR,curval);              
; Line 2093
	*** 003280	8a 46 fc 		mov	al,BYTE PTR [bp-4]	;curval
	*** 003283	25 01 00 		and	ax,1
	*** 003286	c1 e0 02 		shl	ax,2
	*** 003289	8d 54 1c 		lea	dx,WORD PTR [si+28]
	*** 00328c	ee 			out	dx, al

;|***     curval = curval |0x02;    //force rising edge on SCLK (bit1 on parallel port)
;|***     outp(base+PVR,curval);    //clock data into ICD 2053
; Line 2095
	*** 00328d	0c 02 			or	al,2
	*** 00328f	ee 			out	dx, al

;|***     curval = curval &0x04;    //force falling edge
;|***     outp(base+PVR,curval);    //set clock low
; Line 2097
	*** 003290	25 04 00 		and	ax,4
	*** 003293	ee 			out	dx, al

;|***     tempval = tempval >> 1;   //get next bit
; Line 2098
	*** 003294	d1 6e fe 		shr	WORD PTR [bp-2],1
	*** 003297	d1 5e fc 		rcr	WORD PTR [bp-4],1	;curval
	*** 00329a	4f 			dec	di
	*** 00329b	75 e3 			jne	$F2011
;|***     }
;|***   
;|***   tempval = hval;
; Line 2101
	*** 00329d	8b 46 0c 		mov	ax,WORD PTR [bp+12]	;hval
	*** 0032a0	8b 56 0e 		mov	dx,WORD PTR [bp+14]
	*** 0032a3	89 46 fc 		mov	WORD PTR [bp-4],ax	;curval
	*** 0032a6	89 56 fe 		mov	WORD PTR [bp-2],dx
;|***   for(i=0;i<nmbits;i++)
; Line 2102
	*** 0032a9	8b 5e 0a 		mov	bx,WORD PTR [bp+10]	;nmbits
	*** 0032ac	0b db 			or	bx,bx
	*** 0032ae	74 22 			je	$FB2017
	*** 0032b0	8b fb 			mov	di,bx
	*** 0032b2	8b 76 fa 		mov	si,WORD PTR [bp-6]	;base
					$F2015:
;|***     {
;|***     curval = 0;
;|***     curval = (char)(tempval&0x1)<<2;  //set bit
;|***     outp(base+PVR,curval);
; Line 2106
	*** 0032b5	8a 46 fc 		mov	al,BYTE PTR [bp-4]	;curval
	*** 0032b8	25 01 00 		and	ax,1
	*** 0032bb	c1 e0 02 		shl	ax,2
	*** 0032be	8d 54 1c 		lea	dx,WORD PTR [si+28]
	*** 0032c1	ee 			out	dx, al

;|***     curval = curval |0x02;    //force rising edge
;|***     outp(base+PVR,curval);    //clock in data
; Line 2108
	*** 0032c2	0c 02 			or	al,2
	*** 0032c4	ee 			out	dx, al

;|***     curval = curval &0x04;    //force falling edge
;|***     outp(base+PVR,curval);    //set clock low
; Line 2110
	*** 0032c5	25 04 00 		and	ax,4
	*** 0032c8	ee 			out	dx, al

;|***     tempval = tempval >> 1;   //get next bit
; Line 2111
	*** 0032c9	d1 6e fe 		shr	WORD PTR [bp-2],1
	*** 0032cc	d1 5e fc 		rcr	WORD PTR [bp-4],1	;curval
	*** 0032cf	4f 			dec	di
	*** 0032d0	75 e3 			jne	$F2015
;|***     }
; Line 2112
					$FB2017:
;|*** 
;|***   tempval = MIDWRD;        //0x1e04
; Line 2114
	*** 0032d2	c7 46 fc 04 1e 		mov	WORD PTR [bp-4],7684	;1e04H	;curval
	*** 0032d7	c7 46 fe 00 00 		mov	WORD PTR [bp-2],0
	*** 0032dc	bf 0e 00 		mov	di,14	;000eH
	*** 0032df	8b 76 fa 		mov	si,WORD PTR [bp-6]	;base
;|***   for(i=0;i<14;i++)
; Line 2115
					$F2019:
;|***     {
;|***     curval = 0;
;|***     curval = (char)(tempval&0x1)<<2;  //set bit
;|***     outp(base+PVR,curval);
; Line 2119
	*** 0032e2	8a 46 fc 		mov	al,BYTE PTR [bp-4]	;curval
	*** 0032e5	25 01 00 		and	ax,1
	*** 0032e8	c1 e0 02 		shl	ax,2
	*** 0032eb	8d 54 1c 		lea	dx,WORD PTR [si+28]
	*** 0032ee	ee 			out	dx, al

;|***     curval = curval |0x02;    //force rising edge
;|***     outp(base+PVR,curval);    //clock in data
; Line 2121
	*** 0032ef	0c 02 			or	al,2
	*** 0032f1	ee 			out	dx, al

;|***     curval = curval &0x04;    //force falling edge
;|***     outp(base+PVR,curval);    //set clock low
; Line 2123
	*** 0032f2	25 04 00 		and	ax,4
	*** 0032f5	ee 			out	dx, al

;|***     tempval = tempval >> 1;   //get next bit
; Line 2124
	*** 0032f6	d1 6e fe 		shr	WORD PTR [bp-2],1
	*** 0032f9	d1 5e fc 		rcr	WORD PTR [bp-4],1	;curval
	*** 0032fc	4f 			dec	di
	*** 0032fd	75 e3 			jne	$F2019
;|***     }
; Line 2125
	*** 0032ff	bb 00 7d 		mov	bx,32000	;7d00H
;|***   
;|***   //pause for >10ms --should be replaced with a regulation pause routine
;|***   for(i=0;i<32000;i++) inp(0x20);
; Line 2128
					$F2023:
	*** 003302	e4 20 			in	al,32	;0020H
	*** 003304	4b 			dec	bx
	*** 003305	75 fb 			jne	$F2023
;|*** 
;|***   tempval = ENDWRD;        //0x1e00
; Line 2130
	*** 003307	c7 46 fc 00 1e 		mov	WORD PTR [bp-4],7680	;1e00H	;curval
	*** 00330c	c7 46 fe 00 00 		mov	WORD PTR [bp-2],0
	*** 003311	bf 0e 00 		mov	di,14	;000eH
;|***   for(i=0;i<14;i++)
; Line 2131
					$F2026:
;|***     {
;|***     curval = 0;
;|***     curval = (char)(tempval&0x1)<<2;  //set bit
;|***     outp(base+PVR,curval);
; Line 2135
	*** 003314	8a 46 fc 		mov	al,BYTE PTR [bp-4]	;curval
	*** 003317	25 01 00 		and	ax,1
	*** 00331a	c1 e0 02 		shl	ax,2
	*** 00331d	8d 54 1c 		lea	dx,WORD PTR [si+28]
	*** 003320	ee 			out	dx, al

;|***     curval = curval |0x02;    //force rising edge
;|***     outp(base+PVR,curval);    //clock in data
; Line 2137
	*** 003321	0c 02 			or	al,2
	*** 003323	ee 			out	dx, al

;|***     curval = curval &0x04;    //force falling edge
;|***     outp(base+PVR,curval);    //set clock low
; Line 2139
	*** 003324	25 04 00 		and	ax,4
	*** 003327	ee 			out	dx, al

;|***     tempval = tempval >> 1;   //get next bit
; Line 2140
	*** 003328	d1 6e fe 		shr	WORD PTR [bp-2],1
	*** 00332b	d1 5e fc 		rcr	WORD PTR [bp-4],1	;curval
	*** 00332e	4f 			dec	di
	*** 00332f	75 e3 			jne	$F2026
;|***     }
;|***   }
; Line 2142
	*** 003331	5e 			pop	si
	*** 003332	5f 			pop	di
	*** 003333	c9 			leave	
	*** 003334	ca 0c 00 		ret	12	;0000000cH
	*** 003337	90 			nop	

?set_clock_generator@Cescc@@RECXIKI@Z	ENDP
	PUBLIC	?wait_for_tx@Cescc@@RECII@Z	; Cescc::wait_for_tx
?wait_for_tx@Cescc@@RECII@Z	PROC FAR	; Cescc::wait_for_tx
;|***   
;|***   
;|***   
;|*** unsigned Cescc::wait_for_tx(unsigned port)
;|***   {
; Line 2147
	*** 003338	55 			push	bp
	*** 003339	8b ec 			mov	bp,sp
	*** 00333b	57 			push	di
	*** 00333c	56 			push	si
;	port = 10
;	this = 6
;	i = -4
	*** 00333d	c5 7e 06 		lds	di,DWORD PTR [bp+6]	;this
	ASSUME DS: NOTHING
	*** 003340	8b 5e 0a 		mov	bx,WORD PTR [bp+10]	;port
;|***   unsigned long i = 0;
;|***   if(port_open_list[port]!=0)
; Line 2149
	*** 003343	8b c3 			mov	ax,bx
	*** 003345	03 c3 			add	ax,bx
	*** 003347	8d 75 04 		lea	si,WORD PTR [di+4]
	*** 00334a	03 f0 			add	si,ax
	*** 00334c	83 3c 00 		cmp	WORD PTR [si],0
	*** 00334f	75 0b 			jne	$L2309
;|***     {
;|***     while(istxing[port]==1)
;|***       {
;|***       // The screen writes inserted here are a desperation move to avoid
;|***       // system crashes.  Perhaps it is a timing issue and the screen
;|***       // writes provide a small delay.  They do reduce the likelihood
;|***       // of system crashes substantially, but not completely.  The
;|***       // problem may also be due to sporadic misbehavior by the Tech 80
;|***       // motion controllers.  It was noted during development that
;|***       // occasional screen writes eliminated the Tech 80 anomalies.
;|***       // Go figure.  Let me know if you ever solve this problem.  JTM.
;|***       /*if(i++ > 10000000)  // jtm remove for autonomous
;|***         {
;|***         cout << "\t\t\t\t\t\t\t\t\tX\r" << flush;
;|***         return TRUE;
;|***         }
;|***       */  
;|***       }
;|***     return TRUE;
;|***     }
;|***   else 
;|***     {
;|***     //printf("L\r");
;|***     return FALSE;
; Line 2173
	*** 003351	b8 01 00 		mov	ax,1
	*** 003354	16 			push	ss
	*** 003355	1f 			pop	ds
	ASSUME DS: DGROUP
	*** 003356	5e 			pop	si
	*** 003357	5f 			pop	di
	*** 003358	c9 			leave	
	*** 003359	ca 06 00 		ret	6
					$L2309:
;|***     while(istxing[port]==1)
; Line 2151
	*** 00335c	8b c3 			mov	ax,bx
	*** 00335e	03 c3 			add	ax,bx
	*** 003360	8d b5 92 01 		lea	si,WORD PTR [di+402]
	*** 003364	03 f0 			add	si,ax
	*** 003366	83 3c 01 		cmp	WORD PTR [si],1
	*** 003369	74 f1 			je	$L2309
	*** 00336b	16 			push	ss
	*** 00336c	1f 			pop	ds
	ASSUME DS: DGROUP
;|***       {
;|***       // The screen writes inserted here are a desperation move to avoid
;|***       // system crashes.  Perhaps it is a timing issue and the screen
;|***       // writes provide a small delay.  They do reduce the likelihood
;|***       // of system crashes substantially, but not completely.  The
;|***       // problem may also be due to sporadic misbehavior by the Tech 80
;|***       // motion controllers.  It was noted during development that
;|***       // occasional screen writes eliminated the Tech 80 anomalies.
;|***       // Go figure.  Let me know if you ever solve this problem.  JTM.
;|***       /*if(i++ > 10000000)  // jtm remove for autonomous
;|***         {
;|***         cout << "\t\t\t\t\t\t\t\t\tX\r" << flush;
;|***         return TRUE;
;|***         }
;|***       */  
;|***       }
;|***     return TRUE;
; Line 2168
	*** 00336d	33 c0 			xor	ax,ax
;|***     }
;|***   else 
;|***     {
;|***     //printf("L\r");
;|***     return FALSE;
;|***     }
;|***   }
; Line 2175
	*** 00336f	5e 			pop	si
	*** 003370	5f 			pop	di
	*** 003371	c9 			leave	
	*** 003372	ca 06 00 		ret	6
	*** 003375	90 			nop	

?wait_for_tx@Cescc@@RECII@Z	ENDP
ESCCAUTO_TEXT	ENDS
END
