;	Static Name Aliases
;
	TITLE   c:\dmmtest\rs232.cpp
	.286p
INCLUDELIB      LLIBCE
INCLUDELIB	OLDNAMES.LIB
RS232_TEXT	SEGMENT  WORD PUBLIC 'CODE'
RS232_TEXT	ENDS
_DATA	SEGMENT  WORD PUBLIC 'DATA'
_DATA	ENDS
CONST	SEGMENT  WORD PUBLIC 'CONST'
CONST	ENDS
_BSS	SEGMENT  WORD PUBLIC 'BSS'
_BSS	ENDS
DGROUP	GROUP	CONST, _BSS, _DATA
	ASSUME DS: DGROUP, SS: DGROUP
PUBLIC  ?tx4_index@@3IE
PUBLIC  ?tx4_counter@@3IE
PUBLIC  ?tx4_len@@3IE
PUBLIC  ?rx4_index@@3IE
PUBLIC  ?tx1_index@@3IE
PUBLIC  ?tx1_counter@@3IE
PUBLIC  ?tx1_len@@3IE
PUBLIC  ?rx1_index@@3IE
PUBLIC  ?tx2_index@@3IE
PUBLIC  ?tx2_counter@@3IE
PUBLIC  ?tx2_len@@3IE
PUBLIC  ?rx2_index@@3IE
EXTRN	??6ostream@@RECAEV0@PFD@Z:FAR
EXTRN	__disable:FAR
EXTRN	??6ostream@@RECAEV0@E@Z:FAR
EXTRN	__fmemcpy:FAR
EXTRN	__dos_setvect:FAR
EXTRN	__fmemset:FAR
EXTRN	_memcpy:FAR
EXTRN	__inp:FAR
EXTRN	__enable:FAR
EXTRN	?time_stamp@@ZAXPEUTIMER@@@Z:FAR
EXTRN	__outp:FAR
EXTRN	__dos_getvect:FAR
EXTRN	?flush@ostream@@RECAEV1@XZ:FAR
EXTRN	?adcp_buffer@@3QEEE:BYTE
EXTRN	?adcp_new_data@@3IE:WORD
EXTRN	?adcp_data_frame@@3KE:DWORD
EXTRN	?ds_buffer@@3QEEE:BYTE
EXTRN	?ds_new_data@@3IE:WORD
EXTRN	?ds_data_frame@@3KE:DWORD
EXTRN	?gps_buffer@@3QEEE:BYTE
EXTRN	?gps_new_data@@3IE:WORD
EXTRN	?gps_data_frame@@3KE:DWORD
EXTRN	?com1_tx@@3IE:WORD
EXTRN	?com2_tx@@3IE:WORD
EXTRN	?com4_tx@@3IE:WORD
EXTRN	?basefield@ios@@2JF:DWORD
EXTRN	?frame@@3KE:DWORD
EXTRN	?adcp_time@@3UTIMER@@E:FWORD
EXTRN	?ds_time@@3UTIMER@@E:FWORD
EXTRN	?x_statebuf@ios@@0PEJE:DWORD
EXTRN	?gps_time@@3UTIMER@@E:FWORD
EXTRN	?cout@@3Vostream_withassign@@E:BYTE
_DATA      SEGMENT
?tx1_index@@3IE	DW	00H
?tx1_counter@@3IE	DW	00H
?tx1_len@@3IE	DW	00H
?rx1_index@@3IE	DW	00H
?tx2_index@@3IE	DW	00H
?tx2_counter@@3IE	DW	00H
?tx2_len@@3IE	DW	00H
?rx2_index@@3IE	DW	00H
?tx4_index@@3IE	DW	00H
?tx4_counter@@3IE	DW	00H
?tx4_len@@3IE	DW	00H
?rx4_index@@3IE	DW	00H
$SG2987	DB	'Begin Com1 initialization.   ',  00H
$SG2991	DB	'Com1 initialized.',  00H
$SG2994	DB	'Begin Com2 initialization.   ',  00H
$SG2998	DB	'Com2 initialized.',  00H
$SG3001	DB	'Begin Com4 initialization.   ',  00H
$SG3005	DB	'Com4 initialized.',  00H
_DATA      ENDS
_BSS      SEGMENT
	ORG	$+2208
PUBLIC  ?tx4_message@@3QEEE
?tx4_message@@3QEEE	DW 028H DUP (?)
PUBLIC  ?rx4_message@@3QEEE
?rx4_message@@3QEEE	DW 028H DUP (?)
PUBLIC  ?com1_old_vector@@3P7AXXZE
?com1_old_vector@@3P7AXXZE	DW 02H DUP (?)
PUBLIC  ?com2_old_vector@@3P7AXXZE
?com2_old_vector@@3P7AXXZE	DW 02H DUP (?)
PUBLIC  ?com4_old_vector@@3P7AXXZE
?com4_old_vector@@3P7AXXZE	DW 02H DUP (?)
	ORG	$-2380
PUBLIC  ?tx1_message@@3QEEE
?tx1_message@@3QEEE	DW 028H DUP (?)
PUBLIC  ?rx1_message@@3QEEE
?rx1_message@@3QEEE	DW 0200H DUP (?)
PUBLIC  ?tx2_message@@3QEEE
?tx2_message@@3QEEE	DW 028H DUP (?)
PUBLIC  ?rx2_message@@3QEEE
?rx2_message@@3QEEE	DW 0200H DUP (?)
_BSS      ENDS
RS232_TEXT      SEGMENT
	ASSUME	CS: RS232_TEXT
	PUBLIC	?init_com1@@ZAXXZ	; init_com1
?init_com1@@ZAXXZ	PROC FAR	; init_com1
;|*** /* rs323.cpp
;|***    serial port routines for the autonomous obc
;|***    modified 11/16/2007 for PD0 ADCP messages
;|*** */   
;|***    
;|*** #include <stdlib.h>
;|*** #include <stdio.h>
;|*** #include <dos.h>
;|*** #include <conio.h>
;|*** #include <string.h>
;|*** #include <graph.h>
;|*** #include <iostream.h>
;|*** #include "pc.h"
;|*** #include "rs232.h"
;|*** #include "dmmtest.h"
;|*** #include "dmm32.h"                                                  
;|*** 
;|*** // adcp variables
;|*** unsigned char tx1_message[80];
;|*** unsigned tx1_index = 0;
;|*** unsigned tx1_counter = 0;
;|*** unsigned tx1_len = 0;
;|*** unsigned rx1_index = 0;
;|*** unsigned char rx1_message[1024];
;|*** //unsigned char adcp_test[88];
;|*** 
;|*** // desert star variables
;|*** unsigned char tx2_message[80];
;|*** unsigned tx2_index = 0;
;|*** unsigned tx2_counter = 0;
;|*** unsigned tx2_len = 0;
;|*** unsigned rx2_index = 0;
;|*** unsigned char rx2_message[1024];
;|*** 
;|*** // gps variables
;|*** unsigned char tx4_message[80];
;|*** unsigned tx4_index = 0;
;|*** unsigned tx4_counter = 0;
;|*** unsigned tx4_len = 0;
;|*** unsigned rx4_index = 0;
;|*** unsigned char rx4_message[80];
;|*** 
;|*** // global variables
;|*** void (interrupt far * com1_old_vector)();
;|*** void (interrupt far * com2_old_vector)();
;|*** void (interrupt far * com4_old_vector)();
;|*** 
;|*** // global flags
;|*** 
;|*** 
;|*** // external variables
;|*** //extern unsigned char adcp_buffer[88];
;|*** extern unsigned char adcp_buffer[213];  // for PD0 file format db & jtm 11/16/2007
;|*** extern unsigned      adcp_new_data;
;|*** extern unsigned long adcp_data_frame;
;|*** extern unsigned char ds_buffer[80];
;|*** extern unsigned      ds_new_data;
;|*** extern unsigned long ds_data_frame;
;|*** extern unsigned char gps_buffer[80];
;|*** extern unsigned      gps_new_data;
;|*** extern unsigned long gps_data_frame;
;|*** extern unsigned      com1_tx;
;|*** extern unsigned      com2_tx;
;|*** extern unsigned      com4_tx;
;|*** extern unsigned long frame;
;|*** 
;|*** struct TIMER
;|***   {
;|***   unsigned long high;
;|***   unsigned      low;
;|***   };
;|*** 
;|*** extern TIMER sys_timer;
;|*** extern TIMER adcp_time;
;|*** extern TIMER ds_time;
;|*** extern TIMER gps_time;
;|*** 
;|*** 
;|*** void init_com1(void)
;|***   {
; Line 80
	*** 000000	c8 00 00 00 		enter	0,0
	*** 000004	57 			push	di
	*** 000005	56 			push	si
;|***   cout << "Begin Com1 initialization.   ";
; Line 81
	*** 000006	1e 			push	ds
	*** 000007	68 00 00 		push	OFFSET DGROUP:$SG2987
	*** 00000a	68 00 00 		push	SEG ?cout@@3Vostream_withassign@@E	;cout
	*** 00000d	68 00 00 		push	OFFSET ?cout@@3Vostream_withassign@@E	;cout
	*** 000010	9a 00 00 00 00 		call	FAR PTR ??6ostream@@RECAEV0@PFD@Z	; ostream::operator<<
;|***   // disable cpu interrupts
;|***   _disable();
; Line 83
	*** 000015	9a 00 00 00 00 		call	FAR PTR __disable
;|***   
;|***   // set vector for COM1, irq4
;|***   com1_old_vector = _dos_getvect(4+8); // irq4
; Line 86
	*** 00001a	6a 0c 			push	12	;000cH
	*** 00001c	9a 00 00 00 00 		call	FAR PTR __dos_getvect
	*** 000021	83 c4 02 		add	sp,2
	*** 000024	a3 00 00 		mov	WORD PTR ?com1_old_vector@@3P7AXXZE,ax	;com1_old_vector
	*** 000027	89 16 02 00 		mov	WORD PTR ?com1_old_vector@@3P7AXXZE+2,dx	;com1_old_vector
;|***   _dos_setvect(4+8, com1_isr);
; Line 87
	*** 00002b	68 00 00 		push	SEG ?com1_isr@@ZAXXZ	;com1_isr
	*** 00002e	68 00 00 		push	OFFSET ?com1_isr@@ZAXXZ	;com1_isr
	*** 000031	6a 0c 			push	12	;000cH
	*** 000033	9a 00 00 00 00 		call	FAR PTR __dos_setvect
	*** 000038	83 c4 06 		add	sp,6
;|***      
;|***   // initialize COM1 16550
;|***   _outp( COM1_LCR, (DLAB1 | NO | STOP1 | EIGHT));
; Line 90
	*** 00003b	68 83 00 		push	131	;0083H
	*** 00003e	68 fb 03 		push	1019	;03fbH
	*** 000041	9a 00 00 00 00 		call	FAR PTR __outp
	*** 000046	83 c4 04 		add	sp,4
;|***   _outp( COM1_DLL, BR_9600);
; Line 91
	*** 000049	6a 0c 			push	12	;000cH
	*** 00004b	68 f8 03 		push	1016	;03f8H
	*** 00004e	9a 00 00 00 00 		call	FAR PTR __outp
	*** 000053	83 c4 04 		add	sp,4
;|***   //_outp( COM1_DLL, BR_115200);
;|***   //_outp( COM1_DLL, BR_57600);
;|***   //_outp( COM1_DLL, BR_19200);
;|***   _outp( COM1_DLM, 0);
; Line 95
	*** 000056	6a 00 			push	0
	*** 000058	68 f9 03 		push	1017	;03f9H
	*** 00005b	9a 00 00 00 00 		call	FAR PTR __outp
	*** 000060	83 c4 04 		add	sp,4
;|***   _outp( COM1_LCR, (DLAB0 | NO | STOP1 | EIGHT));
; Line 96
	*** 000063	6a 03 			push	3
	*** 000065	68 fb 03 		push	1019	;03fbH
	*** 000068	9a 00 00 00 00 		call	FAR PTR __outp
	*** 00006d	83 c4 04 		add	sp,4
;|***   //_outp( COM1_FCR, 0xc1); // enable FIFOs to 14, reset FIFOs
;|***   _outp( COM1_FCR, 0xc7); // enable FIFOs to 14, reset FIFOs
; Line 98
	*** 000070	68 c7 00 		push	199	;00c7H
	*** 000073	68 fa 03 		push	1018	;03faH
	*** 000076	9a 00 00 00 00 		call	FAR PTR __outp
	*** 00007b	83 c4 04 		add	sp,4
;|***     
;|***   // unmask all com1 uart interrupts
;|***   //_outp( COM1_IER, 0x0f);  //jtm
;|***   _outp( COM1_IER, 0x07);
; Line 102
	*** 00007e	6a 07 			push	7
	*** 000080	68 f9 03 		push	1017	;03f9H
	*** 000083	9a 00 00 00 00 		call	FAR PTR __outp
	*** 000088	83 c4 04 		add	sp,4
;|***   
;|***   // clear garbage from the com1 iir
;|***   while((_inp(COM1_IIR) & 0x01) != 1)
; Line 105
					$FC2989:
	*** 00008b	68 fa 03 		push	1018	;03faH
	*** 00008e	9a 00 00 00 00 		call	FAR PTR __inp
	*** 000093	83 c4 02 		add	sp,2
	*** 000096	24 01 			and	al,1
	*** 000098	3c 01 			cmp	al,1
	*** 00009a	75 03 			jne	$JCC154
	*** 00009c	e9 24 00 		jmp	$FB2990
					$JCC154:
;|***     {
; Line 106
;|***     _inp(COM1_RX);
; Line 107
	*** 00009f	68 f8 03 		push	1016	;03f8H
	*** 0000a2	9a 00 00 00 00 		call	FAR PTR __inp
	*** 0000a7	83 c4 02 		add	sp,2
;|***     _inp(COM1_LSR);
; Line 108
	*** 0000aa	68 fd 03 		push	1021	;03fdH
	*** 0000ad	9a 00 00 00 00 		call	FAR PTR __inp
	*** 0000b2	83 c4 02 		add	sp,2
;|***     _inp(COM1_MSR);
; Line 109
	*** 0000b5	68 fe 03 		push	1022	;03feH
	*** 0000b8	9a 00 00 00 00 		call	FAR PTR __inp
	*** 0000bd	83 c4 02 		add	sp,2
;|***     }
; Line 110
	*** 0000c0	e9 c8 ff 		jmp	$FC2989
					$FB2990:
;|***   
;|***   // enable com1 irq4 interrupts at the pic
;|***   _outp(0x21, _inp(0x21) & 0xef);
; Line 113
	*** 0000c3	6a 21 			push	33	;0021H
	*** 0000c5	9a 00 00 00 00 		call	FAR PTR __inp
	*** 0000ca	83 c4 02 		add	sp,2
	*** 0000cd	25 ef 00 		and	ax,239	;00efH
	*** 0000d0	50 			push	ax
	*** 0000d1	6a 21 			push	33	;0021H
	*** 0000d3	9a 00 00 00 00 		call	FAR PTR __outp
	*** 0000d8	83 c4 04 		add	sp,4
;|*** 
;|***   // turn on the com1 mcr gate (out2)
;|***   _outp( COM1_MCR, _inp(COM1_MCR) | 0x08); 
; Line 116
	*** 0000db	68 fc 03 		push	1020	;03fcH
	*** 0000de	9a 00 00 00 00 		call	FAR PTR __inp
	*** 0000e3	83 c4 02 		add	sp,2
	*** 0000e6	0d 08 00 		or	ax,8
	*** 0000e9	50 			push	ax
	*** 0000ea	68 fc 03 		push	1020	;03fcH
	*** 0000ed	9a 00 00 00 00 		call	FAR PTR __outp
	*** 0000f2	83 c4 04 		add	sp,4
;|***   
;|***   // enable cpu interrupts          
;|***   _enable();
; Line 119
	*** 0000f5	9a 00 00 00 00 		call	FAR PTR __enable
;|***   cout << "Com1 initialized." << endl;
; Line 120
	*** 0000fa	68 00 00 		push	SEG ?endl@@ZAAEVostream@@AEV1@@Z	;endl
	*** 0000fd	68 00 00 		push	OFFSET ?endl@@ZAAEVostream@@AEV1@@Z	;endl
	*** 000100	1e 			push	ds
	*** 000101	68 00 00 		push	OFFSET DGROUP:$SG2991
	*** 000104	68 00 00 		push	SEG ?cout@@3Vostream_withassign@@E	;cout
	*** 000107	68 00 00 		push	OFFSET ?cout@@3Vostream_withassign@@E	;cout
	*** 00010a	9a 00 00 00 00 		call	FAR PTR ??6ostream@@RECAEV0@PFD@Z	; ostream::operator<<
	*** 00010f	52 			push	dx
	*** 000110	50 			push	ax
	*** 000111	9a 00 00 00 00 		call	FAR PTR ??6ostream@@RECAEV0@P7AAEV0@AEV0@@Z@Z	; ostream::operator<<
;|***   // done 
;|***   } // end init_com1()
; Line 122
	*** 000116	e9 00 00 		jmp	$EX2986
					$EX2986:
	*** 000119	5e 			pop	si
	*** 00011a	5f 			pop	di
	*** 00011b	c9 			leave	
	*** 00011c	cb 			ret	

?init_com1@@ZAXXZ	ENDP
	PUBLIC	?init_com2@@ZAXXZ	; init_com2
?init_com2@@ZAXXZ	PROC FAR	; init_com2
;|*** 
;|*** 
;|*** 
;|*** void init_com2(void)
;|***   {
; Line 127
	*** 00011d	c8 00 00 00 		enter	0,0
	*** 000121	57 			push	di
	*** 000122	56 			push	si
;|***   cout << "Begin Com2 initialization.   ";
; Line 128
	*** 000123	1e 			push	ds
	*** 000124	68 00 00 		push	OFFSET DGROUP:$SG2994
	*** 000127	68 00 00 		push	SEG ?cout@@3Vostream_withassign@@E	;cout
	*** 00012a	68 00 00 		push	OFFSET ?cout@@3Vostream_withassign@@E	;cout
	*** 00012d	9a 00 00 00 00 		call	FAR PTR ??6ostream@@RECAEV0@PFD@Z	; ostream::operator<<
;|***   // disable cpu interrupts
;|***   _disable();
; Line 130
	*** 000132	9a 00 00 00 00 		call	FAR PTR __disable
;|***   
;|***   // set vector for COM2, irq3
;|***   com2_old_vector = _dos_getvect(3+8);
; Line 133
	*** 000137	6a 0b 			push	11	;000bH
	*** 000139	9a 00 00 00 00 		call	FAR PTR __dos_getvect
	*** 00013e	83 c4 02 		add	sp,2
	*** 000141	a3 00 00 		mov	WORD PTR ?com2_old_vector@@3P7AXXZE,ax	;com2_old_vector
	*** 000144	89 16 02 00 		mov	WORD PTR ?com2_old_vector@@3P7AXXZE+2,dx	;com2_old_vector
;|***   _dos_setvect(3+8, com2_isr);
; Line 134
	*** 000148	68 00 00 		push	SEG ?com2_isr@@ZAXXZ	;com2_isr
	*** 00014b	68 00 00 		push	OFFSET ?com2_isr@@ZAXXZ	;com2_isr
	*** 00014e	6a 0b 			push	11	;000bH
	*** 000150	9a 00 00 00 00 		call	FAR PTR __dos_setvect
	*** 000155	83 c4 06 		add	sp,6
;|***      
;|***   // initialize COM2 16550
;|***   _outp( COM2_LCR, (DLAB1 | NO | STOP1 | EIGHT));
; Line 137
	*** 000158	68 83 00 		push	131	;0083H
	*** 00015b	68 fb 02 		push	763	;02fbH
	*** 00015e	9a 00 00 00 00 		call	FAR PTR __outp
	*** 000163	83 c4 04 		add	sp,4
;|***   _outp( COM2_DLL, BR_19200);  // for acoustic modem
; Line 138
	*** 000166	6a 06 			push	6
	*** 000168	68 f8 02 		push	760	;02f8H
	*** 00016b	9a 00 00 00 00 		call	FAR PTR __outp
	*** 000170	83 c4 04 		add	sp,4
;|***   //_outp( COM2_DLL, BR_9600);  // for acoustic modem
;|***   //_outp( COM2_DLL, BR_4800);  // for desert star
;|***   //_outp( COM2_DLL, BR_57600);  // for crossbow
;|***   _outp( COM2_DLM, 0);
; Line 142
	*** 000173	6a 00 			push	0
	*** 000175	68 f9 02 		push	761	;02f9H
	*** 000178	9a 00 00 00 00 		call	FAR PTR __outp
	*** 00017d	83 c4 04 		add	sp,4
;|***   _outp( COM2_LCR, (DLAB0 | NO | STOP1 | EIGHT));
; Line 143
	*** 000180	6a 03 			push	3
	*** 000182	68 fb 02 		push	763	;02fbH
	*** 000185	9a 00 00 00 00 		call	FAR PTR __outp
	*** 00018a	83 c4 04 		add	sp,4
;|*** //sjc  _outp( COM2_FCR, 0xc1); // enable FIFOs to 14, reset FIFOs
;|***   _outp( COM2_FCR, 0xc7); // enable FIFOs to 14, reset FIFOs
; Line 145
	*** 00018d	68 c7 00 		push	199	;00c7H
	*** 000190	68 fa 02 		push	762	;02faH
	*** 000193	9a 00 00 00 00 		call	FAR PTR __outp
	*** 000198	83 c4 04 		add	sp,4
;|***     
;|***   // unmask all com1 uart interrupts
;|*** //sjc  _outp( COM2_IER, 0x0f);
;|***   _outp( COM2_IER, 0x07);
; Line 149
	*** 00019b	6a 07 			push	7
	*** 00019d	68 f9 02 		push	761	;02f9H
	*** 0001a0	9a 00 00 00 00 		call	FAR PTR __outp
	*** 0001a5	83 c4 04 		add	sp,4
;|***   
;|***   // clear garbage from the com1 iir
;|***   while((_inp(COM2_IIR) & 0x01) != 1)
; Line 152
					$FC2996:
	*** 0001a8	68 fa 02 		push	762	;02faH
	*** 0001ab	9a 00 00 00 00 		call	FAR PTR __inp
	*** 0001b0	83 c4 02 		add	sp,2
	*** 0001b3	24 01 			and	al,1
	*** 0001b5	3c 01 			cmp	al,1
	*** 0001b7	75 03 			jne	$JCC439
	*** 0001b9	e9 24 00 		jmp	$FB2997
					$JCC439:
;|***     {
; Line 153
;|***     _inp(COM2_RX);
; Line 154
	*** 0001bc	68 f8 02 		push	760	;02f8H
	*** 0001bf	9a 00 00 00 00 		call	FAR PTR __inp
	*** 0001c4	83 c4 02 		add	sp,2
;|***     _inp(COM2_LSR);
; Line 155
	*** 0001c7	68 fd 02 		push	765	;02fdH
	*** 0001ca	9a 00 00 00 00 		call	FAR PTR __inp
	*** 0001cf	83 c4 02 		add	sp,2
;|***     _inp(COM2_MSR);
; Line 156
	*** 0001d2	68 fe 02 		push	766	;02feH
	*** 0001d5	9a 00 00 00 00 		call	FAR PTR __inp
	*** 0001da	83 c4 02 		add	sp,2
;|***     }
; Line 157
	*** 0001dd	e9 c8 ff 		jmp	$FC2996
					$FB2997:
;|***   
;|***   // enable com2 irq3 interrupts at the pic
;|***   _outp(0x21, _inp(0x21) & 0xf7);
; Line 160
	*** 0001e0	6a 21 			push	33	;0021H
	*** 0001e2	9a 00 00 00 00 		call	FAR PTR __inp
	*** 0001e7	83 c4 02 		add	sp,2
	*** 0001ea	25 f7 00 		and	ax,247	;00f7H
	*** 0001ed	50 			push	ax
	*** 0001ee	6a 21 			push	33	;0021H
	*** 0001f0	9a 00 00 00 00 		call	FAR PTR __outp
	*** 0001f5	83 c4 04 		add	sp,4
;|*** 
;|***   // turn on the com2 mcr gate (out2)
;|***   _outp( COM2_MCR, _inp(COM2_MCR) | 0x08); 
; Line 163
	*** 0001f8	68 fc 02 		push	764	;02fcH
	*** 0001fb	9a 00 00 00 00 		call	FAR PTR __inp
	*** 000200	83 c4 02 		add	sp,2
	*** 000203	0d 08 00 		or	ax,8
	*** 000206	50 			push	ax
	*** 000207	68 fc 02 		push	764	;02fcH
	*** 00020a	9a 00 00 00 00 		call	FAR PTR __outp
	*** 00020f	83 c4 04 		add	sp,4
;|***   
;|***   // enable cpu interrupts          
;|***   _enable();
; Line 166
	*** 000212	9a 00 00 00 00 		call	FAR PTR __enable
;|***   cout << "Com2 initialized." << endl;
; Line 167
	*** 000217	68 00 00 		push	SEG ?endl@@ZAAEVostream@@AEV1@@Z	;endl
	*** 00021a	68 00 00 		push	OFFSET ?endl@@ZAAEVostream@@AEV1@@Z	;endl
	*** 00021d	1e 			push	ds
	*** 00021e	68 00 00 		push	OFFSET DGROUP:$SG2998
	*** 000221	68 00 00 		push	SEG ?cout@@3Vostream_withassign@@E	;cout
	*** 000224	68 00 00 		push	OFFSET ?cout@@3Vostream_withassign@@E	;cout
	*** 000227	9a 00 00 00 00 		call	FAR PTR ??6ostream@@RECAEV0@PFD@Z	; ostream::operator<<
	*** 00022c	52 			push	dx
	*** 00022d	50 			push	ax
	*** 00022e	9a 00 00 00 00 		call	FAR PTR ??6ostream@@RECAEV0@P7AAEV0@AEV0@@Z@Z	; ostream::operator<<
;|***   // done 
;|***   } // end init_com2()
; Line 169
	*** 000233	e9 00 00 		jmp	$EX2993
					$EX2993:
	*** 000236	5e 			pop	si
	*** 000237	5f 			pop	di
	*** 000238	c9 			leave	
	*** 000239	cb 			ret	

?init_com2@@ZAXXZ	ENDP
	PUBLIC	?init_com4@@ZAXXZ	; init_com4
?init_com4@@ZAXXZ	PROC FAR	; init_com4
;|*** 
;|*** void init_com4(void)
;|***   {
; Line 172
	*** 00023a	c8 00 00 00 		enter	0,0
	*** 00023e	57 			push	di
	*** 00023f	56 			push	si
;|***   cout << "Begin Com4 initialization.   ";
; Line 173
	*** 000240	1e 			push	ds
	*** 000241	68 00 00 		push	OFFSET DGROUP:$SG3001
	*** 000244	68 00 00 		push	SEG ?cout@@3Vostream_withassign@@E	;cout
	*** 000247	68 00 00 		push	OFFSET ?cout@@3Vostream_withassign@@E	;cout
	*** 00024a	9a 00 00 00 00 		call	FAR PTR ??6ostream@@RECAEV0@PFD@Z	; ostream::operator<<
;|***   // disable cpu interrupts
;|***   _disable();
; Line 175
	*** 00024f	9a 00 00 00 00 		call	FAR PTR __disable
;|***   
;|***   // set vector for COM4, irq9
;|***   com4_old_vector = _dos_getvect(9+0x70-8);
; Line 178
	*** 000254	6a 71 			push	113	;0071H
	*** 000256	9a 00 00 00 00 		call	FAR PTR __dos_getvect
	*** 00025b	83 c4 02 		add	sp,2
	*** 00025e	a3 00 00 		mov	WORD PTR ?com4_old_vector@@3P7AXXZE,ax	;com4_old_vector
	*** 000261	89 16 02 00 		mov	WORD PTR ?com4_old_vector@@3P7AXXZE+2,dx	;com4_old_vector
;|***   _dos_setvect(9+0x70-8, com4_isr);
; Line 179
	*** 000265	68 00 00 		push	SEG ?com4_isr@@ZAXXZ	;com4_isr
	*** 000268	68 00 00 		push	OFFSET ?com4_isr@@ZAXXZ	;com4_isr
	*** 00026b	6a 71 			push	113	;0071H
	*** 00026d	9a 00 00 00 00 		call	FAR PTR __dos_setvect
	*** 000272	83 c4 06 		add	sp,6
;|***      
;|***   // initialize COM4 16550
;|***   _outp( COM4_LCR, (DLAB1 | NO | STOP1 | EIGHT));
; Line 182
	*** 000275	68 83 00 		push	131	;0083H
	*** 000278	68 eb 02 		push	747	;02ebH
	*** 00027b	9a 00 00 00 00 		call	FAR PTR __outp
	*** 000280	83 c4 04 		add	sp,4
;|***   _outp( COM4_DLL, BR_9600);  // for gps
; Line 183
	*** 000283	6a 0c 			push	12	;000cH
	*** 000285	68 e8 02 		push	744	;02e8H
	*** 000288	9a 00 00 00 00 		call	FAR PTR __outp
	*** 00028d	83 c4 04 		add	sp,4
;|***   //_outp( COM4_DLL, BR_4800);  //
;|***   //_outp( COM4_DLL, BR_57600);
;|***   _outp( COM4_DLM, 0);
; Line 186
	*** 000290	6a 00 			push	0
	*** 000292	68 e9 02 		push	745	;02e9H
	*** 000295	9a 00 00 00 00 		call	FAR PTR __outp
	*** 00029a	83 c4 04 		add	sp,4
;|***   _outp( COM4_LCR, (DLAB0 | NO | STOP1 | EIGHT));
; Line 187
	*** 00029d	6a 03 			push	3
	*** 00029f	68 eb 02 		push	747	;02ebH
	*** 0002a2	9a 00 00 00 00 		call	FAR PTR __outp
	*** 0002a7	83 c4 04 		add	sp,4
;|***   _outp( COM4_FCR, 0xc1); // enable FIFOs to 14, reset FIFOs
; Line 188
	*** 0002aa	68 c1 00 		push	193	;00c1H
	*** 0002ad	68 ea 02 		push	746	;02eaH
	*** 0002b0	9a 00 00 00 00 		call	FAR PTR __outp
	*** 0002b5	83 c4 04 		add	sp,4
;|***     
;|***   // unmask all com4 uart interrupts
;|***   _outp( COM4_IER, 0x0f);
; Line 191
	*** 0002b8	6a 0f 			push	15	;000fH
	*** 0002ba	68 e9 02 		push	745	;02e9H
	*** 0002bd	9a 00 00 00 00 		call	FAR PTR __outp
	*** 0002c2	83 c4 04 		add	sp,4
;|***   
;|***   // clear garbage from the com4 iir
;|***   while((_inp(COM4_IIR) & 0x01) != 1)
; Line 194
					$FC3003:
	*** 0002c5	68 ea 02 		push	746	;02eaH
	*** 0002c8	9a 00 00 00 00 		call	FAR PTR __inp
	*** 0002cd	83 c4 02 		add	sp,2
	*** 0002d0	24 01 			and	al,1
	*** 0002d2	3c 01 			cmp	al,1
	*** 0002d4	75 03 			jne	$JCC724
	*** 0002d6	e9 24 00 		jmp	$FB3004
					$JCC724:
;|***     {
; Line 195
;|***     _inp(COM4_RX);
; Line 196
	*** 0002d9	68 e8 02 		push	744	;02e8H
	*** 0002dc	9a 00 00 00 00 		call	FAR PTR __inp
	*** 0002e1	83 c4 02 		add	sp,2
;|***     _inp(COM4_LSR);
; Line 197
	*** 0002e4	68 ed 02 		push	749	;02edH
	*** 0002e7	9a 00 00 00 00 		call	FAR PTR __inp
	*** 0002ec	83 c4 02 		add	sp,2
;|***     _inp(COM4_MSR);
; Line 198
	*** 0002ef	68 ee 02 		push	750	;02eeH
	*** 0002f2	9a 00 00 00 00 		call	FAR PTR __inp
	*** 0002f7	83 c4 02 		add	sp,2
;|***     }
; Line 199
	*** 0002fa	e9 c8 ff 		jmp	$FC3003
					$FB3004:
;|***   
;|***   // enable com4 irq9 interrupts at the pic
;|***   _outp(0xa1, _inp(0xa1) & 0xfd);
; Line 202
	*** 0002fd	68 a1 00 		push	161	;00a1H
	*** 000300	9a 00 00 00 00 		call	FAR PTR __inp
	*** 000305	83 c4 02 		add	sp,2
	*** 000308	25 fd 00 		and	ax,253	;00fdH
	*** 00030b	50 			push	ax
	*** 00030c	68 a1 00 		push	161	;00a1H
	*** 00030f	9a 00 00 00 00 		call	FAR PTR __outp
	*** 000314	83 c4 04 		add	sp,4
;|*** 
;|***   // turn on the com4 mcr gate (out2)
;|***   _outp( COM4_MCR, _inp(COM4_MCR) | 0x08); 
; Line 205
	*** 000317	68 ec 02 		push	748	;02ecH
	*** 00031a	9a 00 00 00 00 		call	FAR PTR __inp
	*** 00031f	83 c4 02 		add	sp,2
	*** 000322	0d 08 00 		or	ax,8
	*** 000325	50 			push	ax
	*** 000326	68 ec 02 		push	748	;02ecH
	*** 000329	9a 00 00 00 00 		call	FAR PTR __outp
	*** 00032e	83 c4 04 		add	sp,4
;|***   
;|***   // enable cpu interrupts          
;|***   _enable();
; Line 208
	*** 000331	9a 00 00 00 00 		call	FAR PTR __enable
;|***   cout << "Com4 initialized." << endl;
; Line 209
	*** 000336	68 00 00 		push	SEG ?endl@@ZAAEVostream@@AEV1@@Z	;endl
	*** 000339	68 00 00 		push	OFFSET ?endl@@ZAAEVostream@@AEV1@@Z	;endl
	*** 00033c	1e 			push	ds
	*** 00033d	68 00 00 		push	OFFSET DGROUP:$SG3005
	*** 000340	68 00 00 		push	SEG ?cout@@3Vostream_withassign@@E	;cout
	*** 000343	68 00 00 		push	OFFSET ?cout@@3Vostream_withassign@@E	;cout
	*** 000346	9a 00 00 00 00 		call	FAR PTR ??6ostream@@RECAEV0@PFD@Z	; ostream::operator<<
	*** 00034b	52 			push	dx
	*** 00034c	50 			push	ax
	*** 00034d	9a 00 00 00 00 		call	FAR PTR ??6ostream@@RECAEV0@P7AAEV0@AEV0@@Z@Z	; ostream::operator<<
;|***   // done 
;|***   } // end init_com4()
; Line 211
	*** 000352	e9 00 00 		jmp	$EX3000
					$EX3000:
	*** 000355	5e 			pop	si
	*** 000356	5f 			pop	di
	*** 000357	c9 			leave	
	*** 000358	cb 			ret	

?init_com4@@ZAXXZ	ENDP
	PUBLIC	?com1_isr@@ZAXXZ	; com1_isr
?com1_isr@@ZAXXZ	PROC FAR	; com1_isr
;|*** 
;|*** 
;|*** 
;|*** void interrupt far com1_isr(void)
;|***   {
; Line 216
	*** 000359	60 			pusha
	*** 00035a	1e 			push	ds
	*** 00035b	06 			push	es
	*** 00035c	8b ec 			mov	bp,sp
	*** 00035e	81 ec 06 00 		sub	sp,6
	*** 000362	1e 			push	ds
	*** 000363	b8 00 00 		mov	ax,DGROUP
	*** 000366	8e d8 			mov	ds,ax
	ASSUME DS: DGROUP
	*** 000368	fc 			cld	
;	intr = -2
;	i = -4
;|***   // performs rs232 functions on com1
;|***   unsigned intr;
;|***   unsigned i;
;|***   //unsigned lsb;
;|***   //unsigned msb;
;|***     
;|***   _enable();
; Line 223
	*** 000369	9a 00 00 00 00 		call	FAR PTR __enable
;|***     
;|***   // disable com1 uart interrupts      
;|***   _outp(COM1_MCR, _inp(COM1_MCR) & 0xf7);
; Line 226
	*** 00036e	68 fc 03 		push	1020	;03fcH
	*** 000371	9a 00 00 00 00 		call	FAR PTR __inp
	*** 000376	83 c4 02 		add	sp,2
	*** 000379	25 f7 00 		and	ax,247	;00f7H
	*** 00037c	50 			push	ax
	*** 00037d	68 fc 03 		push	1020	;03fcH
	*** 000380	9a 00 00 00 00 		call	FAR PTR __outp
	*** 000385	83 c4 04 		add	sp,4
;|***   
;|***   start_com1_isr:
; Line 228
					$start_com1_isr3010:
;|***   
;|***   // check contents of COM1_IIR  
;|***   intr = _inp(COM1_IIR);
; Line 231
	*** 000388	68 fa 03 		push	1018	;03faH
	*** 00038b	9a 00 00 00 00 		call	FAR PTR __inp
	*** 000390	83 c4 02 		add	sp,2
	*** 000393	89 46 fe 		mov	WORD PTR [bp-2],ax	;intr
;|***   intr = intr & 0x0f; // mask off b7 to b4
; Line 232
	*** 000396	83 66 fe 0f 		and	WORD PTR [bp-2],15	;000fH	;intr
;|***   
;|***   if((intr & 0x01) == 0) // if a valid com1 interrupt is pending
; Line 234
	*** 00039a	f6 46 fe 01 		test	BYTE PTR [bp-2],1	;intr
	*** 00039e	74 03 			je	$JCC926
	*** 0003a0	e9 b4 01 		jmp	$I3011
					$JCC926:
;|***     {   
; Line 235
;|***     // shift IIR value right one bit and test to see which routine is required
;|***     intr = intr >> 1;
; Line 237
	*** 0003a3	d1 6e fe 		shr	WORD PTR [bp-2],1	;intr
;|***   
;|***     // do rs232 input interrupt routine
;|***     if(intr == 0)
; Line 240
	*** 0003a6	83 7e fe 00 		cmp	WORD PTR [bp-2],0	;intr
	*** 0003aa	74 03 			je	$JCC938
	*** 0003ac	e9 11 00 		jmp	$I3012
					$JCC938:
;|***       {
; Line 241
;	msr_char = -6
;|***       // read the rs232 status register
;|***       unsigned msr_char = _inp(COM1_MSR);
; Line 243
	*** 0003af	68 fe 03 		push	1022	;03feH
	*** 0003b2	9a 00 00 00 00 		call	FAR PTR __inp
	*** 0003b7	83 c4 02 		add	sp,2
	*** 0003ba	89 46 fa 		mov	WORD PTR [bp-6],ax	;msr_char
;|***       goto start_com1_isr;
; Line 244
	*** 0003bd	e9 c8 ff 		jmp	$start_com1_isr3010
;|***       }
; Line 245
;|***      
;|***     // do tx buffer empty interrupt routine
;|***     if(intr == 1)
; Line 248
					$I3012:
	*** 0003c0	83 7e fe 01 		cmp	WORD PTR [bp-2],1	;intr
	*** 0003c4	74 03 			je	$JCC964
	*** 0003c6	e9 8b 00 		jmp	$I3014
					$JCC964:
;|***       {
; Line 249
;|***       // either write to tx FIFO or read int id register again
;|***       
;|***       // the idea here is to continue a tx once it has started,
;|***       // not to start one in the first place
;|***       
;|***       // the tx is started by the main() program writing the first
;|***       // char to the tx buffer, which will send the char out
;|***       
;|***       // once the tx fifo has drained, the tbe bit will be
;|***       // set in the iir, indicating that the tx buffer is ready for more
;|***       
;|***       if(com1_tx==0)  // no message to tx
; Line 261
	*** 0003c9	83 3e 00 00 00 		cmp	WORD PTR ?com1_tx@@3IE,0	;com1_tx
	*** 0003ce	74 03 			je	$JCC974
	*** 0003d0	e9 0e 00 		jmp	$I3015
					$JCC974:
;|***         {
; Line 262
;|***         _inp(COM1_IIR);
; Line 263
	*** 0003d3	68 fa 03 		push	1018	;03faH
	*** 0003d6	9a 00 00 00 00 		call	FAR PTR __inp
	*** 0003db	83 c4 02 		add	sp,2
;|***         goto start_com1_isr;
; Line 264
	*** 0003de	e9 a7 ff 		jmp	$start_com1_isr3010
;|***         }
; Line 265
;|***       if(com1_tx==1)  // tx remaining message
; Line 266
					$I3015:
	*** 0003e1	83 3e 00 00 01 		cmp	WORD PTR ?com1_tx@@3IE,1	;com1_tx
	*** 0003e6	74 03 			je	$JCC998
	*** 0003e8	e9 66 00 		jmp	$I3016
					$JCC998:
;|***         {
; Line 267
;|***         for(i=0; i<16;i++) // load 16 characters into the tx fifo
; Line 268
	*** 0003eb	c7 46 fc 00 00 		mov	WORD PTR [bp-4],0	;i
	*** 0003f0	e9 03 00 		jmp	$F3017
					$FC3018:
	*** 0003f3	ff 46 fc 		inc	WORD PTR [bp-4]	;i
					$F3017:
	*** 0003f6	83 7e fc 10 		cmp	WORD PTR [bp-4],16	;0010H	;i
	*** 0003fa	72 03 			jb	$JCC1018
	*** 0003fc	e9 52 00 		jmp	$FB3019
					$JCC1018:
;|***           {
; Line 269
;|***           if(com1_tx==0) break;
; Line 270
	*** 0003ff	83 3e 00 00 00 		cmp	WORD PTR ?com1_tx@@3IE,0	;com1_tx
	*** 000404	74 03 			je	$JCC1028
	*** 000406	e9 06 00 		jmp	$I3020
					$JCC1028:
	*** 000409	e9 45 00 		jmp	$FB3019
;|***           else  // only if more message needs to be sent
; Line 271
	*** 00040c	e9 3f 00 		jmp	$I3021
					$I3020:
;|***             {
; Line 272
;|***             _outp(COM1_TX, tx1_message[tx1_index]); // write the next character
; Line 273
	*** 00040f	8b 1e 00 00 		mov	bx,WORD PTR ?tx1_index@@3IE	;tx1_index
	*** 000413	8a 87 00 00 		mov	al,BYTE PTR ?tx1_message@@3QEEE[bx]	;tx1_message
	*** 000417	2a e4 			sub	ah,ah
	*** 000419	50 			push	ax
	*** 00041a	68 f8 03 		push	1016	;03f8H
	*** 00041d	9a 00 00 00 00 		call	FAR PTR __outp
	*** 000422	83 c4 04 		add	sp,4
;|***             tx1_index++;
; Line 274
	*** 000425	ff 06 00 00 		inc	WORD PTR ?tx1_index@@3IE	;tx1_index
;|***             tx1_counter++;
; Line 275
	*** 000429	ff 06 00 00 		inc	WORD PTR ?tx1_counter@@3IE	;tx1_counter
;|***             if(tx1_index >= tx1_len)  // entire message has been sent
; Line 276
	*** 00042d	a1 00 00 		mov	ax,WORD PTR ?tx1_index@@3IE	;tx1_index
	*** 000430	39 06 00 00 		cmp	WORD PTR ?tx1_len@@3IE,ax	;tx1_len
	*** 000434	76 03 			jbe	$JCC1076
	*** 000436	e9 15 00 		jmp	$I3022
					$JCC1076:
;|***               {
; Line 277
;|***               tx1_index = 0;
; Line 278
	*** 000439	c7 06 00 00 00 00 	mov	WORD PTR ?tx1_index@@3IE,0	;tx1_index
;|***               com1_tx = 0;
; Line 279
	*** 00043f	c7 06 00 00 00 00 	mov	WORD PTR ?com1_tx@@3IE,0	;com1_tx
;|***               tx1_len = 0;
; Line 280
	*** 000445	c7 06 00 00 00 00 	mov	WORD PTR ?tx1_len@@3IE,0	;tx1_len
;|***               goto start_com1_isr;  
; Line 281
	*** 00044b	e9 3a ff 		jmp	$start_com1_isr3010
;|***               }
; Line 282
;|***             }
; Line 283
					$I3022:
					$I3021:
;|***           }
; Line 284
	*** 00044e	e9 a2 ff 		jmp	$FC3018
					$FB3019:
;|***         }
; Line 285
;|***       goto start_com1_isr;    
; Line 286
					$I3016:
	*** 000451	e9 34 ff 		jmp	$start_com1_isr3010
;|***       }
; Line 287
;|***       
;|***     // rx data received interrupt routine (>= 14 bytes in receive buffer)
;|***     if(intr == 2)
; Line 290
					$I3014:
	*** 000454	83 7e fe 02 		cmp	WORD PTR [bp-2],2	;intr
	*** 000458	74 03 			je	$JCC1112
	*** 00045a	e9 42 00 		jmp	$I3023
					$JCC1112:
;|***       {
; Line 291
;|***       // read rx register
;|***             
;|***       // read 12 bytes from the rx register (still at least 2 bytes left)
;|***       for(i = 0; i < 12; i++)
; Line 295
	*** 00045d	c7 46 fc 00 00 		mov	WORD PTR [bp-4],0	;i
	*** 000462	e9 03 00 		jmp	$F3024
					$FC3025:
	*** 000465	ff 46 fc 		inc	WORD PTR [bp-4]	;i
					$F3024:
	*** 000468	83 7e fc 0c 		cmp	WORD PTR [bp-4],12	;000cH	;i
	*** 00046c	72 03 			jb	$JCC1132
	*** 00046e	e9 2b 00 		jmp	$FB3026
					$JCC1132:
;|***         {
; Line 296
;|***         rx1_message[rx1_index] = _inp(COM1_RX);
; Line 297
	*** 000471	68 f8 03 		push	1016	;03f8H
	*** 000474	9a 00 00 00 00 		call	FAR PTR __inp
	*** 000479	83 c4 02 		add	sp,2
	*** 00047c	8b 1e 00 00 		mov	bx,WORD PTR ?rx1_index@@3IE	;rx1_index
	*** 000480	88 87 00 00 		mov	BYTE PTR ?rx1_message@@3QEEE[bx],al	;rx1_message
;|***         rx1_index++;
; Line 298
	*** 000484	ff 06 00 00 		inc	WORD PTR ?rx1_index@@3IE	;rx1_index
;|***         if(rx1_index >= sizeof(rx1_message))
; Line 299
	*** 000488	81 3e 00 00 00 04 	cmp	WORD PTR ?rx1_index@@3IE,1024	;0400H	;rx1_index
	*** 00048e	73 03 			jae	$JCC1166
	*** 000490	e9 06 00 		jmp	$I3027
					$JCC1166:
;|***           rx1_index = 0;
; Line 300
	*** 000493	c7 06 00 00 00 00 	mov	WORD PTR ?rx1_index@@3IE,0	;rx1_index
;|***         }
; Line 301
					$I3027:
	*** 000499	e9 c9 ff 		jmp	$FC3025
					$FB3026:
;|***         
;|***       goto start_com1_isr;
; Line 303
	*** 00049c	e9 e9 fe 		jmp	$start_com1_isr3010
;|***       }
; Line 304
;|***     
;|***     // else do serialization error/break routine  
;|***     if(intr == 3)
; Line 307
					$I3023:
	*** 00049f	83 7e fe 03 		cmp	WORD PTR [bp-2],3	;intr
	*** 0004a3	74 03 			je	$JCC1187
	*** 0004a5	e9 11 00 		jmp	$I3028
					$JCC1187:
;|***       {
; Line 308
;	lsr_char = -6
;|***       // read serialization/line status register
;|***       unsigned lsr_char = _inp(COM1_LSR);
; Line 310
	*** 0004a8	68 fd 03 		push	1021	;03fdH
	*** 0004ab	9a 00 00 00 00 		call	FAR PTR __inp
	*** 0004b0	83 c4 02 		add	sp,2
	*** 0004b3	89 46 fa 		mov	WORD PTR [bp-6],ax	;msr_char
;|***       goto start_com1_isr;
; Line 311
	*** 0004b6	e9 cf fe 		jmp	$start_com1_isr3010
;|***       }
; Line 312
;|***     
;|***     // do rx character timeout routine: message end
;|***     if(intr == 6)
; Line 315
					$I3028:
	*** 0004b9	83 7e fe 06 		cmp	WORD PTR [bp-2],6	;intr
	*** 0004bd	74 03 			je	$JCC1213
	*** 0004bf	e9 92 00 		jmp	$I3030
					$JCC1213:
;|***       {
; Line 316
;|***       // drain rx fifo
;|***       while((_inp(COM1_LSR) & 0x01) == 1)
; Line 318
					$FC3032:
	*** 0004c2	68 fd 03 		push	1021	;03fdH
	*** 0004c5	9a 00 00 00 00 		call	FAR PTR __inp
	*** 0004ca	83 c4 02 		add	sp,2
	*** 0004cd	24 01 			and	al,1
	*** 0004cf	3c 01 			cmp	al,1
	*** 0004d1	74 03 			je	$JCC1233
	*** 0004d3	e9 2b 00 		jmp	$FB3033
					$JCC1233:
;|***         {
; Line 319
;|***         rx1_message[rx1_index] = _inp(COM1_RX);
; Line 320
	*** 0004d6	68 f8 03 		push	1016	;03f8H
	*** 0004d9	9a 00 00 00 00 		call	FAR PTR __inp
	*** 0004de	83 c4 02 		add	sp,2
	*** 0004e1	8b 1e 00 00 		mov	bx,WORD PTR ?rx1_index@@3IE	;rx1_index
	*** 0004e5	88 87 00 00 		mov	BYTE PTR ?rx1_message@@3QEEE[bx],al	;rx1_message
;|***         rx1_index++;
; Line 321
	*** 0004e9	ff 06 00 00 		inc	WORD PTR ?rx1_index@@3IE	;rx1_index
;|***         if(rx1_index >= sizeof(rx1_message)) rx1_index = 0;
; Line 322
	*** 0004ed	81 3e 00 00 00 04 	cmp	WORD PTR ?rx1_index@@3IE,1024	;0400H	;rx1_index
	*** 0004f3	73 03 			jae	$JCC1267
	*** 0004f5	e9 06 00 		jmp	$I3034
					$JCC1267:
	*** 0004f8	c7 06 00 00 00 00 	mov	WORD PTR ?rx1_index@@3IE,0	;rx1_index
;|***         }
; Line 323
					$I3034:
	*** 0004fe	e9 c1 ff 		jmp	$FC3032
					$FB3033:
;|***       
;|***       //if(rx1_index >= 88) // complete frame received
;|***       if(rx1_index >= 213) // complete frame received  // for PD0 format db & jtm 11/16/2007
; Line 326
	*** 000501	81 3e 00 00 d5 00 	cmp	WORD PTR ?rx1_index@@3IE,213	;00d5H	;rx1_index
	*** 000507	73 03 			jae	$JCC1287
	*** 000509	e9 3f 00 		jmp	$I3035
					$JCC1287:
;|***         {
; Line 327
;|***         // timestamp the adcp message
;|***         _disable();
; Line 329
	*** 00050c	9a 00 00 00 00 		call	FAR PTR __disable
;|***         time_stamp(&adcp_time);
; Line 330
	*** 000511	68 00 00 		push	SEG ?adcp_time@@3UTIMER@@E	;adcp_time
	*** 000514	68 00 00 		push	OFFSET ?adcp_time@@3UTIMER@@E	;adcp_time
	*** 000517	9a 00 00 00 00 		call	FAR PTR ?time_stamp@@ZAXPEUTIMER@@@Z	; time_stamp
	*** 00051c	83 c4 04 		add	sp,4
;|***         _enable();
; Line 331
	*** 00051f	9a 00 00 00 00 		call	FAR PTR __enable
;|*** 
;|***         //memcpy(adcp_buffer, rx1_message, 88);
;|***         //_fmemcpy(adcp_buffer, rx1_message, sizeof(adcp_buffer));//for PD0 format db & jtm 11/16/2007
;|***         _fmemcpy(adcp_buffer, rx1_message, 213);//for PD0 format db & jtm 11/16/2007
; Line 335
	*** 000524	68 d5 00 		push	213	;00d5H
	*** 000527	1e 			push	ds
	*** 000528	68 00 00 		push	OFFSET DGROUP:?rx1_message@@3QEEE	;rx1_message
	*** 00052b	1e 			push	ds
	*** 00052c	68 00 00 		push	OFFSET ?adcp_buffer@@3QEEE	;adcp_buffer
	*** 00052f	9a 00 00 00 00 		call	FAR PTR __fmemcpy
	*** 000534	83 c4 0a 		add	sp,10	;000aH
;|***         //rx1_index = 0;
;|***         adcp_new_data = 1;
; Line 337
	*** 000537	c7 06 00 00 01 00 	mov	WORD PTR ?adcp_new_data@@3IE,1	;adcp_new_data
;|***         adcp_data_frame = frame;
; Line 338
	*** 00053d	a1 00 00 		mov	ax,WORD PTR ?frame@@3KE	;frame
	*** 000540	8b 16 02 00 		mov	dx,WORD PTR ?frame@@3KE+2	;frame
	*** 000544	a3 00 00 		mov	WORD PTR ?adcp_data_frame@@3KE,ax	;adcp_data_frame
	*** 000547	89 16 02 00 		mov	WORD PTR ?adcp_data_frame@@3KE+2,dx	;adcp_data_frame
;|***         }
; Line 339
;|***       rx1_index = 0;
; Line 340
					$I3035:
	*** 00054b	c7 06 00 00 00 00 	mov	WORD PTR ?rx1_index@@3IE,0	;rx1_index
;|***       goto start_com1_isr;      
; Line 341
	*** 000551	e9 34 fe 		jmp	$start_com1_isr3010
;|***       } // end rx character timeout routine
; Line 342
;|***         
;|***     goto start_com1_isr;
; Line 344
					$I3030:
	*** 000554	e9 31 fe 		jmp	$start_com1_isr3010
;|***     }  // end if((intr & 0x01) == 0)
; Line 345
;|***   
;|***   //_disable();  
;|***   // enable com1 uart tx interrupts    
;|***   _outp(COM1_MCR, _inp(COM1_MCR) | 0x08);
; Line 349
					$I3011:
	*** 000557	68 fc 03 		push	1020	;03fcH
	*** 00055a	9a 00 00 00 00 		call	FAR PTR __inp
	*** 00055f	83 c4 02 		add	sp,2
	*** 000562	0d 08 00 		or	ax,8
	*** 000565	50 			push	ax
	*** 000566	68 fc 03 		push	1020	;03fcH
	*** 000569	9a 00 00 00 00 		call	FAR PTR __outp
	*** 00056e	83 c4 04 		add	sp,4
;|***   _outp(0x20, 0x20);  // non-specific return from interrupt
; Line 350
	*** 000571	6a 20 			push	32	;0020H
	*** 000573	6a 20 			push	32	;0020H
	*** 000575	9a 00 00 00 00 		call	FAR PTR __outp
	*** 00057a	83 c4 04 		add	sp,4
;|***   _disable();
; Line 351
	*** 00057d	9a 00 00 00 00 		call	FAR PTR __disable
;|***   
;|***   }  // end com1_isr()
; Line 353
	*** 000582	e9 00 00 		jmp	$EX3007
					$EX3007:
	*** 000585	8b e5 			mov	sp,bp
	*** 000587	07 			pop	es
	*** 000588	1f 			pop	ds
	ASSUME DS: DGROUP
	*** 000589	61 			popa
	*** 00058a	cf 			iret	

?com1_isr@@ZAXXZ	ENDP
	PUBLIC	?com2_isr@@ZAXXZ	; com2_isr
?com2_isr@@ZAXXZ	PROC FAR	; com2_isr
;|*** 
;|*** 
;|*** 
;|*** void interrupt far com2_isr(void)
;|***   {
; Line 358
	*** 00058b	60 			pusha
	*** 00058c	1e 			push	ds
	*** 00058d	06 			push	es
	*** 00058e	8b ec 			mov	bp,sp
	*** 000590	81 ec 06 00 		sub	sp,6
	*** 000594	1e 			push	ds
	*** 000595	b8 00 00 		mov	ax,DGROUP
	*** 000598	8e d8 			mov	ds,ax
	ASSUME DS: DGROUP
	*** 00059a	fc 			cld	
;	intr = -2
;	i = -4
;|***   // performs rs232 functions on com2
;|***   unsigned intr;
;|***   unsigned i;
;|***     
;|***   _enable();
; Line 363
	*** 00059b	9a 00 00 00 00 		call	FAR PTR __enable
;|***     
;|***   // disable com2 uart interrupts      
;|***   _outp(COM2_MCR, _inp(COM2_MCR) & 0xf7);
; Line 366
	*** 0005a0	68 fc 02 		push	764	;02fcH
	*** 0005a3	9a 00 00 00 00 		call	FAR PTR __inp
	*** 0005a8	83 c4 02 		add	sp,2
	*** 0005ab	25 f7 00 		and	ax,247	;00f7H
	*** 0005ae	50 			push	ax
	*** 0005af	68 fc 02 		push	764	;02fcH
	*** 0005b2	9a 00 00 00 00 		call	FAR PTR __outp
	*** 0005b7	83 c4 04 		add	sp,4
;|***   
;|***   start_com2_isr:
; Line 368
					$start_com2_isr3040:
;|***   
;|***   // check contents of COM2_IIR  
;|***   intr = _inp(COM2_IIR);
; Line 371
	*** 0005ba	68 fa 02 		push	762	;02faH
	*** 0005bd	9a 00 00 00 00 		call	FAR PTR __inp
	*** 0005c2	83 c4 02 		add	sp,2
	*** 0005c5	89 46 fe 		mov	WORD PTR [bp-2],ax	;intr
;|***   intr = intr & 0x0f; // mask off b7 to b4
; Line 372
	*** 0005c8	83 66 fe 0f 		and	WORD PTR [bp-2],15	;000fH	;intr
;|***   
;|***   if((intr & 0x01) == 0) // if a valid com2 interrupt is pending
; Line 374
	*** 0005cc	f6 46 fe 01 		test	BYTE PTR [bp-2],1	;intr
	*** 0005d0	74 03 			je	$JCC1488
	*** 0005d2	e9 b2 01 		jmp	$I3041
					$JCC1488:
;|***     {   
; Line 375
;|***     // shift IIR value right one bit and test to see which routine is required
;|***     intr = intr >> 1;
; Line 377
	*** 0005d5	d1 6e fe 		shr	WORD PTR [bp-2],1	;intr
;|***   
;|***     // do rs232 input interrupt routine
;|***     if(intr == 0)
; Line 380
	*** 0005d8	83 7e fe 00 		cmp	WORD PTR [bp-2],0	;intr
	*** 0005dc	74 03 			je	$JCC1500
	*** 0005de	e9 11 00 		jmp	$I3042
					$JCC1500:
;|***       {
; Line 381
;	msr_char = -6
;|***       // read the rs232 status register
;|***       unsigned msr_char = _inp(COM2_MSR);
; Line 383
	*** 0005e1	68 fe 02 		push	766	;02feH
	*** 0005e4	9a 00 00 00 00 		call	FAR PTR __inp
	*** 0005e9	83 c4 02 		add	sp,2
	*** 0005ec	89 46 fa 		mov	WORD PTR [bp-6],ax	;msr_char
;|***       goto start_com2_isr;
; Line 384
	*** 0005ef	e9 c8 ff 		jmp	$start_com2_isr3040
;|***       }
; Line 385
;|***      
;|***     // do tx buffer empty interrupt routine
;|***     if(intr == 1)
; Line 388
					$I3042:
	*** 0005f2	83 7e fe 01 		cmp	WORD PTR [bp-2],1	;intr
	*** 0005f6	74 03 			je	$JCC1526
	*** 0005f8	e9 8b 00 		jmp	$I3044
					$JCC1526:
;|***       {
; Line 389
;|***       // either write to tx FIFO or read int id register again
;|***       
;|***       // the idea here is to continue a tx once it has started,
;|***       // not to start one in the first place
;|***       
;|***       // the tx is started by the main() program writing the first
;|***       // char to the tx buffer, which will send the char out
;|***       
;|***       // once the tx fifo has drained, the tbe bit will be
;|***       // set in the iir, indicating that the tx buffer is ready for more
;|***       
;|***       // we will refill the tx fifo, up to 127 chars, for a total of 128
;|***       if(com2_tx==0)  // no message to tx
; Line 402
	*** 0005fb	83 3e 00 00 00 		cmp	WORD PTR ?com2_tx@@3IE,0	;com2_tx
	*** 000600	74 03 			je	$JCC1536
	*** 000602	e9 0e 00 		jmp	$I3045
					$JCC1536:
;|***         {
; Line 403
;|***         _inp(COM2_IIR);
; Line 404
	*** 000605	68 fa 02 		push	762	;02faH
	*** 000608	9a 00 00 00 00 		call	FAR PTR __inp
	*** 00060d	83 c4 02 		add	sp,2
;|***         goto start_com2_isr;
; Line 405
	*** 000610	e9 a7 ff 		jmp	$start_com2_isr3040
;|***         }
; Line 406
;|***       if(com2_tx==1)  // tx remaining message
; Line 407
					$I3045:
	*** 000613	83 3e 00 00 01 		cmp	WORD PTR ?com2_tx@@3IE,1	;com2_tx
	*** 000618	74 03 			je	$JCC1560
	*** 00061a	e9 66 00 		jmp	$I3046
					$JCC1560:
;|***         {
; Line 408
;|***         for(i=0; i<16;i++) // load 16 characters into the tx fifo
; Line 409
	*** 00061d	c7 46 fc 00 00 		mov	WORD PTR [bp-4],0	;i
	*** 000622	e9 03 00 		jmp	$F3047
					$FC3048:
	*** 000625	ff 46 fc 		inc	WORD PTR [bp-4]	;i
					$F3047:
	*** 000628	83 7e fc 10 		cmp	WORD PTR [bp-4],16	;0010H	;i
	*** 00062c	72 03 			jb	$JCC1580
	*** 00062e	e9 52 00 		jmp	$FB3049
					$JCC1580:
;|***           {
; Line 410
;|***           if(com2_tx==0) break;
; Line 411
	*** 000631	83 3e 00 00 00 		cmp	WORD PTR ?com2_tx@@3IE,0	;com2_tx
	*** 000636	74 03 			je	$JCC1590
	*** 000638	e9 06 00 		jmp	$I3050
					$JCC1590:
	*** 00063b	e9 45 00 		jmp	$FB3049
;|***           else  // only if more message needs to be sent
; Line 412
	*** 00063e	e9 3f 00 		jmp	$I3051
					$I3050:
;|***             {
; Line 413
;|***             _outp(COM2_TX, tx2_message[tx2_index]); // write the next character
; Line 414
	*** 000641	8b 1e 00 00 		mov	bx,WORD PTR ?tx2_index@@3IE	;tx2_index
	*** 000645	8a 87 00 00 		mov	al,BYTE PTR ?tx2_message@@3QEEE[bx]	;tx2_message
	*** 000649	2a e4 			sub	ah,ah
	*** 00064b	50 			push	ax
	*** 00064c	68 f8 02 		push	760	;02f8H
	*** 00064f	9a 00 00 00 00 		call	FAR PTR __outp
	*** 000654	83 c4 04 		add	sp,4
;|***             tx2_index++;
; Line 415
	*** 000657	ff 06 00 00 		inc	WORD PTR ?tx2_index@@3IE	;tx2_index
;|***             tx2_counter++;
; Line 416
	*** 00065b	ff 06 00 00 		inc	WORD PTR ?tx2_counter@@3IE	;tx2_counter
;|***             if(tx2_index >= tx2_len)  // entire message has been sent
; Line 417
	*** 00065f	a1 00 00 		mov	ax,WORD PTR ?tx2_index@@3IE	;tx2_index
	*** 000662	39 06 00 00 		cmp	WORD PTR ?tx2_len@@3IE,ax	;tx2_len
	*** 000666	76 03 			jbe	$JCC1638
	*** 000668	e9 15 00 		jmp	$I3052
					$JCC1638:
;|***               {
; Line 418
;|***               tx2_index = 0;
; Line 419
	*** 00066b	c7 06 00 00 00 00 	mov	WORD PTR ?tx2_index@@3IE,0	;tx2_index
;|***               com2_tx = 0;
; Line 420
	*** 000671	c7 06 00 00 00 00 	mov	WORD PTR ?com2_tx@@3IE,0	;com2_tx
;|***               tx2_len = 0;
; Line 421
	*** 000677	c7 06 00 00 00 00 	mov	WORD PTR ?tx2_len@@3IE,0	;tx2_len
;|***               goto start_com2_isr;  
; Line 422
	*** 00067d	e9 3a ff 		jmp	$start_com2_isr3040
;|***               }
; Line 423
;|***             }
; Line 424
					$I3052:
					$I3051:
;|***           }
; Line 425
	*** 000680	e9 a2 ff 		jmp	$FC3048
					$FB3049:
;|***         }
; Line 426
;|***       goto start_com2_isr;    
; Line 427
					$I3046:
	*** 000683	e9 34 ff 		jmp	$start_com2_isr3040
;|***       }
; Line 428
;|***       
;|***     // rx data received interrupt routine (>= 14 bytes in receive buffer)
;|***     if(intr == 2)
; Line 431
					$I3044:
	*** 000686	83 7e fe 02 		cmp	WORD PTR [bp-2],2	;intr
	*** 00068a	74 03 			je	$JCC1674
	*** 00068c	e9 42 00 		jmp	$I3053
					$JCC1674:
;|***       {
; Line 432
;|***       // read rx register
;|***             
;|***       // read 12 bytes from the rx register (still at least 2 bytes left)
;|***       for(i = 0; i < 12; i++)
; Line 436
	*** 00068f	c7 46 fc 00 00 		mov	WORD PTR [bp-4],0	;i
	*** 000694	e9 03 00 		jmp	$F3054
					$FC3055:
	*** 000697	ff 46 fc 		inc	WORD PTR [bp-4]	;i
					$F3054:
	*** 00069a	83 7e fc 0c 		cmp	WORD PTR [bp-4],12	;000cH	;i
	*** 00069e	72 03 			jb	$JCC1694
	*** 0006a0	e9 2b 00 		jmp	$FB3056
					$JCC1694:
;|***         {
; Line 437
;|***         rx2_message[rx2_index] = _inp(COM2_RX);
; Line 438
	*** 0006a3	68 f8 02 		push	760	;02f8H
	*** 0006a6	9a 00 00 00 00 		call	FAR PTR __inp
	*** 0006ab	83 c4 02 		add	sp,2
	*** 0006ae	8b 1e 00 00 		mov	bx,WORD PTR ?rx2_index@@3IE	;rx2_index
	*** 0006b2	88 87 00 00 		mov	BYTE PTR ?rx2_message@@3QEEE[bx],al	;rx2_message
;|***         rx2_index++;
; Line 439
	*** 0006b6	ff 06 00 00 		inc	WORD PTR ?rx2_index@@3IE	;rx2_index
;|***         if(rx2_index >= sizeof(rx2_message))
; Line 440
	*** 0006ba	81 3e 00 00 00 04 	cmp	WORD PTR ?rx2_index@@3IE,1024	;0400H	;rx2_index
	*** 0006c0	73 03 			jae	$JCC1728
	*** 0006c2	e9 06 00 		jmp	$I3057
					$JCC1728:
;|***           rx2_index = 0;
; Line 441
	*** 0006c5	c7 06 00 00 00 00 	mov	WORD PTR ?rx2_index@@3IE,0	;rx2_index
;|***         }
; Line 442
					$I3057:
	*** 0006cb	e9 c9 ff 		jmp	$FC3055
					$FB3056:
;|***         
;|***       goto start_com2_isr;
; Line 444
	*** 0006ce	e9 e9 fe 		jmp	$start_com2_isr3040
;|***       }
; Line 445
;|***     
;|***     // else do serialization error/break routine  
;|***     if(intr == 3)
; Line 448
					$I3053:
	*** 0006d1	83 7e fe 03 		cmp	WORD PTR [bp-2],3	;intr
	*** 0006d5	74 03 			je	$JCC1749
	*** 0006d7	e9 11 00 		jmp	$I3058
					$JCC1749:
;|***       {
; Line 449
;	lsr_char = -6
;|***       // read serialization status register
;|***       unsigned lsr_char = _inp(COM2_LSR);
; Line 451
	*** 0006da	68 fd 02 		push	765	;02fdH
	*** 0006dd	9a 00 00 00 00 		call	FAR PTR __inp
	*** 0006e2	83 c4 02 		add	sp,2
	*** 0006e5	89 46 fa 		mov	WORD PTR [bp-6],ax	;msr_char
;|***       goto start_com2_isr;
; Line 452
	*** 0006e8	e9 cf fe 		jmp	$start_com2_isr3040
;|***       }
; Line 453
;|***     
;|***     // do rx character timeout routine: message end
;|***     if(intr == 6)
; Line 456
					$I3058:
	*** 0006eb	83 7e fe 06 		cmp	WORD PTR [bp-2],6	;intr
	*** 0006ef	74 03 			je	$JCC1775
	*** 0006f1	e9 90 00 		jmp	$I3060
					$JCC1775:
;|***       {
; Line 457
;|***       // drain rx register first
;|***       while((_inp(COM2_LSR) & 0x01) == 1)
; Line 459
					$FC3062:
	*** 0006f4	68 fd 02 		push	765	;02fdH
	*** 0006f7	9a 00 00 00 00 		call	FAR PTR __inp
	*** 0006fc	83 c4 02 		add	sp,2
	*** 0006ff	24 01 			and	al,1
	*** 000701	3c 01 			cmp	al,1
	*** 000703	74 03 			je	$JCC1795
	*** 000705	e9 2b 00 		jmp	$FB3063
					$JCC1795:
;|***         {
; Line 460
;|***         rx2_message[rx2_index] = _inp(COM2_RX);
; Line 461
	*** 000708	68 f8 02 		push	760	;02f8H
	*** 00070b	9a 00 00 00 00 		call	FAR PTR __inp
	*** 000710	83 c4 02 		add	sp,2
	*** 000713	8b 1e 00 00 		mov	bx,WORD PTR ?rx2_index@@3IE	;rx2_index
	*** 000717	88 87 00 00 		mov	BYTE PTR ?rx2_message@@3QEEE[bx],al	;rx2_message
;|***         rx2_index++;
; Line 462
	*** 00071b	ff 06 00 00 		inc	WORD PTR ?rx2_index@@3IE	;rx2_index
;|***         if(rx2_index >= sizeof(rx2_message))
; Line 463
	*** 00071f	81 3e 00 00 00 04 	cmp	WORD PTR ?rx2_index@@3IE,1024	;0400H	;rx2_index
	*** 000725	73 03 			jae	$JCC1829
	*** 000727	e9 06 00 		jmp	$I3064
					$JCC1829:
;|***           rx2_index = 0;
; Line 464
	*** 00072a	c7 06 00 00 00 00 	mov	WORD PTR ?rx2_index@@3IE,0	;rx2_index
;|***         }
; Line 465
					$I3064:
	*** 000730	e9 c1 ff 		jmp	$FC3062
					$FB3063:
;|***       
;|***       if(rx2_index >= 49) // complete frame received
; Line 467
	*** 000733	83 3e 00 00 31 		cmp	WORD PTR ?rx2_index@@3IE,49	;0031H	;rx2_index
	*** 000738	73 03 			jae	$JCC1848
	*** 00073a	e9 3e 00 		jmp	$I3065
					$JCC1848:
;|***         {
; Line 468
;|***         _disable();   //sjc added to match com1
; Line 469
	*** 00073d	9a 00 00 00 00 		call	FAR PTR __disable
;|***         time_stamp(&ds_time);                  
; Line 470
	*** 000742	68 00 00 		push	SEG ?ds_time@@3UTIMER@@E	;ds_time
	*** 000745	68 00 00 		push	OFFSET ?ds_time@@3UTIMER@@E	;ds_time
	*** 000748	9a 00 00 00 00 		call	FAR PTR ?time_stamp@@ZAXPEUTIMER@@@Z	; time_stamp
	*** 00074d	83 c4 04 		add	sp,4
;|***         _enable();    //sjc added to match com1
; Line 471
	*** 000750	9a 00 00 00 00 		call	FAR PTR __enable
;|***         //memcpy(ds_buffer, rx2_message, sizeof(ds_buffer));
;|***         // First fill with 0's then put in 49 byte msg
;|***         //memcpy(ds_buffer, 0, sizeof(ds_buffer));
;|***         //sjc memcpy(ds_buffer, rx2_message, 49);
;|***         _fmemcpy(ds_buffer, rx2_message, 49);
; Line 476
	*** 000755	6a 31 			push	49	;0031H
	*** 000757	1e 			push	ds
	*** 000758	68 00 00 		push	OFFSET DGROUP:?rx2_message@@3QEEE	;rx2_message
	*** 00075b	1e 			push	ds
	*** 00075c	68 00 00 		push	OFFSET ?ds_buffer@@3QEEE	;ds_buffer
	*** 00075f	9a 00 00 00 00 		call	FAR PTR __fmemcpy
	*** 000764	83 c4 0a 		add	sp,10	;000aH
;|***         ds_new_data = 1;
; Line 477
	*** 000767	c7 06 00 00 01 00 	mov	WORD PTR ?ds_new_data@@3IE,1	;ds_new_data
;|***         ds_data_frame = frame;
; Line 478
	*** 00076d	a1 00 00 		mov	ax,WORD PTR ?frame@@3KE	;frame
	*** 000770	8b 16 02 00 		mov	dx,WORD PTR ?frame@@3KE+2	;frame
	*** 000774	a3 00 00 		mov	WORD PTR ?ds_data_frame@@3KE,ax	;ds_data_frame
	*** 000777	89 16 02 00 		mov	WORD PTR ?ds_data_frame@@3KE+2,dx	;ds_data_frame
;|***         //sjc rx2_index = 0;
;|***         //for(i=0; i<sizeof(rx2_message); i++)
;|***         //  rx2_message[i] = 0;
;|***         //sjc _fmemset(rx2_message, 0, sizeof(rx2_message));
;|***         }
; Line 483
;|***       rx2_index = 0; //sjc added to match com1
; Line 484
					$I3065:
	*** 00077b	c7 06 00 00 00 00 	mov	WORD PTR ?rx2_index@@3IE,0	;rx2_index
;|*** 
;|***       goto start_com2_isr;      
; Line 486
	*** 000781	e9 36 fe 		jmp	$start_com2_isr3040
;|***       } // end rx character timeout routine
; Line 487
;|***         
;|***     goto start_com2_isr;
; Line 489
					$I3060:
	*** 000784	e9 33 fe 		jmp	$start_com2_isr3040
;|***     }  // end if((intr & 0x01) == 0)
; Line 490
;|***   
;|***   //sjc _disable();  
;|***   // enable com2 uart interrupts    
;|***   _outp(COM2_MCR, _inp(COM2_MCR) | 0x08);
; Line 494
					$I3041:
	*** 000787	68 fc 02 		push	764	;02fcH
	*** 00078a	9a 00 00 00 00 		call	FAR PTR __inp
	*** 00078f	83 c4 02 		add	sp,2
	*** 000792	0d 08 00 		or	ax,8
	*** 000795	50 			push	ax
	*** 000796	68 fc 02 		push	764	;02fcH
	*** 000799	9a 00 00 00 00 		call	FAR PTR __outp
	*** 00079e	83 c4 04 		add	sp,4
;|***   _outp(0x20, 0x20);  // non-specific return from interrupt
; Line 495
	*** 0007a1	6a 20 			push	32	;0020H
	*** 0007a3	6a 20 			push	32	;0020H
	*** 0007a5	9a 00 00 00 00 		call	FAR PTR __outp
	*** 0007aa	83 c4 04 		add	sp,4
;|***   _disable();  //sjc added to match com1
; Line 496
	*** 0007ad	9a 00 00 00 00 		call	FAR PTR __disable
;|***   }  // end com2_isr()
; Line 497
	*** 0007b2	e9 00 00 		jmp	$EX3037
					$EX3037:
	*** 0007b5	8b e5 			mov	sp,bp
	*** 0007b7	07 			pop	es
	*** 0007b8	1f 			pop	ds
	ASSUME DS: DGROUP
	*** 0007b9	61 			popa
	*** 0007ba	cf 			iret	

?com2_isr@@ZAXXZ	ENDP
	PUBLIC	?com4_isr@@ZAXXZ	; com4_isr
?com4_isr@@ZAXXZ	PROC FAR	; com4_isr
;|*** 
;|*** 
;|*** 
;|*** void interrupt far com4_isr(void)
;|***   {
; Line 502
	*** 0007bb	60 			pusha
	*** 0007bc	1e 			push	ds
	*** 0007bd	06 			push	es
	*** 0007be	8b ec 			mov	bp,sp
	*** 0007c0	81 ec 06 00 		sub	sp,6
	*** 0007c4	1e 			push	ds
	*** 0007c5	b8 00 00 		mov	ax,DGROUP
	*** 0007c8	8e d8 			mov	ds,ax
	ASSUME DS: DGROUP
	*** 0007ca	fc 			cld	
;	intr = -2
;	i = -4
;|***   // performs rs232 functions on com4
;|***   unsigned intr;
;|***   unsigned i;
;|***     
;|***   _enable();
; Line 507
	*** 0007cb	9a 00 00 00 00 		call	FAR PTR __enable
;|***     
;|***   // disable com4 uart interrupts      
;|***   _outp(COM4_MCR, _inp(COM4_MCR) & 0xf7);
; Line 510
	*** 0007d0	68 ec 02 		push	748	;02ecH
	*** 0007d3	9a 00 00 00 00 		call	FAR PTR __inp
	*** 0007d8	83 c4 02 		add	sp,2
	*** 0007db	25 f7 00 		and	ax,247	;00f7H
	*** 0007de	50 			push	ax
	*** 0007df	68 ec 02 		push	748	;02ecH
	*** 0007e2	9a 00 00 00 00 		call	FAR PTR __outp
	*** 0007e7	83 c4 04 		add	sp,4
;|***   
;|***   start_com4_isr:
; Line 512
					$start_com4_isr3070:
;|***   
;|***   // check contents of COM4_IIR  
;|***   intr = _inp(COM4_IIR);
; Line 515
	*** 0007ea	68 ea 02 		push	746	;02eaH
	*** 0007ed	9a 00 00 00 00 		call	FAR PTR __inp
	*** 0007f2	83 c4 02 		add	sp,2
	*** 0007f5	89 46 fe 		mov	WORD PTR [bp-2],ax	;intr
;|***   intr = intr & 0x0f; // mask off b7 to b4
; Line 516
	*** 0007f8	83 66 fe 0f 		and	WORD PTR [bp-2],15	;000fH	;intr
;|***   
;|***   if((intr & 0x01) == 0) // if a valid com4 interrupt is pending
; Line 518
	*** 0007fc	f6 46 fe 01 		test	BYTE PTR [bp-2],1	;intr
	*** 000800	74 03 			je	$JCC2048
	*** 000802	e9 b6 01 		jmp	$I3071
					$JCC2048:
;|***     {   
; Line 519
;|***     // shift IIR value right one bit and test to see which routine is required
;|***     intr = intr >> 1;
; Line 521
	*** 000805	d1 6e fe 		shr	WORD PTR [bp-2],1	;intr
;|***   
;|***     // do rs232 input interrupt routine
;|***     if(intr == 0)
; Line 524
	*** 000808	83 7e fe 00 		cmp	WORD PTR [bp-2],0	;intr
	*** 00080c	74 03 			je	$JCC2060
	*** 00080e	e9 11 00 		jmp	$I3072
					$JCC2060:
;|***       {
; Line 525
;	msr_char = -6
;|***       // read the rs232 status register
;|***       unsigned msr_char = _inp(COM4_MSR);
; Line 527
	*** 000811	68 ee 02 		push	750	;02eeH
	*** 000814	9a 00 00 00 00 		call	FAR PTR __inp
	*** 000819	83 c4 02 		add	sp,2
	*** 00081c	89 46 fa 		mov	WORD PTR [bp-6],ax	;msr_char
;|***       goto start_com4_isr;
; Line 528
	*** 00081f	e9 c8 ff 		jmp	$start_com4_isr3070
;|***       }
; Line 529
;|***      
;|***     // do tx buffer empty interrupt routine
;|***     if(intr == 1)
; Line 532
					$I3072:
	*** 000822	83 7e fe 01 		cmp	WORD PTR [bp-2],1	;intr
	*** 000826	74 03 			je	$JCC2086
	*** 000828	e9 8b 00 		jmp	$I3074
					$JCC2086:
;|***       {
; Line 533
;|***       // either write to tx FIFO or read int id register again
;|***       
;|***       // the idea here is to continue a tx once it has started,
;|***       // not to start one in the first place
;|***       
;|***       // the tx is started by the main() program writing the first
;|***       // char to the tx buffer, which will send the char out
;|***       
;|***       // once the tx fifo has drained, the tbe bit will be
;|***       // set in the iir, indicating that the tx buffer is ready for more
;|***       
;|***       // we will refill the tx fifo, up to 127 chars, for a total of 128
;|***       if(com4_tx==0)  // no message to tx
; Line 546
	*** 00082b	83 3e 00 00 00 		cmp	WORD PTR ?com4_tx@@3IE,0	;com4_tx
	*** 000830	74 03 			je	$JCC2096
	*** 000832	e9 0e 00 		jmp	$I3075
					$JCC2096:
;|***         {
; Line 547
;|***         _inp(COM4_IIR);
; Line 548
	*** 000835	68 ea 02 		push	746	;02eaH
	*** 000838	9a 00 00 00 00 		call	FAR PTR __inp
	*** 00083d	83 c4 02 		add	sp,2
;|***         goto start_com4_isr;
; Line 549
	*** 000840	e9 a7 ff 		jmp	$start_com4_isr3070
;|***         }
; Line 550
;|***       if(com4_tx==1)  // tx remaining message
; Line 551
					$I3075:
	*** 000843	83 3e 00 00 01 		cmp	WORD PTR ?com4_tx@@3IE,1	;com4_tx
	*** 000848	74 03 			je	$JCC2120
	*** 00084a	e9 66 00 		jmp	$I3076
					$JCC2120:
;|***         {
; Line 552
;|***         for(i=0; i<16;i++) // load 16 characters into the tx fifo
; Line 553
	*** 00084d	c7 46 fc 00 00 		mov	WORD PTR [bp-4],0	;i
	*** 000852	e9 03 00 		jmp	$F3077
					$FC3078:
	*** 000855	ff 46 fc 		inc	WORD PTR [bp-4]	;i
					$F3077:
	*** 000858	83 7e fc 10 		cmp	WORD PTR [bp-4],16	;0010H	;i
	*** 00085c	72 03 			jb	$JCC2140
	*** 00085e	e9 52 00 		jmp	$FB3079
					$JCC2140:
;|***           {
; Line 554
;|***           if(com4_tx==0) break;
; Line 555
	*** 000861	83 3e 00 00 00 		cmp	WORD PTR ?com4_tx@@3IE,0	;com4_tx
	*** 000866	74 03 			je	$JCC2150
	*** 000868	e9 06 00 		jmp	$I3080
					$JCC2150:
	*** 00086b	e9 45 00 		jmp	$FB3079
;|***           else  // only if more message needs to be sent
; Line 556
	*** 00086e	e9 3f 00 		jmp	$I3081
					$I3080:
;|***             {
; Line 557
;|***             _outp(COM4_TX, tx4_message[tx4_index]); // write the next character
; Line 558
	*** 000871	8b 1e 00 00 		mov	bx,WORD PTR ?tx4_index@@3IE	;tx4_index
	*** 000875	8a 87 00 00 		mov	al,BYTE PTR ?tx4_message@@3QEEE[bx]	;tx4_message
	*** 000879	2a e4 			sub	ah,ah
	*** 00087b	50 			push	ax
	*** 00087c	68 e8 02 		push	744	;02e8H
	*** 00087f	9a 00 00 00 00 		call	FAR PTR __outp
	*** 000884	83 c4 04 		add	sp,4
;|***             tx4_index++;
; Line 559
	*** 000887	ff 06 00 00 		inc	WORD PTR ?tx4_index@@3IE	;tx4_index
;|***             tx4_counter++;
; Line 560
	*** 00088b	ff 06 00 00 		inc	WORD PTR ?tx4_counter@@3IE	;tx4_counter
;|***             if(tx4_index >= tx4_len)  // entire message has been sent
; Line 561
	*** 00088f	a1 00 00 		mov	ax,WORD PTR ?tx4_index@@3IE	;tx4_index
	*** 000892	39 06 00 00 		cmp	WORD PTR ?tx4_len@@3IE,ax	;tx4_len
	*** 000896	76 03 			jbe	$JCC2198
	*** 000898	e9 15 00 		jmp	$I3082
					$JCC2198:
;|***               {
; Line 562
;|***               tx4_index = 0;
; Line 563
	*** 00089b	c7 06 00 00 00 00 	mov	WORD PTR ?tx4_index@@3IE,0	;tx4_index
;|***               com4_tx = 0;
; Line 564
	*** 0008a1	c7 06 00 00 00 00 	mov	WORD PTR ?com4_tx@@3IE,0	;com4_tx
;|***               tx4_len = 0;
; Line 565
	*** 0008a7	c7 06 00 00 00 00 	mov	WORD PTR ?tx4_len@@3IE,0	;tx4_len
;|***               goto start_com4_isr;  
; Line 566
	*** 0008ad	e9 3a ff 		jmp	$start_com4_isr3070
;|***               }
; Line 567
;|***             }
; Line 568
					$I3082:
					$I3081:
;|***           }
; Line 569
	*** 0008b0	e9 a2 ff 		jmp	$FC3078
					$FB3079:
;|***         }
; Line 570
;|***       goto start_com4_isr;    
; Line 571
					$I3076:
	*** 0008b3	e9 34 ff 		jmp	$start_com4_isr3070
;|***       }
; Line 572
;|***       
;|***     // rx data received interrupt routine (>= 14 bytes in receive buffer)
;|***     if(intr == 2)
; Line 575
					$I3074:
	*** 0008b6	83 7e fe 02 		cmp	WORD PTR [bp-2],2	;intr
	*** 0008ba	74 03 			je	$JCC2234
	*** 0008bc	e9 41 00 		jmp	$I3083
					$JCC2234:
;|***       {
; Line 576
;|***       // read rx register
;|***             
;|***       // read 12 bytes from the rx register (still at least 2 bytes left)
;|***       for(i = 0; i < 12; i++)
; Line 580
	*** 0008bf	c7 46 fc 00 00 		mov	WORD PTR [bp-4],0	;i
	*** 0008c4	e9 03 00 		jmp	$F3084
					$FC3085:
	*** 0008c7	ff 46 fc 		inc	WORD PTR [bp-4]	;i
					$F3084:
	*** 0008ca	83 7e fc 0c 		cmp	WORD PTR [bp-4],12	;000cH	;i
	*** 0008ce	72 03 			jb	$JCC2254
	*** 0008d0	e9 2a 00 		jmp	$FB3086
					$JCC2254:
;|***         {
; Line 581
;|***         rx4_message[rx4_index] = _inp(COM4_RX);
; Line 582
	*** 0008d3	68 e8 02 		push	744	;02e8H
	*** 0008d6	9a 00 00 00 00 		call	FAR PTR __inp
	*** 0008db	83 c4 02 		add	sp,2
	*** 0008de	8b 1e 00 00 		mov	bx,WORD PTR ?rx4_index@@3IE	;rx4_index
	*** 0008e2	88 87 00 00 		mov	BYTE PTR ?rx4_message@@3QEEE[bx],al	;rx4_message
;|***         rx4_index++;
; Line 583
	*** 0008e6	ff 06 00 00 		inc	WORD PTR ?rx4_index@@3IE	;rx4_index
;|***         if(rx4_index >= 80)
; Line 584
	*** 0008ea	83 3e 00 00 50 		cmp	WORD PTR ?rx4_index@@3IE,80	;0050H	;rx4_index
	*** 0008ef	73 03 			jae	$JCC2287
	*** 0008f1	e9 06 00 		jmp	$I3087
					$JCC2287:
;|***           rx4_index = 0;
; Line 585
	*** 0008f4	c7 06 00 00 00 00 	mov	WORD PTR ?rx4_index@@3IE,0	;rx4_index
;|***         }
; Line 586
					$I3087:
	*** 0008fa	e9 ca ff 		jmp	$FC3085
					$FB3086:
;|***         
;|***       goto start_com4_isr;
; Line 588
	*** 0008fd	e9 ea fe 		jmp	$start_com4_isr3070
;|***       }
; Line 589
;|***     
;|***     // else do serialization error/break routine  
;|***     if(intr == 3)
; Line 592
					$I3083:
	*** 000900	83 7e fe 03 		cmp	WORD PTR [bp-2],3	;intr
	*** 000904	74 03 			je	$JCC2308
	*** 000906	e9 11 00 		jmp	$I3088
					$JCC2308:
;|***       {
; Line 593
;	lsr_char = -6
;|***       // read serialization status register
;|***       unsigned lsr_char = _inp(COM4_LSR);
; Line 595
	*** 000909	68 ed 02 		push	749	;02edH
	*** 00090c	9a 00 00 00 00 		call	FAR PTR __inp
	*** 000911	83 c4 02 		add	sp,2
	*** 000914	89 46 fa 		mov	WORD PTR [bp-6],ax	;msr_char
;|***       goto start_com4_isr;
; Line 596
	*** 000917	e9 d0 fe 		jmp	$start_com4_isr3070
;|***       }
; Line 597
;|***     
;|***     // do rx character timeout routine: message end
;|***     if(intr == 6)
; Line 600
					$I3088:
	*** 00091a	83 7e fe 06 		cmp	WORD PTR [bp-2],6	;intr
	*** 00091e	74 03 			je	$JCC2334
	*** 000920	e9 95 00 		jmp	$I3090
					$JCC2334:
;|***       {
; Line 601
;|***       // drain rx register first
;|***       while((_inp(COM4_LSR) & 0x01) == 1)
; Line 603
					$FC3092:
	*** 000923	68 ed 02 		push	749	;02edH
	*** 000926	9a 00 00 00 00 		call	FAR PTR __inp
	*** 00092b	83 c4 02 		add	sp,2
	*** 00092e	24 01 			and	al,1
	*** 000930	3c 01 			cmp	al,1
	*** 000932	74 03 			je	$JCC2354
	*** 000934	e9 2a 00 		jmp	$FB3093
					$JCC2354:
;|***         {
; Line 604
;|***         rx4_message[rx4_index] = _inp(COM4_RX);
; Line 605
	*** 000937	68 e8 02 		push	744	;02e8H
	*** 00093a	9a 00 00 00 00 		call	FAR PTR __inp
	*** 00093f	83 c4 02 		add	sp,2
	*** 000942	8b 1e 00 00 		mov	bx,WORD PTR ?rx4_index@@3IE	;rx4_index
	*** 000946	88 87 00 00 		mov	BYTE PTR ?rx4_message@@3QEEE[bx],al	;rx4_message
;|***         rx4_index++;
; Line 606
	*** 00094a	ff 06 00 00 		inc	WORD PTR ?rx4_index@@3IE	;rx4_index
;|***         if(rx4_index >= 80)
; Line 607
	*** 00094e	83 3e 00 00 50 		cmp	WORD PTR ?rx4_index@@3IE,80	;0050H	;rx4_index
	*** 000953	73 03 			jae	$JCC2387
	*** 000955	e9 06 00 		jmp	$I3094
					$JCC2387:
;|***           rx4_index = 0;
; Line 608
	*** 000958	c7 06 00 00 00 00 	mov	WORD PTR ?rx4_index@@3IE,0	;rx4_index
;|***         }
; Line 609
					$I3094:
	*** 00095e	e9 c2 ff 		jmp	$FC3092
					$FB3093:
;|***       
;|***       if(rx4_index >= 77) // complete frame received
; Line 611
	*** 000961	83 3e 00 00 4d 		cmp	WORD PTR ?rx4_index@@3IE,77	;004dH	;rx4_index
	*** 000966	73 03 			jae	$JCC2406
	*** 000968	e9 4a 00 		jmp	$I3095
					$JCC2406:
;|***         {
; Line 612
;|***         time_stamp(&gps_time);
; Line 613
	*** 00096b	68 00 00 		push	SEG ?gps_time@@3UTIMER@@E	;gps_time
	*** 00096e	68 00 00 		push	OFFSET ?gps_time@@3UTIMER@@E	;gps_time
	*** 000971	9a 00 00 00 00 		call	FAR PTR ?time_stamp@@ZAXPEUTIMER@@@Z	; time_stamp
	*** 000976	83 c4 04 		add	sp,4
;|***         memcpy(gps_buffer, rx4_message, sizeof(gps_buffer));
; Line 614
	*** 000979	6a 50 			push	80	;0050H
	*** 00097b	1e 			push	ds
	*** 00097c	68 00 00 		push	OFFSET DGROUP:?rx4_message@@3QEEE	;rx4_message
	*** 00097f	1e 			push	ds
	*** 000980	68 00 00 		push	OFFSET ?gps_buffer@@3QEEE	;gps_buffer
	*** 000983	9a 00 00 00 00 		call	FAR PTR _memcpy
	*** 000988	83 c4 0a 		add	sp,10	;000aH
;|***         gps_new_data = 1;
; Line 615
	*** 00098b	c7 06 00 00 01 00 	mov	WORD PTR ?gps_new_data@@3IE,1	;gps_new_data
;|***         gps_data_frame = frame;
; Line 616
	*** 000991	a1 00 00 		mov	ax,WORD PTR ?frame@@3KE	;frame
	*** 000994	8b 16 02 00 		mov	dx,WORD PTR ?frame@@3KE+2	;frame
	*** 000998	a3 00 00 		mov	WORD PTR ?gps_data_frame@@3KE,ax	;gps_data_frame
	*** 00099b	89 16 02 00 		mov	WORD PTR ?gps_data_frame@@3KE+2,dx	;gps_data_frame
;|***         rx4_index = 0;
; Line 617
	*** 00099f	c7 06 00 00 00 00 	mov	WORD PTR ?rx4_index@@3IE,0	;rx4_index
;|***         //for(i=0; i<sizeof(rx4_message); i++)
;|***         //  rx4_message[i] = 0;
;|***         _fmemset(rx4_message, 0, sizeof(rx4_message));
; Line 620
	*** 0009a5	6a 50 			push	80	;0050H
	*** 0009a7	6a 00 			push	0
	*** 0009a9	1e 			push	ds
	*** 0009aa	68 00 00 		push	OFFSET DGROUP:?rx4_message@@3QEEE	;rx4_message
	*** 0009ad	9a 00 00 00 00 		call	FAR PTR __fmemset
	*** 0009b2	83 c4 08 		add	sp,8
;|***         }
; Line 621
;|*** 
;|***       goto start_com4_isr;      
; Line 623
					$I3095:
	*** 0009b5	e9 32 fe 		jmp	$start_com4_isr3070
;|***       } // end rx character timeout routine
; Line 624
;|***         
;|***     goto start_com4_isr;
; Line 626
					$I3090:
	*** 0009b8	e9 2f fe 		jmp	$start_com4_isr3070
;|***     }  // end if((intr & 0x01) == 0)
; Line 627
;|***   
;|***   _disable();  
; Line 629
					$I3071:
	*** 0009bb	9a 00 00 00 00 		call	FAR PTR __disable
;|***   // enable com4 uart interrupts    
;|***   _outp(COM4_MCR, _inp(COM4_MCR) | 0x08);
; Line 631
	*** 0009c0	68 ec 02 		push	748	;02ecH
	*** 0009c3	9a 00 00 00 00 		call	FAR PTR __inp
	*** 0009c8	83 c4 02 		add	sp,2
	*** 0009cb	0d 08 00 		or	ax,8
	*** 0009ce	50 			push	ax
	*** 0009cf	68 ec 02 		push	748	;02ecH
	*** 0009d2	9a 00 00 00 00 		call	FAR PTR __outp
	*** 0009d7	83 c4 04 		add	sp,4
;|***   _outp(0xa0, 0x20);  // non-specific return from interrupt slave pic
; Line 632
	*** 0009da	6a 20 			push	32	;0020H
	*** 0009dc	68 a0 00 		push	160	;00a0H
	*** 0009df	9a 00 00 00 00 		call	FAR PTR __outp
	*** 0009e4	83 c4 04 		add	sp,4
;|***   _outp(0x20, 0x20);  // non-specific return from interrupt master pic
; Line 633
	*** 0009e7	6a 20 			push	32	;0020H
	*** 0009e9	6a 20 			push	32	;0020H
	*** 0009eb	9a 00 00 00 00 		call	FAR PTR __outp
	*** 0009f0	83 c4 04 		add	sp,4
;|***   }  // end com4_isr()
; Line 634
	*** 0009f3	e9 00 00 		jmp	$EX3067
					$EX3067:
	*** 0009f6	8b e5 			mov	sp,bp
	*** 0009f8	07 			pop	es
	*** 0009f9	1f 			pop	ds
	ASSUME DS: DGROUP
	*** 0009fa	61 			popa
	*** 0009fb	cf 			iret	

?com4_isr@@ZAXXZ	ENDP
	PUBLIC	?shutdown_com1@@ZAXXZ	; shutdown_com1
?shutdown_com1@@ZAXXZ	PROC FAR	; shutdown_com1
;|*** 
;|*** 
;|*** void shutdown_com1(void)
;|***   {
; Line 638
	*** 0009fc	c8 00 00 00 		enter	0,0
	*** 000a00	57 			push	di
	*** 000a01	56 			push	si
;|***   _disable();
; Line 639
	*** 000a02	9a 00 00 00 00 		call	FAR PTR __disable
;|***   // disable com1 interrupts at the uart
;|***   _outp( COM1_MCR, 0X00);
; Line 641
	*** 000a07	6a 00 			push	0
	*** 000a09	68 fc 03 		push	1020	;03fcH
	*** 000a0c	9a 00 00 00 00 		call	FAR PTR __outp
	*** 000a11	83 c4 04 		add	sp,4
;|***   _outp( COM1_IER, 0x00);
; Line 642
	*** 000a14	6a 00 			push	0
	*** 000a16	68 f9 03 		push	1017	;03f9H
	*** 000a19	9a 00 00 00 00 		call	FAR PTR __outp
	*** 000a1e	83 c4 04 		add	sp,4
;|***   // mask irq4 interrupts at pic
;|***   _outp(0x21, _inp(0x21) | ~0xef);
; Line 644
	*** 000a21	6a 21 			push	33	;0021H
	*** 000a23	9a 00 00 00 00 		call	FAR PTR __inp
	*** 000a28	83 c4 02 		add	sp,2
	*** 000a2b	0d 10 ff 		or	ax,-240	;ff10H
	*** 000a2e	50 			push	ax
	*** 000a2f	6a 21 			push	33	;0021H
	*** 000a31	9a 00 00 00 00 		call	FAR PTR __outp
	*** 000a36	83 c4 04 		add	sp,4
;|***   // restore original COM1 vector
;|***   _dos_setvect(4+8, com1_old_vector);
; Line 646
	*** 000a39	ff 36 02 00 		push	WORD PTR ?com1_old_vector@@3P7AXXZE+2	;com1_old_vector
	*** 000a3d	ff 36 00 00 		push	WORD PTR ?com1_old_vector@@3P7AXXZE	;com1_old_vector
	*** 000a41	6a 0c 			push	12	;000cH
	*** 000a43	9a 00 00 00 00 		call	FAR PTR __dos_setvect
	*** 000a48	83 c4 06 		add	sp,6
;|***   _enable();
; Line 647
	*** 000a4b	9a 00 00 00 00 		call	FAR PTR __enable
;|***   }
; Line 648
	*** 000a50	e9 00 00 		jmp	$EX3097
					$EX3097:
	*** 000a53	5e 			pop	si
	*** 000a54	5f 			pop	di
	*** 000a55	c9 			leave	
	*** 000a56	cb 			ret	

?shutdown_com1@@ZAXXZ	ENDP
	PUBLIC	?shutdown_com2@@ZAXXZ	; shutdown_com2
?shutdown_com2@@ZAXXZ	PROC FAR	; shutdown_com2
;|***   
;|***   
;|*** void shutdown_com2(void)
;|***   {
; Line 652
	*** 000a57	c8 00 00 00 		enter	0,0
	*** 000a5b	57 			push	di
	*** 000a5c	56 			push	si
;|***   _disable();
; Line 653
	*** 000a5d	9a 00 00 00 00 		call	FAR PTR __disable
;|***   // disable com2 interrupts at the uart
;|***   _outp( COM2_MCR, 0x00);
; Line 655
	*** 000a62	6a 00 			push	0
	*** 000a64	68 fc 02 		push	764	;02fcH
	*** 000a67	9a 00 00 00 00 		call	FAR PTR __outp
	*** 000a6c	83 c4 04 		add	sp,4
;|***   _outp( COM2_IER, 0x00);
; Line 656
	*** 000a6f	6a 00 			push	0
	*** 000a71	68 f9 02 		push	761	;02f9H
	*** 000a74	9a 00 00 00 00 		call	FAR PTR __outp
	*** 000a79	83 c4 04 		add	sp,4
;|***   // mask irq3 interrupts at pic
;|***   _outp(0x21, _inp(0x21) | ~0xf7); 
; Line 658
	*** 000a7c	6a 21 			push	33	;0021H
	*** 000a7e	9a 00 00 00 00 		call	FAR PTR __inp
	*** 000a83	83 c4 02 		add	sp,2
	*** 000a86	0d 08 ff 		or	ax,-248	;ff08H
	*** 000a89	50 			push	ax
	*** 000a8a	6a 21 			push	33	;0021H
	*** 000a8c	9a 00 00 00 00 		call	FAR PTR __outp
	*** 000a91	83 c4 04 		add	sp,4
;|***   // restore original COM2 vector
;|***   _dos_setvect(3+8, com2_old_vector);
; Line 660
	*** 000a94	ff 36 02 00 		push	WORD PTR ?com2_old_vector@@3P7AXXZE+2	;com2_old_vector
	*** 000a98	ff 36 00 00 		push	WORD PTR ?com2_old_vector@@3P7AXXZE	;com2_old_vector
	*** 000a9c	6a 0b 			push	11	;000bH
	*** 000a9e	9a 00 00 00 00 		call	FAR PTR __dos_setvect
	*** 000aa3	83 c4 06 		add	sp,6
;|***   _enable();
; Line 661
	*** 000aa6	9a 00 00 00 00 		call	FAR PTR __enable
;|***   }
; Line 662
	*** 000aab	e9 00 00 		jmp	$EX3099
					$EX3099:
	*** 000aae	5e 			pop	si
	*** 000aaf	5f 			pop	di
	*** 000ab0	c9 			leave	
	*** 000ab1	cb 			ret	

?shutdown_com2@@ZAXXZ	ENDP
	PUBLIC	?shutdown_com4@@ZAXXZ	; shutdown_com4
?shutdown_com4@@ZAXXZ	PROC FAR	; shutdown_com4
;|***   
;|*** 
;|*** void shutdown_com4(void)
;|***   {
; Line 666
	*** 000ab2	c8 00 00 00 		enter	0,0
	*** 000ab6	57 			push	di
	*** 000ab7	56 			push	si
;|***   _disable();
; Line 667
	*** 000ab8	9a 00 00 00 00 		call	FAR PTR __disable
;|***   // disable com4 interrupts at the uart
;|***   _outp( COM4_MCR, 0x00);
; Line 669
	*** 000abd	6a 00 			push	0
	*** 000abf	68 ec 02 		push	748	;02ecH
	*** 000ac2	9a 00 00 00 00 		call	FAR PTR __outp
	*** 000ac7	83 c4 04 		add	sp,4
;|***   _outp( COM4_IER, 0x00);
; Line 670
	*** 000aca	6a 00 			push	0
	*** 000acc	68 e9 02 		push	745	;02e9H
	*** 000acf	9a 00 00 00 00 		call	FAR PTR __outp
	*** 000ad4	83 c4 04 		add	sp,4
;|***   // mask irq9 interrupts at pic
;|***   _outp(0xa1, _inp(0xa1) | ~0xfd); 
; Line 672
	*** 000ad7	68 a1 00 		push	161	;00a1H
	*** 000ada	9a 00 00 00 00 		call	FAR PTR __inp
	*** 000adf	83 c4 02 		add	sp,2
	*** 000ae2	0d 02 ff 		or	ax,-254	;ff02H
	*** 000ae5	50 			push	ax
	*** 000ae6	68 a1 00 		push	161	;00a1H
	*** 000ae9	9a 00 00 00 00 		call	FAR PTR __outp
	*** 000aee	83 c4 04 		add	sp,4
;|***   // restore original COM4 vector
;|***   _dos_setvect(9+0x70-8, com4_old_vector);
; Line 674
	*** 000af1	ff 36 02 00 		push	WORD PTR ?com4_old_vector@@3P7AXXZE+2	;com4_old_vector
	*** 000af5	ff 36 00 00 		push	WORD PTR ?com4_old_vector@@3P7AXXZE	;com4_old_vector
	*** 000af9	6a 71 			push	113	;0071H
	*** 000afb	9a 00 00 00 00 		call	FAR PTR __dos_setvect
	*** 000b00	83 c4 06 		add	sp,6
;|***   _enable();
; Line 675
	*** 000b03	9a 00 00 00 00 		call	FAR PTR __enable
;|***   }
; Line 676
	*** 000b08	e9 00 00 		jmp	$EX3101
					$EX3101:
	*** 000b0b	5e 			pop	si
	*** 000b0c	5f 			pop	di
	*** 000b0d	c9 			leave	
	*** 000b0e	cb 			ret	

?shutdown_com4@@ZAXXZ	ENDP
	PUBLIC	??6ostream@@RECAEV0@P7AAEV0@AEV0@@Z@Z	; ostream::operator<<
??6ostream@@RECAEV0@P7AAEV0@AEV0@@Z@Z	PROC FAR	; ostream::operator<< COMDAT
;|*** /***
;|*** *ostream.h - definitions/declarations for the ostream class
;|*** *
;|*** *   Copyright (c) 1991-1992, Microsoft Corporation.  All rights reserved.
;|*** *
;|*** *Purpose:
;|*** *   This file defines the classes, values, macros, and functions
;|*** *   used by the ostream class.
;|*** *   [AT&T C++]
;|*** *
;|*** ****/
;|*** 
;|*** #ifndef _INC_OSTREAM
;|*** #define _INC_OSTREAM
;|*** 
;|*** #include <ios.h>
;|*** 
;|*** // Force word packing to avoid possible -Zp override
;|*** #pragma pack(2)
;|*** 
;|*** #pragma warning(disable:4505)       // disable unwanted /W4 warning
;|*** // #pragma warning(default:4505)    // use this to reenable, if necessary
;|*** 
;|*** #ifdef M_I86HM
;|*** #define _HFAR_ __far
;|*** #else 
;|*** #define _HFAR_
;|*** #endif 
;|*** 
;|*** typedef long streamoff, streampos;
;|*** 
;|*** class ostream : virtual public ios {
;|*** 
;|*** public:
;|***     ostream(streambuf*);
;|***     virtual ~ostream();
;|*** 
;|***     ostream& flush();
;|***     int  opfx();
;|***     void osfx();
;|*** 
;|*** inline  ostream& operator<<(ostream& (*f)(ostream&));
;|*** inline  ostream& operator<<(ios& (*f)(ios&));
;|***     ostream& operator<<(const char _HFAR_ *);
;|*** inline  ostream& operator<<(const unsigned char _HFAR_ *);
;|*** inline  ostream& operator<<(const signed char _HFAR_ *);
;|*** inline  ostream& operator<<(char);
;|***     ostream& operator<<(unsigned char);
;|*** inline  ostream& operator<<(signed char);
;|***     ostream& operator<<(short);
;|***     ostream& operator<<(unsigned short);
;|***     ostream& operator<<(int);
;|***     ostream& operator<<(unsigned int);
;|***     ostream& operator<<(long);
;|***     ostream& operator<<(unsigned long);
;|*** inline  ostream& operator<<(float);
;|***     ostream& operator<<(double);
;|***     ostream& operator<<(long double);
;|***     ostream& operator<<(const void _HFAR_ *);
;|***     ostream& operator<<(streambuf*);
;|*** inline  ostream& put(char);
;|***     ostream& put(unsigned char);
;|*** inline  ostream& put(signed char);
;|***     ostream& write(const char _HFAR_ *,int);
;|*** inline  ostream& write(const unsigned char _HFAR_ *,int);
;|*** inline  ostream& write(const signed char _HFAR_ *,int);
;|***     ostream& seekp(streampos);
;|***     ostream& seekp(streamoff,ios::seek_dir);
;|***     streampos tellp();
;|*** 
;|*** protected:
;|***     ostream();
;|***     ostream(const ostream&);    // treat as private
;|***     ostream& operator=(streambuf*); // treat as private
;|***     ostream& operator=(const ostream& _os) {return operator=(_os.rdbuf()); }
;|***     int do_opfx(int);       // not used
;|***     void do_osfx();         // not used
;|*** 
;|*** private:
;|***     ostream(ios&);
;|***     ostream& writepad(const char _HFAR_ *, const char _HFAR_ *);
;|***     int x_floatused;
;|*** };
;|*** 
;|*** inline ostream& ostream::operator<<(ostream& (*f)(ostream&)) { (*f)(*this); return *this; }
; Line 85
	*** 000000	c8 00 00 00 		enter	0,0
	*** 000004	57 			push	di
	*** 000005	56 			push	si
;	this = 6
;	f = 10
	*** 000006	ff 76 08 		push	WORD PTR [bp+8]
	*** 000009	ff 76 06 		push	WORD PTR [bp+6]	;this
	*** 00000c	ff 5e 0a 		call	DWORD PTR [bp+10]	;f
	*** 00000f	83 c4 04 		add	sp,4
	*** 000012	8b 46 06 		mov	ax,WORD PTR [bp+6]	;this
	*** 000015	8b 56 08 		mov	dx,WORD PTR [bp+8]
	*** 000018	e9 00 00 		jmp	$EX2658
					$EX2658:
	*** 00001b	5e 			pop	si
	*** 00001c	5f 			pop	di
	*** 00001d	c9 			leave	
	*** 00001e	ca 08 00 		ret	8

??6ostream@@RECAEV0@P7AAEV0@AEV0@@Z@Z	ENDP
	PUBLIC	?endl@@ZAAEVostream@@AEV1@@Z	; endl
?endl@@ZAAEVostream@@AEV1@@Z	PROC FAR	; endl COMDAT
;|*** inline ostream& ostream::operator<<(ios& (*f)(ios& )) { (*f)(*this); return *this; }
;|*** 
;|*** inline  ostream& ostream::operator<<(char c) { return operator<<((unsigned char) c); }
;|*** inline  ostream& ostream::operator<<(signed char c) { return operator<<((unsigned char) c); }
;|*** 
;|*** inline  ostream& ostream::operator<<(const unsigned char _HFAR_ * s) { return operator<<((const char _HFAR_ *) s); }
;|*** inline  ostream& ostream::operator<<(const signed char _HFAR_ * s) { return operator<<((const char _HFAR_ *) s); }
;|*** 
;|*** inline  ostream& ostream::operator<<(float f) { x_floatused = 1; return operator<<((double) f); }
;|*** 
;|*** inline  ostream& ostream::put(char c) { return put((unsigned char) c); }
;|*** inline  ostream& ostream::put(signed char c) { return put((unsigned char) c); }
;|*** 
;|*** inline  ostream& ostream::write(const unsigned char _HFAR_ * s, int n) { return write((char _HFAR_ *) s, n); }
;|*** inline  ostream& ostream::write(const signed char _HFAR_ * s, int n) { return write((char _HFAR_ *) s, n); }
;|*** 
;|*** 
;|*** class ostream_withassign : public ostream {
;|***     public:
;|***         ostream_withassign();
;|***         ostream_withassign(streambuf* _is);
;|***         ~ostream_withassign();
;|***     ostream& operator=(const ostream& _os) { return ostream::operator=(_os.rdbuf()); }
;|***     ostream& operator=(streambuf* _sb) { return ostream::operator=(_sb); }
;|*** };
;|*** 
;|*** #ifndef _WINDLL
;|*** extern ostream_withassign cout;
;|*** extern ostream_withassign cerr;
;|*** extern ostream_withassign clog;
;|*** #endif 
;|*** 
;|*** inline ostream& flush(ostream& _outs) { return _outs.flush(); }
;|*** inline ostream& endl(ostream& _outs) { return _outs << '\n' << flush; }
; Line 119
	*** 000000	c8 00 00 00 		enter	0,0
	*** 000004	57 			push	di
	*** 000005	56 			push	si
;	_outs = 6
	*** 000006	68 00 00 		push	SEG ?flush@@ZAAEVostream@@AEV1@@Z	;flush
	*** 000009	68 00 00 		push	OFFSET ?flush@@ZAAEVostream@@AEV1@@Z	;flush
	*** 00000c	6a 0a 			push	10	;000aH
	*** 00000e	ff 76 08 		push	WORD PTR [bp+8]
	*** 000011	ff 76 06 		push	WORD PTR [bp+6]	;_outs
	*** 000014	9a 00 00 00 00 		call	FAR PTR ??6ostream@@RECAEV0@D@Z	; ostream::operator<<
	*** 000019	52 			push	dx
	*** 00001a	50 			push	ax
	*** 00001b	9a 00 00 00 00 		call	FAR PTR ??6ostream@@RECAEV0@P7AAEV0@AEV0@@Z@Z	; ostream::operator<<
	*** 000020	e9 00 00 		jmp	$EX2742
					$EX2742:
	*** 000023	5e 			pop	si
	*** 000024	5f 			pop	di
	*** 000025	c9 			leave	
	*** 000026	cb 			ret	

?endl@@ZAAEVostream@@AEV1@@Z	ENDP
	PUBLIC	??6ostream@@RECAEV0@D@Z	; ostream::operator<<
??6ostream@@RECAEV0@D@Z	PROC FAR	; ostream::operator<< COMDAT
;|*** inline  ostream& ostream::operator<<(char c) { return operator<<((unsigned char) c); }
; Line 88
	*** 000000	c8 00 00 00 		enter	0,0
	*** 000004	57 			push	di
	*** 000005	56 			push	si
;	this = 6
;	c = 10
	*** 000006	8a 46 0a 		mov	al,BYTE PTR [bp+10]	;c
	*** 000009	50 			push	ax
	*** 00000a	ff 76 08 		push	WORD PTR [bp+8]
	*** 00000d	ff 76 06 		push	WORD PTR [bp+6]	;this
	*** 000010	9a 00 00 00 00 		call	FAR PTR ??6ostream@@RECAEV0@E@Z	; ostream::operator<<
	*** 000015	e9 00 00 		jmp	$EX2665
					$EX2665:
	*** 000018	5e 			pop	si
	*** 000019	5f 			pop	di
	*** 00001a	c9 			leave	
	*** 00001b	ca 06 00 		ret	6

??6ostream@@RECAEV0@D@Z	ENDP
	PUBLIC	?flush@@ZAAEVostream@@AEV1@@Z	; flush
?flush@@ZAAEVostream@@AEV1@@Z	PROC FAR	; flush COMDAT
;|*** inline  ostream& ostream::operator<<(signed char c) { return operator<<((unsigned char) c); }
;|*** 
;|*** inline  ostream& ostream::operator<<(const unsigned char _HFAR_ * s) { return operator<<((const char _HFAR_ *) s); }
;|*** inline  ostream& ostream::operator<<(const signed char _HFAR_ * s) { return operator<<((const char _HFAR_ *) s); }
;|*** 
;|*** inline  ostream& ostream::operator<<(float f) { x_floatused = 1; return operator<<((double) f); }
;|*** 
;|*** inline  ostream& ostream::put(char c) { return put((unsigned char) c); }
;|*** inline  ostream& ostream::put(signed char c) { return put((unsigned char) c); }
;|*** 
;|*** inline  ostream& ostream::write(const unsigned char _HFAR_ * s, int n) { return write((char _HFAR_ *) s, n); }
;|*** inline  ostream& ostream::write(const signed char _HFAR_ * s, int n) { return write((char _HFAR_ *) s, n); }
;|*** 
;|*** 
;|*** class ostream_withassign : public ostream {
;|***     public:
;|***         ostream_withassign();
;|***         ostream_withassign(streambuf* _is);
;|***         ~ostream_withassign();
;|***     ostream& operator=(const ostream& _os) { return ostream::operator=(_os.rdbuf()); }
;|***     ostream& operator=(streambuf* _sb) { return ostream::operator=(_sb); }
;|*** };
;|*** 
;|*** #ifndef _WINDLL
;|*** extern ostream_withassign cout;
;|*** extern ostream_withassign cerr;
;|*** extern ostream_withassign clog;
;|*** #endif 
;|*** 
;|*** inline ostream& flush(ostream& _outs) { return _outs.flush(); }
; Line 118
	*** 000000	c8 00 00 00 		enter	0,0
	*** 000004	57 			push	di
	*** 000005	56 			push	si
;	_outs = 6
	*** 000006	ff 76 08 		push	WORD PTR [bp+8]
	*** 000009	ff 76 06 		push	WORD PTR [bp+6]	;_outs
	*** 00000c	9a 00 00 00 00 		call	FAR PTR ?flush@ostream@@RECAEV1@XZ	; ostream::flush
	*** 000011	e9 00 00 		jmp	$EX2739
					$EX2739:
	*** 000014	5e 			pop	si
	*** 000015	5f 			pop	di
	*** 000016	c9 			leave	
	*** 000017	cb 			ret	

?flush@@ZAAEVostream@@AEV1@@Z	ENDP
RS232_TEXT	ENDS
END
