;	Static Name Aliases
;
;	$S4049__aam	EQU	_aam
;	$S4057__aao	EQU	_aao
	TITLE   c:\cba\cba.cpp
	.286p
INCLUDELIB      LLIBCE
INCLUDELIB	OLDNAMES.LIB
CBA_TEXT	SEGMENT  WORD PUBLIC 'CODE'
CBA_TEXT	ENDS
_DATA	SEGMENT  WORD PUBLIC 'DATA'
_DATA	ENDS
CONST	SEGMENT  WORD PUBLIC 'CONST'
CONST	ENDS
_BSS	SEGMENT  WORD PUBLIC 'BSS'
_BSS	ENDS
XIFCB	SEGMENT  WORD PUBLIC 'DATA'
XIFCB	ENDS
XIFU	SEGMENT  WORD PUBLIC 'DATA'
XIFU	ENDS
XIFL	SEGMENT  WORD PUBLIC 'DATA'
XIFL	ENDS
XIFM	SEGMENT  WORD PUBLIC 'DATA'
XIFM	ENDS
XIFCE	SEGMENT  WORD PUBLIC 'DATA'
XIFCE	ENDS
XOB	SEGMENT  WORD PUBLIC 'BSS'
XOB	ENDS
XO	SEGMENT  WORD PUBLIC 'BSS'
XO	ENDS
XOE	SEGMENT  WORD PUBLIC 'BSS'
XOE	ENDS
CBA13_DATA	SEGMENT  PARA PUBLIC 'FAR_DATA'
CBA13_DATA	ENDS
DGROUP	GROUP	CONST, _BSS, _DATA
	ASSUME DS: DGROUP, SS: DGROUP
PUBLIC  ?adcp@@3UADCP@@E
PUBLIC  ?pcm_sent@@3HE
PUBLIC  ?data_ready@@3IE
PUBLIC  ?ln200@@3ULN200@@E
PUBLIC  ?send_message@@3HE
PUBLIC  ?obc_mac@@3QIEI
PUBLIC  ?micron_mac@@3QIEI
PUBLIC  ?control_mac@@3QIEI
PUBLIC  ?broadcast_mac@@3QIEI
PUBLIC  ?shore_mac@@3QIEI
PUBLIC  ?cmd_buffer@@3QEEE
PUBLIC  ?gps@@3UGPS@@E
PUBLIC  ?sys@@3USYS@@E
PUBLIC  ?sys_frame@@3KE
PUBLIC  ?sys_status@@3IE
PUBLIC  ?commands@@3UCOMMANDS@@E
PUBLIC  ?mux_addr@@3IE
PUBLIC  ?time_since_last_command@@3HE
PUBLIC  ?sys_timer@@3UTIMER@@E
PUBLIC  ?frame_time@@3UTIMER@@E
PUBLIC  ?obs@@3UOBS@@E
PUBLIC  ?obs_time@@3UTIMER@@E
PUBLIC  ?dyno_time@@3UTIMER@@E
PUBLIC  ?prop_rpm_time@@3UTIMER@@E
PUBLIC  ?prop_position_time@@3UTIMER@@E
PUBLIC  ?prop_position_time_previous@@3UTIMER@@E
PUBLIC  ?prop_adc_time@@3UTIMER@@E
PUBLIC  ?prop_position@@3JE
PUBLIC  ?ln200_time@@3UTIMER@@E
PUBLIC  ?echo@@3UECHO@@E
PUBLIC  ?cmds_time@@3UTIMER@@E
PUBLIC  ?ds_time@@3UTIMER@@E
PUBLIC  ?prop_index@@3JE
PUBLIC  ?adcp_time@@3UTIMER@@E
PUBLIC  ?prop_position_absolute_current@@3JE
PUBLIC  ?gps_time@@3UTIMER@@E
PUBLIC  ?prop_position_absolute_previous@@3JE
PUBLIC  ?dyno@@3UDYNO@@E
PUBLIC  ?settings@@3Uescc_regs@@E
PUBLIC  ?escc1@@3VCescc@@E
PUBLIC  ?ln200_rx_num@@3KE
PUBLIC  ?ds@@3UDS@@E
PUBLIC  ?stern1_cmd@@3IE
PUBLIC  ?stern2_cmd@@3IE
PUBLIC  ?fore_cmd@@3IE
PUBLIC  ?rudder_cmd@@3IE
PUBLIC  ?prop_cmd@@3IE
PUBLIC  ?prop@@3UPROP@@E
EXTRN	__acrtused:ABS
EXTRN	__fltused:ABS
EXTRN	__aFuldiv:FAR
EXTRN	??6ostream@@RECAEV0@E@Z:FAR
EXTRN	_te5650CapturePos:FAR
EXTRN	__aFulmul:FAR
EXTRN	?set_tx_type@Cescc@@RECIII@Z:FAR
EXTRN	__aFfldl:FAR
EXTRN	__aFfmuls:FAR
EXTRN	_te5650MotorOff:FAR
EXTRN	??6ostream@@RECAEV0@F@Z:FAR
EXTRN	__aFftol:FAR
EXTRN	_te5650SetAxis:FAR
EXTRN	??6ostream@@RECAEV0@H@Z:FAR
EXTRN	??6ostream@@RECAEV0@I@Z:FAR
EXTRN	__fatexit:FAR
EXTRN	?read_port@@ZAIH@Z:FAR
EXTRN	__chain_intr:FAR
EXTRN	??0Cescc@@REC@XZ:FAR
EXTRN	??1Cescc@@REC@XZ:FAR
EXTRN	??6ostream@@RECAEV0@N@Z:FAR
EXTRN	_te5650SetMotor:FAR
EXTRN	_te5650PhasesPolarity:FAR
EXTRN	?set_clock_generator@Cescc@@RECXIKI@Z:FAR
EXTRN	_system:FAR
EXTRN	_te5650InitServo:FAR
EXTRN	?receiver@@ZAXIIIIIIIIIIIII@Z:FAR
EXTRN	_te5650InitSw:FAR
EXTRN	?add_port@Cescc@@RECIIIIII@Z:FAR
EXTRN	?driver_info@@ZAHI@Z:FAR
EXTRN	?kill_port@Cescc@@RECII@Z:FAR
EXTRN	__AHINCR:FAR
EXTRN	?init_port@Cescc@@RECIIIPEUescc_regs@@II@Z:FAR
EXTRN	__dos_setvect:FAR
EXTRN	__aFeldw:FAR
EXTRN	?init_com1@@ZAXXZ:FAR
EXTRN	__aFflds:FAR
EXTRN	__aFfmuld:FAR
EXTRN	_sprintf:FAR
EXTRN	__aFdcvt:FAR
EXTRN	_te5650IsCapture:FAR
EXTRN	_te5650ActPos:FAR
EXTRN	?init_com2@@ZAXXZ:FAR
EXTRN	__aFfstdp:FAR
EXTRN	__getch:FAR
EXTRN	?init_com4@@ZAXXZ:FAR
EXTRN	?tx_port@Cescc@@RECIIPEDI@Z:FAR
EXTRN	?flush@ostream@@RECAEV1@XZ:FAR
EXTRN	?shutdown_com1@@ZAXXZ:FAR
EXTRN	_te5650Update:FAR
EXTRN	?shutdown_com2@@ZAXXZ:FAR
EXTRN	_exit:FAR
EXTRN	?access_type@@ZAHHHHPEDIP7AXIIIIIIIIIIIII@Z@Z:FAR
EXTRN	__kbhit:FAR
EXTRN	?clear_rx_buffer@Cescc@@RECII@Z:FAR
EXTRN	?send_pkt@@ZAHPEEI@Z:FAR
EXTRN	_te5650ResetCapture:FAR
EXTRN	?clear_tx_buffer@Cescc@@RECII@Z:FAR
EXTRN	?terminate@@ZAHH@Z:FAR
EXTRN	__dos_getvect:FAR
EXTRN	??6ostream@@RECAEV0@PFD@Z:FAR
EXTRN	?init_io@@ZAXI@Z:FAR
EXTRN	?read_bit@@ZAHH@Z:FAR
EXTRN	?write_bit@@ZAXHH@Z:FAR
EXTRN	_te5650CaptureIndex:FAR
EXTRN	?handle@@3HE:WORD
EXTRN	?packets_rcvd@@3KE:DWORD
EXTRN	?ax0_counter@@3KE:DWORD
EXTRN	?ax1_counter@@3KE:DWORD
EXTRN	?discards@@3KE:DWORD
EXTRN	?receiver_calls@@3KE:DWORD
EXTRN	?basefield@ios@@2JF:DWORD
EXTRN	?x_statebuf@ios@@0PEJE:DWORD
EXTRN	?cout@@3Vostream_withassign@@E:BYTE
_DATA      SEGMENT
?pcm_sent@@3HE	DW	00H
?send_message@@3HE	DW	00H
?obc_mac@@3QIEI	DB	00H
	DB	01H
	DB	045H
	DB	00H
	DB	07aH
	DB	0a0H
?micron_mac@@3QIEI	DB	08H
	DB	00H
	DB	017H
	DB	08H
	DB	087H
	DB	04dH
?control_mac@@3QIEI	DB	00H
	DB	01H
	DB	045H
	DB	00H
	DB	08aH
	DB	021H
?broadcast_mac@@3QIEI	DB	0ffH
	DB	0ffH
	DB	0ffH
	DB	0ffH
	DB	0ffH
	DB	0ffH
?shore_mac@@3QIEI	DB	00H
	DB	0eH
	DB	0a6H
	DB	0b6H
	DB	0c0H
	DB	04eH
?sys_frame@@3KE	DD	00H
?sys_status@@3IE	DW	00H
?mux_addr@@3IE	DW	00H
?prop_position@@3JE	DD	00H
?prop_index@@3JE	DD	00H
?prop_position_absolute_current@@3JE	DD	00H
?prop_position_absolute_previous@@3JE	DD	00H
?ln200_rx_num@@3KE	DD	00H
?time_since_last_command@@3HE	DW	00H
?stern1_cmd@@3IE	DW	00H
?stern2_cmd@@3IE	DW	00H
?fore_cmd@@3IE	DW	00H
?rudder_cmd@@3IE	DW	00H
?prop_cmd@@3IE	DW	00H
?data_ready@@3IE	DW	00H
$SG3698	DB	'Stern1:    %04x',  00H
$SG3706	DB	'Stern2:    %04x',  00H
$SG3720	DB	'Rudder:    %04x',  00H
$SG3728	DB	'Prop:      %04x',  00H
$SG3730	DB	'Ballast:   %04x',  00H
$SG3752	DB	'Timer configured OK.',  00H
$SG3753	DB	'Packet driver loaded OK.',  00H
$SG3754	DB	'Dmm32A OK.',  00H
$SG3755	DB	'Dmm32B a OK.',  00H
$SG3758	DB	'te5650InitSw:    ',  00H
$SG3759	DB	'te5650InitServo: ',  00H
$SG3760	DB	'te5650SetAxis:   ',  00H
$SG3761	DB	'Tech80 configured OK.',  00H
$SG3768	DB	'c:\packet\pktdrv\ne2000 0x7e 10 0x300',  00H
$SG3769	DB	'Access_type() error: ',  00H
$SG3770	DB	'Handle: ',  00H
$SG3771	DB	'Driver_info() error: ',  00H
$SG3772	DB	'Rpm_sf: ',  00H
$SG3775	DB	'Channel A = ',  00H
$SG3776	DB	'Channel B = ',  00H
$SG3777	DB	'initializing channel a',  00H
$SG3779	DB	'Intialize Channel A OK.',  00H
$SG3781	DB	'Initialize Channel A FAILED!',  00H
$SG3783	DB	'Channel A rx buffer cleared OK.  ',  00H
$SG3785	DB	'Channel A rx buffer clear FAILED!',  00H
$SG3787	DB	'Channel A tx buffer cleared OK.',  00H
$SG3789	DB	'Channel A tx buffer clear FAILED!',  00H
$SG3791	DB	'Channel A set to Transparent Mode.  ',  00H
$SG3793	DB	'Channel A Transparent Mode not set!  Channel not open!',  00H
$SG3795	DB	'Intialize Channel B OK.',  00H
$SG3797	DB	'Initialize Channel B FAILED!',  00H
$SG3799	DB	'Channel B rx buffer cleared OK.  ',  00H
$SG3801	DB	'Channel B rx buffer clear FAILED!',  00H
$SG3803	DB	'Channel B tx buffer cleared OK.',  00H
$SG3805	DB	'Channel B tx buffer clear FAILED!',  00H
$SG3807	DB	'Channel B set to Transparent Mode.  ',  00H
$SG3809	DB	'Channel B Transparent Mode not set!  Channel not open!',  00H
$SG3815	DB	'Pitch:   %04x  %10.2f deg',  00H
$SG3817	DB	'Roll:    %04x  %10.2f deg',  00H
$SG3819	DB	'Heading: %04x  %10.2f deg',  00H
$SG3821	DB	'Stern 1: %04x',  00H
$SG3823	DB	'Stern 2: %04x',  00H
$SG3825	DB	'Rudder:  %04x',  00H
$SG3827	DB	'Fore:    %04x',  00H
$SG3829	DB	'RawPos:    %08ld',  00H
$SG3831	DB	'RawIndex:    %08ld',  00H
$SG3833	DB	'PPos:    %08d',  00H
$SG3901	DB	'    Frame # ',  00H
$SG3902	DB	'Frame start:   ',  00H
$SG3903	DB	'%s%8lu %5u%s%8lu',  00H
$SG3905	DB	'OBS data:      ',  00H
$SG3906	DB	'%s%8lu %5u',  00H
$SG3908	DB	'Dyno data:     ',  00H
$SG3909	DB	'%s%8lu %5u',  00H
$SG3911	DB	'Prop adc:      ',  00H
$SG3912	DB	'%s%8lu %5u',  00H
$SG3914	DB	'Prop position: ',  00H
$SG3915	DB	'%s%8lu %5u',  00H
$SG3917	DB	'Commands rcvd: ',  00H
$SG3918	DB	'%s%8lu %5u',  00H
$SG3920	DB	'ADCP rcvd:     ',  00H
$SG3921	DB	'%s%8lu %5u',  00H
$SG3923	DB	'DS rcvd:       ',  00H
$SG3924	DB	'%s%8lu %5u',  00H
$SG3926	DB	'    LN200 # ',  00H
$SG3927	DB	'LN200 rcvd:    ',  00H
$SG3928	DB	'%s%8lu %5u%s%8lu ',  00H
$SG3930	DB	'Received packets: ',  00H
$SG3931	DB	'%s%lu',  00H
$SG3933	DB	'Ax0 count:        ',  00H
$SG3934	DB	'%s%lu',  00H
$SG3936	DB	'Ax1 count:        ',  00H
$SG3937	DB	'%s%lu',  00H
$SG3939	DB	'Discards:         ',  00H
$SG3940	DB	'%s%lu',  00H
$SG3942	DB	'Receiver calls:   ',  00H
$SG3943	DB	'%s%lu',  00H
$SG4004	DB	'                       Autonomous Model Onboard Computer    '
	DB	'                    ',  00H
$SG4005	DB	'%s',  00H
$SG4007	DB	'                               NSWC-CD Code 5600            '
	DB	'                    ',  00H
$SG4008	DB	'%s',  00H
$SG4010	DB	'                             March 8, 2004 Rev 0.8          '
	DB	'                    ',  00H
$SG4011	DB	'%s',  00H
_DATA      ENDS
XIFU      SEGMENT
$S4057__aao	DD	_aan
XIFU      ENDS
_BSS      SEGMENT
	ORG	$+2738
PUBLIC  ?adcp_data_frame@@3KE
?adcp_data_frame@@3KE	DW 02H DUP (?)
PUBLIC  ?adcp_array@@3QIEI
?adcp_array@@3QIEI	DB 0d5H DUP (?)
	ORG	$+1
PUBLIC  ?adcp_buffer@@3QIEI
?adcp_buffer@@3QIEI	DB 0d5H DUP (?)
	ORG	$+1
PUBLIC  ?adcp_test@@3QIEI
?adcp_test@@3QIEI	DW 02cH DUP (?)
PUBLIC  ?gps_new_data@@3IE
?gps_new_data@@3IE	DW 01H DUP (?)
PUBLIC  ?gps_data_frame@@3KE
?gps_data_frame@@3KE	DW 02H DUP (?)
_BSS      ENDS
CBA13_DATA      SEGMENT
	ORG	$+2632
?adcp@@3UADCP@@E	DB 0e1H DUP (?)
CBA13_DATA      ENDS
_BSS      SEGMENT
PUBLIC  ?gps_array@@3QIEI
?gps_array@@3QIEI	DW 028H DUP (?)
PUBLIC  ?gps_buffer@@3QIEI
?gps_buffer@@3QIEI	DW 028H DUP (?)
	ORG	$-3424
PUBLIC  ?pcm@@3QIDI
?pcm@@3QIDI	DW 078H DUP (?)
	ORG	$+3202
PUBLIC  ?ip_id@@3IE
?ip_id@@3IE	DW 01H DUP (?)
	ORG	$-3204
PUBLIC  ?s@@3QIDI
?s@@3QIDI	DB 051H DUP (?)
_BSS      ENDS
CBA13_DATA      SEGMENT
	ORG	$-445
?ln200@@3ULN200@@E	DW 016H DUP (?)
CBA13_DATA      ENDS
_BSS      SEGMENT
	ORG	$+1
PUBLIC  ?acoustic_message@@3QIDI
?acoustic_message@@3QIDI	DW 03H DUP (?)
_BSS      ENDS
XO      SEGMENT
$S4049__aam	DW 02H DUP (?)
XO      ENDS
CBA13_DATA      SEGMENT
	ORG	$-2456
?cmd_buffer@@3QEEE	DW 03ecH DUP (?)
	ORG	$+850
?gps@@3UGPS@@E	DW 02eH DUP (?)
	ORG	$-942
?sys@@3USYS@@E	DW 09H DUP (?)
CBA13_DATA      ENDS
_BSS      SEGMENT
PUBLIC  ?channela@@3IE
?channela@@3IE	DW 01H DUP (?)
PUBLIC  ?channelb@@3IE
?channelb@@3IE	DW 01H DUP (?)
PUBLIC  ?frame@@3KE
?frame@@3KE	DW 02H DUP (?)
PUBLIC  ?next_frame@@3KE
?next_frame@@3KE	DW 02H DUP (?)
PUBLIC  ?reading_prop@@3IE
?reading_prop@@3IE	DW 01H DUP (?)
_BSS      ENDS
CBA13_DATA      SEGMENT
	ORG	$+430
?commands@@3UCOMMANDS@@E	DW 012H DUP (?)
CBA13_DATA      ENDS
_BSS      SEGMENT
PUBLIC  ?data_pkt@@3QIEI
?data_pkt@@3QIEI	DW 02f5H DUP (?)
PUBLIC  ?obs_new_data@@3IE
?obs_new_data@@3IE	DW 01H DUP (?)
PUBLIC  ?obs_data_frame@@3KE
?obs_data_frame@@3KE	DW 02H DUP (?)
PUBLIC  ?obs_array@@3QIII
?obs_array@@3QIII	DW 020H DUP (?)
PUBLIC  ?obs_buffer@@3QIEI
?obs_buffer@@3QIEI	DW 020H DUP (?)
_BSS      ENDS
CBA13_DATA      SEGMENT
	ORG	$+458
?sys_timer@@3UTIMER@@E	DW 03H DUP (?)
CBA13_DATA      ENDS
_BSS      SEGMENT
PUBLIC  ?dyno_new_data@@3IE
?dyno_new_data@@3IE	DW 01H DUP (?)
_BSS      ENDS
CBA13_DATA      SEGMENT
?frame_time@@3UTIMER@@E	DW 03H DUP (?)
	ORG	$-936
?obs@@3UOBS@@E	DW 026H DUP (?)
CBA13_DATA      ENDS
_BSS      SEGMENT
PUBLIC  ?dyno_data_frame@@3KE
?dyno_data_frame@@3KE	DW 02H DUP (?)
_BSS      ENDS
CBA13_DATA      SEGMENT
	ORG	$+860
?obs_time@@3UTIMER@@E	DW 03H DUP (?)
CBA13_DATA      ENDS
_BSS      SEGMENT
PUBLIC  ?dyno_array@@3QIII
?dyno_array@@3QIII	DW 080H DUP (?)
_BSS      ENDS
CBA13_DATA      SEGMENT
?dyno_time@@3UTIMER@@E	DW 03H DUP (?)
CBA13_DATA      ENDS
_BSS      SEGMENT
PUBLIC  ?dyno_buffer@@3QIEI
?dyno_buffer@@3QIEI	DW 080H DUP (?)
_BSS      ENDS
CBA13_DATA      SEGMENT
?prop_rpm_time@@3UTIMER@@E	DW 03H DUP (?)
CBA13_DATA      ENDS
_BSS      SEGMENT
PUBLIC  ?prop_new_data@@3IE
?prop_new_data@@3IE	DW 01H DUP (?)
_BSS      ENDS
CBA13_DATA      SEGMENT
?prop_position_time@@3UTIMER@@E	DW 03H DUP (?)
CBA13_DATA      ENDS
_BSS      SEGMENT
PUBLIC  ?prop_data_frame@@3KE
?prop_data_frame@@3KE	DW 02H DUP (?)
_BSS      ENDS
CBA13_DATA      SEGMENT
?prop_position_time_previous@@3UTIMER@@E	DW 03H DUP (?)
CBA13_DATA      ENDS
_BSS      SEGMENT
PUBLIC  ?prop_rpm@@3HE
?prop_rpm@@3HE	DW 01H DUP (?)
_BSS      ENDS
CBA13_DATA      SEGMENT
?prop_adc_time@@3UTIMER@@E	DW 03H DUP (?)
?ln200_time@@3UTIMER@@E	DW 03H DUP (?)
CBA13_DATA      ENDS
_BSS      SEGMENT
PUBLIC  ?prop_report@@3JE
?prop_report@@3JE	DW 02H DUP (?)
_BSS      ENDS
CBA13_DATA      SEGMENT
	ORG	$-512
?echo@@3UECHO@@E	DW 018H DUP (?)
	ORG	$+464
?cmds_time@@3UTIMER@@E	DW 03H DUP (?)
CBA13_DATA      ENDS
_BSS      SEGMENT
PUBLIC  ?index_report@@3JE
?index_report@@3JE	DW 02H DUP (?)
_BSS      ENDS
CBA13_DATA      SEGMENT
?ds_time@@3UTIMER@@E	DW 03H DUP (?)
?adcp_time@@3UTIMER@@E	DW 03H DUP (?)
?gps_time@@3UTIMER@@E	DW 03H DUP (?)
CBA13_DATA      ENDS
_BSS      SEGMENT
PUBLIC  ?rpm_sf@@3ME
?rpm_sf@@3ME	DW 02H DUP (?)
	ORG	$+896
PUBLIC  ?old_dmm32a_vect@@3P7AXXZE
?old_dmm32a_vect@@3P7AXXZE	DW 02H DUP (?)
	ORG	$-900
PUBLIC  ?prop_array@@3QIII
?prop_array@@3QIII	DW 06H DUP (?)
_BSS      ENDS
CBA13_DATA      SEGMENT
	ORG	$-926
?dyno@@3UDYNO@@E	DW 086H DUP (?)
CBA13_DATA      ENDS
_BSS      SEGMENT
PUBLIC  ?prop_buffer@@3QIEI
?prop_buffer@@3QIEI	DW 06H DUP (?)
	ORG	$+876
PUBLIC  ?old_dmm32b_vect@@3P7AXXZE
?old_dmm32b_vect@@3P7AXXZE	DW 02H DUP (?)
	ORG	$-880
PUBLIC  ?ln200_new_data@@3IE
?ln200_new_data@@3IE	DW 01H DUP (?)
PUBLIC  ?ln200_data_frame@@3KE
?ln200_data_frame@@3KE	DW 02H DUP (?)
	ORG	$+874
PUBLIC  ?rtc_vect@@3P7AXXZE
?rtc_vect@@3P7AXXZE	DW 02H DUP (?)
	ORG	$-878
PUBLIC  ?ln200_buffer@@3QIEI
?ln200_buffer@@3QIEI	DW 010H DUP (?)
_BSS      ENDS
CBA13_DATA      SEGMENT
	ORG	$+658
?settings@@3Uescc_regs@@E	DW 01fH DUP (?)
CBA13_DATA      ENDS
_BSS      SEGMENT
PUBLIC  ?ln200_command@@3QIDI
?ln200_command@@3QIDI	DW 07H DUP (?)
_BSS      ENDS
CBA13_DATA      SEGMENT
?escc1@@3VCescc@@E	DW 0d1H DUP (?)
CBA13_DATA      ENDS
_BSS      SEGMENT
PUBLIC  ?echo_new_data@@3IE
?echo_new_data@@3IE	DW 01H DUP (?)
PUBLIC  ?echo_data_frame@@3KE
?echo_data_frame@@3KE	DW 02H DUP (?)
_BSS      ENDS
CBA13_DATA      SEGMENT
	ORG	$-968
?ds@@3UDS@@E	DW 02eH DUP (?)
CBA13_DATA      ENDS
_BSS      SEGMENT
PUBLIC  ?echo_array@@3QIII
?echo_array@@3QIII	DW 08H DUP (?)
PUBLIC  ?echo_buffer@@3QIEI
?echo_buffer@@3QIEI	DW 08H DUP (?)
PUBLIC  ?ds_new_data@@3IE
?ds_new_data@@3IE	DW 01H DUP (?)
PUBLIC  ?ds_data_frame@@3KE
?ds_data_frame@@3KE	DW 02H DUP (?)
	ORG	$+788
PUBLIC  ?com1_tx@@3IE
?com1_tx@@3IE	DW 01H DUP (?)
	ORG	$-790
PUBLIC  ?ds_array@@3QIII
?ds_array@@3QIII	DW 04H DUP (?)
	ORG	$+782
PUBLIC  ?com2_tx@@3IE
?com2_tx@@3IE	DW 01H DUP (?)
	ORG	$-784
PUBLIC  ?ds_buffer@@3QIEI
?ds_buffer@@3QIEI	DW 028H DUP (?)
_BSS      ENDS
CBA13_DATA      SEGMENT
	ORG	$-262
?prop@@3UPROP@@E	DW 015H DUP (?)
CBA13_DATA      ENDS
_BSS      SEGMENT
	ORG	$+704
PUBLIC  ?com4_tx@@3IE
?com4_tx@@3IE	DW 01H DUP (?)
	ORG	$-706
PUBLIC  ?adcp_new_data@@3IE
?adcp_new_data@@3IE	DW 01H DUP (?)
_BSS      ENDS
CBA_TEXT      SEGMENT
	ASSUME	CS: CBA_TEXT
	PUBLIC	?PC_DispChar@@ZAXEEEE@Z	; PC_DispChar
?PC_DispChar@@ZAXEEEE@Z	PROC FAR	; PC_DispChar
;|*** /*  cb9.cpp
;|***     derived from dmmtest.cpp original 2/18/2004
;|***     
;|***     VER 1.0
;|***     12/18/2007 jtm
;|***     
;|***     new features:
;|***       modified pcm data stream to 120 16-bit channels @ 10Hz
;|***     
;|***     source files in project:
;|***       cb9.cpp           main source module, this file
;|***       esccauto.cpp    escc104 routines for LN200 & PCM data communications
;|***       rs232gps.cpp    routines for com1 adcp, com2 rf ethernet, com4 gps
;|***       ether.cpp     interface to dos ethernet packet driver
;|***       uio48.cpp         routines for LBC586 I/O ports
;|***       pc.c              direct video ram access for fast display writes
;|***       
;|***     library file in project
;|***       tech80h.lib   tech80 5650B library  
;|***       
;|***     compile and link with MSVC 1.52 as a dos executable, huge memory model
;|*** */   
;|*** 
;|*** 
;|*** 
;|*** #include <bios.h>
;|*** #include <time.h>
;|*** #include <process.h>
;|*** #include <stdlib.h>
;|*** #include "cba.h"
;|*** #include "esccauto.h"
;|*** #include "dmm32.h"
;|*** #include "rs232.h"
;|*** #include "uio48.h"
;|*** #include "ether.h"
;|*** #include "pc.c"
;|*** #include "commands.h"
;|*** #include <conio.h>
;|*** #include <stdio.h>
;|*** #include <iostream.h>
;|*** #include <dos.h>
;|*** #include <string.h>
;|*** extern "C"
;|***  {
;|***  #include "c:\cba\te5650.h"
;|***  }
;|*** 
;|*** char pcm[2*PCMLEN];
;|*** int pcm_sent = 0;          // flag indicates this frame's pcm data has been sent
;|*** 
;|*** char s[81];
;|*** 
;|*** char acoustic_message[6];  // char string to send to shore thru acoustic modem
;|*** int  send_message = 0;     // flag indicates valid acoustic message is ready to send
;|*** 
;|*** //unsigned char obc_mac[6]    =  {0x00, 0x01, 0x45, 0x00, 0x7a, 0x73};
;|*** unsigned char obc_mac[6]    =  {0x00, 0x01, 0x45, 0x00, 0x7a, 0xa0};
;|*** unsigned char micron_mac[6] =  {0x08, 0x00, 0x17, 0x08, 0x87, 0x4d};
;|*** unsigned char control_mac[6] = {0x00, 0x01, 0x45, 0x00, 0x8a, 0x21};
;|*** unsigned char broadcast_mac[6] = {0xff, 0xff, 0xff, 0xff, 0xff, 0xff};
;|*** unsigned char shore_mac[6] =   {0x00, 0x0e, 0xa6, 0xb6, 0xc0, 0x4e};
;|*** 
;|*** unsigned char far cmd_buffer[2008]; // command packet buffer
;|*** 
;|*** long unsigned sys_frame = 0;
;|*** unsigned int  sys_status = 0;
;|*** 
;|*** unsigned channela, channelb;
;|*** unsigned long frame, next_frame;
;|*** unsigned reading_prop;
;|*** unsigned mux_addr = 0;
;|*** 
;|*** unsigned char data_pkt[1514];
;|*** 
;|*** unsigned      obs_new_data;
;|*** unsigned long obs_data_frame;
;|*** unsigned      obs_array[32];
;|*** unsigned char obs_buffer[64];
;|*** 
; Line 79
	*** 000000	55 			push	bp
	*** 000001	8b ec 			mov	bp,sp
;	x = 6
;	y = 8
;	c = 10
;	color = 12
;	pscr = -4
;	offset = -6
;|*** unsigned      dyno_new_data;
;|*** unsigned long dyno_data_frame;
;|*** unsigned      dyno_array[128];
;|*** unsigned char dyno_buffer[256];
;|*** 
;|*** unsigned      prop_new_data;
;|*** unsigned long prop_data_frame;
; Line 86
	*** 000003	8a 46 0a 		mov	al,BYTE PTR [bp+10]	;c
	*** 000006	8a 4e 08 		mov	cl,BYTE PTR [bp+8]	;y
	*** 000009	2a ed 			sub	ch,ch
	*** 00000b	6b d9 50 		imul	bx,cx,80	;0050H
	*** 00000e	8a 4e 06 		mov	cl,BYTE PTR [bp+6]	;x
	*** 000011	03 d9 			add	bx,cx
	*** 000013	03 db 			add	bx,bx
	*** 000015	2b c9 			sub	cx,cx
	*** 000017	2b d9 			sub	bx,cx
	*** 000019	81 d9 00 48 		sbb	cx,18432	;4800H
	*** 00001d	8e c1 			mov	es,cx
	*** 00001f	26 88 07 		mov	BYTE PTR es:[bx],al
;|*** int           prop_rpm;
; Line 87
	*** 000022	8a 46 0c 		mov	al,BYTE PTR [bp+12]	;color
	*** 000025	26 88 47 01 		mov	BYTE PTR es:[bx+1],al
;|*** long int      prop_position = 0;
; Line 88
	*** 000029	c9 			leave	
	*** 00002a	cb 			ret	
	*** 00002b	90 			nop	

?PC_DispChar@@ZAXEEEE@Z	ENDP
	PUBLIC	?PC_DispClrCol@@ZAXEE@Z	; PC_DispClrCol
?PC_DispClrCol@@ZAXEE@Z	PROC FAR	; PC_DispClrCol
;|*** long int      prop_report;  // for on-screen
;|*** long int      index_report;
;|*** long int      prop_index = 0;
;|*** long int      prop_position_absolute_current = 0;
;|*** long int      prop_position_absolute_previous = 0;
;|*** float         rpm_sf;
;|*** unsigned      prop_array[6];
;|*** unsigned char prop_buffer[12];
;|*** 
;|*** unsigned      ln200_new_data;
;|*** unsigned long ln200_data_frame;
;|*** unsigned char ln200_buffer[32];
;|*** char          ln200_command[14];
;|*** unsigned long ln200_rx_num = 0;
;|*** 
;|*** unsigned      echo_new_data;
;|*** unsigned long echo_data_frame;
;|*** unsigned      echo_array[8];
;|*** unsigned char echo_buffer[16];
;|*** 
;|*** unsigned      ds_new_data;
;|*** unsigned long ds_data_frame;
; Line 110
	*** 00002c	55 			push	bp
	*** 00002d	8b ec 			mov	bp,sp
	*** 00002f	57 			push	di
	*** 000030	56 			push	si
;	x = 6
;	color = 8
;	register si = pscr
;	i = -6
;|*** unsigned      ds_array[4];
;|*** unsigned char ds_buffer[80];
;|*** 
;|*** unsigned      adcp_new_data;
;|*** unsigned long adcp_data_frame;
; Line 115
	*** 000031	8a 46 06 		mov	al,BYTE PTR [bp+6]	;x
	*** 000034	2a e4 			sub	ah,ah
	*** 000036	2b d2 			sub	dx,dx
	*** 000038	2b c2 			sub	ax,dx
	*** 00003a	81 da 00 24 		sbb	dx,9216	;2400H
	*** 00003e	03 c0 			add	ax,ax
	*** 000040	13 d2 			adc	dx,dx
	*** 000042	8b f0 			mov	si,ax
	*** 000044	8e da 			mov	ds,dx
	ASSUME DS: NOTHING
	*** 000046	bf 19 00 		mov	di,25	;0019H
;|*** unsigned char adcp_array[ADCPLEN];
; Line 116
					$F1524:
;|*** unsigned char adcp_buffer[ADCPLEN];
; Line 117
	*** 000049	c6 04 20 		mov	BYTE PTR [si],32	;0020H
	*** 00004c	46 			inc	si
;|*** unsigned char adcp_test[88];
; Line 118
	*** 00004d	8a 46 08 		mov	al,BYTE PTR [bp+8]	;color
	*** 000050	88 04 			mov	BYTE PTR [si],al
	*** 000052	81 c6 a0 00 		add	si,160	;00a0H
	*** 000056	4f 			dec	di
	*** 000057	75 f0 			jne	$F1524
;|*** 
;|*** unsigned      gps_new_data;
;|*** unsigned long gps_data_frame;
; Line 121
	*** 000059	16 			push	ss
	*** 00005a	1f 			pop	ds
	ASSUME DS: DGROUP
	*** 00005b	5e 			pop	si
	*** 00005c	5f 			pop	di
	*** 00005d	c9 			leave	
	*** 00005e	cb 			ret	
	*** 00005f	90 			nop	

?PC_DispClrCol@@ZAXEE@Z	ENDP
	PUBLIC	?PC_DispClrRow@@ZAXEE@Z	; PC_DispClrRow
?PC_DispClrRow@@ZAXEE@Z	PROC FAR	; PC_DispClrRow
;|*** unsigned char gps_array[80];
;|*** unsigned char gps_buffer[80];
;|*** 
;|*** struct SYS
;|***   {
;|***   unsigned int  packet_type;
;|***   unsigned int  packet_number;
;|***   unsigned long frame;
;|***   unsigned int  fs_status;
;|***   unsigned int  op_status;
;|***   unsigned long time_high;
;|***   unsigned int  time_low;
;|***   } sys;
;|***   
;|*** 
;|*** struct OBS
;|***   {
;|***   unsigned int  new_data;
;|***   long unsigned frame;
;|***   unsigned long time_high;
;|***   unsigned int  time_low;
;|***   unsigned int  data[32];
; Line 143
	*** 000060	55 			push	bp
	*** 000061	8b ec 			mov	bp,sp
	*** 000063	57 			push	di
	*** 000064	56 			push	si
;	y = 6
;	color = 8
;	register si = pscr
;	i = -6
;|***   } obs;  
;|***   
;|*** 
;|*** struct DYNO
;|***   {
; Line 148
	*** 000065	8a 46 06 		mov	al,BYTE PTR [bp+6]	;y
	*** 000068	2a e4 			sub	ah,ah
	*** 00006a	b9 a0 00 		mov	cx,160	;00a0H
	*** 00006d	f7 e1 			mul	cx
	*** 00006f	2d 00 00 		sub	ax,0
	*** 000072	81 da 00 48 		sbb	dx,18432	;4800H
	*** 000076	8b f0 			mov	si,ax
	*** 000078	8e c2 			mov	es,dx
	*** 00007a	bf 50 00 		mov	di,80	;0050H
;|***   unsigned int  new_data;
; Line 149
					$F1538:
;|***   long unsigned frame;
; Line 150
	*** 00007d	26 c6 04 20 		mov	BYTE PTR es:[si],32	;0020H
	*** 000081	46 			inc	si
;|***   unsigned long time_high;
; Line 151
	*** 000082	8a 46 08 		mov	al,BYTE PTR [bp+8]	;color
	*** 000085	26 88 04 		mov	BYTE PTR es:[si],al
	*** 000088	46 			inc	si
	*** 000089	4f 			dec	di
	*** 00008a	75 f1 			jne	$F1538
;|***   unsigned int  time_low;
;|***   unsigned int  data[128];
; Line 153
	*** 00008c	5e 			pop	si
	*** 00008d	5f 			pop	di
	*** 00008e	c9 			leave	
	*** 00008f	cb 			ret	

?PC_DispClrRow@@ZAXEE@Z	ENDP
	PUBLIC	?PC_DispClrScr@@ZAXE@Z	; PC_DispClrScr
?PC_DispClrScr@@ZAXE@Z	PROC FAR	; PC_DispClrScr
;|***   } dyno;
;|***   
;|*** 
;|*** struct PROP
;|***   {
;|***   unsigned int  new_data;
;|***   long unsigned frame;
;|***   unsigned long rpm_time_high;
;|***   unsigned int  rpm_time_low;
;|***   unsigned long position_time_high;
;|***   unsigned int  position_time_low;
;|***   unsigned long adc_time_high;
;|***   unsigned int  adc_time_low;
;|***   int           rpm;
;|***   long int      position;
;|***   unsigned int  data[6];    
;|***   } prop;
;|***   
;|*** 
; Line 172
	*** 000090	55 			push	bp
	*** 000091	8b ec 			mov	bp,sp
	*** 000093	56 			push	si
;	color = 6
;	register si = pscr
;	i = -6
;|*** struct LN200
;|***   {
;|***   unsigned int  new_data;
;|***   long unsigned frame;
;|***   unsigned long time_high;
; Line 177
	*** 000094	33 c0 			xor	ax,ax
	*** 000096	ba 00 b8 		mov	dx,-18432	;b800H
	*** 000099	8b f0 			mov	si,ax
	*** 00009b	8e da 			mov	ds,dx
	ASSUME DS: NOTHING
	*** 00009d	b9 d0 07 		mov	cx,2000	;07d0H
;|***   unsigned int  time_low;
; Line 178
					$F1550:
;|***   int  data[16];
; Line 179
	*** 0000a0	c6 04 20 		mov	BYTE PTR [si],32	;0020H
	*** 0000a3	46 			inc	si
;|***   } ln200;
; Line 180
	*** 0000a4	8a 46 06 		mov	al,BYTE PTR [bp+6]	;color
	*** 0000a7	88 04 			mov	BYTE PTR [si],al
	*** 0000a9	46 			inc	si
	*** 0000aa	49 			dec	cx
	*** 0000ab	75 f3 			jne	$F1550
;|*** 
;|***   
; Line 182
	*** 0000ad	16 			push	ss
	*** 0000ae	1f 			pop	ds
	ASSUME DS: DGROUP
	*** 0000af	5e 			pop	si
	*** 0000b0	c9 			leave	
	*** 0000b1	cb 			ret	

?PC_DispClrScr@@ZAXE@Z	ENDP
	PUBLIC	?PC_DispStr@@ZAXEEPIEE@Z	; PC_DispStr
?PC_DispStr@@ZAXEEPIEE@Z	PROC FAR	; PC_DispStr
;|*** struct COMMANDS
;|***   {
;|***   unsigned int  sync_word;
;|***   unsigned int  mode;
;|***   unsigned int  rpm;
;|***   unsigned int  rudder;
;|***   unsigned int  stern1;
;|***   unsigned int  stern2;
;|***   unsigned int  fore;  
;|***   unsigned int  ballast;
;|***   unsigned int  ln200_mode;
;|***   unsigned int  ln200_init_heading;
;|***   unsigned int  ln200_init_latitude;
;|***   unsigned int  adcp_reset;
;|***   unsigned int  adcp_heading;
;|***   unsigned int  ds_send_message;
;|***   unsigned int  ds_dmgx;
;|***   unsigned int  ds_dmgy;
;|***   unsigned int  ds_dmgz;        
;|***   unsigned int  spare1;
;|***   } commands;  
;|*** 
;|*** int time_since_last_command = 0;
;|*** 
;|*** struct ECHO
;|***   {
;|***   unsigned int  new_data;
; Line 209
	*** 0000b2	c8 04 00 00 		enter	4,0
	*** 0000b6	56 			push	si
;	x = 6
;	y = 8
;	s = 10
;	color = 14
;	pscr = -4
;	offset = -6
;|***   unsigned long frame;
;|***   unsigned long time_high;
;|***   unsigned int  time_low;
;|***   unsigned char data[sizeof(commands)];
;|***   } echo;
;|*** 
; Line 215
	*** 0000b7	b0 50 			mov	al,80	;0050H
	*** 0000b9	f6 66 08 		mul	BYTE PTR [bp+8]	;y
	*** 0000bc	8a 4e 06 		mov	cl,BYTE PTR [bp+6]	;x
	*** 0000bf	2a ed 			sub	ch,ch
	*** 0000c1	03 c1 			add	ax,cx
	*** 0000c3	03 c0 			add	ax,ax
	*** 0000c5	2b d2 			sub	dx,dx
	*** 0000c7	2b c2 			sub	ax,dx
	*** 0000c9	81 da 00 48 		sbb	dx,18432	;4800H
	*** 0000cd	8b f0 			mov	si,ax
	*** 0000cf	89 56 fe 		mov	WORD PTR [bp-2],dx
;|*** struct DS
; Line 216
	*** 0000d2	c4 5e 0a 		les	bx,DWORD PTR [bp+10]	;s
	*** 0000d5	26 38 2f 		cmp	BYTE PTR es:[bx],ch
	*** 0000d8	74 31 			je	$EX1557
					$FC1568:
;|***   {
; Line 217
	*** 0000da	26 8a 07 		mov	al,BYTE PTR es:[bx]
	*** 0000dd	8e c2 			mov	es,dx
	*** 0000df	26 88 04 		mov	BYTE PTR es:[si],al
;|***   unsigned int  new_data;
; Line 218
	*** 0000e2	8a 46 0e 		mov	al,BYTE PTR [bp+14]	;color
	*** 0000e5	46 			inc	si
	*** 0000e6	8e 46 fe 		mov	es,WORD PTR [bp-2]
	*** 0000e9	26 88 04 		mov	BYTE PTR es:[si],al
	*** 0000ec	8b c6 			mov	ax,si
	*** 0000ee	8c c2 			mov	dx,es
	*** 0000f0	40 			inc	ax
	*** 0000f1	8b f0 			mov	si,ax
	*** 0000f3	8c 46 fe 		mov	WORD PTR [bp-2],es
;|***   long unsigned frame;
; Line 219
	*** 0000f6	83 46 0a 01 		add	WORD PTR [bp+10],1	;s
	*** 0000fa	1b c0 			sbb	ax,ax
	*** 0000fc	25 00 00 		and	ax,OFFSET __AHINCR
	*** 0000ff	01 46 0c 		add	WORD PTR [bp+12],ax
	*** 000102	c4 5e 0a 		les	bx,DWORD PTR [bp+10]	;s
	*** 000105	26 80 3f 00 		cmp	BYTE PTR es:[bx],0
	*** 000109	75 cf 			jne	$FC1568
;|***   unsigned long time_high;
; Line 220
					$EX1557:
	*** 00010b	5e 			pop	si
	*** 00010c	c9 			leave	
	*** 00010d	cb 			ret	

?PC_DispStr@@ZAXEEPIEE@Z	ENDP

_aaj	PROC FAR
;|*** /*  cb9.cpp
;|***     derived from dmmtest.cpp original 2/18/2004
;|***     
;|***     VER 1.0
;|***     12/18/2007 jtm
;|***     
;|***     new features:
;|***       modified pcm data stream to 120 16-bit channels @ 10Hz
;|***     
;|***     source files in project:
;|***       cb9.cpp           main source module, this file
;|***       esccauto.cpp    escc104 routines for LN200 & PCM data communications
;|***       rs232gps.cpp    routines for com1 adcp, com2 rf ethernet, com4 gps
;|***       ether.cpp     interface to dos ethernet packet driver
;|***       uio48.cpp         routines for LBC586 I/O ports
;|***       pc.c              direct video ram access for fast display writes
;|***       
;|***     library file in project
;|***       tech80h.lib   tech80 5650B library  
;|***       
;|***     compile and link with MSVC 1.52 as a dos executable, huge memory model
;|*** */   
;|*** 
;|*** 
;|*** 
;|*** #include <bios.h>
;|*** #include <time.h>
;|*** #include <process.h>
;|*** #include <stdlib.h>
;|*** #include "cba.h"
;|*** #include "esccauto.h"
;|*** #include "dmm32.h"
;|*** #include "rs232.h"
;|*** #include "uio48.h"
;|*** #include "ether.h"
;|*** #include "pc.c"
;|*** #include "commands.h"
;|*** #include <conio.h>
;|*** #include <stdio.h>
;|*** #include <iostream.h>
;|*** #include <dos.h>
;|*** #include <string.h>
;|*** extern "C"
;|***  {
;|***  #include "c:\cba\te5650.h"
;|***  }
;|*** 
;|*** char pcm[2*PCMLEN];
;|*** int pcm_sent = 0;          // flag indicates this frame's pcm data has been sent
;|*** 
;|*** char s[81];
;|*** 
;|*** char acoustic_message[6];  // char string to send to shore thru acoustic modem
;|*** int  send_message = 0;     // flag indicates valid acoustic message is ready to send
;|*** 
;|*** //unsigned char obc_mac[6]    =  {0x00, 0x01, 0x45, 0x00, 0x7a, 0x73};
;|*** unsigned char obc_mac[6]    =  {0x00, 0x01, 0x45, 0x00, 0x7a, 0xa0};
;|*** unsigned char micron_mac[6] =  {0x08, 0x00, 0x17, 0x08, 0x87, 0x4d};
;|*** unsigned char control_mac[6] = {0x00, 0x01, 0x45, 0x00, 0x8a, 0x21};
;|*** unsigned char broadcast_mac[6] = {0xff, 0xff, 0xff, 0xff, 0xff, 0xff};
;|*** unsigned char shore_mac[6] =   {0x00, 0x0e, 0xa6, 0xb6, 0xc0, 0x4e};
;|*** 
;|*** unsigned char far cmd_buffer[2008]; // command packet buffer
;|*** 
;|*** long unsigned sys_frame = 0;
;|*** unsigned int  sys_status = 0;
;|*** 
;|*** unsigned channela, channelb;
;|*** unsigned long frame, next_frame;
;|*** unsigned reading_prop;
;|*** unsigned mux_addr = 0;
;|*** 
;|*** unsigned char data_pkt[1514];
;|*** 
;|*** unsigned      obs_new_data;
;|*** unsigned long obs_data_frame;
;|*** unsigned      obs_array[32];
;|*** unsigned char obs_buffer[64];
;|*** 
;|*** unsigned      dyno_new_data;
;|*** unsigned long dyno_data_frame;
;|*** unsigned      dyno_array[128];
;|*** unsigned char dyno_buffer[256];
;|*** 
;|*** unsigned      prop_new_data;
;|*** unsigned long prop_data_frame;
;|*** int           prop_rpm;
;|*** long int      prop_position = 0;
;|*** long int      prop_report;  // for on-screen
;|*** long int      index_report;
;|*** long int      prop_index = 0;
;|*** long int      prop_position_absolute_current = 0;
;|*** long int      prop_position_absolute_previous = 0;
;|*** float         rpm_sf;
;|*** unsigned      prop_array[6];
;|*** unsigned char prop_buffer[12];
;|*** 
;|*** unsigned      ln200_new_data;
;|*** unsigned long ln200_data_frame;
;|*** unsigned char ln200_buffer[32];
;|*** char          ln200_command[14];
;|*** unsigned long ln200_rx_num = 0;
;|*** 
;|*** unsigned      echo_new_data;
;|*** unsigned long echo_data_frame;
;|*** unsigned      echo_array[8];
;|*** unsigned char echo_buffer[16];
;|*** 
;|*** unsigned      ds_new_data;
;|*** unsigned long ds_data_frame;
;|*** unsigned      ds_array[4];
;|*** unsigned char ds_buffer[80];
;|*** 
;|*** unsigned      adcp_new_data;
;|*** unsigned long adcp_data_frame;
;|*** unsigned char adcp_array[ADCPLEN];
;|*** unsigned char adcp_buffer[ADCPLEN];
;|*** unsigned char adcp_test[88];
;|*** 
;|*** unsigned      gps_new_data;
;|*** unsigned long gps_data_frame;
;|*** unsigned char gps_array[80];
;|*** unsigned char gps_buffer[80];
;|*** 
;|*** struct SYS
;|***   {
;|***   unsigned int  packet_type;
;|***   unsigned int  packet_number;
;|***   unsigned long frame;
;|***   unsigned int  fs_status;
;|***   unsigned int  op_status;
;|***   unsigned long time_high;
;|***   unsigned int  time_low;
;|***   } sys;
;|***   
;|*** 
;|*** struct OBS
;|***   {
;|***   unsigned int  new_data;
;|***   long unsigned frame;
;|***   unsigned long time_high;
;|***   unsigned int  time_low;
;|***   unsigned int  data[32];
;|***   } obs;  
;|***   
;|*** 
;|*** struct DYNO
;|***   {
;|***   unsigned int  new_data;
;|***   long unsigned frame;
;|***   unsigned long time_high;
;|***   unsigned int  time_low;
;|***   unsigned int  data[128];
;|***   } dyno;
;|***   
;|*** 
;|*** struct PROP
;|***   {
;|***   unsigned int  new_data;
;|***   long unsigned frame;
;|***   unsigned long rpm_time_high;
;|***   unsigned int  rpm_time_low;
;|***   unsigned long position_time_high;
;|***   unsigned int  position_time_low;
;|***   unsigned long adc_time_high;
;|***   unsigned int  adc_time_low;
;|***   int           rpm;
;|***   long int      position;
;|***   unsigned int  data[6];    
;|***   } prop;
;|***   
;|*** 
;|*** struct LN200
;|***   {
;|***   unsigned int  new_data;
;|***   long unsigned frame;
;|***   unsigned long time_high;
;|***   unsigned int  time_low;
;|***   int  data[16];
;|***   } ln200;
;|*** 
;|***   
;|*** struct COMMANDS
;|***   {
;|***   unsigned int  sync_word;
;|***   unsigned int  mode;
;|***   unsigned int  rpm;
;|***   unsigned int  rudder;
;|***   unsigned int  stern1;
;|***   unsigned int  stern2;
;|***   unsigned int  fore;  
;|***   unsigned int  ballast;
;|***   unsigned int  ln200_mode;
;|***   unsigned int  ln200_init_heading;
;|***   unsigned int  ln200_init_latitude;
;|***   unsigned int  adcp_reset;
;|***   unsigned int  adcp_heading;
;|***   unsigned int  ds_send_message;
;|***   unsigned int  ds_dmgx;
;|***   unsigned int  ds_dmgy;
;|***   unsigned int  ds_dmgz;        
;|***   unsigned int  spare1;
;|***   } commands;  
;|*** 
;|*** int time_since_last_command = 0;
;|*** 
;|*** struct ECHO
;|***   {
;|***   unsigned int  new_data;
;|***   unsigned long frame;
;|***   unsigned long time_high;
;|***   unsigned int  time_low;
;|***   unsigned char data[sizeof(commands)];
;|***   } echo;
;|*** 
;|*** struct DS
;|***   {
;|***   unsigned int  new_data;
;|***   long unsigned frame;
;|***   unsigned long time_high;
;|***   unsigned int  time_low;
;|***   unsigned char  data[80];
;|***   } ds;
;|***   
;|*** struct ADCP
;|***   {
;|***   unsigned int  new_data;
;|***   long unsigned frame;
;|***   unsigned long time_high;
;|***   unsigned int  time_low;
;|***   unsigned char data[ADCPLEN];  
;|***   } adcp;
;|***   
;|*** struct GPS
;|***   {
;|***   unsigned int  new_data;
;|***   long unsigned frame;
;|***   unsigned long time_high;
;|***   unsigned int  time_low;
;|***   unsigned char  data[80];  
;|***   } gps;  
;|***  
;|*** struct TIMER
;|***   {
;|***   unsigned long high;
;|***   unsigned int  low;
;|***   }     sys_timer,
;|***         frame_time,
;|***         obs_time,
;|***         dyno_time,
;|***         prop_rpm_time,
;|***         prop_position_time,
;|***         prop_position_time_previous,
;|***         prop_adc_time,        
;|***         ln200_time,
;|***         cmds_time,
;|***         ds_time,
;|***         adcp_time,
;|***         gps_time;
;|***    
;|***    
;|*** void (interrupt far * old_dmm32a_vect)();
;|*** void (interrupt far * old_dmm32b_vect)();
;|*** void (interrupt far * rtc_vect)();
;|*** 
;|*** struct escc_regs settings;
;|*** Cescc escc1;
; Line 267
	*** 00010e	68 00 00 		push	SEG ?escc1@@3VCescc@@E	;escc1
	*** 000111	68 00 00 		push	OFFSET ?escc1@@3VCescc@@E	;escc1
	*** 000114	9a 00 00 00 00 		call	FAR PTR ??0Cescc@@REC@XZ	; Cescc::Cescc
	*** 000119	cb 			ret	

_aaj	ENDP
	PUBLIC	_main
_main	PROC FAR
;|*** 
;|*** unsigned stern1_cmd = 0;
;|*** unsigned stern2_cmd = 0;
;|*** unsigned fore_cmd   = 0;
;|*** unsigned rudder_cmd = 0;
;|*** unsigned prop_cmd   = 0;
;|*** unsigned com1_tx;
;|*** unsigned com2_tx;
;|*** unsigned com4_tx;
;|*** 
;|*** extern int handle;
;|*** extern unsigned long packets_rcvd;
;|*** extern unsigned long ax0_counter;
;|*** extern unsigned long ax1_counter;
;|*** extern unsigned long discards;
;|*** extern unsigned long receiver_calls;
;|*** extern unsigned char pc1_addr[6];
;|*** extern unsigned char pc2_addr[6];
;|*** extern unsigned char pc3_addr[6];
;|*** extern unsigned char jim_pc[6];
;|*** extern unsigned char control_mac[6];
;|*** extern unsigned char broadcast_addr[6];
;|*** unsigned int  ip_id;
;|*** unsigned data_ready = 0;
;|*** 
;|*** 
;|*** extern unsigned tx2_len;
;|*** extern unsigned tx2_counter;
;|*** extern unsigned tx2_index;
;|*** 
;|*** void main(void)
;|***   {
;|***   configure_obc();
; Line 300
	*** 00011a	0e 			push	cs
	*** 00011b	e8 00 00 		call	NEAR PTR ?configure_obc@@ZAXXZ	; configure_obc
;|***   wait_for_time_tick();
; Line 301
	*** 00011e	0e 			push	cs
	*** 00011f	e8 00 00 		call	NEAR PTR ?wait_for_time_tick@@ZAXXZ	; wait_for_time_tick
;|***   while(1)
; Line 302
					$FC3668:
;|***     {
;|***     get_frame_time();
; Line 304
	*** 000122	0e 			push	cs
	*** 000123	e8 00 00 		call	NEAR PTR ?get_frame_time@@ZAXXZ	; get_frame_time
;|***     send_data_packet();
; Line 305
	*** 000126	0e 			push	cs
	*** 000127	e8 00 00 		call	NEAR PTR ?send_data_packet@@ZAXXZ	; send_data_packet
;|***     start_data_collection();    
; Line 306
	*** 00012a	0e 			push	cs
	*** 00012b	e8 00 00 		call	NEAR PTR ?start_data_collection@@ZAXXZ	; start_data_collection
;|***     apply_commands();
; Line 307
	*** 00012e	0e 			push	cs
	*** 00012f	e8 00 00 		call	NEAR PTR ?apply_commands@@ZAXXZ	; apply_commands
;|***     heartbeat();
; Line 308
	*** 000132	0e 			push	cs
	*** 000133	e8 00 00 		call	NEAR PTR ?heartbeat@@ZAXXZ	; heartbeat
;|***     send_acoustic_message();
; Line 309
	*** 000136	0e 			push	cs
	*** 000137	e8 00 00 		call	NEAR PTR ?send_acoustic_message@@ZAXXZ	; send_acoustic_message
;|***     wait_for_time_tick();
; Line 310
	*** 00013a	0e 			push	cs
	*** 00013b	e8 00 00 		call	NEAR PTR ?wait_for_time_tick@@ZAXXZ	; wait_for_time_tick
;|***     if(_kbhit()) break;
; Line 311
	*** 00013e	9a 00 00 00 00 		call	FAR PTR __kbhit
	*** 000143	0b c0 			or	ax,ax
	*** 000145	74 db 			je	$FC3668
;|***     }
;|***   terminate();
; Line 313
	*** 000147	0e 			push	cs
	*** 000148	e8 00 00 		call	NEAR PTR ?terminate@@ZAXXZ	; terminate
;|***   exit(0);
; Line 314
	*** 00014b	6a 00 			push	0
	*** 00014d	9a 00 00 00 00 		call	FAR PTR _exit
	*** 000152	83 c4 02 		add	sp,2
;|***   }
; Line 315
	*** 000155	cb 			ret	

_main	ENDP
	PUBLIC	?send_acoustic_message@@ZAXXZ	; send_acoustic_message
?send_acoustic_message@@ZAXXZ	PROC FAR	; send_acoustic_message
;|*** 
;|*** 
;|*** void send_acoustic_message(void)
;|***   {
; Line 319
	*** 000156	56 			push	si
;	register si = i
;|***   if(send_message != 0)
; Line 320
	*** 000157	83 3e 00 00 00 		cmp	WORD PTR ?send_message@@3HE,0	;send_message
	*** 00015c	74 1f 			je	$EX3672
;|***     {
;|***     send_message = 0;
; Line 322
	*** 00015e	c7 06 00 00 00 00 	mov	WORD PTR ?send_message@@3HE,0	;send_message
;|***     //_fstrcpy(acoustic_message,"abcdef");
;|***     if(_inp(COM2_LSR) & TXB_EMPTY)  // if com2 tx is idle
; Line 324
	*** 000164	ba fd 02 		mov	dx,765	;02fdH
	*** 000167	ec 			in	al,dx
	*** 000168	a8 60 			test	al,96	;0060H
	*** 00016a	74 11 			je	$EX3672
;|***       {
;|***       for(int i=0; i<sizeof(acoustic_message); i++)  // send the message
; Line 326
	*** 00016c	33 f6 			xor	si,si
					$F3676:
;|***         {
;|***         _outp(COM2_TX, acoustic_message[i]);
; Line 328
	*** 00016e	8a 84 00 00 		mov	al,BYTE PTR ?acoustic_message@@3QIDI[si]	;acoustic_message
	*** 000172	98 			cbw	
	*** 000173	ba f8 02 		mov	dx,760	;02f8H
	*** 000176	ee 			out	dx, al

	*** 000177	46 			inc	si
	*** 000178	83 fe 06 		cmp	si,6
	*** 00017b	72 f1 			jb	$F3676
;|***         }
;|***       }
;|***     }    
;|***   }
; Line 332
					$EX3672:
	*** 00017d	5e 			pop	si
	*** 00017e	cb 			ret	
	*** 00017f	90 			nop	

?send_acoustic_message@@ZAXXZ	ENDP
CBA_TEXT      ENDS
CONST      SEGMENT
$T4071	DW SEG ?escc1@@3VCescc@@E 
CONST      ENDS
CBA_TEXT      SEGMENT
	ASSUME	CS: CBA_TEXT
	PUBLIC	?send_pcm@@ZAXXZ	; send_pcm
?send_pcm@@ZAXXZ	PROC FAR	; send_pcm
;|*** 
;|*** 
;|*** 
;|*** void send_pcm(void)
;|***   {
;|***   if(escc1.istxing[channelb]==0)
; Line 338
	*** 000180	8e 06 00 00 		mov	es,WORD PTR $T4071
	*** 000184	8b 1e 00 00 		mov	bx,WORD PTR ?channelb@@3IE	;channelb
	*** 000188	03 db 			add	bx,bx
	*** 00018a	26 83 bf 92 01 00 	cmp	WORD PTR es:?escc1@@3VCescc@@E[bx+402],0	;escc1
	*** 000190	75 19 			jne	$EX3680
;|***     {
;|***     pack_pcm();
; Line 340
	*** 000192	0e 			push	cs
	*** 000193	e8 00 00 		call	NEAR PTR ?pack_pcm@@ZAXXZ	; pack_pcm
;|***     //escc1.tx_port(channelb, pcm, 96);            // old decom
;|***     escc1.tx_port(channelb, pcm, sizeof(PCMLEN));  // new decom
; Line 342
	*** 000196	ff 36 00 00 		push	WORD PTR ?channelb@@3IE	;channelb
	*** 00019a	1e 			push	ds
	*** 00019b	68 00 00 		push	OFFSET DGROUP:?pcm@@3QIDI	;pcm
	*** 00019e	6a 02 			push	2
	*** 0001a0	68 00 00 		push	SEG ?escc1@@3VCescc@@E	;escc1
	*** 0001a3	68 00 00 		push	OFFSET ?escc1@@3VCescc@@E	;escc1
	*** 0001a6	9a 00 00 00 00 		call	FAR PTR ?tx_port@Cescc@@RECIIPEDI@Z	; Cescc::tx_port
;|***     }
;|***   }
; Line 344
					$EX3680:
	*** 0001ab	cb 			ret	

?send_pcm@@ZAXXZ	ENDP
	PUBLIC	?pack_pcm@@ZAXXZ	; pack_pcm
?pack_pcm@@ZAXXZ	PROC FAR	; pack_pcm
;|***   
;|***   
;|*** void pack_pcm(void)  // new decom
;|***   {
; Line 348
	*** 0001ac	c8 f0 00 00 		enter	240,0
	*** 0001b0	57 			push	di
	*** 0001b1	56 			push	si
;	data = -240
;|***     
;|***   // Prepare pcm data to be sent up the telemetry link in biphase-m (76.8 KHz)
;|***   // The telemetry frame is 120 16-bit words x 12.
;|***   //
;|***   // All ln200 and a/d data was first collected and stored in separate structures
;|***   // in a total of 48 16-bit words.  For pcm transmission, the data must be:
;|***   // 1) scaled, converted to offset-binary and placed in proper channel slots
;|***   // 2) shifted down from 16-bit to 12-bit (shift and mask) (keep high byte 0000 hex
;|***   // 3) converted from from lsb first to msb first for the bit synchronizer
;|***   // 4) repacked for the escc from 64 12-bit words to 96 8-bit bytes (shift and mask) for the escc 
;|***   
;|***   int data[120];
;|***   //unsigned i = 0;
;|*** /*  
;|***     // first scale the numbers, add the offset, place in slots
;|***   data2[0] = 0x0faf;         // decom sync 1
;|***   data2[1] = 0x0321;         // decom sync 2
;|***   data2[2] = 5 << 1;         // CB ID, 5 << 1
;|***   data2[7] = (sys.frame >> 4) & 0x0ffe; // most significant 11 bits of 16 bit frame counter
;|***   data2[8] = (sys.frame << 7) & 0x0f80; // least sig 5 bits of 16 bit frame counter, LEFT ADJUSTED
;|*** 
;|***   //  "R"
;|***   data2[10] = ((long)ln200.data[5] * 2)    + d_offset;       // z axis angular rate low
;|***   data2[9]  = (data2[10] >> 12) * 2 + d_offset;  // high
;|***   
;|***   //  "Q"
;|***   data2[12] = ((long)ln200.data[3] * 2)    + d_offset;       // y axis angular rate low
;|***   data2[11] = (data2[12] >> 12) * 2 + d_offset;  // high
;|***     
;|***   // "P"
;|***   data2[14] = ((long)ln200.data[4] * 2)    + d_offset;       // x axis angular rate low
;|***   data2[13] = (data2[14] >> 12) * 2 + d_offset;  // high
;|***     
;|***   
;|***   //new 2/10/2005
;|***   //data2[16] = ((long)ln200.data[2] * 2)    + d_offset;       // x axis linear accel low
;|***   //data2[15] = (data2[16] >> 12) * 2 + d_offset;  // high
;|*** 
;|***   //new 2/10/2005
;|***   //data2[18] = ((long)ln200.data[1] * 2)    + d_offset;       // y axis linear accel low
;|***   //data2[17] = (data2[18] >> 12) * 2 + d_offset;  // high
;|*** 
;|***   // compensate LN200 Z accel reading for standard gravity: (32.17405 / 2^-6 counts )
;|***   //new 2/10/2005
;|***   //data2[20] = (((long)ln200.data[0] + ((long)(32.17405 * 64))) * 2)    + d_offset;       // z axis linear accel
;|***   //data2[19] =  (data2[20] >> 12) * 2 + d_offset;
;|*** 
;|***   data2[15] = 0;
;|***   data2[16] = 0;
;|***   data2[17] = 0;
;|***   data2[18] = 0;
;|***   data2[19] = 0;
;|***   data2[20] = 0;
;|*** 
;|***   data2[21] = 0;
;|***   data2[22] = 0;
;|***   data2[23] = 0;
;|***   data2[24] = 0;
;|***   data2[25] = 0;
;|***   data2[26] = 0;
;|***     
;|***  //  ln200 single channel scale factors
;|***  //  convert 16-bit LN200 native data to 12-bit pcm data
;|***  //  to provide desired full-scale range for each channel
;|***  //  scale factor = ln200 lsb value * 2^12 counts / desired full-scale range EUs
;|***  
;|***     // roll_accel (Pdot), ln200 lsb = 2^-4 deg/sec^2
;|***   //data2[27] = data[7];
;|***     // limit roll_accel to 12-bits and max +- 128 deg/sec^2 range
;|***   //if(data2[27] >  2047) data2[27] =  2047;
;|***   //if(data2[27] < -2048) data2[27] = -2048;
;|***   //data2[27] = data2[27] + s_offset;
;|***   //new 2/10/2005
;|***   //data2[27] = ln200.data[7];
;|***     // limit roll_accel to 12-bits and max +- 128 deg/sec^2 range
;|***   //if(data2[27] >  2047) data2[27] =  2047;
;|***   //if(data2[27] < -2048) data2[27] = -2048;
;|***   //data2[27] = data2[27] + s_offset;
;|***     
;|***     // pitch_accel (Qdot), lsb = 2^-6 deg/sec^2/count, range = +-70 deg/sec^2    
;|*** //  data2[28] = int(data[6]  * 0.457142857) + s_offset; // pitch_FAST_ACCEL
;|***   //data2[28] = data[6];
;|***   // limit pitch_accel to 12-bits and max +- 128 deg/sec^2 range  
;|***   //if(data2[28] >  8191) data2[28] =  8191;
;|***   //if(data2[28] < -8192) data2[28] = -8192;
;|***   //data2[28] = (data2[28] >> 2) + s_offset;
;|***   //new 2/10/2005
;|***   //data2[28] = (long)ln200.data[6];
;|***   // limit pitch_accel to 12-bits and max +- 128 deg/sec^2 range  
;|***   //if(data2[28] >  8191) data2[28] =  8191;
;|***   //if(data2[28] < -8192) data2[28] = -8192;
;|***   //data2[28] = (data2[28] >> 2) + s_offset;
;|*** 
;|***     // yaw_accel (Rdot), lsb = 2^-7 deg/sec^2/count, range = +-70 deg/sec^2    
;|***   //data2[29] = int(data[8]  * 0.228571429) + s_offset; // yaw_FAST_ACCEL
;|***   //data2[29] = data[8];
;|***   // limit yaw_accel to 12-bits and max +- 128 deg/sec^2 range  
;|***   //if(data2[29] >  16383) data2[29] =  16383;
;|***   //if(data2[29] < -16384) data2[29] = -16384;
;|***   //data2[29] = (data2[29] >> 3) + s_offset;
;|***   //new 2/10/2005
;|***   //data2[29] = (long)ln200.data[8];
;|***   // limit yaw_accel to 12-bits and max +- 128 deg/sec^2 range  
;|***   //if(data2[29] >  16383) data2[29] =  16383;
;|***   //if(data2[29] < -16384) data2[29] = -16384;
;|***   //data2[29] = (data2[29] >> 3) + s_offset;
;|***   
;|***   data2[26] = 0;
;|***   data2[27] = 0;
;|***   data2[28] = 0;
;|***   data2[29] = 0;
;|***   
;|***     // scale 16-bit data to 12-bit by dividing by 2^4
;|***   data2[30] = ((long)obs.data[21] >> 4)      + s_offset; // prop_cmd
;|***   data2[31] = ((long)obs.data[25] >> 4)      + s_offset; // fwd_cmd
;|***   data2[32] = ((long)obs.data[22] >> 4)      + s_offset; // strn_cmd
;|***   data2[33] = ((long)obs.data[24] >> 4)      + s_offset; // rudd_cmd
;|***   data2[34] = ((long)obs.data[28] >> 4)      + s_offset; // failsafe
;|***   data2[35] = ((long)obs.data[26] >> 4)      + s_offset; // cage/mode
;|***   data2[36] = ((long)obs.data[16] >> 4)      + s_offset; // e_bat
;|***   
;|***     // yaw, ln200 lsb = (2^-15) * 180 deg/count, range = +-180 deg    
;|***   data2[37] = ((long)ln200.data[11] >> 4)      + s_offset; // yaw180  
;|*** 
;|***     // yaw_exp, lsb = (2^-15) * 180 deg/count, range = +-45 deg      
;|***   data2[38] = 0;
;|***   
;|***     // pitch_exp, ln200 lsb = (2^-15) * 180 deg/count, range = +-22.5 deg      
;|***   data2[39] = 0;
;|***   
;|***     // roll, ln200 lsb = (2^-15) * 180 deg/count, range = +-180 deg      
;|***   data2[40] = ((long)ln200.data[10] >> 3) + s_offset; // roll  
;|*** 
;|***     // roll_rate_exp, lsb = 2^-6 deg/sec/count, range = +-14 deg/sec  
;|***     // deleted 2/21/2002 jtm    
;|***   
;|***     // pitch_rate_exp, lsb = 2^-8 deg/sec/count, range = +-14 deg/sec    
;|***     // deleted 2/21/2002 jtm    
;|***   
;|***   // new depth gauges 2/17/2005 jtm
;|***   data2[41] = ((long)obs.data[0] >> 4) + s_offset; // depth 1
;|***   data2[42] = ((long)obs.data[1] >> 4) + s_offset; // depth 2
;|***   data2[43] = ((long)obs.data[2] >> 4) + s_offset; // depth 3
;|***   
;|***   // new status bits
;|***   data2[44] = sys.fs_status & 0x0fff;
;|***   data2[45] = commands.mode  & 0x0fff;
;|*** 
;|***     // yaw_rate_exp, lsb = 2^-9 deg/sec/count, range = +-14 deg/sec  
;|***     // deleted 2/21/2002 jtm
;|***   
;|***     // x_accel_exp, lsb = (2^-6) ft/sec^2/count, range = +-17 ft/sec^2      
;|***     // deleted 2/21/2002 jtm    
;|***     
;|***     // y_accel_exp, lsb = (2^-6) ft/sec^2/count, range = +-17 ft/sec^2        
;|***     // deleted 2/21/2002 jtm    
;|***   
;|***     // z_accel_exp, lsb = (2^-6) ft/sec^2/count, range = +-17 ft/sec^2
;|***     // NOTE:  LN200 reading is compensated for standard gravity: (32.17405 / 2^-6 counts)
;|***     // deleted 2/21/2002 jtm    
;|***   data2[46] = 0;
;|***   
;|***     // Pdot_exp, lsb = 2^-4 deg/sec^2, range = +-17 deg/sec^2
;|***     // deleted 2/21/2002 jtm    
;|***   data2[47] = 0;
;|*** 
;|***   status_word = 0;
;|***   data2[48] = status_word;                          
;|*** 
;|***     // Qdot_exp, lsb = (2^-6) ft/sec^2/count, range = +-17 ft/sec^2                                
;|***     // deleted 2/21/2002 jtm    
;|***   data2[49] = 0;
;|***   
;|***     // Rdot_exp, lsb = (2^-7) ft/sec^2/count, range = +-17 ft/sec^2        
;|***     // deleted 2/21/2002 jtm    
;|***   data2[50] = 0;
;|***     
;|***     //fore plane lvdt
;|***   data2[52] = (long)obs.data[7];
;|***   data2[52] = (data2[52] >> 4) + s_offset;
;|*** 
;|***     //rudder lvdt
;|***   data2[53] = obs.data[6];
;|***   data2[53] = (data2[53] >> 4) + s_offset;
;|*** 
;|***     //stern lvdt
;|***   data2[54] = obs.data[4];  
;|***   data2[54] = (data2[54] >> 4) + s_offset;
;|***   
;|***     // stern tips lvdt
;|***   data2[55] = obs.data[5];
;|***   data2[55] = (data2[55] >> 4) + s_offset;
;|*** 
;|***   
;|***    // prop_voltage, sc1 ch3, mm32 adc ch3; mc output is +- 5V, 40V/V; module is +-10V
;|***    // NOTE:  data is shifted by 3 instead of 4 because 5B module has
;|***    // +/-10 volt input instead of +/- 5 volt input.  ??????????
;|***   //new 2/10/2005
;|***   data2[56] = ((long)obs.data[18] >> 4) + s_offset;  
;|***   //data2[56] = 0;
;|***   
;|***    // prop_current, sc1 ch2, mm32 adc ch2; mc output is +- 5V, 20V/V; module is +-10V
;|***    // NOTE:  data is shifted by 3 instead of 4 because 5B module has
;|***    // +/-10 volt input instead of +/- 5 volt input.  
;|***   //new 2/10/2005
;|***   data2[57] = ((long)obs.data[19] >> 4) + s_offset;
;|***   //data2[57] = 0;
;|*** 
;|***     // pitch, lsb = (2^-15) * 180 deg/count, range = +-90 deg        
;|***   data2[58] = ((long)ln200.data[9] >> 2) + s_offset; // pitch
;|*** 
;|***     // paddle_wheel, module is 500Hz 0-5Volt
;|***   data2[59] = obs.data[3];
;|***   if(data2[59] < 0) data2[59] = 0;    
;|***   data2[59] = (data2[59] >> 4) + s_offset;
;|*** 
;|***     // rpm, 2540 or 5000 pulse/rev, module is 100KHz 0-5Volt
;|***   data2[60] = obs.data[20];
;|***   if(data2[60] < 0) data2[60] = 0;  
;|***   data2[60] = (data2[60] >> 4) + s_offset;  
;|***   
;|*** */    
;|***   
;|***   data[0]  = 0xeb90;        // sync word
; Line 572
	*** 0001b2	c7 86 10 ff 90 eb 	mov	WORD PTR [bp-240],-5232	;eb90H	;data
;|***   data[1]  = sys.fs_status;
; Line 573
	*** 0001b8	8e 06 00 00 		mov	es,WORD PTR $T4071
	*** 0001bc	26 a1 08 00 		mov	ax,WORD PTR es:?sys@@3USYS@@E+8	;sys
	*** 0001c0	89 86 12 ff 		mov	WORD PTR [bp-238],ax
;|***   data[2]  = sys.op_status;
; Line 574
	*** 0001c4	26 a1 0a 00 		mov	ax,WORD PTR es:?sys@@3USYS@@E+10	;sys
	*** 0001c8	89 86 14 ff 		mov	WORD PTR [bp-236],ax
;|***   data[3]  = obs.data[0];  // depth 1
; Line 575
	*** 0001cc	26 a1 0c 00 		mov	ax,WORD PTR es:?obs@@3UOBS@@E+12	;obs
	*** 0001d0	89 86 16 ff 		mov	WORD PTR [bp-234],ax
;|***   data[4]  = obs.data[1];  // depth 2
; Line 576
	*** 0001d4	26 a1 0e 00 		mov	ax,WORD PTR es:?obs@@3UOBS@@E+14	;obs
	*** 0001d8	89 86 18 ff 		mov	WORD PTR [bp-232],ax
;|***   data[5]  = obs.data[2];  // depth 3
; Line 577
	*** 0001dc	26 a1 10 00 		mov	ax,WORD PTR es:?obs@@3UOBS@@E+16	;obs
	*** 0001e0	89 86 1a ff 		mov	WORD PTR [bp-230],ax
;|***   data[6]  = obs.data[3];  // paddle wheel
; Line 578
	*** 0001e4	26 a1 12 00 		mov	ax,WORD PTR es:?obs@@3UOBS@@E+18	;obs
	*** 0001e8	89 86 1c ff 		mov	WORD PTR [bp-228],ax
;|***   data[7]  = obs.data[4];  // stern1 lvdt
; Line 579
	*** 0001ec	26 a1 14 00 		mov	ax,WORD PTR es:?obs@@3UOBS@@E+20	;obs
	*** 0001f0	89 86 1e ff 		mov	WORD PTR [bp-226],ax
;|***   data[8]  = obs.data[5];  // stern2 lvdt
; Line 580
	*** 0001f4	26 a1 16 00 		mov	ax,WORD PTR es:?obs@@3UOBS@@E+22	;obs
	*** 0001f8	89 86 20 ff 		mov	WORD PTR [bp-224],ax
;|***   data[9]  = obs.data[6];  // rudder lvdt
; Line 581
	*** 0001fc	26 a1 18 00 		mov	ax,WORD PTR es:?obs@@3UOBS@@E+24	;obs
	*** 000200	89 86 22 ff 		mov	WORD PTR [bp-222],ax
;|***   data[10] = obs.data[7];  // fore lvdt
; Line 582
	*** 000204	26 a1 1a 00 		mov	ax,WORD PTR es:?obs@@3UOBS@@E+26	;obs
	*** 000208	89 86 24 ff 		mov	WORD PTR [bp-220],ax
;|***   data[11] = obs.data[8];  // spare lvdt
; Line 583
	*** 00020c	26 a1 1c 00 		mov	ax,WORD PTR es:?obs@@3UOBS@@E+28	;obs
	*** 000210	89 86 26 ff 		mov	WORD PTR [bp-218],ax
;|***   data[12] = obs.data[16];  // ebat volts
; Line 584
	*** 000214	26 a1 2c 00 		mov	ax,WORD PTR es:?obs@@3UOBS@@E+44	;obs
	*** 000218	89 86 28 ff 		mov	WORD PTR [bp-216],ax
;|***   data[13] = obs.data[17];  // pbat volts
; Line 585
	*** 00021c	26 a1 2e 00 		mov	ax,WORD PTR es:?obs@@3UOBS@@E+46	;obs
	*** 000220	89 86 2a ff 		mov	WORD PTR [bp-214],ax
;|***   data[14] = obs.data[18];  // prop volts
; Line 586
	*** 000224	26 a1 30 00 		mov	ax,WORD PTR es:?obs@@3UOBS@@E+48	;obs
	*** 000228	89 86 2c ff 		mov	WORD PTR [bp-212],ax
;|***   data[15] = obs.data[19];  // prop amps
; Line 587
	*** 00022c	26 a1 32 00 		mov	ax,WORD PTR es:?obs@@3UOBS@@E+50	;obs
	*** 000230	89 86 2e ff 		mov	WORD PTR [bp-210],ax
;|***   data[16] = obs.data[20];  // 5B module rpm (unsigned)
; Line 588
	*** 000234	26 a1 34 00 		mov	ax,WORD PTR es:?obs@@3UOBS@@E+52	;obs
	*** 000238	89 86 30 ff 		mov	WORD PTR [bp-208],ax
;|***   data[17] = obs.data[21];  // prop discriminator
; Line 589
	*** 00023c	26 a1 36 00 		mov	ax,WORD PTR es:?obs@@3UOBS@@E+54	;obs
	*** 000240	89 86 32 ff 		mov	WORD PTR [bp-206],ax
;|***   data[18] = obs.data[22];   // stern1 discriminator
; Line 590
	*** 000244	26 a1 38 00 		mov	ax,WORD PTR es:?obs@@3UOBS@@E+56	;obs
	*** 000248	89 86 34 ff 		mov	WORD PTR [bp-204],ax
;|***   data[19] = obs.data[23];   // stern2 discriminator
; Line 591
	*** 00024c	26 a1 3a 00 		mov	ax,WORD PTR es:?obs@@3UOBS@@E+58	;obs
	*** 000250	89 86 36 ff 		mov	WORD PTR [bp-202],ax
;|***   data[20] = obs.data[24];   // rudder discriminator
; Line 592
	*** 000254	26 a1 3c 00 		mov	ax,WORD PTR es:?obs@@3UOBS@@E+60	;obs
	*** 000258	89 86 38 ff 		mov	WORD PTR [bp-200],ax
;|***   data[21] = obs.data[25];   // fore discriminator
; Line 593
	*** 00025c	26 a1 3e 00 		mov	ax,WORD PTR es:?obs@@3UOBS@@E+62	;obs
	*** 000260	89 86 3a ff 		mov	WORD PTR [bp-198],ax
;|***   data[22] = obs.data[26];   // mode discriminator
; Line 594
	*** 000264	26 a1 40 00 		mov	ax,WORD PTR es:?obs@@3UOBS@@E+64	;obs
	*** 000268	89 86 3c ff 		mov	WORD PTR [bp-196],ax
;|***   data[23] = obs.data[27];   // ballast discriminator
; Line 595
	*** 00026c	26 a1 42 00 		mov	ax,WORD PTR es:?obs@@3UOBS@@E+66	;obs
	*** 000270	89 86 3e ff 		mov	WORD PTR [bp-194],ax
;|***   data[24] = obs.data[28];   // failsafe discriminator
; Line 596
	*** 000274	26 a1 44 00 		mov	ax,WORD PTR es:?obs@@3UOBS@@E+68	;obs
	*** 000278	89 86 40 ff 		mov	WORD PTR [bp-192],ax
;|***   data[25] = obs.data[29];   // radio mode discriminator
; Line 597
	*** 00027c	26 a1 46 00 		mov	ax,WORD PTR es:?obs@@3UOBS@@E+70	;obs
	*** 000280	89 86 42 ff 		mov	WORD PTR [bp-190],ax
;|***   data[26] = obs.data[30];   // key discriminator
; Line 598
	*** 000284	26 a1 48 00 		mov	ax,WORD PTR es:?obs@@3UOBS@@E+72	;obs
	*** 000288	89 86 44 ff 		mov	WORD PTR [bp-188],ax
;|***   data[27] = prop.rpm;
; Line 599
	*** 00028c	26 a1 18 00 		mov	ax,WORD PTR es:?prop@@3UPROP@@E+24	;prop
	*** 000290	89 86 46 ff 		mov	WORD PTR [bp-186],ax
;|***   data[28] = (int)prop.position;           
; Line 600
	*** 000294	26 a1 1a 00 		mov	ax,WORD PTR es:?prop@@3UPROP@@E+26	;prop
	*** 000298	89 86 48 ff 		mov	WORD PTR [bp-184],ax
;|***   data[29] = ln200.data[0];  // z linear accel 
; Line 601
	*** 00029c	26 a1 0c 00 		mov	ax,WORD PTR es:?ln200@@3ULN200@@E+12	;ln200
	*** 0002a0	89 86 4a ff 		mov	WORD PTR [bp-182],ax
;|***   data[30] = ln200.data[1];  // y linear accel
; Line 602
	*** 0002a4	26 a1 0e 00 		mov	ax,WORD PTR es:?ln200@@3ULN200@@E+14	;ln200
	*** 0002a8	89 86 4c ff 		mov	WORD PTR [bp-180],ax
;|***   data[31] = ln200.data[2];  // x linear accel
; Line 603
	*** 0002ac	26 a1 10 00 		mov	ax,WORD PTR es:?ln200@@3ULN200@@E+16	;ln200
	*** 0002b0	89 86 4e ff 		mov	WORD PTR [bp-178],ax
;|***   data[32] = ln200.data[3];  // y angular rate
; Line 604
	*** 0002b4	26 a1 12 00 		mov	ax,WORD PTR es:?ln200@@3ULN200@@E+18	;ln200
	*** 0002b8	89 86 50 ff 		mov	WORD PTR [bp-176],ax
;|***   data[33] = ln200.data[4];  // x angular rate
; Line 605
	*** 0002bc	26 a1 14 00 		mov	ax,WORD PTR es:?ln200@@3ULN200@@E+20	;ln200
	*** 0002c0	89 86 52 ff 		mov	WORD PTR [bp-174],ax
;|***   data[34] = ln200.data[5];  // z angular rate
; Line 606
	*** 0002c4	26 a1 16 00 		mov	ax,WORD PTR es:?ln200@@3ULN200@@E+22	;ln200
	*** 0002c8	89 86 54 ff 		mov	WORD PTR [bp-172],ax
;|***   data[35] = ln200.data[6];  // y angular accel
; Line 607
	*** 0002cc	26 a1 18 00 		mov	ax,WORD PTR es:?ln200@@3ULN200@@E+24	;ln200
	*** 0002d0	89 86 56 ff 		mov	WORD PTR [bp-170],ax
;|***   data[36] = ln200.data[7];  // x angular accel
; Line 608
	*** 0002d4	26 a1 1a 00 		mov	ax,WORD PTR es:?ln200@@3ULN200@@E+26	;ln200
	*** 0002d8	89 86 58 ff 		mov	WORD PTR [bp-168],ax
;|***   data[37] = ln200.data[8];  // z angular accel
; Line 609
	*** 0002dc	26 a1 1c 00 		mov	ax,WORD PTR es:?ln200@@3ULN200@@E+28	;ln200
	*** 0002e0	89 86 5a ff 		mov	WORD PTR [bp-166],ax
;|***   data[38] = ln200.data[9];  // pitch
; Line 610
	*** 0002e4	26 a1 1e 00 		mov	ax,WORD PTR es:?ln200@@3ULN200@@E+30	;ln200
	*** 0002e8	89 86 5c ff 		mov	WORD PTR [bp-164],ax
;|***   data[39] = ln200.data[10]; // roll 
; Line 611
	*** 0002ec	26 a1 20 00 		mov	ax,WORD PTR es:?ln200@@3ULN200@@E+32	;ln200
	*** 0002f0	89 86 5e ff 		mov	WORD PTR [bp-162],ax
;|***   data[40] = ln200.data[11]; // heading 
; Line 612
	*** 0002f4	26 a1 22 00 		mov	ax,WORD PTR es:?ln200@@3ULN200@@E+34	;ln200
	*** 0002f8	89 86 60 ff 		mov	WORD PTR [bp-160],ax
;|***   data[41] = commands.mode;
; Line 613
	*** 0002fc	26 a1 02 00 		mov	ax,WORD PTR es:?commands@@3UCOMMANDS@@E+2	;commands
	*** 000300	89 86 62 ff 		mov	WORD PTR [bp-158],ax
;|***   data[42] = commands.rpm;
; Line 614
	*** 000304	26 a1 04 00 		mov	ax,WORD PTR es:?commands@@3UCOMMANDS@@E+4	;commands
	*** 000308	89 86 64 ff 		mov	WORD PTR [bp-156],ax
;|***   data[43] = commands.rudder;
; Line 615
	*** 00030c	26 a1 06 00 		mov	ax,WORD PTR es:?commands@@3UCOMMANDS@@E+6	;commands
	*** 000310	89 86 66 ff 		mov	WORD PTR [bp-154],ax
;|***   data[44] = commands.stern1;
; Line 616
	*** 000314	26 a1 08 00 		mov	ax,WORD PTR es:?commands@@3UCOMMANDS@@E+8	;commands
	*** 000318	89 86 68 ff 		mov	WORD PTR [bp-152],ax
;|***   data[45] = commands.stern2;
; Line 617
	*** 00031c	26 a1 0a 00 		mov	ax,WORD PTR es:?commands@@3UCOMMANDS@@E+10	;commands
	*** 000320	89 86 6a ff 		mov	WORD PTR [bp-150],ax
;|***   data[46] = commands.fore;
; Line 618
	*** 000324	26 a1 0c 00 		mov	ax,WORD PTR es:?commands@@3UCOMMANDS@@E+12	;commands
	*** 000328	89 86 6c ff 		mov	WORD PTR [bp-148],ax
;|***   data[47] = commands.ballast;
; Line 619
	*** 00032c	26 a1 0e 00 		mov	ax,WORD PTR es:?commands@@3UCOMMANDS@@E+14	;commands
	*** 000330	89 86 6e ff 		mov	WORD PTR [bp-146],ax
;|***   data[48] = commands.ds_dmgx;
; Line 620
	*** 000334	26 a1 1c 00 		mov	ax,WORD PTR es:?commands@@3UCOMMANDS@@E+28	;commands
	*** 000338	89 86 70 ff 		mov	WORD PTR [bp-144],ax
;|***   data[49] = commands.ds_dmgy;
; Line 621
	*** 00033c	26 a1 1e 00 		mov	ax,WORD PTR es:?commands@@3UCOMMANDS@@E+30	;commands
	*** 000340	89 86 72 ff 		mov	WORD PTR [bp-142],ax
;|***   data[50] = commands.ds_dmgz;
; Line 622
	*** 000344	26 a1 20 00 		mov	ax,WORD PTR es:?commands@@3UCOMMANDS@@E+32	;commands
	*** 000348	89 86 74 ff 		mov	WORD PTR [bp-140],ax
;|***   data[51] = commands.spare1;
; Line 623
	*** 00034c	26 a1 22 00 		mov	ax,WORD PTR es:?commands@@3UCOMMANDS@@E+34	;commands
	*** 000350	89 86 76 ff 		mov	WORD PTR [bp-138],ax
;|***   memcpy(&data[52],&adcp.data[154],2); // y_vel_btm;
; Line 624
	*** 000354	6a 02 			push	2
	*** 000356	68 00 00 		push	SEG ?adcp@@3UADCP@@E	;adcp
	*** 000359	68 a6 00 		push	OFFSET ?adcp@@3UADCP@@E+166	;adcp
	*** 00035c	8d 86 78 ff 		lea	ax,WORD PTR [bp-136]
	*** 000360	16 			push	ss
	*** 000361	50 			push	ax
	*** 000362	b8 ac 00 		mov	ax,172	;00acH
	*** 000365	ff d0 			call	ax
;|***   memcpy(&data[53],&adcp.data[158],2); // z_vel_btm;
; Line 625
	*** 000367	6a 02 			push	2
	*** 000369	68 00 00 		push	SEG ?adcp@@3UADCP@@E	;adcp
	*** 00036c	68 aa 00 		push	OFFSET ?adcp@@3UADCP@@E+170	;adcp
	*** 00036f	8d 86 7a ff 		lea	ax,WORD PTR [bp-134]
	*** 000373	16 			push	ss
	*** 000374	50 			push	ax
	*** 000375	b8 ac 00 		mov	ax,172	;00acH
	*** 000378	ff d0 			call	ax
;|***   memcpy(&data[54],&adcp.data[156],2); // x_vel_btm;
; Line 626
	*** 00037a	6a 02 			push	2
	*** 00037c	68 00 00 		push	SEG ?adcp@@3UADCP@@E	;adcp
	*** 00037f	68 a8 00 		push	OFFSET ?adcp@@3UADCP@@E+168	;adcp
	*** 000382	8d 86 7c ff 		lea	ax,WORD PTR [bp-132]
	*** 000386	16 			push	ss
	*** 000387	50 			push	ax
	*** 000388	b8 ac 00 		mov	ax,172	;00acH
	*** 00038b	ff d0 			call	ax
;|***   memcpy(&data[55],&adcp.data[146],2); // bm1_rng_to_btm;
; Line 627
	*** 00038d	6a 02 			push	2
	*** 00038f	68 00 00 		push	SEG ?adcp@@3UADCP@@E	;adcp
	*** 000392	68 9e 00 		push	OFFSET ?adcp@@3UADCP@@E+158	;adcp
	*** 000395	8d 86 7e ff 		lea	ax,WORD PTR [bp-130]
	*** 000399	16 			push	ss
	*** 00039a	50 			push	ax
	*** 00039b	b8 ac 00 		mov	ax,172	;00acH
	*** 00039e	ff d0 			call	ax
;|***   memcpy(&data[56],&adcp.data[148],2); // bm2_rng_to_btm;
; Line 628
	*** 0003a0	6a 02 			push	2
	*** 0003a2	68 00 00 		push	SEG ?adcp@@3UADCP@@E	;adcp
	*** 0003a5	68 a0 00 		push	OFFSET ?adcp@@3UADCP@@E+160	;adcp
	*** 0003a8	8d 46 80 		lea	ax,WORD PTR [bp-128]
	*** 0003ab	16 			push	ss
	*** 0003ac	50 			push	ax
	*** 0003ad	b8 ac 00 		mov	ax,172	;00acH
	*** 0003b0	ff d0 			call	ax
;|***   memcpy(&data[57],&adcp.data[150],2); // bm3_rng_to_btm;
; Line 629
	*** 0003b2	6a 02 			push	2
	*** 0003b4	68 00 00 		push	SEG ?adcp@@3UADCP@@E	;adcp
	*** 0003b7	68 a2 00 		push	OFFSET ?adcp@@3UADCP@@E+162	;adcp
	*** 0003ba	8d 46 82 		lea	ax,WORD PTR [bp-126]
	*** 0003bd	16 			push	ss
	*** 0003be	50 			push	ax
	*** 0003bf	b8 ac 00 		mov	ax,172	;00acH
	*** 0003c2	ff d0 			call	ax
;|***   memcpy(&data[58],&adcp.data[152],2); // bm4_rng_to_btm;
; Line 630
	*** 0003c4	6a 02 			push	2
	*** 0003c6	68 00 00 		push	SEG ?adcp@@3UADCP@@E	;adcp
	*** 0003c9	68 a4 00 		push	OFFSET ?adcp@@3UADCP@@E+164	;adcp
	*** 0003cc	8d 46 84 		lea	ax,WORD PTR [bp-124]
	*** 0003cf	16 			push	ss
	*** 0003d0	50 			push	ax
	*** 0003d1	b8 ac 00 		mov	ax,172	;00acH
	*** 0003d4	ff d0 			call	ax
;|***   data[59] = 0;
; Line 631
	*** 0003d6	c7 46 86 00 00 		mov	WORD PTR [bp-122],0
;|***   _fmemcpy(&data[60],&dyno.data,2*60);
; Line 632
	*** 0003db	b8 00 00 		mov	ax,SEG ?dyno@@3UDYNO@@E	;dyno
	*** 0003de	1e 			push	ds
	*** 0003df	8d 7e 88 		lea	di,WORD PTR [bp-120]
	*** 0003e2	be 0c 00 		mov	si,OFFSET ?dyno@@3UDYNO@@E+12	;dyno
	*** 0003e5	16 			push	ss
	*** 0003e6	07 			pop	es
	*** 0003e7	8e d8 			mov	ds,ax
	ASSUME DS: SEG ?dyno@@3UDYNO@@E
	*** 0003e9	b9 3c 00 		mov	cx,60	;003cH
	*** 0003ec	f3 			rep
	*** 0003ed	a5 			movsw
	*** 0003ee	1f 			pop	ds
	ASSUME DS: DGROUP
;|***   _fmemcpy(pcm,data,sizeof(pcm));
; Line 633
	*** 0003ef	bf 00 00 		mov	di,OFFSET DGROUP:?pcm@@3QIDI	;pcm
	*** 0003f2	8d b6 10 ff 		lea	si,WORD PTR [bp-240]	;data
	*** 0003f6	8c d8 			mov	ax,ds
	*** 0003f8	8e c0 			mov	es,ax
	*** 0003fa	b9 78 00 		mov	cx,120	;0078H
	*** 0003fd	f3 			rep
	*** 0003fe	a5 			movsw
;|***   }  
; Line 634
	*** 0003ff	5e 			pop	si
	*** 000400	5f 			pop	di
	*** 000401	c9 			leave	
	*** 000402	cb 			ret	
	*** 000403	90 			nop	

?pack_pcm@@ZAXXZ	ENDP
	PUBLIC	?get_frame_time@@ZAXXZ	; get_frame_time
?get_frame_time@@ZAXXZ	PROC FAR	; get_frame_time
;|*** 
;|*** 
;|*** void get_frame_time(void)
;|***   {
;|***   _disable();
; Line 639
	*** 000404	fa 			cli	
;|***   time_stamp(&frame_time);
; Line 640
	*** 000405	68 00 00 		push	SEG ?frame_time@@3UTIMER@@E	;frame_time
	*** 000408	68 00 00 		push	OFFSET ?frame_time@@3UTIMER@@E	;frame_time
	*** 00040b	0e 			push	cs
	*** 00040c	e8 00 00 		call	NEAR PTR ?time_stamp@@ZAXPEUTIMER@@@Z	; time_stamp
	*** 00040f	83 c4 04 		add	sp,4
;|***   _enable();
; Line 641
	*** 000412	fb 			sti	
;|***   }
; Line 642
	*** 000413	cb 			ret	

?get_frame_time@@ZAXXZ	ENDP
	PUBLIC	?send_data_packet@@ZAXXZ	; send_data_packet
?send_data_packet@@ZAXXZ	PROC FAR	; send_data_packet
;|***   
;|***   
;|*** void send_data_packet(void)
;|***   {
; Line 646
;	lsb = -2
;	msb = -4
;|***   unsigned int lsb = 0;
;|***   unsigned int msb = 0;
;|***   
;|***   build_packet();
; Line 650
	*** 000414	0e 			push	cs
	*** 000415	e8 00 00 		call	NEAR PTR ?build_packet@@ZAXXZ	; build_packet
;|***   send_pkt(data_pkt, 1514);  // 1514 bytes total w/o checksum
; Line 651
	*** 000418	68 ea 05 		push	1514	;05eaH
	*** 00041b	1e 			push	ds
	*** 00041c	68 00 00 		push	OFFSET DGROUP:?data_pkt@@3QIEI	;data_pkt
	*** 00041f	9a 00 00 00 00 		call	FAR PTR ?send_pkt@@ZAHPEEI@Z	; send_pkt
	*** 000424	83 c4 06 		add	sp,6
;|***   }
; Line 652
	*** 000427	cb 			ret	

?send_data_packet@@ZAXXZ	ENDP
	PUBLIC	?apply_commands@@ZAXXZ	; apply_commands
?apply_commands@@ZAXXZ	PROC FAR	; apply_commands
;|***   
;|***   
;|*** void apply_commands(void)
;|***   {
; Line 656
	*** 000428	c8 04 00 00 		enter	4,0
	*** 00042c	57 			push	di
	*** 00042d	56 			push	si
;	lsb = -2
;	msb = -4
;|***   unsigned int lsb = 0;
;|***   unsigned int msb = 0;
;|*** 
;|***   // get commands from buffered udp packet
;|***   _disable();
; Line 661
	*** 00042e	fa 			cli	
;|***   _fmemcpy(&commands, &cmd_buffer[42], sizeof(commands));
; Line 662
	*** 00042f	8e 06 00 00 		mov	es,WORD PTR $T4071
	*** 000433	b8 00 00 		mov	ax,SEG ?cmd_buffer@@3QEEE	;cmd_buffer
	*** 000436	1e 			push	ds
	*** 000437	bf 00 00 		mov	di,OFFSET ?commands@@3UCOMMANDS@@E	;commands
	*** 00043a	be 2a 00 		mov	si,OFFSET ?cmd_buffer@@3QEEE+42	;cmd_buffer
	*** 00043d	8e d8 			mov	ds,ax
	ASSUME DS: SEG ?cmd_buffer@@3QEEE
	*** 00043f	b9 12 00 		mov	cx,18	;0012H
	*** 000442	f3 			rep
	*** 000443	a5 			movsw
	*** 000444	1f 			pop	ds
	ASSUME DS: DGROUP
;|***   _enable();
; Line 663
	*** 000445	fb 			sti	
;|***   
;|***   // zero out the commands if no response from control for 1 second (100 frames) (new 8/24/2005 jtm)
;|***   if(++time_since_last_command > 100)  
; Line 666
	*** 000446	ff 06 00 00 		inc	WORD PTR ?time_since_last_command@@3HE	;time_since_last_command
	*** 00044a	83 3e 00 00 64 		cmp	WORD PTR ?time_since_last_command@@3HE,100	;0064H	;time_since_last_command
	*** 00044f	7e 1a 			jle	$I3696
;|***     {                                
;|***     commands.rpm = 0;
; Line 668
	*** 000451	26 c7 06 04 00 00 00 	mov	WORD PTR es:?commands@@3UCOMMANDS@@E+4,0	;commands
;|***     commands.rudder = 0x800;
;|***     commands.stern1 = 0x800;
;|***     commands.stern2 = 0x800;
;|***     commands.fore   = 0x800;
; Line 672
	*** 000458	b8 00 08 		mov	ax,2048	;0800H
	*** 00045b	26 a3 06 00 		mov	WORD PTR es:?commands@@3UCOMMANDS@@E+6,ax	;commands
	*** 00045f	26 a3 08 00 		mov	WORD PTR es:?commands@@3UCOMMANDS@@E+8,ax	;commands
	*** 000463	26 a3 0a 00 		mov	WORD PTR es:?commands@@3UCOMMANDS@@E+10,ax	;commands
	*** 000467	26 a3 0c 00 		mov	WORD PTR es:?commands@@3UCOMMANDS@@E+12,ax	;commands
;|***     }
;|*** 
;|***   
;|***   //  blow the ERS if no response from control for 2 minutes
;|***   if(time_since_last_command > 12000)  
; Line 677
					$I3696:
	*** 00046b	81 3e 00 00 e0 2e 	cmp	WORD PTR ?time_since_last_command@@3HE,12000	;2ee0H	;time_since_last_command
	*** 000471	7e 0c 			jle	$I3697
;|***     {                                
;|***     commands.ballast = commands.ballast | ERS_BLOW;
; Line 679
	*** 000473	26 80 0e 0f 00 04 	or	BYTE PTR es:?commands@@3UCOMMANDS@@E+15,4	;commands
;|***     time_since_last_command = 12000;
; Line 680
	*** 000479	c7 06 00 00 e0 2e 	mov	WORD PTR ?time_since_last_command@@3HE,12000	;2ee0H	;time_since_last_command
;|***     }
;|***     
;|***   // apply commands
;|***   // stern1
;|***   sprintf(s, "Stern1:    %04x", commands.stern1);
; Line 685
					$I3697:
	*** 00047f	26 ff 36 08 00 		push	WORD PTR es:?commands@@3UCOMMANDS@@E+8	;commands
	*** 000484	1e 			push	ds
	*** 000485	68 00 00 		push	OFFSET DGROUP:$SG3698
	*** 000488	1e 			push	ds
	*** 000489	68 00 00 		push	OFFSET DGROUP:?s@@3QIDI	;s
	*** 00048c	9a 00 00 00 00 		call	FAR PTR _sprintf
	*** 000491	83 c4 0a 		add	sp,10	;000aH
;|***   PC_DispStr(20,16, (unsigned char *)s, DISP_FGND_BLACK + DISP_BGND_RED);
; Line 686
	*** 000494	6a 40 			push	64	;0040H
	*** 000496	1e 			push	ds
	*** 000497	68 00 00 		push	OFFSET DGROUP:?s@@3QIDI	;s
	*** 00049a	6a 10 			push	16	;0010H
	*** 00049c	6a 14 			push	20	;0014H
	*** 00049e	0e 			push	cs
	*** 00049f	e8 00 00 		call	NEAR PTR ?PC_DispStr@@ZAXEEPIEE@Z	; PC_DispStr
	*** 0004a2	83 c4 0a 		add	sp,10	;000aH
;|***   while(_inp(OBS_BASE+DACLSB) & 0x80);
; Line 687
					$FC3701:
	*** 0004a5	ba 44 03 		mov	dx,836	;0344H
	*** 0004a8	ec 			in	al,dx
	*** 0004a9	a8 80 			test	al,128	;0080H
	*** 0004ab	75 f8 			jne	$FC3701
	*** 0004ad	b8 00 00 		mov	ax,SEG ?commands@@3UCOMMANDS@@E	;commands
	*** 0004b0	8e c0 			mov	es,ax
;|***   _outp(OBS_BASE+DACLSB, commands.stern1 & 0xff);
; Line 688
	*** 0004b2	26 a0 08 00 		mov	al,BYTE PTR es:?commands@@3UCOMMANDS@@E+8	;commands
	*** 0004b6	2a e4 			sub	ah,ah
	*** 0004b8	ee 			out	dx, al

;|***   _outp(OBS_BASE+DACMSB, (commands.stern1>>8) & 0x0f | STERN1_CHAN);
; Line 689
	*** 0004b9	26 a0 09 00 		mov	al,BYTE PTR es:?commands@@3UCOMMANDS@@E+9	;commands
	*** 0004bd	25 0f 00 		and	ax,15	;000fH
	*** 0004c0	ba 45 03 		mov	dx,837	;0345H
	*** 0004c3	ee 			out	dx, al

;|***   while(_inp(OBS_BASE+DACLSB) & 0x80);
; Line 690
					$FC3704:
	*** 0004c4	ba 44 03 		mov	dx,836	;0344H
	*** 0004c7	ec 			in	al,dx
	*** 0004c8	a8 80 			test	al,128	;0080H
	*** 0004ca	75 f8 			jne	$FC3704
;|***   _inp( OBS_BASE+DACMSB);
; Line 691
	*** 0004cc	ba 45 03 		mov	dx,837	;0345H
	*** 0004cf	ec 			in	al,dx
;|*** 
;|***   // stern2
;|***   sprintf(s, "Stern2:    %04x", commands.stern2);
; Line 694
	*** 0004d0	8e 06 00 00 		mov	es,WORD PTR $T4071
	*** 0004d4	26 ff 36 0a 00 		push	WORD PTR es:?commands@@3UCOMMANDS@@E+10	;commands
	*** 0004d9	1e 			push	ds
	*** 0004da	68 00 00 		push	OFFSET DGROUP:$SG3706
	*** 0004dd	1e 			push	ds
	*** 0004de	68 00 00 		push	OFFSET DGROUP:?s@@3QIDI	;s
	*** 0004e1	9a 00 00 00 00 		call	FAR PTR _sprintf
	*** 0004e6	83 c4 0a 		add	sp,10	;000aH
;|***   PC_DispStr(20,17, (unsigned char *)s, DISP_FGND_BLACK + DISP_BGND_RED);
; Line 695
	*** 0004e9	6a 40 			push	64	;0040H
	*** 0004eb	1e 			push	ds
	*** 0004ec	68 00 00 		push	OFFSET DGROUP:?s@@3QIDI	;s
	*** 0004ef	6a 11 			push	17	;0011H
	*** 0004f1	6a 14 			push	20	;0014H
	*** 0004f3	0e 			push	cs
	*** 0004f4	e8 00 00 		call	NEAR PTR ?PC_DispStr@@ZAXEEPIEE@Z	; PC_DispStr
	*** 0004f7	83 c4 0a 		add	sp,10	;000aH
;|***   while(_inp(OBS_BASE+DACLSB) & 0x80);
; Line 696
					$FC3709:
	*** 0004fa	ba 44 03 		mov	dx,836	;0344H
	*** 0004fd	ec 			in	al,dx
	*** 0004fe	a8 80 			test	al,128	;0080H
	*** 000500	75 f8 			jne	$FC3709
	*** 000502	b8 00 00 		mov	ax,SEG ?commands@@3UCOMMANDS@@E	;commands
	*** 000505	8e c0 			mov	es,ax
;|***   _outp(OBS_BASE+DACLSB, commands.stern2 & 0xff);
; Line 697
	*** 000507	26 a0 0a 00 		mov	al,BYTE PTR es:?commands@@3UCOMMANDS@@E+10	;commands
	*** 00050b	2a e4 			sub	ah,ah
	*** 00050d	ee 			out	dx, al

;|***   _outp(OBS_BASE+DACMSB, (commands.stern2>>8) & 0x0f | STERN2_CHAN);
; Line 698
	*** 00050e	26 a0 0b 00 		mov	al,BYTE PTR es:?commands@@3UCOMMANDS@@E+11	;commands
	*** 000512	25 0f 00 		and	ax,15	;000fH
	*** 000515	0c 40 			or	al,64	;0040H
	*** 000517	ba 45 03 		mov	dx,837	;0345H
	*** 00051a	ee 			out	dx, al

;|***   while(_inp(OBS_BASE+DACLSB) & 0x80);
; Line 699
					$FC3712:
	*** 00051b	ba 44 03 		mov	dx,836	;0344H
	*** 00051e	ec 			in	al,dx
	*** 00051f	a8 80 			test	al,128	;0080H
	*** 000521	75 f8 			jne	$FC3712
;|***   _inp( OBS_BASE+DACMSB);
; Line 700
	*** 000523	ba 45 03 		mov	dx,837	;0345H
	*** 000526	ec 			in	al,dx
;|***   
;|***   // forward
;|***   while(_inp(OBS_BASE+DACLSB) & 0x80);
; Line 703
					$FC3715:
	*** 000527	ba 44 03 		mov	dx,836	;0344H
	*** 00052a	ec 			in	al,dx
	*** 00052b	a8 80 			test	al,128	;0080H
	*** 00052d	75 f8 			jne	$FC3715
;|***   _outp(OBS_BASE+DACLSB, commands.fore & 0xff);
; Line 704
	*** 00052f	26 a0 0c 00 		mov	al,BYTE PTR es:?commands@@3UCOMMANDS@@E+12	;commands
	*** 000533	2a e4 			sub	ah,ah
	*** 000535	ee 			out	dx, al

;|***   _outp(OBS_BASE+DACMSB, (commands.fore>>8) & 0x0f | FORE_CHAN);
; Line 705
	*** 000536	26 8a 26 0d 00 		mov	ah,BYTE PTR es:?commands@@3UCOMMANDS@@E+13	;commands
	*** 00053b	25 00 0f 		and	ax,3840	;0f00H
	*** 00053e	0d ff c0 		or	ax,-16129	;c0ffH
	*** 000541	c1 e8 08 		shr	ax,8
	*** 000544	ba 45 03 		mov	dx,837	;0345H
	*** 000547	ee 			out	dx, al

;|***   while(_inp(OBS_BASE+DACLSB) & 0x80);
; Line 706
					$FC3718:
	*** 000548	ba 44 03 		mov	dx,836	;0344H
	*** 00054b	ec 			in	al,dx
	*** 00054c	a8 80 			test	al,128	;0080H
	*** 00054e	75 f8 			jne	$FC3718
;|***   _inp( OBS_BASE+DACMSB);
; Line 707
	*** 000550	ba 45 03 		mov	dx,837	;0345H
	*** 000553	ec 			in	al,dx
;|***   
;|***   // rudder
;|***   sprintf(s, "Rudder:    %04x", commands.rudder);
; Line 710
	*** 000554	8e 06 00 00 		mov	es,WORD PTR $T4071
	*** 000558	26 ff 36 06 00 		push	WORD PTR es:?commands@@3UCOMMANDS@@E+6	;commands
	*** 00055d	1e 			push	ds
	*** 00055e	68 00 00 		push	OFFSET DGROUP:$SG3720
	*** 000561	1e 			push	ds
	*** 000562	68 00 00 		push	OFFSET DGROUP:?s@@3QIDI	;s
	*** 000565	9a 00 00 00 00 		call	FAR PTR _sprintf
	*** 00056a	83 c4 0a 		add	sp,10	;000aH
;|***   PC_DispStr(20,19, (unsigned char *)s, DISP_FGND_BLACK + DISP_BGND_RED);
; Line 711
	*** 00056d	6a 40 			push	64	;0040H
	*** 00056f	1e 			push	ds
	*** 000570	68 00 00 		push	OFFSET DGROUP:?s@@3QIDI	;s
	*** 000573	6a 13 			push	19	;0013H
	*** 000575	6a 14 			push	20	;0014H
	*** 000577	0e 			push	cs
	*** 000578	e8 00 00 		call	NEAR PTR ?PC_DispStr@@ZAXEEPIEE@Z	; PC_DispStr
	*** 00057b	83 c4 0a 		add	sp,10	;000aH
;|***   while(_inp(OBS_BASE+DACLSB) & 0x80);
; Line 712
					$FC3723:
	*** 00057e	ba 44 03 		mov	dx,836	;0344H
	*** 000581	ec 			in	al,dx
	*** 000582	a8 80 			test	al,128	;0080H
	*** 000584	75 f8 			jne	$FC3723
	*** 000586	b8 00 00 		mov	ax,SEG ?commands@@3UCOMMANDS@@E	;commands
	*** 000589	8e c0 			mov	es,ax
;|***   _outp(OBS_BASE+DACLSB, commands.rudder & 0xff);
; Line 713
	*** 00058b	26 a0 06 00 		mov	al,BYTE PTR es:?commands@@3UCOMMANDS@@E+6	;commands
	*** 00058f	2a e4 			sub	ah,ah
	*** 000591	ee 			out	dx, al

;|***   _outp(OBS_BASE+DACMSB, (commands.rudder>>8) & 0x0f | RUDDER_CHAN);
; Line 714
	*** 000592	26 8a 26 07 00 		mov	ah,BYTE PTR es:?commands@@3UCOMMANDS@@E+7	;commands
	*** 000597	25 00 0f 		and	ax,3840	;0f00H
	*** 00059a	0d ff 80 		or	ax,-32513	;80ffH
	*** 00059d	c1 e8 08 		shr	ax,8
	*** 0005a0	ba 45 03 		mov	dx,837	;0345H
	*** 0005a3	ee 			out	dx, al

;|***   while(_inp(OBS_BASE+DACLSB) & 0x80);
; Line 715
					$FC3726:
	*** 0005a4	ba 44 03 		mov	dx,836	;0344H
	*** 0005a7	ec 			in	al,dx
	*** 0005a8	a8 80 			test	al,128	;0080H
	*** 0005aa	75 f8 			jne	$FC3726
;|***   _inp( OBS_BASE+DACMSB);
; Line 716
	*** 0005ac	ba 45 03 		mov	dx,837	;0345H
	*** 0005af	ec 			in	al,dx
;|***   
;|***   // prop
;|***   sprintf(s, "Prop:      %04x", commands.rpm);
; Line 719
	*** 0005b0	8e 06 00 00 		mov	es,WORD PTR $T4071
	*** 0005b4	26 ff 36 04 00 		push	WORD PTR es:?commands@@3UCOMMANDS@@E+4	;commands
	*** 0005b9	1e 			push	ds
	*** 0005ba	68 00 00 		push	OFFSET DGROUP:$SG3728
	*** 0005bd	1e 			push	ds
	*** 0005be	68 00 00 		push	OFFSET DGROUP:?s@@3QIDI	;s
	*** 0005c1	9a 00 00 00 00 		call	FAR PTR _sprintf
	*** 0005c6	83 c4 0a 		add	sp,10	;000aH
;|***   PC_DispStr(20,18, (unsigned char *)s, DISP_FGND_BLACK + DISP_BGND_RED);
; Line 720
	*** 0005c9	6a 40 			push	64	;0040H
	*** 0005cb	1e 			push	ds
	*** 0005cc	68 00 00 		push	OFFSET DGROUP:?s@@3QIDI	;s
	*** 0005cf	6a 12 			push	18	;0012H
	*** 0005d1	6a 14 			push	20	;0014H
	*** 0005d3	0e 			push	cs
	*** 0005d4	e8 00 00 		call	NEAR PTR ?PC_DispStr@@ZAXEEPIEE@Z	; PC_DispStr
	*** 0005d7	83 c4 0a 		add	sp,10	;000aH
;|***   te5650SetMotor(commands.rpm);
; Line 721
	*** 0005da	8e 06 00 00 		mov	es,WORD PTR $T4071
	*** 0005de	26 ff 36 04 00 		push	WORD PTR es:?commands@@3UCOMMANDS@@E+4	;commands
	*** 0005e3	9a 00 00 00 00 		call	FAR PTR _te5650SetMotor
	*** 0005e8	83 c4 02 		add	sp,2
;|***   te5650Update();
; Line 722
	*** 0005eb	9a 00 00 00 00 		call	FAR PTR _te5650Update
;|*** 
;|***   // ballast
;|***   // ers blow  
;|***   sprintf(s, "Ballast:   %04x", commands.ballast);
; Line 726
	*** 0005f0	bb 0e 00 		mov	bx,OFFSET ?commands@@3UCOMMANDS@@E+14	;commands
	*** 0005f3	8e 06 00 00 		mov	es,WORD PTR $T4071
	*** 0005f7	89 5e fc 		mov	WORD PTR [bp-4],bx	;msb
	*** 0005fa	8c 46 fe 		mov	WORD PTR [bp-2],es	;lsb
	*** 0005fd	26 ff 37 		push	WORD PTR es:[bx]
	*** 000600	1e 			push	ds
	*** 000601	68 00 00 		push	OFFSET DGROUP:$SG3730
	*** 000604	1e 			push	ds
	*** 000605	68 00 00 		push	OFFSET DGROUP:?s@@3QIDI	;s
	*** 000608	9a 00 00 00 00 		call	FAR PTR _sprintf
	*** 00060d	83 c4 0a 		add	sp,10	;000aH
;|***   PC_DispStr(20,20, (unsigned char *)s, DISP_FGND_BLACK + DISP_BGND_RED);
; Line 727
	*** 000610	6a 40 			push	64	;0040H
	*** 000612	1e 			push	ds
	*** 000613	68 00 00 		push	OFFSET DGROUP:?s@@3QIDI	;s
	*** 000616	6a 14 			push	20	;0014H
	*** 000618	6a 14 			push	20	;0014H
	*** 00061a	0e 			push	cs
	*** 00061b	e8 00 00 		call	NEAR PTR ?PC_DispStr@@ZAXEEPIEE@Z	; PC_DispStr
	*** 00061e	83 c4 0a 		add	sp,10	;000aH
;|***   if(commands.ballast & ERS_BLOW)
; Line 728
	*** 000621	c4 5e fc 		les	bx,DWORD PTR [bp-4]	;msb
	*** 000624	26 f6 47 01 04 		test	BYTE PTR es:[bx+1],4
	*** 000629	74 60 			je	$I3732
;|***     {
;|***     write_bit(PUMP,   PUMPOFF);
; Line 730
	*** 00062b	6a 01 			push	1
	*** 00062d	6a 10 			push	16	;0010H
	*** 00062f	9a 00 00 00 00 		call	FAR PTR ?write_bit@@ZAXHH@Z	; write_bit
	*** 000634	83 c4 04 		add	sp,4
;|***     write_bit(VALVE1, VALVEOFF);
; Line 731
	*** 000637	6a 01 			push	1
	*** 000639	6a 0a 			push	10	;000aH
	*** 00063b	9a 00 00 00 00 		call	FAR PTR ?write_bit@@ZAXHH@Z	; write_bit
	*** 000640	83 c4 04 		add	sp,4
;|***     write_bit(VALVE2, VALVEOFF);
; Line 732
	*** 000643	6a 01 			push	1
	*** 000645	6a 0b 			push	11	;000bH
	*** 000647	9a 00 00 00 00 		call	FAR PTR ?write_bit@@ZAXHH@Z	; write_bit
	*** 00064c	83 c4 04 		add	sp,4
;|***     write_bit(VALVE3, VALVEOFF);
; Line 733
	*** 00064f	6a 01 			push	1
	*** 000651	6a 0c 			push	12	;000cH
	*** 000653	9a 00 00 00 00 		call	FAR PTR ?write_bit@@ZAXHH@Z	; write_bit
	*** 000658	83 c4 04 		add	sp,4
;|***     write_bit(VALVE4, VALVEOFF);
; Line 734
	*** 00065b	6a 01 			push	1
	*** 00065d	6a 0d 			push	13	;000dH
	*** 00065f	9a 00 00 00 00 		call	FAR PTR ?write_bit@@ZAXHH@Z	; write_bit
	*** 000664	83 c4 04 		add	sp,4
;|***     write_bit(VALVE5, VALVEOFF);
; Line 735
	*** 000667	6a 01 			push	1
	*** 000669	6a 0e 			push	14	;000eH
	*** 00066b	9a 00 00 00 00 		call	FAR PTR ?write_bit@@ZAXHH@Z	; write_bit
	*** 000670	83 c4 04 		add	sp,4
;|***     write_bit(VALVE6, VALVEOFF);
; Line 736
	*** 000673	6a 01 			push	1
	*** 000675	6a 0f 			push	15	;000fH
	*** 000677	9a 00 00 00 00 		call	FAR PTR ?write_bit@@ZAXHH@Z	; write_bit
	*** 00067c	83 c4 04 		add	sp,4
;|***     write_bit(ERS,    ERSBLOW);
; Line 737
	*** 00067f	6a 00 			push	0
	*** 000681	6a 12 			push	18	;0012H
	*** 000683	9a 00 00 00 00 		call	FAR PTR ?write_bit@@ZAXHH@Z	; write_bit
	*** 000688	83 c4 04 		add	sp,4
;|***     }
;|***   
;|***   // pfs blow
;|***   if(commands.ballast & PFS_BLOW)
; Line 741
					$I3732:
	*** 00068b	c4 5e fc 		les	bx,DWORD PTR [bp-4]	;msb
	*** 00068e	26 f6 47 01 01 		test	BYTE PTR es:[bx+1],1
	*** 000693	74 0c 			je	$I3733
;|***     {
;|***     write_bit(PFSVENTBLOW, PFSBLOW);
; Line 743
	*** 000695	6a 00 			push	0
	*** 000697	6a 09 			push	9
	*** 000699	9a 00 00 00 00 		call	FAR PTR ?write_bit@@ZAXHH@Z	; write_bit
	*** 00069e	83 c4 04 		add	sp,4
;|***     }
;|***   
;|***   // pfs flood
;|***   if(commands.ballast & PFS_FLOOD)
; Line 747
					$I3733:
	*** 0006a1	c4 5e fc 		les	bx,DWORD PTR [bp-4]	;msb
	*** 0006a4	26 f6 47 01 02 		test	BYTE PTR es:[bx+1],2
	*** 0006a9	74 0c 			je	$I3734
;|***     {
;|***     write_bit(PFSVENTBLOW, PFSVENT);    
; Line 749
	*** 0006ab	6a 01 			push	1
	*** 0006ad	6a 09 			push	9
	*** 0006af	9a 00 00 00 00 		call	FAR PTR ?write_bit@@ZAXHH@Z	; write_bit
	*** 0006b4	83 c4 04 		add	sp,4
;|***     }
;|***   
;|***   // turn pump and valves off if no blow/flood command
;|***   if(!(commands.ballast & 0x00ff))
; Line 753
					$I3734:
	*** 0006b7	c4 5e fc 		les	bx,DWORD PTR [bp-4]	;msb
	*** 0006ba	26 f6 07 ff 		test	BYTE PTR es:[bx],255	;00ffH
	*** 0006be	75 54 			jne	$I3735
;|***     {
;|***     write_bit(PUMP,   PUMPOFF);
; Line 755
	*** 0006c0	6a 01 			push	1
	*** 0006c2	6a 10 			push	16	;0010H
	*** 0006c4	9a 00 00 00 00 		call	FAR PTR ?write_bit@@ZAXHH@Z	; write_bit
	*** 0006c9	83 c4 04 		add	sp,4
;|***     write_bit(VALVE1, VALVEOFF);
; Line 756
	*** 0006cc	6a 01 			push	1
	*** 0006ce	6a 0a 			push	10	;000aH
	*** 0006d0	9a 00 00 00 00 		call	FAR PTR ?write_bit@@ZAXHH@Z	; write_bit
	*** 0006d5	83 c4 04 		add	sp,4
;|***     write_bit(VALVE2, VALVEOFF);
; Line 757
	*** 0006d8	6a 01 			push	1
	*** 0006da	6a 0b 			push	11	;000bH
	*** 0006dc	9a 00 00 00 00 		call	FAR PTR ?write_bit@@ZAXHH@Z	; write_bit
	*** 0006e1	83 c4 04 		add	sp,4
;|***     write_bit(VALVE3, VALVEOFF);
; Line 758
	*** 0006e4	6a 01 			push	1
	*** 0006e6	6a 0c 			push	12	;000cH
	*** 0006e8	9a 00 00 00 00 		call	FAR PTR ?write_bit@@ZAXHH@Z	; write_bit
	*** 0006ed	83 c4 04 		add	sp,4
;|***     write_bit(VALVE4, VALVEOFF);
; Line 759
	*** 0006f0	6a 01 			push	1
	*** 0006f2	6a 0d 			push	13	;000dH
	*** 0006f4	9a 00 00 00 00 		call	FAR PTR ?write_bit@@ZAXHH@Z	; write_bit
	*** 0006f9	83 c4 04 		add	sp,4
;|***     write_bit(VALVE5, VALVEOFF);
; Line 760
	*** 0006fc	6a 01 			push	1
	*** 0006fe	6a 0e 			push	14	;000eH
	*** 000700	9a 00 00 00 00 		call	FAR PTR ?write_bit@@ZAXHH@Z	; write_bit
	*** 000705	83 c4 04 		add	sp,4
;|***     write_bit(VALVE6, VALVEOFF);
; Line 761
	*** 000708	6a 01 			push	1
	*** 00070a	6a 0f 			push	15	;000fH
	*** 00070c	9a 00 00 00 00 		call	FAR PTR ?write_bit@@ZAXHH@Z	; write_bit
	*** 000711	83 c4 04 		add	sp,4
;|***     }
;|*** 
;|***   // all blow is pump,1,4,5
;|***   if(commands.ballast & ALL_BLOW)
; Line 765
					$I3735:
	*** 000714	c4 5e fc 		les	bx,DWORD PTR [bp-4]	;msb
	*** 000717	26 f6 07 01 		test	BYTE PTR es:[bx],1
	*** 00071b	74 54 			je	$I3736
;|***     {
;|***     write_bit(PUMP,   PUMPON);
; Line 767
	*** 00071d	6a 00 			push	0
	*** 00071f	6a 10 			push	16	;0010H
	*** 000721	9a 00 00 00 00 		call	FAR PTR ?write_bit@@ZAXHH@Z	; write_bit
	*** 000726	83 c4 04 		add	sp,4
;|***     write_bit(VALVE1, VALVEON);
; Line 768
	*** 000729	6a 00 			push	0
	*** 00072b	6a 0a 			push	10	;000aH
	*** 00072d	9a 00 00 00 00 		call	FAR PTR ?write_bit@@ZAXHH@Z	; write_bit
	*** 000732	83 c4 04 		add	sp,4
;|***     write_bit(VALVE2, VALVEOFF);
; Line 769
	*** 000735	6a 01 			push	1
	*** 000737	6a 0b 			push	11	;000bH
	*** 000739	9a 00 00 00 00 		call	FAR PTR ?write_bit@@ZAXHH@Z	; write_bit
	*** 00073e	83 c4 04 		add	sp,4
;|***     write_bit(VALVE3, VALVEOFF);
; Line 770
	*** 000741	6a 01 			push	1
	*** 000743	6a 0c 			push	12	;000cH
	*** 000745	9a 00 00 00 00 		call	FAR PTR ?write_bit@@ZAXHH@Z	; write_bit
	*** 00074a	83 c4 04 		add	sp,4
;|***     write_bit(VALVE4, VALVEON);
; Line 771
	*** 00074d	6a 00 			push	0
	*** 00074f	6a 0d 			push	13	;000dH
	*** 000751	9a 00 00 00 00 		call	FAR PTR ?write_bit@@ZAXHH@Z	; write_bit
	*** 000756	83 c4 04 		add	sp,4
;|***     write_bit(VALVE5, VALVEON);
; Line 772
	*** 000759	6a 00 			push	0
	*** 00075b	6a 0e 			push	14	;000eH
	*** 00075d	9a 00 00 00 00 		call	FAR PTR ?write_bit@@ZAXHH@Z	; write_bit
	*** 000762	83 c4 04 		add	sp,4
;|***     write_bit(VALVE6, VALVEOFF);
; Line 773
	*** 000765	6a 01 			push	1
	*** 000767	6a 0f 			push	15	;000fH
	*** 000769	9a 00 00 00 00 		call	FAR PTR ?write_bit@@ZAXHH@Z	; write_bit
	*** 00076e	83 c4 04 		add	sp,4
;|***     }
;|*** 
;|***   // all flood is pump,2,3,6
;|***   if(commands.ballast & ALL_FLOOD)
; Line 777
					$I3736:
	*** 000771	c4 5e fc 		les	bx,DWORD PTR [bp-4]	;msb
	*** 000774	26 f6 07 02 		test	BYTE PTR es:[bx],2
	*** 000778	74 54 			je	$I3737
;|***     {
;|***     write_bit(PUMP,   PUMPON);
; Line 779
	*** 00077a	6a 00 			push	0
	*** 00077c	6a 10 			push	16	;0010H
	*** 00077e	9a 00 00 00 00 		call	FAR PTR ?write_bit@@ZAXHH@Z	; write_bit
	*** 000783	83 c4 04 		add	sp,4
;|***     write_bit(VALVE1, VALVEOFF);
; Line 780
	*** 000786	6a 01 			push	1
	*** 000788	6a 0a 			push	10	;000aH
	*** 00078a	9a 00 00 00 00 		call	FAR PTR ?write_bit@@ZAXHH@Z	; write_bit
	*** 00078f	83 c4 04 		add	sp,4
;|***     write_bit(VALVE2, VALVEON);
; Line 781
	*** 000792	6a 00 			push	0
	*** 000794	6a 0b 			push	11	;000bH
	*** 000796	9a 00 00 00 00 		call	FAR PTR ?write_bit@@ZAXHH@Z	; write_bit
	*** 00079b	83 c4 04 		add	sp,4
;|***     write_bit(VALVE3, VALVEON);
; Line 782
	*** 00079e	6a 00 			push	0
	*** 0007a0	6a 0c 			push	12	;000cH
	*** 0007a2	9a 00 00 00 00 		call	FAR PTR ?write_bit@@ZAXHH@Z	; write_bit
	*** 0007a7	83 c4 04 		add	sp,4
;|***     write_bit(VALVE4, VALVEOFF);
; Line 783
	*** 0007aa	6a 01 			push	1
	*** 0007ac	6a 0d 			push	13	;000dH
	*** 0007ae	9a 00 00 00 00 		call	FAR PTR ?write_bit@@ZAXHH@Z	; write_bit
	*** 0007b3	83 c4 04 		add	sp,4
;|***     write_bit(VALVE5, VALVEOFF);
; Line 784
	*** 0007b6	6a 01 			push	1
	*** 0007b8	6a 0e 			push	14	;000eH
	*** 0007ba	9a 00 00 00 00 		call	FAR PTR ?write_bit@@ZAXHH@Z	; write_bit
	*** 0007bf	83 c4 04 		add	sp,4
;|***     write_bit(VALVE6, VALVEON);
; Line 785
	*** 0007c2	6a 00 			push	0
	*** 0007c4	6a 0f 			push	15	;000fH
	*** 0007c6	9a 00 00 00 00 		call	FAR PTR ?write_bit@@ZAXHH@Z	; write_bit
	*** 0007cb	83 c4 04 		add	sp,4
;|***     }
;|***     
;|***   // trim forward is pump,2,5
;|***   if(commands.ballast & TRIM_FORWARD)
; Line 789
					$I3737:
	*** 0007ce	c4 5e fc 		les	bx,DWORD PTR [bp-4]	;msb
	*** 0007d1	26 f6 07 04 		test	BYTE PTR es:[bx],4
	*** 0007d5	74 54 			je	$I3738
;|***     {
;|***     write_bit(PUMP,   PUMPON);
; Line 791
	*** 0007d7	6a 00 			push	0
	*** 0007d9	6a 10 			push	16	;0010H
	*** 0007db	9a 00 00 00 00 		call	FAR PTR ?write_bit@@ZAXHH@Z	; write_bit
	*** 0007e0	83 c4 04 		add	sp,4
;|***     write_bit(VALVE1, VALVEOFF);
; Line 792
	*** 0007e3	6a 01 			push	1
	*** 0007e5	6a 0a 			push	10	;000aH
	*** 0007e7	9a 00 00 00 00 		call	FAR PTR ?write_bit@@ZAXHH@Z	; write_bit
	*** 0007ec	83 c4 04 		add	sp,4
;|***     write_bit(VALVE2, VALVEON);
; Line 793
	*** 0007ef	6a 00 			push	0
	*** 0007f1	6a 0b 			push	11	;000bH
	*** 0007f3	9a 00 00 00 00 		call	FAR PTR ?write_bit@@ZAXHH@Z	; write_bit
	*** 0007f8	83 c4 04 		add	sp,4
;|***     write_bit(VALVE3, VALVEOFF);
; Line 794
	*** 0007fb	6a 01 			push	1
	*** 0007fd	6a 0c 			push	12	;000cH
	*** 0007ff	9a 00 00 00 00 		call	FAR PTR ?write_bit@@ZAXHH@Z	; write_bit
	*** 000804	83 c4 04 		add	sp,4
;|***     write_bit(VALVE4, VALVEOFF);
; Line 795
	*** 000807	6a 01 			push	1
	*** 000809	6a 0d 			push	13	;000dH
	*** 00080b	9a 00 00 00 00 		call	FAR PTR ?write_bit@@ZAXHH@Z	; write_bit
	*** 000810	83 c4 04 		add	sp,4
;|***     write_bit(VALVE5, VALVEON);
; Line 796
	*** 000813	6a 00 			push	0
	*** 000815	6a 0e 			push	14	;000eH
	*** 000817	9a 00 00 00 00 		call	FAR PTR ?write_bit@@ZAXHH@Z	; write_bit
	*** 00081c	83 c4 04 		add	sp,4
;|***     write_bit(VALVE6, VALVEOFF);
; Line 797
	*** 00081f	6a 01 			push	1
	*** 000821	6a 0f 			push	15	;000fH
	*** 000823	9a 00 00 00 00 		call	FAR PTR ?write_bit@@ZAXHH@Z	; write_bit
	*** 000828	83 c4 04 		add	sp,4
;|***     }
;|***     
;|***   // trim aft is pump,3,4
;|***   if(commands.ballast & TRIM_AFT)
; Line 801
					$I3738:
	*** 00082b	c4 5e fc 		les	bx,DWORD PTR [bp-4]	;msb
	*** 00082e	26 f6 07 08 		test	BYTE PTR es:[bx],8
	*** 000832	74 54 			je	$I3739
;|***     {
;|***     write_bit(PUMP,   PUMPON);
; Line 803
	*** 000834	6a 00 			push	0
	*** 000836	6a 10 			push	16	;0010H
	*** 000838	9a 00 00 00 00 		call	FAR PTR ?write_bit@@ZAXHH@Z	; write_bit
	*** 00083d	83 c4 04 		add	sp,4
;|***     write_bit(VALVE1, VALVEOFF);
; Line 804
	*** 000840	6a 01 			push	1
	*** 000842	6a 0a 			push	10	;000aH
	*** 000844	9a 00 00 00 00 		call	FAR PTR ?write_bit@@ZAXHH@Z	; write_bit
	*** 000849	83 c4 04 		add	sp,4
;|***     write_bit(VALVE2, VALVEOFF);
; Line 805
	*** 00084c	6a 01 			push	1
	*** 00084e	6a 0b 			push	11	;000bH
	*** 000850	9a 00 00 00 00 		call	FAR PTR ?write_bit@@ZAXHH@Z	; write_bit
	*** 000855	83 c4 04 		add	sp,4
;|***     write_bit(VALVE3, VALVEON);
; Line 806
	*** 000858	6a 00 			push	0
	*** 00085a	6a 0c 			push	12	;000cH
	*** 00085c	9a 00 00 00 00 		call	FAR PTR ?write_bit@@ZAXHH@Z	; write_bit
	*** 000861	83 c4 04 		add	sp,4
;|***     write_bit(VALVE4, VALVEON);
; Line 807
	*** 000864	6a 00 			push	0
	*** 000866	6a 0d 			push	13	;000dH
	*** 000868	9a 00 00 00 00 		call	FAR PTR ?write_bit@@ZAXHH@Z	; write_bit
	*** 00086d	83 c4 04 		add	sp,4
;|***     write_bit(VALVE5, VALVEOFF);
; Line 808
	*** 000870	6a 01 			push	1
	*** 000872	6a 0e 			push	14	;000eH
	*** 000874	9a 00 00 00 00 		call	FAR PTR ?write_bit@@ZAXHH@Z	; write_bit
	*** 000879	83 c4 04 		add	sp,4
;|***     write_bit(VALVE6, VALVEOFF);
; Line 809
	*** 00087c	6a 01 			push	1
	*** 00087e	6a 0f 			push	15	;000fH
	*** 000880	9a 00 00 00 00 		call	FAR PTR ?write_bit@@ZAXHH@Z	; write_bit
	*** 000885	83 c4 04 		add	sp,4
;|***     }
;|***     
;|***   // forward blow
;|***   if(commands.ballast & FORWARD_BLOW)
; Line 813
					$I3739:
;|***     {
;|***     }
;|***   
;|***   // forward flood
;|***   if(commands.ballast & FORWARD_FLOOD)
;|***     {
;|***     }
;|***   
;|***   // aft blow
;|***   if(commands.ballast & AFT_BLOW)
;|***     {
;|***     }
;|***     
;|***   // aft flood
;|***   if(commands.ballast & AFT_FLOOD)
;|***     {
;|***     }
;|***    
;|***    
;|***   if(commands.ds_send_message != 0)
; Line 833
	*** 000888	8e 06 00 00 		mov	es,WORD PTR $T4071
	*** 00088c	26 83 3e 1a 00 00 	cmp	WORD PTR es:?commands@@3UCOMMANDS@@E+26,0	;commands
	*** 000892	74 18 			je	$EX3693
;|***     {
;|***     send_message = 1;
; Line 835
	*** 000894	c7 06 00 00 01 00 	mov	WORD PTR ?send_message@@3HE,1	;send_message
;|***     //_fstrcpy(acoustic_message, "abcdef");
;|***     _fmemcpy(&acoustic_message, &commands.ds_dmgx, sizeof(acoustic_message));
; Line 837
	*** 00089a	b8 00 00 		mov	ax,SEG ?commands@@3UCOMMANDS@@E	;commands
	*** 00089d	1e 			push	ds
	*** 00089e	bf 00 00 		mov	di,OFFSET DGROUP:?acoustic_message@@3QIDI	;acoustic_message
	*** 0008a1	be 1c 00 		mov	si,OFFSET ?commands@@3UCOMMANDS@@E+28	;commands
	*** 0008a4	1e 			push	ds
	*** 0008a5	07 			pop	es
	*** 0008a6	8e d8 			mov	ds,ax
	ASSUME DS: SEG ?commands@@3UCOMMANDS@@E
	*** 0008a8	a5 			movsw
	*** 0008a9	a5 			movsw
	*** 0008aa	a5 			movsw
	*** 0008ab	1f 			pop	ds
	ASSUME DS: DGROUP
;|***     }
;|***   }
; Line 839
					$EX3693:
	*** 0008ac	5e 			pop	si
	*** 0008ad	5f 			pop	di
	*** 0008ae	c9 			leave	
	*** 0008af	cb 			ret	

?apply_commands@@ZAXXZ	ENDP
CBA_TEXT      ENDS
CONST      SEGMENT
$T4094	DD	045dc32adr   ;	7046.3345
CONST      ENDS
CBA_TEXT      SEGMENT
	ASSUME	CS: CBA_TEXT
	PUBLIC	?configure_obc@@ZAXXZ	; configure_obc
?configure_obc@@ZAXXZ	PROC FAR	; configure_obc
;|***   
;|***         
;|***   
;|*** void configure_obc(void)
;|***   {
; Line 844
	*** 0008b0	c8 08 00 00 		enter	8,0
;	register bx = i
;|***   unsigned i;
;|***   for(i=0; i<88; i++) adcp_test[i] = (unsigned char) i;
; Line 846
	*** 0008b4	33 db 			xor	bx,bx
					$F3748:
	*** 0008b6	88 9f 00 00 		mov	BYTE PTR ?adcp_test@@3QIEI[bx],bl	;adcp_test
	*** 0008ba	43 			inc	bx
	*** 0008bb	83 fb 58 		cmp	bx,88	;0058H
	*** 0008be	72 f6 			jb	$F3748
;|***   
;|***   rpm_sf = 60.0f * 1000000.0f / 0.838097f / 10160.0f;
; Line 848
	*** 0008c0	a1 00 00 		mov	ax,WORD PTR $T4094
	*** 0008c3	8b 16 02 00 		mov	dx,WORD PTR $T4094+2
	*** 0008c7	a3 00 00 		mov	WORD PTR ?rpm_sf@@3ME,ax	;rpm_sf
	*** 0008ca	89 16 02 00 		mov	WORD PTR ?rpm_sf@@3ME+2,dx	;rpm_sf
;|***   
;|***   sys_timer.high = 0;
; Line 850
	*** 0008ce	8e 06 00 00 		mov	es,WORD PTR $T4071
	*** 0008d2	2b c0 			sub	ax,ax
	*** 0008d4	26 a3 02 00 		mov	WORD PTR es:?sys_timer@@3UTIMER@@E+2,ax	;sys_timer
	*** 0008d8	26 a3 00 00 		mov	WORD PTR es:?sys_timer@@3UTIMER@@E,ax	;sys_timer
;|***   sys_timer.low = 0;
;|***   
;|***   frame = 0;
; Line 853
	*** 0008dc	a3 02 00 		mov	WORD PTR ?frame@@3KE+2,ax	;frame
	*** 0008df	a3 00 00 		mov	WORD PTR ?frame@@3KE,ax	;frame
;|***   next_frame = frame;
; Line 854
	*** 0008e2	a3 02 00 		mov	WORD PTR ?next_frame@@3KE+2,ax	;next_frame
	*** 0008e5	a3 00 00 		mov	WORD PTR ?next_frame@@3KE,ax	;next_frame
;|***   
;|***   sys.packet_type = 0xf0c1;   // obc data packet  //3
; Line 856
	*** 0008e8	26 c7 06 00 00 c1 f0 	mov	WORD PTR es:?sys@@3USYS@@E,-3903	;f0c1H	;sys
;|***   sys.packet_number = 0xfffe;
; Line 857
	*** 0008ef	26 c7 06 02 00 fe ff 	mov	WORD PTR es:?sys@@3USYS@@E+2,-2	;fffeH	;sys
;|***   sys.fs_status = 0;
;|***   sys.op_status = 0;
;|***   
;|***   obs.new_data = 0;
;|***   obs.frame = frame;
; Line 862
	*** 0008f6	26 a3 04 00 		mov	WORD PTR es:?obs@@3UOBS@@E+4,ax	;obs
	*** 0008fa	26 a3 02 00 		mov	WORD PTR es:?obs@@3UOBS@@E+2,ax	;obs
;|***   
;|***   dyno.new_data = 0;
;|***   obs.frame = frame;
;|***   
;|***   prop.new_data = 0;
;|***   prop.frame = frame;
; Line 868
	*** 0008fe	26 a3 04 00 		mov	WORD PTR es:?prop@@3UPROP@@E+4,ax	;prop
	*** 000902	26 a3 02 00 		mov	WORD PTR es:?prop@@3UPROP@@E+2,ax	;prop
;|***   
;|***   ln200.new_data = 0;
;|***   ln200.frame = frame;
; Line 871
	*** 000906	26 a3 04 00 		mov	WORD PTR es:?ln200@@3ULN200@@E+4,ax	;ln200
	*** 00090a	26 a3 02 00 		mov	WORD PTR es:?ln200@@3ULN200@@E+2,ax	;ln200
;|***   
;|***   echo.new_data = 0;
;|***   echo.frame = frame;
; Line 874
	*** 00090e	26 a3 04 00 		mov	WORD PTR es:?echo@@3UECHO@@E+4,ax	;echo
	*** 000912	26 a3 02 00 		mov	WORD PTR es:?echo@@3UECHO@@E+2,ax	;echo
;|***   
;|***   ds.new_data = 0;
;|***   ds.frame = frame;
; Line 877
	*** 000916	26 a3 04 00 		mov	WORD PTR es:?ds@@3UDS@@E+4,ax	;ds
	*** 00091a	26 a3 02 00 		mov	WORD PTR es:?ds@@3UDS@@E+2,ax	;ds
;|***   
;|***   adcp.new_data = 0;
; Line 879
	*** 00091e	26 a3 04 00 		mov	WORD PTR es:?sys_timer@@3UTIMER@@E+4,ax	;sys_timer
	*** 000922	26 a3 08 00 		mov	WORD PTR es:?sys@@3USYS@@E+8,ax	;sys
	*** 000926	26 a3 0a 00 		mov	WORD PTR es:?sys@@3USYS@@E+10,ax	;sys
	*** 00092a	26 a3 00 00 		mov	WORD PTR es:?obs@@3UOBS@@E,ax	;obs
	*** 00092e	26 a3 00 00 		mov	WORD PTR es:?dyno@@3UDYNO@@E,ax	;dyno
	*** 000932	26 a3 00 00 		mov	WORD PTR es:?prop@@3UPROP@@E,ax	;prop
	*** 000936	26 a3 00 00 		mov	WORD PTR es:?ln200@@3ULN200@@E,ax	;ln200
	*** 00093a	26 a3 00 00 		mov	WORD PTR es:?echo@@3UECHO@@E,ax	;echo
	*** 00093e	26 a3 00 00 		mov	WORD PTR es:?ds@@3UDS@@E,ax	;ds
	*** 000942	26 a3 00 00 		mov	WORD PTR es:?adcp@@3UADCP@@E,ax	;adcp
;|***   adcp.frame = frame;
; Line 880
	*** 000946	26 a3 04 00 		mov	WORD PTR es:?adcp@@3UADCP@@E+4,ax	;adcp
	*** 00094a	26 a3 02 00 		mov	WORD PTR es:?adcp@@3UADCP@@E+2,ax	;adcp
;|***   
;|***   init_io(0x120);
; Line 882
	*** 00094e	68 20 01 		push	288	;0120H
	*** 000951	9a 00 00 00 00 		call	FAR PTR ?init_io@@ZAXI@Z	; init_io
	*** 000956	83 c4 02 		add	sp,2
;|***   write_bit(PUMP, PUMPOFF);
; Line 883
	*** 000959	6a 01 			push	1
	*** 00095b	6a 10 			push	16	;0010H
	*** 00095d	9a 00 00 00 00 		call	FAR PTR ?write_bit@@ZAXHH@Z	; write_bit
	*** 000962	83 c4 04 		add	sp,4
;|***   write_bit(VALVE1, VALVEOFF);
; Line 884
	*** 000965	6a 01 			push	1
	*** 000967	6a 0a 			push	10	;000aH
	*** 000969	9a 00 00 00 00 		call	FAR PTR ?write_bit@@ZAXHH@Z	; write_bit
	*** 00096e	83 c4 04 		add	sp,4
;|***   write_bit(VALVE2, VALVEOFF);
; Line 885
	*** 000971	6a 01 			push	1
	*** 000973	6a 0b 			push	11	;000bH
	*** 000975	9a 00 00 00 00 		call	FAR PTR ?write_bit@@ZAXHH@Z	; write_bit
	*** 00097a	83 c4 04 		add	sp,4
;|***   write_bit(VALVE3, VALVEOFF);
; Line 886
	*** 00097d	6a 01 			push	1
	*** 00097f	6a 0c 			push	12	;000cH
	*** 000981	9a 00 00 00 00 		call	FAR PTR ?write_bit@@ZAXHH@Z	; write_bit
	*** 000986	83 c4 04 		add	sp,4
;|***   write_bit(VALVE4, VALVEOFF);
; Line 887
	*** 000989	6a 01 			push	1
	*** 00098b	6a 0d 			push	13	;000dH
	*** 00098d	9a 00 00 00 00 		call	FAR PTR ?write_bit@@ZAXHH@Z	; write_bit
	*** 000992	83 c4 04 		add	sp,4
;|***   write_bit(VALVE5, VALVEOFF);
; Line 888
	*** 000995	6a 01 			push	1
	*** 000997	6a 0e 			push	14	;000eH
	*** 000999	9a 00 00 00 00 		call	FAR PTR ?write_bit@@ZAXHH@Z	; write_bit
	*** 00099e	83 c4 04 		add	sp,4
;|***   write_bit(VALVE6, VALVEOFF);
; Line 889
	*** 0009a1	6a 01 			push	1
	*** 0009a3	6a 0f 			push	15	;000fH
	*** 0009a5	9a 00 00 00 00 		call	FAR PTR ?write_bit@@ZAXHH@Z	; write_bit
	*** 0009aa	83 c4 04 		add	sp,4
;|***   write_bit(ERS, ERSNOBLOW);
; Line 890
	*** 0009ad	6a 01 			push	1
	*** 0009af	6a 12 			push	18	;0012H
	*** 0009b1	9a 00 00 00 00 		call	FAR PTR ?write_bit@@ZAXHH@Z	; write_bit
	*** 0009b6	83 c4 04 		add	sp,4
;|***   write_bit(PFSVENTBLOW, PFSBLOW);
; Line 891
	*** 0009b9	6a 00 			push	0
	*** 0009bb	6a 09 			push	9
	*** 0009bd	9a 00 00 00 00 		call	FAR PTR ?write_bit@@ZAXHH@Z	; write_bit
	*** 0009c2	83 c4 04 		add	sp,4
;|*** 
;|***   configure_escc();
; Line 893
	*** 0009c5	0e 			push	cs
	*** 0009c6	e8 00 00 		call	NEAR PTR ?configure_escc@@ZAXXZ	; configure_escc
;|***   init_tech80();
; Line 894
	*** 0009c9	0e 			push	cs
	*** 0009ca	e8 00 00 		call	NEAR PTR ?init_tech80@@ZAXXZ	; init_tech80
;|***   init_sys_timer();
; Line 895
	*** 0009cd	0e 			push	cs
	*** 0009ce	e8 00 00 		call	NEAR PTR ?init_sys_timer@@ZAXXZ	; init_sys_timer
;|***   cout << "Timer configured OK." << endl;
; Line 896
	*** 0009d1	1e 			push	ds
	*** 0009d2	68 00 00 		push	OFFSET DGROUP:$SG3752
	*** 0009d5	b8 00 00 		mov	ax,OFFSET ?cout@@3Vostream_withassign@@E	;cout
	*** 0009d8	b9 00 00 		mov	cx,SEG ?cout@@3Vostream_withassign@@E	;cout
	*** 0009db	89 46 f8 		mov	WORD PTR [bp-8],ax
	*** 0009de	89 4e fa 		mov	WORD PTR [bp-6],cx
	*** 0009e1	51 			push	cx
	*** 0009e2	50 			push	ax
	*** 0009e3	9a 00 00 00 00 		call	FAR PTR ??6ostream@@RECAEV0@PFD@Z	; ostream::operator<<
	*** 0009e8	52 			push	dx
	*** 0009e9	50 			push	ax
	*** 0009ea	9a 00 00 00 00 		call	FAR PTR ?endl@@ZAAEVostream@@AEV1@@Z	; endl
	*** 0009ef	83 c4 04 		add	sp,4
;|***   init_com1();
; Line 897
	*** 0009f2	9a 00 00 00 00 		call	FAR PTR ?init_com1@@ZAXXZ	; init_com1
;|***   init_com2();
; Line 898
	*** 0009f7	9a 00 00 00 00 		call	FAR PTR ?init_com2@@ZAXXZ	; init_com2
;|***   init_com4();
; Line 899
	*** 0009fc	9a 00 00 00 00 		call	FAR PTR ?init_com4@@ZAXXZ	; init_com4
;|***   configure_enet();
; Line 900
	*** 000a01	0e 			push	cs
	*** 000a02	e8 00 00 		call	NEAR PTR ?configure_enet@@ZAXXZ	; configure_enet
;|***   cout << "Packet driver loaded OK." << endl;
; Line 901
	*** 000a05	1e 			push	ds
	*** 000a06	68 00 00 		push	OFFSET DGROUP:$SG3753
	*** 000a09	ff 76 fa 		push	WORD PTR [bp-6]
	*** 000a0c	ff 76 f8 		push	WORD PTR [bp-8]
	*** 000a0f	9a 00 00 00 00 		call	FAR PTR ??6ostream@@RECAEV0@PFD@Z	; ostream::operator<<
	*** 000a14	52 			push	dx
	*** 000a15	50 			push	ax
	*** 000a16	9a 00 00 00 00 		call	FAR PTR ?endl@@ZAAEVostream@@AEV1@@Z	; endl
	*** 000a1b	83 c4 04 		add	sp,4
;|***   configure_dmm32a(); // onboard sensor adc
; Line 902
	*** 000a1e	0e 			push	cs
	*** 000a1f	e8 00 00 		call	NEAR PTR ?configure_dmm32a@@ZAXXZ	; configure_dmm32a
;|***   cout << "Dmm32A OK." << endl;
; Line 903
	*** 000a22	1e 			push	ds
	*** 000a23	68 00 00 		push	OFFSET DGROUP:$SG3754
	*** 000a26	ff 76 fa 		push	WORD PTR [bp-6]
	*** 000a29	ff 76 f8 		push	WORD PTR [bp-8]
	*** 000a2c	9a 00 00 00 00 		call	FAR PTR ??6ostream@@RECAEV0@PFD@Z	; ostream::operator<<
	*** 000a31	52 			push	dx
	*** 000a32	50 			push	ax
	*** 000a33	9a 00 00 00 00 		call	FAR PTR ?endl@@ZAAEVostream@@AEV1@@Z	; endl
	*** 000a38	83 c4 04 		add	sp,4
;|***   configure_dmm32b(); // dyno adc
; Line 904
	*** 000a3b	0e 			push	cs
	*** 000a3c	e8 00 00 		call	NEAR PTR ?configure_dmm32b@@ZAXXZ	; configure_dmm32b
;|***   cout << "Dmm32B a OK." << endl;
; Line 905
	*** 000a3f	1e 			push	ds
	*** 000a40	68 00 00 		push	OFFSET DGROUP:$SG3755
	*** 000a43	ff 76 fa 		push	WORD PTR [bp-6]
	*** 000a46	ff 76 f8 		push	WORD PTR [bp-8]
	*** 000a49	9a 00 00 00 00 		call	FAR PTR ??6ostream@@RECAEV0@PFD@Z	; ostream::operator<<
	*** 000a4e	52 			push	dx
	*** 000a4f	50 			push	ax
	*** 000a50	9a 00 00 00 00 		call	FAR PTR ?endl@@ZAAEVostream@@AEV1@@Z	; endl
	*** 000a55	83 c4 04 		add	sp,4
;|***   init_screen();  
; Line 906
	*** 000a58	0e 			push	cs
	*** 000a59	e8 00 00 		call	NEAR PTR ?init_screen@@ZAXXZ	; init_screen
;|***   
;|***   }
; Line 908
	*** 000a5c	c9 			leave	
	*** 000a5d	cb 			ret	

?configure_obc@@ZAXXZ	ENDP
	PUBLIC	?init_tech80@@ZAXXZ	; init_tech80
?init_tech80@@ZAXXZ	PROC FAR	; init_tech80
;|*** 
;|*** 
;|*** void init_tech80(void)
;|***   {
; Line 912
	*** 000a5e	c8 0c 00 00 		enter	12,0
	*** 000a62	56 			push	si
;|***   cout << "te5650InitSw:    " << hex << te5650InitSw() << dec << endl;
; Line 913
	*** 000a63	1e 			push	ds
	*** 000a64	68 00 00 		push	OFFSET DGROUP:$SG3758
	*** 000a67	b8 00 00 		mov	ax,OFFSET ?cout@@3Vostream_withassign@@E	;cout
	*** 000a6a	b9 00 00 		mov	cx,SEG ?cout@@3Vostream_withassign@@E	;cout
	*** 000a6d	89 46 f4 		mov	WORD PTR [bp-12],ax
	*** 000a70	89 4e f6 		mov	WORD PTR [bp-10],cx
	*** 000a73	51 			push	cx
	*** 000a74	50 			push	ax
	*** 000a75	9a 00 00 00 00 		call	FAR PTR ??6ostream@@RECAEV0@PFD@Z	; ostream::operator<<
	*** 000a7a	8b f0 			mov	si,ax
	*** 000a7c	89 56 fa 		mov	WORD PTR [bp-6],dx
	*** 000a7f	0b d0 			or	dx,ax
	*** 000a81	75 05 			jne	$L4099
	*** 000a83	33 c0 			xor	ax,ax
	*** 000a85	99 			cwd	
	*** 000a86	eb 0d 			jmp	SHORT $L4261
					$L4099:
	*** 000a88	8e 46 fa 		mov	es,WORD PTR [bp-6]
	*** 000a8b	26 c4 1c 		les	bx,DWORD PTR es:[si]
	*** 000a8e	8b 56 fa 		mov	dx,WORD PTR [bp-6]
	*** 000a91	26 03 47 02 		add	ax,WORD PTR es:[bx+2]
					$L4261:
	*** 000a95	52 			push	dx
	*** 000a96	50 			push	ax
	*** 000a97	9a 00 00 00 00 		call	FAR PTR ?hex@@ZAAEVios@@AEV1@@Z	; hex
	*** 000a9c	83 c4 04 		add	sp,4
	*** 000a9f	9a 00 00 00 00 		call	FAR PTR _te5650InitSw
	*** 000aa4	50 			push	ax
	*** 000aa5	ff 76 fa 		push	WORD PTR [bp-6]
	*** 000aa8	56 			push	si
	*** 000aa9	9a 00 00 00 00 		call	FAR PTR ??6ostream@@RECAEV0@F@Z	; ostream::operator<<
	*** 000aae	89 46 fc 		mov	WORD PTR [bp-4],ax
	*** 000ab1	89 56 fe 		mov	WORD PTR [bp-2],dx
	*** 000ab4	0b d0 			or	dx,ax
	*** 000ab6	75 0a 			jne	$L4105
	*** 000ab8	33 c0 			xor	ax,ax
	*** 000aba	99 			cwd	
	*** 000abb	8b c8 			mov	cx,ax
	*** 000abd	89 56 fa 		mov	WORD PTR [bp-6],dx
	*** 000ac0	eb 11 			jmp	SHORT $L4106
					$L4105:
	*** 000ac2	c4 5e fc 		les	bx,DWORD PTR [bp-4]
	*** 000ac5	8c c0 			mov	ax,es
	*** 000ac7	26 c4 37 		les	si,DWORD PTR es:[bx]
	*** 000aca	26 03 5c 02 		add	bx,WORD PTR es:[si+2]
	*** 000ace	8b cb 			mov	cx,bx
	*** 000ad0	89 46 fa 		mov	WORD PTR [bp-6],ax
					$L4106:
	*** 000ad3	ff 76 fa 		push	WORD PTR [bp-6]
	*** 000ad6	51 			push	cx
	*** 000ad7	9a 00 00 00 00 		call	FAR PTR ?dec@@ZAAEVios@@AEV1@@Z	; dec
	*** 000adc	83 c4 04 		add	sp,4
	*** 000adf	ff 76 fe 		push	WORD PTR [bp-2]
	*** 000ae2	ff 76 fc 		push	WORD PTR [bp-4]
	*** 000ae5	9a 00 00 00 00 		call	FAR PTR ?endl@@ZAAEVostream@@AEV1@@Z	; endl
	*** 000aea	83 c4 04 		add	sp,4
;|***   cout << "te5650InitServo: " << te5650InitServo(0x400, TE5650TYPE_DAC16) << endl;
; Line 914
	*** 000aed	6a 00 			push	0
	*** 000aef	68 00 04 		push	1024	;0400H
	*** 000af2	9a 00 00 00 00 		call	FAR PTR _te5650InitServo
	*** 000af7	83 c4 04 		add	sp,4
	*** 000afa	50 			push	ax
	*** 000afb	1e 			push	ds
	*** 000afc	68 00 00 		push	OFFSET DGROUP:$SG3759
	*** 000aff	ff 76 f6 		push	WORD PTR [bp-10]
	*** 000b02	ff 76 f4 		push	WORD PTR [bp-12]
	*** 000b05	9a 00 00 00 00 		call	FAR PTR ??6ostream@@RECAEV0@PFD@Z	; ostream::operator<<
	*** 000b0a	52 			push	dx
	*** 000b0b	50 			push	ax
	*** 000b0c	9a 00 00 00 00 		call	FAR PTR ??6ostream@@RECAEV0@F@Z	; ostream::operator<<
	*** 000b11	52 			push	dx
	*** 000b12	50 			push	ax
	*** 000b13	9a 00 00 00 00 		call	FAR PTR ?endl@@ZAAEVostream@@AEV1@@Z	; endl
	*** 000b18	83 c4 04 		add	sp,4
;|***   cout << "te5650SetAxis:   " << te5650SetAxis(1,1) << endl;
; Line 915
	*** 000b1b	6a 01 			push	1
	*** 000b1d	6a 01 			push	1
	*** 000b1f	9a 00 00 00 00 		call	FAR PTR _te5650SetAxis
	*** 000b24	83 c4 04 		add	sp,4
	*** 000b27	50 			push	ax
	*** 000b28	1e 			push	ds
	*** 000b29	68 00 00 		push	OFFSET DGROUP:$SG3760
	*** 000b2c	ff 76 f6 		push	WORD PTR [bp-10]
	*** 000b2f	ff 76 f4 		push	WORD PTR [bp-12]
	*** 000b32	9a 00 00 00 00 		call	FAR PTR ??6ostream@@RECAEV0@PFD@Z	; ostream::operator<<
	*** 000b37	52 			push	dx
	*** 000b38	50 			push	ax
	*** 000b39	9a 00 00 00 00 		call	FAR PTR ??6ostream@@RECAEV0@F@Z	; ostream::operator<<
	*** 000b3e	52 			push	dx
	*** 000b3f	50 			push	ax
	*** 000b40	9a 00 00 00 00 		call	FAR PTR ?endl@@ZAAEVostream@@AEV1@@Z	; endl
	*** 000b45	83 c4 04 		add	sp,4
;|***   te5650PhasesPolarity(1,1,1);  // invert A,B,I phases
; Line 916
	*** 000b48	6a 01 			push	1
	*** 000b4a	6a 01 			push	1
	*** 000b4c	6a 01 			push	1
	*** 000b4e	9a 00 00 00 00 		call	FAR PTR _te5650PhasesPolarity
	*** 000b53	83 c4 06 		add	sp,6
;|***   te5650Update();
; Line 917
	*** 000b56	9a 00 00 00 00 		call	FAR PTR _te5650Update
;|***   te5650CaptureIndex();  
; Line 918
	*** 000b5b	9a 00 00 00 00 		call	FAR PTR _te5650CaptureIndex
;|***   te5650Update();
; Line 919
	*** 000b60	9a 00 00 00 00 		call	FAR PTR _te5650Update
;|***   te5650ResetCapture();
; Line 920
	*** 000b65	9a 00 00 00 00 		call	FAR PTR _te5650ResetCapture
;|***   te5650Update();
; Line 921
	*** 000b6a	9a 00 00 00 00 		call	FAR PTR _te5650Update
;|***   te5650MotorOff();
; Line 922
	*** 000b6f	9a 00 00 00 00 		call	FAR PTR _te5650MotorOff
;|***   te5650Update();
; Line 923
	*** 000b74	9a 00 00 00 00 		call	FAR PTR _te5650Update
;|***   te5650SetMotor(0);
; Line 924
	*** 000b79	6a 00 			push	0
	*** 000b7b	9a 00 00 00 00 		call	FAR PTR _te5650SetMotor
	*** 000b80	83 c4 02 		add	sp,2
;|***   te5650Update();
; Line 925
	*** 000b83	9a 00 00 00 00 		call	FAR PTR _te5650Update
;|***   cout << "Tech80 configured OK." << endl;
; Line 926
	*** 000b88	1e 			push	ds
	*** 000b89	68 00 00 		push	OFFSET DGROUP:$SG3761
	*** 000b8c	ff 76 f6 		push	WORD PTR [bp-10]
	*** 000b8f	ff 76 f4 		push	WORD PTR [bp-12]
	*** 000b92	9a 00 00 00 00 		call	FAR PTR ??6ostream@@RECAEV0@PFD@Z	; ostream::operator<<
	*** 000b97	52 			push	dx
	*** 000b98	50 			push	ax
	*** 000b99	9a 00 00 00 00 		call	FAR PTR ?endl@@ZAAEVostream@@AEV1@@Z	; endl
	*** 000b9e	83 c4 04 		add	sp,4
;|*** 
;|***   }
; Line 928
	*** 000ba1	5e 			pop	si
	*** 000ba2	c9 			leave	
	*** 000ba3	cb 			ret	

?init_tech80@@ZAXXZ	ENDP
	PUBLIC	?init_sys_timer@@ZAXXZ	; init_sys_timer
?init_sys_timer@@ZAXXZ	PROC FAR	; init_sys_timer
;|***   
;|***   
;|*** void init_sys_timer(void)
;|***   {
;|***   rtc_vect = _dos_getvect(0x08);               // save the pc's default rtc isr vector
; Line 933
	*** 000ba4	6a 08 			push	8
	*** 000ba6	9a 00 00 00 00 		call	FAR PTR __dos_getvect
	*** 000bab	83 c4 02 		add	sp,2
	*** 000bae	a3 00 00 		mov	WORD PTR ?rtc_vect@@3P7AXXZE,ax	;rtc_vect
	*** 000bb1	89 16 02 00 		mov	WORD PTR ?rtc_vect@@3P7AXXZE+2,dx	;rtc_vect
;|***   _disable();                                  // so we can chain into it later
; Line 934
	*** 000bb5	fa 			cli	
;|***   _dos_setvect(0x08, sys_timer_isr);           // hook our system timer isr
; Line 935
	*** 000bb6	68 00 00 		push	SEG ?sys_timer_isr@@ZAXXZ	;sys_timer_isr
	*** 000bb9	68 00 00 		push	OFFSET ?sys_timer_isr@@ZAXXZ	;sys_timer_isr
	*** 000bbc	6a 08 			push	8
	*** 000bbe	9a 00 00 00 00 		call	FAR PTR __dos_setvect
	*** 000bc3	83 c4 06 		add	sp,6
;|***   _outp(0x43, CTC0 | LSBMSB | MODE2 | BINARY); // change the pc's 8254 to mode2 operation
; Line 936
	*** 000bc6	b8 34 00 		mov	ax,52	;0034H
	*** 000bc9	e6 43 			out	67	;0043H, al

;|***   _outp(0x40, 0xff);                           // load timer divisor LSB, then MSB
; Line 937
	*** 000bcb	b8 ff 00 		mov	ax,255	;00ffH
	*** 000bce	e6 40 			out	64	;0040H, al

;|***   _outp(0x40, 0xff);
; Line 938
	*** 000bd0	e6 40 			out	64	;0040H, al

;|***   _enable();
; Line 939
	*** 000bd2	fb 			sti	
;|***   //cout << "Timer configured OK." << endl;
;|***   }
; Line 941
	*** 000bd3	cb 			ret	

?init_sys_timer@@ZAXXZ	ENDP
	PUBLIC	?configure_enet@@ZAXXZ	; configure_enet
?configure_enet@@ZAXXZ	PROC FAR	; configure_enet
;|*** 
;|*** 
;|*** void configure_enet(void)
;|***   {
; Line 945
	*** 000bd4	c8 12 00 00 		enter	18,0
	*** 000bd8	56 			push	si
;	packet_type = -10
;	ptype = -6
;|***   char packet_type[2] = {0x08, 0x00};
; Line 946
	*** 000bd9	c6 46 f6 08 		mov	BYTE PTR [bp-10],8	;packet_type
	*** 000bdd	c6 46 f7 00 		mov	BYTE PTR [bp-9],0
;|***   char far *ptype = packet_type;
;|*** 
;|*** /*
;|***   // use at/lantic packet driver
;|***   system("c:\\ne2000\\pktdrv\\atdrive -i 0x7e -b 0x300 -q 10");
;|***   cout << "Access_type() error: " << access_type(1, 52, 0, ptype, 2, receiver) << endl;
;|***   cout << "Handle: " << handle << endl;
;|***   cout << "Set_rcv_mode() error: " << set_rcv_mode(handle, 6) << endl;
;|*** */  
;|***   
;|***   // use ne2000 packet driver
;|***   system("c:\\packet\\pktdrv\\ne2000 0x7e 10 0x300");
; Line 958
	*** 000be1	1e 			push	ds
	*** 000be2	68 00 00 		push	OFFSET DGROUP:$SG3768
	*** 000be5	9a 00 00 00 00 		call	FAR PTR _system
	*** 000bea	83 c4 04 		add	sp,4
;|***   cout << "Access_type() error: " << access_type(1, 52, 0, NULL, 0, receiver) << endl;
; Line 959
	*** 000bed	68 00 00 		push	SEG ?receiver@@ZAXIIIIIIIIIIIII@Z	;receiver
	*** 000bf0	68 00 00 		push	OFFSET ?receiver@@ZAXIIIIIIIIIIIII@Z	;receiver
	*** 000bf3	6a 00 			push	0
	*** 000bf5	6a 00 			push	0
	*** 000bf7	6a 00 			push	0
	*** 000bf9	6a 00 			push	0
	*** 000bfb	6a 34 			push	52	;0034H
	*** 000bfd	6a 01 			push	1
	*** 000bff	9a 00 00 00 00 		call	FAR PTR ?access_type@@ZAHHHHPEDIP7AXIIIIIIIIIIIII@Z@Z	; access_type
	*** 000c04	83 c4 10 		add	sp,16	;0010H
	*** 000c07	50 			push	ax
	*** 000c08	1e 			push	ds
	*** 000c09	68 00 00 		push	OFFSET DGROUP:$SG3769
	*** 000c0c	b8 00 00 		mov	ax,OFFSET ?cout@@3Vostream_withassign@@E	;cout
	*** 000c0f	b9 00 00 		mov	cx,SEG ?cout@@3Vostream_withassign@@E	;cout
	*** 000c12	89 46 ee 		mov	WORD PTR [bp-18],ax
	*** 000c15	89 4e f0 		mov	WORD PTR [bp-16],cx
	*** 000c18	51 			push	cx
	*** 000c19	50 			push	ax
	*** 000c1a	9a 00 00 00 00 		call	FAR PTR ??6ostream@@RECAEV0@PFD@Z	; ostream::operator<<
	*** 000c1f	52 			push	dx
	*** 000c20	50 			push	ax
	*** 000c21	9a 00 00 00 00 		call	FAR PTR ??6ostream@@RECAEV0@H@Z	; ostream::operator<<
	*** 000c26	89 46 fc 		mov	WORD PTR [bp-4],ax
	*** 000c29	89 56 fe 		mov	WORD PTR [bp-2],dx
	*** 000c2c	52 			push	dx
	*** 000c2d	50 			push	ax
	*** 000c2e	9a 00 00 00 00 		call	FAR PTR ?endl@@ZAAEVostream@@AEV1@@Z	; endl
	*** 000c33	83 c4 04 		add	sp,4
;|***   cout << "Handle: " << handle << endl;
; Line 960
	*** 000c36	ff 36 00 00 		push	WORD PTR ?handle@@3HE	;handle
	*** 000c3a	1e 			push	ds
	*** 000c3b	68 00 00 		push	OFFSET DGROUP:$SG3770
	*** 000c3e	ff 76 f0 		push	WORD PTR [bp-16]
	*** 000c41	ff 76 ee 		push	WORD PTR [bp-18]
	*** 000c44	9a 00 00 00 00 		call	FAR PTR ??6ostream@@RECAEV0@PFD@Z	; ostream::operator<<
	*** 000c49	52 			push	dx
	*** 000c4a	50 			push	ax
	*** 000c4b	9a 00 00 00 00 		call	FAR PTR ??6ostream@@RECAEV0@H@Z	; ostream::operator<<
	*** 000c50	89 46 fc 		mov	WORD PTR [bp-4],ax
	*** 000c53	89 56 fe 		mov	WORD PTR [bp-2],dx
	*** 000c56	52 			push	dx
	*** 000c57	50 			push	ax
	*** 000c58	9a 00 00 00 00 		call	FAR PTR ?endl@@ZAAEVostream@@AEV1@@Z	; endl
	*** 000c5d	83 c4 04 		add	sp,4
;|***   cout << "Driver_info() error: " << driver_info(handle) << endl;
; Line 961
	*** 000c60	ff 36 00 00 		push	WORD PTR ?handle@@3HE	;handle
	*** 000c64	9a 00 00 00 00 		call	FAR PTR ?driver_info@@ZAHI@Z	; driver_info
	*** 000c69	83 c4 02 		add	sp,2
	*** 000c6c	50 			push	ax
	*** 000c6d	1e 			push	ds
	*** 000c6e	68 00 00 		push	OFFSET DGROUP:$SG3771
	*** 000c71	ff 76 f0 		push	WORD PTR [bp-16]
	*** 000c74	ff 76 ee 		push	WORD PTR [bp-18]
	*** 000c77	9a 00 00 00 00 		call	FAR PTR ??6ostream@@RECAEV0@PFD@Z	; ostream::operator<<
	*** 000c7c	52 			push	dx
	*** 000c7d	50 			push	ax
	*** 000c7e	9a 00 00 00 00 		call	FAR PTR ??6ostream@@RECAEV0@H@Z	; ostream::operator<<
	*** 000c83	89 46 fc 		mov	WORD PTR [bp-4],ax
	*** 000c86	89 56 fe 		mov	WORD PTR [bp-2],dx
	*** 000c89	52 			push	dx
	*** 000c8a	50 			push	ax
	*** 000c8b	9a 00 00 00 00 		call	FAR PTR ?endl@@ZAAEVostream@@AEV1@@Z	; endl
	*** 000c90	83 c4 04 		add	sp,4
;|***   cout << "Rpm_sf: " << rpm_sf << endl;
; Line 962
	*** 000c93	1e 			push	ds
	*** 000c94	68 00 00 		push	OFFSET DGROUP:$SG3772
	*** 000c97	ff 76 f0 		push	WORD PTR [bp-16]
	*** 000c9a	ff 76 ee 		push	WORD PTR [bp-18]
	*** 000c9d	9a 00 00 00 00 		call	FAR PTR ??6ostream@@RECAEV0@PFD@Z	; ostream::operator<<
	*** 000ca2	8b f0 			mov	si,ax
	*** 000ca4	89 56 fe 		mov	WORD PTR [bp-2],dx
	*** 000ca7	a1 00 00 		mov	ax,WORD PTR ?rpm_sf@@3ME	;rpm_sf
	*** 000caa	8b 16 02 00 		mov	dx,WORD PTR ?rpm_sf@@3ME+2	;rpm_sf
	*** 000cae	89 46 f8 		mov	WORD PTR [bp-8],ax
	*** 000cb1	89 56 fa 		mov	WORD PTR [bp-6],dx	;ptype
	*** 000cb4	8e 46 fe 		mov	es,WORD PTR [bp-2]
	*** 000cb7	26 c7 44 04 01 00 	mov	WORD PTR es:[si+4],1
	*** 000cbd	8d 5e f8 		lea	bx,WORD PTR [bp-8]
	*** 000cc0	9a 00 00 00 00 		call	FAR PTR __aFflds
	*** 000cc5	9a 00 00 00 00 		call	FAR PTR __aFdcvt
	*** 000cca	83 ec 08 		sub	sp,8
	*** 000ccd	8b dc 			mov	bx,sp
	*** 000ccf	9a 00 00 00 00 		call	FAR PTR __aFfstdp
	*** 000cd4	ff 76 fe 		push	WORD PTR [bp-2]
	*** 000cd7	56 			push	si
	*** 000cd8	9a 00 00 00 00 		call	FAR PTR ??6ostream@@RECAEV0@N@Z	; ostream::operator<<
	*** 000cdd	89 46 f2 		mov	WORD PTR [bp-14],ax
	*** 000ce0	89 56 f4 		mov	WORD PTR [bp-12],dx
	*** 000ce3	52 			push	dx
	*** 000ce4	50 			push	ax
	*** 000ce5	9a 00 00 00 00 		call	FAR PTR ?endl@@ZAAEVostream@@AEV1@@Z	; endl
	*** 000cea	83 c4 04 		add	sp,4
;|*** 
;|***   }
; Line 964
	*** 000ced	5e 			pop	si
	*** 000cee	c9 			leave	
	*** 000cef	cb 			ret	

?configure_enet@@ZAXXZ	ENDP
	PUBLIC	?configure_escc@@ZAXXZ	; configure_escc
?configure_escc@@ZAXXZ	PROC FAR	; configure_escc
;|*** 
;|***   
;|*** void configure_escc(void)
;|***   {
; Line 968
	*** 000cf0	c8 0c 00 00 		enter	12,0
;|***   //int i;
;|***   //for(i=0;i<96;i++) pcm[i] = 'a';  // clear pcm data buffer
;|***   
;|***   // open the two escc communications ports using add_port() function
;|***   // parameters: (base address of escc board,
;|***   //              escc channel 0 or 1,
;|***   //              IRQ setting,   
;|***   //              dma channel for receive,  
;|***   //              dma channel for transmit)
;|*** 
;|***   // channel A to communicate with the LN200                  
;|***   channela = escc1.add_port(0x240,0,5,0,0);  //1st channel, IRQ 5, no dma
; Line 980
	*** 000cf4	68 40 02 		push	576	;0240H
	*** 000cf7	6a 00 			push	0
	*** 000cf9	6a 05 			push	5
	*** 000cfb	6a 00 			push	0
	*** 000cfd	6a 00 			push	0
	*** 000cff	b8 00 00 		mov	ax,OFFSET ?escc1@@3VCescc@@E	;escc1
	*** 000d02	b9 00 00 		mov	cx,SEG ?escc1@@3VCescc@@E	;escc1
	*** 000d05	89 46 f8 		mov	WORD PTR [bp-8],ax
	*** 000d08	89 4e fa 		mov	WORD PTR [bp-6],cx
	*** 000d0b	51 			push	cx
	*** 000d0c	50 			push	ax
	*** 000d0d	9a 00 00 00 00 		call	FAR PTR ?add_port@Cescc@@RECIIIIII@Z	; Cescc::add_port
	*** 000d12	a3 00 00 		mov	WORD PTR ?channela@@3IE,ax	;channela
;|***   cout << "Channel A = " << channela << endl;
; Line 981
	*** 000d15	50 			push	ax
	*** 000d16	1e 			push	ds
	*** 000d17	68 00 00 		push	OFFSET DGROUP:$SG3775
	*** 000d1a	b8 00 00 		mov	ax,OFFSET ?cout@@3Vostream_withassign@@E	;cout
	*** 000d1d	b9 00 00 		mov	cx,SEG ?cout@@3Vostream_withassign@@E	;cout
	*** 000d20	89 46 f4 		mov	WORD PTR [bp-12],ax
	*** 000d23	89 4e f6 		mov	WORD PTR [bp-10],cx
	*** 000d26	51 			push	cx
	*** 000d27	50 			push	ax
	*** 000d28	9a 00 00 00 00 		call	FAR PTR ??6ostream@@RECAEV0@PFD@Z	; ostream::operator<<
	*** 000d2d	52 			push	dx
	*** 000d2e	50 			push	ax
	*** 000d2f	9a 00 00 00 00 		call	FAR PTR ??6ostream@@RECAEV0@I@Z	; ostream::operator<<
	*** 000d34	52 			push	dx
	*** 000d35	50 			push	ax
	*** 000d36	9a 00 00 00 00 		call	FAR PTR ?endl@@ZAAEVostream@@AEV1@@Z	; endl
	*** 000d3b	83 c4 04 		add	sp,4
;|***   
;|***   // channel B to transmit the pcm telemetry
;|***   channelb = escc1.add_port(0x240,1,5,1,5);  //2nd channel IRQ 5, Rx=DMA Ch1, Tx=DMA Ch5
; Line 984
	*** 000d3e	68 40 02 		push	576	;0240H
	*** 000d41	6a 01 			push	1
	*** 000d43	6a 05 			push	5
	*** 000d45	6a 01 			push	1
	*** 000d47	6a 05 			push	5
	*** 000d49	ff 76 fa 		push	WORD PTR [bp-6]
	*** 000d4c	ff 76 f8 		push	WORD PTR [bp-8]
	*** 000d4f	9a 00 00 00 00 		call	FAR PTR ?add_port@Cescc@@RECIIIIII@Z	; Cescc::add_port
	*** 000d54	a3 00 00 		mov	WORD PTR ?channelb@@3IE,ax	;channelb
;|***   cout << "Channel B = " << channelb  << endl;
; Line 985
	*** 000d57	50 			push	ax
	*** 000d58	1e 			push	ds
	*** 000d59	68 00 00 		push	OFFSET DGROUP:$SG3776
	*** 000d5c	ff 76 f6 		push	WORD PTR [bp-10]
	*** 000d5f	ff 76 f4 		push	WORD PTR [bp-12]
	*** 000d62	9a 00 00 00 00 		call	FAR PTR ??6ostream@@RECAEV0@PFD@Z	; ostream::operator<<
	*** 000d67	52 			push	dx
	*** 000d68	50 			push	ax
	*** 000d69	9a 00 00 00 00 		call	FAR PTR ??6ostream@@RECAEV0@I@Z	; ostream::operator<<
	*** 000d6e	52 			push	dx
	*** 000d6f	50 			push	ax
	*** 000d70	9a 00 00 00 00 		call	FAR PTR ?endl@@ZAAEVostream@@AEV1@@Z	; endl
	*** 000d75	83 c4 04 		add	sp,4
;|***   
;|***   // assemble configuration data for channel_a for LN200 SDLC operation.
;|***   // see Siemens SAB 82532 ESCC User's Manual page 110.
;|***   settings.mode = 0x88;   // transparent 0 frames, receiver active
; Line 989
	*** 000d78	8e 06 00 00 		mov	es,WORD PTR $T4071
	*** 000d7c	26 c7 06 02 00 88 00 	mov	WORD PTR es:?settings@@3Uescc_regs@@E+2,136	;0088H	;settings
;|***   settings.timr = 0x1f;   // for cb98
; Line 990
	*** 000d83	26 c7 06 04 00 1f 00 	mov	WORD PTR es:?settings@@3Uescc_regs@@E+4,31	;001fH	;settings
;|***   settings.xbcl = 0x00;   // n/a for interrupt mode
;|***   settings.xbch = 0x00;   // interrupt mode (no dma)
;|***   settings.ccr0 = 0xc0;   // power up, master clock enabled
; Line 993
	*** 000d8a	26 c7 06 0a 00 c0 00 	mov	WORD PTR es:?settings@@3Uescc_regs@@E+10,192	;00c0H	;settings
;|***   settings.ccr1 = 0x10;   // txd push-pull, one's insertion, clk mode 0 (use LN200 clock)
; Line 994
	*** 000d91	26 c7 06 0c 00 10 00 	mov	WORD PTR es:?settings@@3Uescc_regs@@E+12,16	;0010H	;settings
;|***   settings.ccr2 = 0x00;   // normal txd/rxd, ssel=0 (clk mode 0a), crc-ccitt, no inversion 
;|***   settings.ccr3 = 0x00;   // no preamble, rx crc off, tx crc generated internally
;|***   settings.ccr4 = 0x00;   // 
;|***   settings.bgr  = 0x00;   // 
;|***   settings.iva  = 0x00;   // 
;|***   settings.ipc  = 0x03;   // masked interrupts NOT visible, pin INT = push/pull active high
; Line 1000
	*** 000d98	26 c7 06 18 00 03 00 	mov	WORD PTR es:?settings@@3Uescc_regs@@E+24,3	;settings
;|***   settings.imr0 = 0x04;   // cdsc disabled
; Line 1001
	*** 000d9f	26 c7 06 1a 00 04 00 	mov	WORD PTR es:?settings@@3Uescc_regs@@E+26,4	;settings
;|***   settings.imr1 = 0x00;   // all interrupts enabled 
;|***   settings.pvr  = 0x00;   //
;|***   settings.pim  = 0xff;
;|***   settings.pcr  = 0xe0;
; Line 1005
	*** 000da6	26 c7 06 22 00 e0 00 	mov	WORD PTR es:?settings@@3Uescc_regs@@E+34,224	;00e0H	;settings
;|***   settings.xad1 = 0xff;
;|***   settings.xad2 = 0xff;
;|***   settings.rah1 = 0xff;
;|***   settings.rah2 = 0xff;
;|***   settings.ral1 = 0xff;
;|***   settings.ral2 = 0xff;
; Line 1011
	*** 000dad	b8 ff 00 		mov	ax,255	;00ffH
	*** 000db0	26 a3 20 00 		mov	WORD PTR es:?settings@@3Uescc_regs@@E+32,ax	;settings
	*** 000db4	26 a3 24 00 		mov	WORD PTR es:?settings@@3Uescc_regs@@E+36,ax	;settings
	*** 000db8	26 a3 26 00 		mov	WORD PTR es:?settings@@3Uescc_regs@@E+38,ax	;settings
	*** 000dbc	26 a3 28 00 		mov	WORD PTR es:?settings@@3Uescc_regs@@E+40,ax	;settings
	*** 000dc0	26 a3 2a 00 		mov	WORD PTR es:?settings@@3Uescc_regs@@E+42,ax	;settings
	*** 000dc4	26 a3 2c 00 		mov	WORD PTR es:?settings@@3Uescc_regs@@E+44,ax	;settings
	*** 000dc8	26 a3 2e 00 		mov	WORD PTR es:?settings@@3Uescc_regs@@E+46,ax	;settings
;|***   settings.rlcr = 0x00;
;|***   settings.pre  = 0x00;
; Line 1013
	*** 000dcc	33 c0 			xor	ax,ax
	*** 000dce	26 a3 06 00 		mov	WORD PTR es:?settings@@3Uescc_regs@@E+6,ax	;settings
	*** 000dd2	26 a3 08 00 		mov	WORD PTR es:?settings@@3Uescc_regs@@E+8,ax	;settings
	*** 000dd6	26 a3 0e 00 		mov	WORD PTR es:?settings@@3Uescc_regs@@E+14,ax	;settings
	*** 000dda	26 a3 10 00 		mov	WORD PTR es:?settings@@3Uescc_regs@@E+16,ax	;settings
	*** 000dde	26 a3 12 00 		mov	WORD PTR es:?settings@@3Uescc_regs@@E+18,ax	;settings
	*** 000de2	26 a3 14 00 		mov	WORD PTR es:?settings@@3Uescc_regs@@E+20,ax	;settings
	*** 000de6	26 a3 16 00 		mov	WORD PTR es:?settings@@3Uescc_regs@@E+22,ax	;settings
	*** 000dea	26 a3 1c 00 		mov	WORD PTR es:?settings@@3Uescc_regs@@E+28,ax	;settings
	*** 000dee	26 a3 1e 00 		mov	WORD PTR es:?settings@@3Uescc_regs@@E+30,ax	;settings
	*** 000df2	26 a3 30 00 		mov	WORD PTR es:?settings@@3Uescc_regs@@E+48,ax	;settings
	*** 000df6	26 a3 32 00 		mov	WORD PTR es:?settings@@3Uescc_regs@@E+50,ax	;settings
;|***     
;|***   // write configuration data to escc channel a registers
;|***   // parameters:(port to intialize,
;|***   //             operating mode,
;|***   //             settings defined above,
;|***   //             number of receive buffers,
;|***   //             number of transmit buffers)
;|***   cout << "initializing channel a" << endl;
; Line 1021
	*** 000dfa	1e 			push	ds
	*** 000dfb	68 00 00 		push	OFFSET DGROUP:$SG3777
	*** 000dfe	ff 76 f6 		push	WORD PTR [bp-10]
	*** 000e01	ff 76 f4 		push	WORD PTR [bp-12]
	*** 000e04	9a 00 00 00 00 		call	FAR PTR ??6ostream@@RECAEV0@PFD@Z	; ostream::operator<<
	*** 000e09	52 			push	dx
	*** 000e0a	50 			push	ax
	*** 000e0b	9a 00 00 00 00 		call	FAR PTR ?endl@@ZAAEVostream@@AEV1@@Z	; endl
	*** 000e10	83 c4 04 		add	sp,4
;|***   if(escc1.init_port(channela,OPMODE_HDLC,&settings,2,2)==TRUE)
; Line 1022
	*** 000e13	ff 36 00 00 		push	WORD PTR ?channela@@3IE	;channela
	*** 000e17	6a 00 			push	0
	*** 000e19	68 00 00 		push	SEG ?settings@@3Uescc_regs@@E	;settings
	*** 000e1c	68 00 00 		push	OFFSET ?settings@@3Uescc_regs@@E	;settings
	*** 000e1f	6a 02 			push	2
	*** 000e21	6a 02 			push	2
	*** 000e23	ff 76 fa 		push	WORD PTR [bp-6]
	*** 000e26	ff 76 f8 		push	WORD PTR [bp-8]
	*** 000e29	9a 00 00 00 00 		call	FAR PTR ?init_port@Cescc@@RECIIIPEUescc_regs@@II@Z	; Cescc::init_port
	*** 000e2e	0b c0 			or	ax,ax
	*** 000e30	75 1c 			jne	$I3778
;|***     cout << "Intialize Channel A OK." << endl;
; Line 1023
	*** 000e32	1e 			push	ds
	*** 000e33	68 00 00 		push	OFFSET DGROUP:$SG3779
	*** 000e36	ff 76 f6 		push	WORD PTR [bp-10]
	*** 000e39	ff 76 f4 		push	WORD PTR [bp-12]
	*** 000e3c	9a 00 00 00 00 		call	FAR PTR ??6ostream@@RECAEV0@PFD@Z	; ostream::operator<<
	*** 000e41	52 			push	dx
	*** 000e42	50 			push	ax
	*** 000e43	9a 00 00 00 00 		call	FAR PTR ?endl@@ZAAEVostream@@AEV1@@Z	; endl
	*** 000e48	83 c4 04 		add	sp,4
	*** 000e4b	eb 24 			jmp	SHORT $I3780
	*** 000e4d	90 			nop	
;|***   else
; Line 1024
					$I3778:
;|***     {
;|***     cout << "Initialize Channel A FAILED!" << endl;
; Line 1026
	*** 000e4e	1e 			push	ds
	*** 000e4f	68 00 00 		push	OFFSET DGROUP:$SG3781
	*** 000e52	ff 76 f6 		push	WORD PTR [bp-10]
	*** 000e55	ff 76 f4 		push	WORD PTR [bp-12]
	*** 000e58	9a 00 00 00 00 		call	FAR PTR ??6ostream@@RECAEV0@PFD@Z	; ostream::operator<<
	*** 000e5d	52 			push	dx
	*** 000e5e	50 			push	ax
	*** 000e5f	9a 00 00 00 00 		call	FAR PTR ?endl@@ZAAEVostream@@AEV1@@Z	; endl
	*** 000e64	83 c4 04 		add	sp,4
;|***     //terminate();
;|***     exit(0);
; Line 1028
	*** 000e67	6a 00 			push	0
	*** 000e69	9a 00 00 00 00 		call	FAR PTR _exit
	*** 000e6e	83 c4 02 		add	sp,2
;|***     }
; Line 1029
					$I3780:
;|***   
;|***   // test channel a to make sure it opened
;|***   if(escc1.clear_rx_buffer(channela)==TRUE)
; Line 1032
	*** 000e71	ff 36 00 00 		push	WORD PTR ?channela@@3IE	;channela
	*** 000e75	ff 76 fa 		push	WORD PTR [bp-6]
	*** 000e78	ff 76 f8 		push	WORD PTR [bp-8]
	*** 000e7b	9a 00 00 00 00 		call	FAR PTR ?clear_rx_buffer@Cescc@@RECII@Z	; Cescc::clear_rx_buffer
	*** 000e80	0b c0 			or	ax,ax
	*** 000e82	75 1c 			jne	$I3782
;|***     cout << "Channel A rx buffer cleared OK.  " << endl;
; Line 1033
	*** 000e84	1e 			push	ds
	*** 000e85	68 00 00 		push	OFFSET DGROUP:$SG3783
	*** 000e88	ff 76 f6 		push	WORD PTR [bp-10]
	*** 000e8b	ff 76 f4 		push	WORD PTR [bp-12]
	*** 000e8e	9a 00 00 00 00 		call	FAR PTR ??6ostream@@RECAEV0@PFD@Z	; ostream::operator<<
	*** 000e93	52 			push	dx
	*** 000e94	50 			push	ax
	*** 000e95	9a 00 00 00 00 		call	FAR PTR ?endl@@ZAAEVostream@@AEV1@@Z	; endl
	*** 000e9a	83 c4 04 		add	sp,4
	*** 000e9d	eb 24 			jmp	SHORT $I3784
	*** 000e9f	90 			nop	
;|***   else
; Line 1034
					$I3782:
;|***     {
;|***     cout << "Channel A rx buffer clear FAILED!" << endl;
; Line 1036
	*** 000ea0	1e 			push	ds
	*** 000ea1	68 00 00 		push	OFFSET DGROUP:$SG3785
	*** 000ea4	ff 76 f6 		push	WORD PTR [bp-10]
	*** 000ea7	ff 76 f4 		push	WORD PTR [bp-12]
	*** 000eaa	9a 00 00 00 00 		call	FAR PTR ??6ostream@@RECAEV0@PFD@Z	; ostream::operator<<
	*** 000eaf	52 			push	dx
	*** 000eb0	50 			push	ax
	*** 000eb1	9a 00 00 00 00 		call	FAR PTR ?endl@@ZAAEVostream@@AEV1@@Z	; endl
	*** 000eb6	83 c4 04 		add	sp,4
;|***     //terminate();
;|***     exit(0);
; Line 1038
	*** 000eb9	6a 00 			push	0
	*** 000ebb	9a 00 00 00 00 		call	FAR PTR _exit
	*** 000ec0	83 c4 02 		add	sp,2
;|***     }
; Line 1039
					$I3784:
;|*** 
;|***   if(escc1.clear_tx_buffer(channela)==TRUE)
; Line 1041
	*** 000ec3	ff 36 00 00 		push	WORD PTR ?channela@@3IE	;channela
	*** 000ec7	ff 76 fa 		push	WORD PTR [bp-6]
	*** 000eca	ff 76 f8 		push	WORD PTR [bp-8]
	*** 000ecd	9a 00 00 00 00 		call	FAR PTR ?clear_tx_buffer@Cescc@@RECII@Z	; Cescc::clear_tx_buffer
	*** 000ed2	0b c0 			or	ax,ax
	*** 000ed4	75 1c 			jne	$I3786
;|***     cout << "Channel A tx buffer cleared OK." << endl;
; Line 1042
	*** 000ed6	1e 			push	ds
	*** 000ed7	68 00 00 		push	OFFSET DGROUP:$SG3787
	*** 000eda	ff 76 f6 		push	WORD PTR [bp-10]
	*** 000edd	ff 76 f4 		push	WORD PTR [bp-12]
	*** 000ee0	9a 00 00 00 00 		call	FAR PTR ??6ostream@@RECAEV0@PFD@Z	; ostream::operator<<
	*** 000ee5	52 			push	dx
	*** 000ee6	50 			push	ax
	*** 000ee7	9a 00 00 00 00 		call	FAR PTR ?endl@@ZAAEVostream@@AEV1@@Z	; endl
	*** 000eec	83 c4 04 		add	sp,4
	*** 000eef	eb 1e 			jmp	SHORT $I3788
	*** 000ef1	90 			nop	
;|***   else
; Line 1043
					$I3786:
;|***     {
;|***     cout << "Channel A tx buffer clear FAILED!" << endl;
; Line 1045
	*** 000ef2	1e 			push	ds
	*** 000ef3	68 00 00 		push	OFFSET DGROUP:$SG3789
	*** 000ef6	ff 76 f6 		push	WORD PTR [bp-10]
	*** 000ef9	ff 76 f4 		push	WORD PTR [bp-12]
	*** 000efc	9a 00 00 00 00 		call	FAR PTR ??6ostream@@RECAEV0@PFD@Z	; ostream::operator<<
	*** 000f01	52 			push	dx
	*** 000f02	50 			push	ax
	*** 000f03	9a 00 00 00 00 		call	FAR PTR ?endl@@ZAAEVostream@@AEV1@@Z	; endl
	*** 000f08	83 c4 04 		add	sp,4
;|***     terminate();
; Line 1046
	*** 000f0b	0e 			push	cs
	*** 000f0c	e8 00 00 		call	NEAR PTR ?terminate@@ZAXXZ	; terminate
;|***     }
; Line 1047
					$I3788:
;|***   
;|***   // set channel a frame transmission type
;|***   if(escc1.set_tx_type(channela, TRANSPARENT_MODE)==TRUE)
; Line 1050
	*** 000f0f	ff 36 00 00 		push	WORD PTR ?channela@@3IE	;channela
	*** 000f13	6a 01 			push	1
	*** 000f15	ff 76 fa 		push	WORD PTR [bp-6]
	*** 000f18	ff 76 f8 		push	WORD PTR [bp-8]
	*** 000f1b	9a 00 00 00 00 		call	FAR PTR ?set_tx_type@Cescc@@RECIII@Z	; Cescc::set_tx_type
	*** 000f20	0b c0 			or	ax,ax
	*** 000f22	75 1c 			jne	$I3790
;|***     cout << "Channel A set to Transparent Mode.  " << endl;
; Line 1051
	*** 000f24	1e 			push	ds
	*** 000f25	68 00 00 		push	OFFSET DGROUP:$SG3791
	*** 000f28	ff 76 f6 		push	WORD PTR [bp-10]
	*** 000f2b	ff 76 f4 		push	WORD PTR [bp-12]
	*** 000f2e	9a 00 00 00 00 		call	FAR PTR ??6ostream@@RECAEV0@PFD@Z	; ostream::operator<<
	*** 000f33	52 			push	dx
	*** 000f34	50 			push	ax
	*** 000f35	9a 00 00 00 00 		call	FAR PTR ?endl@@ZAAEVostream@@AEV1@@Z	; endl
	*** 000f3a	83 c4 04 		add	sp,4
	*** 000f3d	eb 1e 			jmp	SHORT $I3792
	*** 000f3f	90 			nop	
;|***   else
; Line 1052
					$I3790:
;|***     {
;|***     cout << "Channel A Transparent Mode not set!  Channel not open!" << endl;
; Line 1054
	*** 000f40	1e 			push	ds
	*** 000f41	68 00 00 		push	OFFSET DGROUP:$SG3793
	*** 000f44	ff 76 f6 		push	WORD PTR [bp-10]
	*** 000f47	ff 76 f4 		push	WORD PTR [bp-12]
	*** 000f4a	9a 00 00 00 00 		call	FAR PTR ??6ostream@@RECAEV0@PFD@Z	; ostream::operator<<
	*** 000f4f	52 			push	dx
	*** 000f50	50 			push	ax
	*** 000f51	9a 00 00 00 00 		call	FAR PTR ?endl@@ZAAEVostream@@AEV1@@Z	; endl
	*** 000f56	83 c4 04 		add	sp,4
;|***     terminate();
; Line 1055
	*** 000f59	0e 			push	cs
	*** 000f5a	e8 00 00 		call	NEAR PTR ?terminate@@ZAXXZ	; terminate
;|***     }
; Line 1056
					$I3792:
;|*** 
;|***   // Channel b will run off the escc internal oscillator, so must first
;|***   // configure the escc frequency generator to produce a 9.8304 MHz clock signal
;|***   // from the onboard 18.432 MHz TTL oscillator.  The 9.8304 MHz clock is 
;|***   // then divided by 128 to be used as the master clock for the 76.8 KHz pcm data stream
;|***   //
;|***   // See escc.cpp, Cypress ICD2053B datasheet and BitCalc software
;|***   // available at the Cypress Web site to calculate the clock scaling factor
;|***   // to be loaded into the clock generator.
;|***   //
;|***   // void Cescc::set_clock_generator(unsigned port,     //either channel A or B will work
;|***   //                                 unsigned long hval,//stuffed hex value from BitCalc
;|***   //                                 unsigned nmbits)   //number of bits in stuffed value
;|***   
;|***   //escc1.set_clock_generator(channela, 0x5d31c0L, 0x18);
;|***   
;|***     // new 2.4576 MHz clock for 19.2 KHz PCM bit rate 12/19/2007 jtm
;|***   escc1.set_clock_generator(channela, 0x5d51c0L, 24);
; Line 1074
	*** 000f5d	ff 36 00 00 		push	WORD PTR ?channela@@3IE	;channela
	*** 000f61	6a 5d 			push	93	;005dH
	*** 000f63	68 c0 51 		push	20928	;51c0H
	*** 000f66	6a 18 			push	24	;0018H
	*** 000f68	ff 76 fa 		push	WORD PTR [bp-6]
	*** 000f6b	ff 76 f8 		push	WORD PTR [bp-8]
	*** 000f6e	9a 00 00 00 00 		call	FAR PTR ?set_clock_generator@Cescc@@RECXIKI@Z	; Cescc::set_clock_generator
;|***   
;|***   
;|***   // Configure channel_b for biphase-m operation for pcm telemetry.
;|***   // see Siemens SAB 82532 ESCC User's Manual page 110 for register descriptions.
;|***   settings.mode = 0xC8;  // extended transparent mode 0, rcvr active, extern timer k=32768
; Line 1079
	*** 000f73	8e 06 00 00 		mov	es,WORD PTR $T4071
	*** 000f77	26 c7 06 02 00 c8 00 	mov	WORD PTR es:?settings@@3Uescc_regs@@E+2,200	;00c8H	;settings
;|***   settings.timr = 0xe2;  // cnt=7, value=2, continuous 100 Hz interrupts when tcp=1/9.8304MHz
; Line 1080
	*** 000f7e	26 c7 06 04 00 e2 00 	mov	WORD PTR es:?settings@@3Uescc_regs@@E+4,226	;00e2H	;settings
;|***   settings.xbcl = 0x00;  // set up by setupdmat() when transmission is started
;|***   settings.xbch = 0x80;  // dma data transfer mode
; Line 1082
	*** 000f85	26 c7 06 08 00 80 00 	mov	WORD PTR es:?settings@@3Uescc_regs@@E+8,128	;0080H	;settings
;|***   
;|***   // Note:  ESCC User's manual p 92/129 has switched FM0 & FM1?  Actually FM0=101, FM1=100 ?
;|***   settings.ccr0 = 0xD0;  // power-up, master clk=xtal, FM1(biphase-m), hdlc/sdlc
; Line 1085
	*** 000f8c	26 c7 06 0a 00 d0 00 	mov	WORD PTR es:?settings@@3Uescc_regs@@E+10,208	;00d0H	;settings
;|***   settings.ccr1 = 0x17;  // set txd push-pull, set clk mode 7b
; Line 1086
	*** 000f93	26 c7 06 0c 00 17 00 	mov	WORD PTR es:?settings@@3Uescc_regs@@E+12,23	;0017H	;settings
;|***   settings.ccr2 = 0x38;  // br9&8=0, bdf=1, ssel=1, toe=1, rwx=0, crc-ccitt, no inversion
; Line 1087
	*** 000f9a	26 c7 06 0e 00 38 00 	mov	WORD PTR es:?settings@@3Uescc_regs@@E+14,56	;0038H	;settings
;|***   settings.ccr3 = 0x02;  // no preamble, radd=0, crl=0, rcrc=off, xcrc=off, psd=na
; Line 1088
	*** 000fa1	26 c7 06 10 00 02 00 	mov	WORD PTR es:?settings@@3Uescc_regs@@E+16,2	;settings
;|***   settings.ccr4 = 0x00;  // added to implement MCK4 and EBRG, but not used
;|***   settings.bgr  = 0x3f;  // brg divisor=63 (0x3F), 76.8 KHz = 9.8304 MHz /((63+1)*2)
; Line 1090
	*** 000fa8	26 c7 06 14 00 3f 00 	mov	WORD PTR es:?settings@@3Uescc_regs@@E+20,63	;003fH	;settings
;|***   settings.iva  = 0x00;  // not set here
;|***   settings.ipc  = 0x03;  // masked interrupts not visible, pin INT = push/pull active high
; Line 1092
	*** 000faf	26 c7 06 18 00 03 00 	mov	WORD PTR es:?settings@@3Uescc_regs@@E+24,3	;settings
;|***   settings.imr0 = 0x00;  // all interrupts enabled
;|***   settings.imr1 = 0x00;  // all interrupts enabled
;|***   settings.pvr  = 0x00;  
;|***   settings.pim  = 0xff;
;|***   settings.pcr  = 0xe0;
; Line 1097
	*** 000fb6	26 c7 06 22 00 e0 00 	mov	WORD PTR es:?settings@@3Uescc_regs@@E+34,224	;00e0H	;settings
;|***   settings.xad1 = 0xff;
;|***   settings.xad2 = 0xff;
;|***   settings.rah1 = 0xff;
;|***   settings.rah2 = 0xff;
;|***   settings.ral1 = 0xff;
;|***   settings.ral2 = 0xff;
; Line 1103
	*** 000fbd	b8 ff 00 		mov	ax,255	;00ffH
	*** 000fc0	26 a3 20 00 		mov	WORD PTR es:?settings@@3Uescc_regs@@E+32,ax	;settings
	*** 000fc4	26 a3 24 00 		mov	WORD PTR es:?settings@@3Uescc_regs@@E+36,ax	;settings
	*** 000fc8	26 a3 26 00 		mov	WORD PTR es:?settings@@3Uescc_regs@@E+38,ax	;settings
	*** 000fcc	26 a3 28 00 		mov	WORD PTR es:?settings@@3Uescc_regs@@E+40,ax	;settings
	*** 000fd0	26 a3 2a 00 		mov	WORD PTR es:?settings@@3Uescc_regs@@E+42,ax	;settings
	*** 000fd4	26 a3 2c 00 		mov	WORD PTR es:?settings@@3Uescc_regs@@E+44,ax	;settings
	*** 000fd8	26 a3 2e 00 		mov	WORD PTR es:?settings@@3Uescc_regs@@E+46,ax	;settings
;|***   settings.rlcr = 0x00;
;|***   settings.pre  = 0x00;
;|***   
;|***   //Write configuration to channelb registers
;|***   //Parameters: (port to intialize,
;|***   //             operating mode,
;|***   //             settings defined above,
;|***   //             number of receive buffers,
;|***   //             number of transmit buffers)
;|***   if(escc1.init_port(channelb,OPMODE_HDLC,&settings,MAX_RBUFS,MAX_TBUFS)==TRUE)
; Line 1113
	*** 000fdc	ff 36 00 00 		push	WORD PTR ?channelb@@3IE	;channelb
	*** 000fe0	33 c0 			xor	ax,ax
	*** 000fe2	26 a3 06 00 		mov	WORD PTR es:?settings@@3Uescc_regs@@E+6,ax	;settings
	*** 000fe6	26 a3 12 00 		mov	WORD PTR es:?settings@@3Uescc_regs@@E+18,ax	;settings
	*** 000fea	26 a3 16 00 		mov	WORD PTR es:?settings@@3Uescc_regs@@E+22,ax	;settings
	*** 000fee	26 a3 1a 00 		mov	WORD PTR es:?settings@@3Uescc_regs@@E+26,ax	;settings
	*** 000ff2	26 a3 1c 00 		mov	WORD PTR es:?settings@@3Uescc_regs@@E+28,ax	;settings
	*** 000ff6	26 a3 1e 00 		mov	WORD PTR es:?settings@@3Uescc_regs@@E+30,ax	;settings
	*** 000ffa	26 a3 30 00 		mov	WORD PTR es:?settings@@3Uescc_regs@@E+48,ax	;settings
	*** 000ffe	26 a3 32 00 		mov	WORD PTR es:?settings@@3Uescc_regs@@E+50,ax	;settings
	*** 001002	50 			push	ax
	*** 001003	06 			push	es
	*** 001004	68 00 00 		push	OFFSET ?settings@@3Uescc_regs@@E	;settings
	*** 001007	6a 10 			push	16	;0010H
	*** 001009	6a 10 			push	16	;0010H
	*** 00100b	ff 76 fa 		push	WORD PTR [bp-6]
	*** 00100e	ff 76 f8 		push	WORD PTR [bp-8]
	*** 001011	9a 00 00 00 00 		call	FAR PTR ?init_port@Cescc@@RECIIIPEUescc_regs@@II@Z	; Cescc::init_port
	*** 001016	0b c0 			or	ax,ax
	*** 001018	75 1c 			jne	$I3794
;|***     cout << "Intialize Channel B OK." << endl;
; Line 1114
	*** 00101a	1e 			push	ds
	*** 00101b	68 00 00 		push	OFFSET DGROUP:$SG3795
	*** 00101e	ff 76 f6 		push	WORD PTR [bp-10]
	*** 001021	ff 76 f4 		push	WORD PTR [bp-12]
	*** 001024	9a 00 00 00 00 		call	FAR PTR ??6ostream@@RECAEV0@PFD@Z	; ostream::operator<<
	*** 001029	52 			push	dx
	*** 00102a	50 			push	ax
	*** 00102b	9a 00 00 00 00 		call	FAR PTR ?endl@@ZAAEVostream@@AEV1@@Z	; endl
	*** 001030	83 c4 04 		add	sp,4
	*** 001033	eb 1e 			jmp	SHORT $I3796
	*** 001035	90 			nop	
;|***   else
; Line 1115
					$I3794:
;|***     {
;|***     cout << "Initialize Channel B FAILED!" << endl;
; Line 1117
	*** 001036	1e 			push	ds
	*** 001037	68 00 00 		push	OFFSET DGROUP:$SG3797
	*** 00103a	ff 76 f6 		push	WORD PTR [bp-10]
	*** 00103d	ff 76 f4 		push	WORD PTR [bp-12]
	*** 001040	9a 00 00 00 00 		call	FAR PTR ??6ostream@@RECAEV0@PFD@Z	; ostream::operator<<
	*** 001045	52 			push	dx
	*** 001046	50 			push	ax
	*** 001047	9a 00 00 00 00 		call	FAR PTR ?endl@@ZAAEVostream@@AEV1@@Z	; endl
	*** 00104c	83 c4 04 		add	sp,4
;|***     terminate();
; Line 1118
	*** 00104f	0e 			push	cs
	*** 001050	e8 00 00 		call	NEAR PTR ?terminate@@ZAXXZ	; terminate
;|***     }
; Line 1119
					$I3796:
;|***   
;|***   // test channelb to make sure it opened
;|***   if(escc1.clear_rx_buffer(channelb)==TRUE)
; Line 1122
	*** 001053	ff 36 00 00 		push	WORD PTR ?channelb@@3IE	;channelb
	*** 001057	ff 76 fa 		push	WORD PTR [bp-6]
	*** 00105a	ff 76 f8 		push	WORD PTR [bp-8]
	*** 00105d	9a 00 00 00 00 		call	FAR PTR ?clear_rx_buffer@Cescc@@RECII@Z	; Cescc::clear_rx_buffer
	*** 001062	0b c0 			or	ax,ax
	*** 001064	75 1c 			jne	$I3798
;|***     cout << "Channel B rx buffer cleared OK.  " << endl;
; Line 1123
	*** 001066	1e 			push	ds
	*** 001067	68 00 00 		push	OFFSET DGROUP:$SG3799
	*** 00106a	ff 76 f6 		push	WORD PTR [bp-10]
	*** 00106d	ff 76 f4 		push	WORD PTR [bp-12]
	*** 001070	9a 00 00 00 00 		call	FAR PTR ??6ostream@@RECAEV0@PFD@Z	; ostream::operator<<
	*** 001075	52 			push	dx
	*** 001076	50 			push	ax
	*** 001077	9a 00 00 00 00 		call	FAR PTR ?endl@@ZAAEVostream@@AEV1@@Z	; endl
	*** 00107c	83 c4 04 		add	sp,4
	*** 00107f	eb 1e 			jmp	SHORT $I3800
	*** 001081	90 			nop	
;|***   else
; Line 1124
					$I3798:
;|***     {
;|***     cout << "Channel B rx buffer clear FAILED!" << endl;
; Line 1126
	*** 001082	1e 			push	ds
	*** 001083	68 00 00 		push	OFFSET DGROUP:$SG3801
	*** 001086	ff 76 f6 		push	WORD PTR [bp-10]
	*** 001089	ff 76 f4 		push	WORD PTR [bp-12]
	*** 00108c	9a 00 00 00 00 		call	FAR PTR ??6ostream@@RECAEV0@PFD@Z	; ostream::operator<<
	*** 001091	52 			push	dx
	*** 001092	50 			push	ax
	*** 001093	9a 00 00 00 00 		call	FAR PTR ?endl@@ZAAEVostream@@AEV1@@Z	; endl
	*** 001098	83 c4 04 		add	sp,4
;|***     terminate();
; Line 1127
	*** 00109b	0e 			push	cs
	*** 00109c	e8 00 00 		call	NEAR PTR ?terminate@@ZAXXZ	; terminate
;|***     }
; Line 1128
					$I3800:
;|***   
;|***   if(escc1.clear_tx_buffer(channelb)==TRUE)
; Line 1130
	*** 00109f	ff 36 00 00 		push	WORD PTR ?channelb@@3IE	;channelb
	*** 0010a3	ff 76 fa 		push	WORD PTR [bp-6]
	*** 0010a6	ff 76 f8 		push	WORD PTR [bp-8]
	*** 0010a9	9a 00 00 00 00 		call	FAR PTR ?clear_tx_buffer@Cescc@@RECII@Z	; Cescc::clear_tx_buffer
	*** 0010ae	0b c0 			or	ax,ax
	*** 0010b0	75 1c 			jne	$I3802
;|***     cout << "Channel B tx buffer cleared OK." << endl;
; Line 1131
	*** 0010b2	1e 			push	ds
	*** 0010b3	68 00 00 		push	OFFSET DGROUP:$SG3803
	*** 0010b6	ff 76 f6 		push	WORD PTR [bp-10]
	*** 0010b9	ff 76 f4 		push	WORD PTR [bp-12]
	*** 0010bc	9a 00 00 00 00 		call	FAR PTR ??6ostream@@RECAEV0@PFD@Z	; ostream::operator<<
	*** 0010c1	52 			push	dx
	*** 0010c2	50 			push	ax
	*** 0010c3	9a 00 00 00 00 		call	FAR PTR ?endl@@ZAAEVostream@@AEV1@@Z	; endl
	*** 0010c8	83 c4 04 		add	sp,4
	*** 0010cb	eb 1e 			jmp	SHORT $I3804
	*** 0010cd	90 			nop	
;|***   else
; Line 1132
					$I3802:
;|***     {
;|***     cout << "Channel B tx buffer clear FAILED!" << endl;
; Line 1134
	*** 0010ce	1e 			push	ds
	*** 0010cf	68 00 00 		push	OFFSET DGROUP:$SG3805
	*** 0010d2	ff 76 f6 		push	WORD PTR [bp-10]
	*** 0010d5	ff 76 f4 		push	WORD PTR [bp-12]
	*** 0010d8	9a 00 00 00 00 		call	FAR PTR ??6ostream@@RECAEV0@PFD@Z	; ostream::operator<<
	*** 0010dd	52 			push	dx
	*** 0010de	50 			push	ax
	*** 0010df	9a 00 00 00 00 		call	FAR PTR ?endl@@ZAAEVostream@@AEV1@@Z	; endl
	*** 0010e4	83 c4 04 		add	sp,4
;|***     terminate();
; Line 1135
	*** 0010e7	0e 			push	cs
	*** 0010e8	e8 00 00 		call	NEAR PTR ?terminate@@ZAXXZ	; terminate
;|***     }
; Line 1136
					$I3804:
;|***   
;|***   //set channelb frame transmission type
;|***   if(escc1.set_tx_type(channelb, TRANSPARENT_MODE)==TRUE)
; Line 1139
	*** 0010eb	ff 36 00 00 		push	WORD PTR ?channelb@@3IE	;channelb
	*** 0010ef	6a 01 			push	1
	*** 0010f1	ff 76 fa 		push	WORD PTR [bp-6]
	*** 0010f4	ff 76 f8 		push	WORD PTR [bp-8]
	*** 0010f7	9a 00 00 00 00 		call	FAR PTR ?set_tx_type@Cescc@@RECIII@Z	; Cescc::set_tx_type
	*** 0010fc	0b c0 			or	ax,ax
	*** 0010fe	75 1c 			jne	$I3806
;|***     cout << "Channel B set to Transparent Mode.  " << endl;
; Line 1140
	*** 001100	1e 			push	ds
	*** 001101	68 00 00 		push	OFFSET DGROUP:$SG3807
	*** 001104	ff 76 f6 		push	WORD PTR [bp-10]
	*** 001107	ff 76 f4 		push	WORD PTR [bp-12]
	*** 00110a	9a 00 00 00 00 		call	FAR PTR ??6ostream@@RECAEV0@PFD@Z	; ostream::operator<<
	*** 00110f	52 			push	dx
	*** 001110	50 			push	ax
	*** 001111	9a 00 00 00 00 		call	FAR PTR ?endl@@ZAAEVostream@@AEV1@@Z	; endl
	*** 001116	83 c4 04 		add	sp,4
	*** 001119	c9 			leave	
	*** 00111a	cb 			ret	
	*** 00111b	90 			nop	
;|***   else
; Line 1141
					$I3806:
;|***     {
;|***     cout << "Channel B Transparent Mode not set!  Channel not open!" << endl;
; Line 1143
	*** 00111c	1e 			push	ds
	*** 00111d	68 00 00 		push	OFFSET DGROUP:$SG3809
	*** 001120	ff 76 f6 		push	WORD PTR [bp-10]
	*** 001123	ff 76 f4 		push	WORD PTR [bp-12]
	*** 001126	9a 00 00 00 00 		call	FAR PTR ??6ostream@@RECAEV0@PFD@Z	; ostream::operator<<
	*** 00112b	52 			push	dx
	*** 00112c	50 			push	ax
	*** 00112d	9a 00 00 00 00 		call	FAR PTR ?endl@@ZAAEVostream@@AEV1@@Z	; endl
	*** 001132	83 c4 04 		add	sp,4
;|***     terminate();
; Line 1144
	*** 001135	0e 			push	cs
	*** 001136	e8 00 00 		call	NEAR PTR ?terminate@@ZAXXZ	; terminate
;|***     }
;|***   }
; Line 1146
	*** 001139	c9 			leave	
	*** 00113a	cb 			ret	
	*** 00113b	90 			nop	

?configure_escc@@ZAXXZ	ENDP
CBA_TEXT      ENDS
CONST      SEGMENT
$T4196	DQ	03f768003999a2d0er    ;	5.493177473577816E-03
CONST      ENDS
CBA_TEXT      SEGMENT
	ASSUME	CS: CBA_TEXT
	PUBLIC	?wait_for_time_tick@@ZAXXZ	; wait_for_time_tick
?wait_for_time_tick@@ZAXXZ	PROC FAR	; wait_for_time_tick
;|*** 
;|*** 
;|*** 
;|***   
;|*** void wait_for_time_tick(void)
;|***   {
;|***   
;|***   while(frame < next_frame)              // idle loop waits until beginning of next frame
; Line 1154
					$FC3813:
	*** 00113c	a1 00 00 		mov	ax,WORD PTR ?frame@@3KE	;frame
	*** 00113f	8b 16 02 00 		mov	dx,WORD PTR ?frame@@3KE+2	;frame
	*** 001143	39 16 02 00 		cmp	WORD PTR ?next_frame@@3KE+2,dx	;next_frame
	*** 001147	77 f3 			ja	$FC3813
	*** 001149	72 06 			jb	$L4197
	*** 00114b	39 06 00 00 		cmp	WORD PTR ?next_frame@@3KE,ax	;next_frame
	*** 00114f	77 eb 			ja	$FC3813
					$L4197:
;|***     {                                    // frame is incremented in dmm32a isr by 100 Hz timer
;|***    /* if(escc1.istxing[channelb]==0)
;|***       {
;|***         send_pcm();
;|***       }  */
;|***     }    
;|***       
;|***   sprintf(s, "Pitch:   %04x  %10.2f deg", ln200.data[9], (ln200.data[9] / 182.044));   // Pitch
; Line 1162
	*** 001151	8e 06 00 00 		mov	es,WORD PTR $T4071
	*** 001155	bb 1e 00 		mov	bx,OFFSET ?ln200@@3ULN200@@E+30	;ln200
	*** 001158	9a 00 00 00 00 		call	FAR PTR __aFeldw
	*** 00115d	9a 00 00 00 00 		call	FAR PTR __aFdcvt
	*** 001162	bb 00 00 		mov	bx,OFFSET DGROUP:$T4196
	*** 001165	9a 00 00 00 00 		call	FAR PTR __aFfmuld
	*** 00116a	83 ec 08 		sub	sp,8
	*** 00116d	8b dc 			mov	bx,sp
	*** 00116f	9a 00 00 00 00 		call	FAR PTR __aFfstdp
	*** 001174	8e 06 00 00 		mov	es,WORD PTR $T4071
	*** 001178	26 ff 36 1e 00 		push	WORD PTR es:?ln200@@3ULN200@@E+30	;ln200
	*** 00117d	1e 			push	ds
	*** 00117e	68 00 00 		push	OFFSET DGROUP:$SG3815
	*** 001181	1e 			push	ds
	*** 001182	68 00 00 		push	OFFSET DGROUP:?s@@3QIDI	;s
	*** 001185	9a 00 00 00 00 		call	FAR PTR _sprintf
	*** 00118a	83 c4 12 		add	sp,18	;0012H
;|***   //sprintf(s, "Pitch:   %04x  %10.2f deg", frame, (ln200.data[9] / 182.044));   // Pitch
;|***   PC_DispStr(0,6, (unsigned char *)s, DISP_FGND_BLACK + DISP_BGND_RED);
; Line 1164
	*** 00118d	6a 40 			push	64	;0040H
	*** 00118f	1e 			push	ds
	*** 001190	68 00 00 		push	OFFSET DGROUP:?s@@3QIDI	;s
	*** 001193	6a 06 			push	6
	*** 001195	6a 00 			push	0
	*** 001197	0e 			push	cs
	*** 001198	e8 00 00 		call	NEAR PTR ?PC_DispStr@@ZAXEEPIEE@Z	; PC_DispStr
	*** 00119b	83 c4 0a 		add	sp,10	;000aH
;|***   sprintf(s, "Roll:    %04x  %10.2f deg", ln200.data[10], (ln200.data[10] / 182.044));  // Roll
; Line 1165
	*** 00119e	8e 06 00 00 		mov	es,WORD PTR $T4071
	*** 0011a2	bb 20 00 		mov	bx,OFFSET ?ln200@@3ULN200@@E+32	;ln200
	*** 0011a5	9a 00 00 00 00 		call	FAR PTR __aFeldw
	*** 0011aa	9a 00 00 00 00 		call	FAR PTR __aFdcvt
	*** 0011af	bb 00 00 		mov	bx,OFFSET DGROUP:$T4196
	*** 0011b2	9a 00 00 00 00 		call	FAR PTR __aFfmuld
	*** 0011b7	83 ec 08 		sub	sp,8
	*** 0011ba	8b dc 			mov	bx,sp
	*** 0011bc	9a 00 00 00 00 		call	FAR PTR __aFfstdp
	*** 0011c1	8e 06 00 00 		mov	es,WORD PTR $T4071
	*** 0011c5	26 ff 36 20 00 		push	WORD PTR es:?ln200@@3ULN200@@E+32	;ln200
	*** 0011ca	1e 			push	ds
	*** 0011cb	68 00 00 		push	OFFSET DGROUP:$SG3817
	*** 0011ce	1e 			push	ds
	*** 0011cf	68 00 00 		push	OFFSET DGROUP:?s@@3QIDI	;s
	*** 0011d2	9a 00 00 00 00 		call	FAR PTR _sprintf
	*** 0011d7	83 c4 12 		add	sp,18	;0012H
;|***   PC_DispStr(0,7, (unsigned char *)s, DISP_FGND_BLACK + DISP_BGND_RED);
; Line 1166
	*** 0011da	6a 40 			push	64	;0040H
	*** 0011dc	1e 			push	ds
	*** 0011dd	68 00 00 		push	OFFSET DGROUP:?s@@3QIDI	;s
	*** 0011e0	6a 07 			push	7
	*** 0011e2	6a 00 			push	0
	*** 0011e4	0e 			push	cs
	*** 0011e5	e8 00 00 		call	NEAR PTR ?PC_DispStr@@ZAXEEPIEE@Z	; PC_DispStr
	*** 0011e8	83 c4 0a 		add	sp,10	;000aH
;|***   sprintf(s, "Heading: %04x  %10.2f deg", ln200.data[11], (ln200.data[11] / 182.044));  // Heading
; Line 1167
	*** 0011eb	8e 06 00 00 		mov	es,WORD PTR $T4071
	*** 0011ef	bb 22 00 		mov	bx,OFFSET ?ln200@@3ULN200@@E+34	;ln200
	*** 0011f2	9a 00 00 00 00 		call	FAR PTR __aFeldw
	*** 0011f7	9a 00 00 00 00 		call	FAR PTR __aFdcvt
	*** 0011fc	bb 00 00 		mov	bx,OFFSET DGROUP:$T4196
	*** 0011ff	9a 00 00 00 00 		call	FAR PTR __aFfmuld
	*** 001204	83 ec 08 		sub	sp,8
	*** 001207	8b dc 			mov	bx,sp
	*** 001209	9a 00 00 00 00 		call	FAR PTR __aFfstdp
	*** 00120e	8e 06 00 00 		mov	es,WORD PTR $T4071
	*** 001212	26 ff 36 22 00 		push	WORD PTR es:?ln200@@3ULN200@@E+34	;ln200
	*** 001217	1e 			push	ds
	*** 001218	68 00 00 		push	OFFSET DGROUP:$SG3819
	*** 00121b	1e 			push	ds
	*** 00121c	68 00 00 		push	OFFSET DGROUP:?s@@3QIDI	;s
	*** 00121f	9a 00 00 00 00 		call	FAR PTR _sprintf
	*** 001224	83 c4 12 		add	sp,18	;0012H
;|***   PC_DispStr(0,8, (unsigned char *)s, DISP_FGND_BLACK + DISP_BGND_RED);
; Line 1168
	*** 001227	6a 40 			push	64	;0040H
	*** 001229	1e 			push	ds
	*** 00122a	68 00 00 		push	OFFSET DGROUP:?s@@3QIDI	;s
	*** 00122d	6a 08 			push	8
	*** 00122f	6a 00 			push	0
	*** 001231	0e 			push	cs
	*** 001232	e8 00 00 		call	NEAR PTR ?PC_DispStr@@ZAXEEPIEE@Z	; PC_DispStr
	*** 001235	83 c4 0a 		add	sp,10	;000aH
;|***   
;|***   sprintf(s, "Stern 1: %04x", echo.data[4]);
; Line 1170
	*** 001238	8e 06 00 00 		mov	es,WORD PTR $T4071
	*** 00123c	26 a0 10 00 		mov	al,BYTE PTR es:?echo@@3UECHO@@E+16	;echo
	*** 001240	2a e4 			sub	ah,ah
	*** 001242	50 			push	ax
	*** 001243	1e 			push	ds
	*** 001244	68 00 00 		push	OFFSET DGROUP:$SG3821
	*** 001247	1e 			push	ds
	*** 001248	68 00 00 		push	OFFSET DGROUP:?s@@3QIDI	;s
	*** 00124b	9a 00 00 00 00 		call	FAR PTR _sprintf
	*** 001250	83 c4 0a 		add	sp,10	;000aH
;|***   PC_DispStr(0,9, (unsigned char *)s, DISP_FGND_BLACK + DISP_BGND_RED);     // Stern 1
; Line 1171
	*** 001253	6a 40 			push	64	;0040H
	*** 001255	1e 			push	ds
	*** 001256	68 00 00 		push	OFFSET DGROUP:?s@@3QIDI	;s
	*** 001259	6a 09 			push	9
	*** 00125b	6a 00 			push	0
	*** 00125d	0e 			push	cs
	*** 00125e	e8 00 00 		call	NEAR PTR ?PC_DispStr@@ZAXEEPIEE@Z	; PC_DispStr
	*** 001261	83 c4 0a 		add	sp,10	;000aH
;|***   sprintf(s, "Stern 2: %04x", echo.data[5]);
; Line 1172
	*** 001264	8e 06 00 00 		mov	es,WORD PTR $T4071
	*** 001268	26 a0 11 00 		mov	al,BYTE PTR es:?echo@@3UECHO@@E+17	;echo
	*** 00126c	2a e4 			sub	ah,ah
	*** 00126e	50 			push	ax
	*** 00126f	1e 			push	ds
	*** 001270	68 00 00 		push	OFFSET DGROUP:$SG3823
	*** 001273	1e 			push	ds
	*** 001274	68 00 00 		push	OFFSET DGROUP:?s@@3QIDI	;s
	*** 001277	9a 00 00 00 00 		call	FAR PTR _sprintf
	*** 00127c	83 c4 0a 		add	sp,10	;000aH
;|***   PC_DispStr(0,10, (unsigned char *)s, DISP_FGND_BLACK + DISP_BGND_RED);     // Stern 2
; Line 1173
	*** 00127f	6a 40 			push	64	;0040H
	*** 001281	1e 			push	ds
	*** 001282	68 00 00 		push	OFFSET DGROUP:?s@@3QIDI	;s
	*** 001285	6a 0a 			push	10	;000aH
	*** 001287	6a 00 			push	0
	*** 001289	0e 			push	cs
	*** 00128a	e8 00 00 		call	NEAR PTR ?PC_DispStr@@ZAXEEPIEE@Z	; PC_DispStr
	*** 00128d	83 c4 0a 		add	sp,10	;000aH
;|***   sprintf(s, "Rudder:  %04x", echo.data[3]);
; Line 1174
	*** 001290	8e 06 00 00 		mov	es,WORD PTR $T4071
	*** 001294	26 a0 0f 00 		mov	al,BYTE PTR es:?echo@@3UECHO@@E+15	;echo
	*** 001298	2a e4 			sub	ah,ah
	*** 00129a	50 			push	ax
	*** 00129b	1e 			push	ds
	*** 00129c	68 00 00 		push	OFFSET DGROUP:$SG3825
	*** 00129f	1e 			push	ds
	*** 0012a0	68 00 00 		push	OFFSET DGROUP:?s@@3QIDI	;s
	*** 0012a3	9a 00 00 00 00 		call	FAR PTR _sprintf
	*** 0012a8	83 c4 0a 		add	sp,10	;000aH
;|***   PC_DispStr(0,11, (unsigned char *)s, DISP_FGND_BLACK + DISP_BGND_RED);     // Rudder
; Line 1175
	*** 0012ab	6a 40 			push	64	;0040H
	*** 0012ad	1e 			push	ds
	*** 0012ae	68 00 00 		push	OFFSET DGROUP:?s@@3QIDI	;s
	*** 0012b1	6a 0b 			push	11	;000bH
	*** 0012b3	6a 00 			push	0
	*** 0012b5	0e 			push	cs
	*** 0012b6	e8 00 00 		call	NEAR PTR ?PC_DispStr@@ZAXEEPIEE@Z	; PC_DispStr
	*** 0012b9	83 c4 0a 		add	sp,10	;000aH
;|***   sprintf(s, "Fore:    %04x", echo.data[6]);
; Line 1176
	*** 0012bc	8e 06 00 00 		mov	es,WORD PTR $T4071
	*** 0012c0	26 a0 12 00 		mov	al,BYTE PTR es:?echo@@3UECHO@@E+18	;echo
	*** 0012c4	2a e4 			sub	ah,ah
	*** 0012c6	50 			push	ax
	*** 0012c7	1e 			push	ds
	*** 0012c8	68 00 00 		push	OFFSET DGROUP:$SG3827
	*** 0012cb	1e 			push	ds
	*** 0012cc	68 00 00 		push	OFFSET DGROUP:?s@@3QIDI	;s
	*** 0012cf	9a 00 00 00 00 		call	FAR PTR _sprintf
	*** 0012d4	83 c4 0a 		add	sp,10	;000aH
;|***   PC_DispStr(0,12, (unsigned char *)s, DISP_FGND_BLACK + DISP_BGND_RED);     // Fore
; Line 1177
	*** 0012d7	6a 40 			push	64	;0040H
	*** 0012d9	1e 			push	ds
	*** 0012da	68 00 00 		push	OFFSET DGROUP:?s@@3QIDI	;s
	*** 0012dd	6a 0c 			push	12	;000cH
	*** 0012df	6a 00 			push	0
	*** 0012e1	0e 			push	cs
	*** 0012e2	e8 00 00 		call	NEAR PTR ?PC_DispStr@@ZAXEEPIEE@Z	; PC_DispStr
	*** 0012e5	83 c4 0a 		add	sp,10	;000aH
;|***   
;|***   sprintf(s, "RawPos:    %08ld", prop_report);
; Line 1179
	*** 0012e8	ff 36 02 00 		push	WORD PTR ?prop_report@@3JE+2	;prop_report
	*** 0012ec	ff 36 00 00 		push	WORD PTR ?prop_report@@3JE	;prop_report
	*** 0012f0	1e 			push	ds
	*** 0012f1	68 00 00 		push	OFFSET DGROUP:$SG3829
	*** 0012f4	1e 			push	ds
	*** 0012f5	68 00 00 		push	OFFSET DGROUP:?s@@3QIDI	;s
	*** 0012f8	9a 00 00 00 00 		call	FAR PTR _sprintf
	*** 0012fd	83 c4 0c 		add	sp,12	;000cH
;|***   PC_DispStr(0,13, (unsigned char *)s, DISP_FGND_BLACK + DISP_BGND_RED);     // Prop position
; Line 1180
	*** 001300	6a 40 			push	64	;0040H
	*** 001302	1e 			push	ds
	*** 001303	68 00 00 		push	OFFSET DGROUP:?s@@3QIDI	;s
	*** 001306	6a 0d 			push	13	;000dH
	*** 001308	6a 00 			push	0
	*** 00130a	0e 			push	cs
	*** 00130b	e8 00 00 		call	NEAR PTR ?PC_DispStr@@ZAXEEPIEE@Z	; PC_DispStr
	*** 00130e	83 c4 0a 		add	sp,10	;000aH
;|***   
;|***   sprintf(s, "RawIndex:    %08ld", index_report);
; Line 1182
	*** 001311	ff 36 02 00 		push	WORD PTR ?index_report@@3JE+2	;index_report
	*** 001315	ff 36 00 00 		push	WORD PTR ?index_report@@3JE	;index_report
	*** 001319	1e 			push	ds
	*** 00131a	68 00 00 		push	OFFSET DGROUP:$SG3831
	*** 00131d	1e 			push	ds
	*** 00131e	68 00 00 		push	OFFSET DGROUP:?s@@3QIDI	;s
	*** 001321	9a 00 00 00 00 		call	FAR PTR _sprintf
	*** 001326	83 c4 0c 		add	sp,12	;000cH
;|***   PC_DispStr(0,14, (unsigned char *)s, DISP_FGND_BLACK + DISP_BGND_RED);     // Prop position
; Line 1183
	*** 001329	6a 40 			push	64	;0040H
	*** 00132b	1e 			push	ds
	*** 00132c	68 00 00 		push	OFFSET DGROUP:?s@@3QIDI	;s
	*** 00132f	6a 0e 			push	14	;000eH
	*** 001331	6a 00 			push	0
	*** 001333	0e 			push	cs
	*** 001334	e8 00 00 		call	NEAR PTR ?PC_DispStr@@ZAXEEPIEE@Z	; PC_DispStr
	*** 001337	83 c4 0a 		add	sp,10	;000aH
;|***   
;|***   sprintf(s, "PPos:    %08d", prop.position);
; Line 1185
	*** 00133a	8e 06 00 00 		mov	es,WORD PTR $T4071
	*** 00133e	26 ff 36 1c 00 		push	WORD PTR es:?prop@@3UPROP@@E+28	;prop
	*** 001343	26 ff 36 1a 00 		push	WORD PTR es:?prop@@3UPROP@@E+26	;prop
	*** 001348	1e 			push	ds
	*** 001349	68 00 00 		push	OFFSET DGROUP:$SG3833
	*** 00134c	1e 			push	ds
	*** 00134d	68 00 00 		push	OFFSET DGROUP:?s@@3QIDI	;s
	*** 001350	9a 00 00 00 00 		call	FAR PTR _sprintf
	*** 001355	83 c4 0c 		add	sp,12	;000cH
;|***   PC_DispStr(0,15, (unsigned char *)s, DISP_FGND_BLACK + DISP_BGND_RED);     // Prop position
; Line 1186
	*** 001358	6a 40 			push	64	;0040H
	*** 00135a	1e 			push	ds
	*** 00135b	68 00 00 		push	OFFSET DGROUP:?s@@3QIDI	;s
	*** 00135e	6a 0f 			push	15	;000fH
	*** 001360	6a 00 			push	0
	*** 001362	0e 			push	cs
	*** 001363	e8 00 00 		call	NEAR PTR ?PC_DispStr@@ZAXEEPIEE@Z	; PC_DispStr
	*** 001366	83 c4 0a 		add	sp,10	;000aH
;|***     
;|*** //  sprintf(s, "GPS: %s", prop.position);
;|*** //  PC_DispStr(0,15, (unsigned char *)s, DISP_FGND_BLACK + DISP_BGND_RED);     // Prop position
;|*** 
;|***   next_frame = frame + 1;                
; Line 1191
	*** 001369	a1 00 00 		mov	ax,WORD PTR ?frame@@3KE	;frame
	*** 00136c	8b 16 02 00 		mov	dx,WORD PTR ?frame@@3KE+2	;frame
	*** 001370	05 01 00 		add	ax,1
	*** 001373	83 d2 00 		adc	dx,0
	*** 001376	a3 00 00 		mov	WORD PTR ?next_frame@@3KE,ax	;next_frame
	*** 001379	89 16 02 00 		mov	WORD PTR ?next_frame@@3KE+2,dx	;next_frame
;|***   
;|***   //clr_bit(48);
;|***   }
; Line 1194
	*** 00137d	cb 			ret	

?wait_for_time_tick@@ZAXXZ	ENDP
	PUBLIC	?start_data_collection@@ZAXXZ	; start_data_collection
?start_data_collection@@ZAXXZ	PROC FAR	; start_data_collection
;|*** 
;|*** 
;|***   
;|*** void start_data_collection(void)  
;|***   {
;|***   trigger_dmm32a();
; Line 1200
	*** 00137e	0e 			push	cs
	*** 00137f	e8 00 00 		call	NEAR PTR ?trigger_dmm32a@@ZAXXZ	; trigger_dmm32a
;|***   trigger_dmm32b();
; Line 1201
	*** 001382	0e 			push	cs
	*** 001383	e8 00 00 		call	NEAR PTR ?trigger_dmm32b@@ZAXXZ	; trigger_dmm32b
;|***   }
; Line 1202
	*** 001386	cb 			ret	
	*** 001387	90 			nop	

?start_data_collection@@ZAXXZ	ENDP
	PUBLIC	?query_ln200@@ZAXXZ	; query_ln200
?query_ln200@@ZAXXZ	PROC FAR	; query_ln200
;|*** 
;|*** 
;|*** void query_ln200(void)
;|***   {
;|***   prep_ln200_command();                        // build the ln200 initialization command
; Line 1207
	*** 001388	0e 			push	cs
	*** 001389	e8 00 00 		call	NEAR PTR ?prep_ln200_command@@ZAXXZ	; prep_ln200_command
;|***   escc1.tx_port(channela, ln200_command, 14);  // and send it to the ln200
; Line 1208
	*** 00138c	ff 36 00 00 		push	WORD PTR ?channela@@3IE	;channela
	*** 001390	1e 			push	ds
	*** 001391	68 00 00 		push	OFFSET DGROUP:?ln200_command@@3QIDI	;ln200_command
	*** 001394	6a 0e 			push	14	;000eH
	*** 001396	68 00 00 		push	SEG ?escc1@@3VCescc@@E	;escc1
	*** 001399	68 00 00 		push	OFFSET ?escc1@@3VCescc@@E	;escc1
	*** 00139c	9a 00 00 00 00 		call	FAR PTR ?tx_port@Cescc@@RECIIPEDI@Z	; Cescc::tx_port
;|***   }
; Line 1209
	*** 0013a1	cb 			ret	

?query_ln200@@ZAXXZ	ENDP
	PUBLIC	?configure_dmm32a@@ZAXXZ	; configure_dmm32a
?configure_dmm32a@@ZAXXZ	PROC FAR	; configure_dmm32a
;|***   
;|*** 
;|*** void configure_dmm32a(void)
;|***   { //io = 0x340, irq=11, top board, reads the two banks of 5B modules
;|***   _disable();
; Line 1214
	*** 0013a2	fa 			cli	
;|***   _outp(OBS_BASE+FCR, FIFORST);                   // reset the fifo
; Line 1215
	*** 0013a3	b8 02 00 		mov	ax,2
	*** 0013a6	ba 47 03 		mov	dx,839	;0347H
	*** 0013a9	ee 			out	dx, al

;|*** 
;|***   _outp(OBS_BASE+MCR, PAGE1);                   
; Line 1217
	*** 0013aa	b8 01 00 		mov	ax,1
	*** 0013ad	ba 48 03 		mov	dx,840	;0348H
	*** 0013b0	ee 			out	dx, al

;|***   //_outp(OBS_BASE+15,  0x80);                  // set dio ports for outputs, mode0, old ln200
;|***   _outp(OBS_BASE+15,  0xff);                    // set dio ports for input mode 1, new ln200
; Line 1219
	*** 0013b1	b8 ff 00 		mov	ax,255	;00ffH
	*** 0013b4	ba 4f 03 		mov	dx,847	;034fH
	*** 0013b7	ee 			out	dx, al

;|***   _outp(OBS_BASE+MCR, PAGE0);
; Line 1220
	*** 0013b8	33 c0 			xor	ax,ax
	*** 0013ba	ba 48 03 		mov	dx,840	;0348H
	*** 0013bd	ee 			out	dx, al

;|*** 
;|***   _outp(OBS_BASE+LCR,  0);                         // set the range of channels to scan
; Line 1222
	*** 0013be	ba 42 03 		mov	dx,834	;0342H
	*** 0013c1	ee 			out	dx, al

;|***   _outp(OBS_BASE+HCR,  31);                        // all channels for the 2 5B module backplanes
; Line 1223
	*** 0013c2	b8 1f 00 		mov	ax,31	;001fH
	*** 0013c5	ba 43 03 		mov	dx,835	;0343H
	*** 0013c8	ee 			out	dx, al

;|***   _outp(OBS_BASE+FCR, SCANEN);                     // enable scan interrupts
; Line 1224
	*** 0013c9	b8 04 00 		mov	ax,4
	*** 0013cc	ba 47 03 		mov	dx,839	;0347H
	*** 0013cf	ee 			out	dx, al

;|***   _outp(OBS_BASE+ACR, KHZ200 | BIPOLAR5 | GAIN1);  // 200KHz scans, +-5Volt inputs
; Line 1225
	*** 0013d0	b8 30 00 		mov	ax,48	;0030H
	*** 0013d3	ba 4b 03 		mov	dx,843	;034bH
	*** 0013d6	ee 			out	dx, al

;|***   while(_inp(OBS_BASE+ARR) & WAIT);                // wait for the adc circuits to settle
; Line 1226
					$FC3842:
	*** 0013d7	ec 			in	al,dx
	*** 0013d8	a8 80 			test	al,128	;0080H
	*** 0013da	75 fb 			jne	$FC3842
;|*** 
;|***   _outp(OBS_BASE+MCR, PAGE2);                      // configure ctc0 for falling edge trigger
; Line 1228
	*** 0013dc	b8 02 00 		mov	ax,2
	*** 0013df	ba 48 03 		mov	dx,840	;0348H
	*** 0013e2	ee 			out	dx, al

;|***   _outp(OBS_BASE+CCR , 1);
; Line 1229
	*** 0013e3	b8 01 00 		mov	ax,1
	*** 0013e6	ba 4f 03 		mov	dx,847	;034fH
	*** 0013e9	ee 			out	dx, al

;|***   _outp(OBS_BASE+MCR, PAGE0);
; Line 1230
	*** 0013ea	33 c0 			xor	ax,ax
	*** 0013ec	ba 48 03 		mov	dx,840	;0348H
	*** 0013ef	ee 			out	dx, al

;|***   _outp(OBS_BASE+CTCCR, 0x42);                     // set CTC0 to 10 KHz input
; Line 1231
	*** 0013f0	b8 42 00 		mov	ax,66	;0042H
	*** 0013f3	ba 4a 03 		mov	dx,842	;034aH
	*** 0013f6	ee 			out	dx, al

;|***   _outp(OBS_BASE+MCR, PAGE0);                      // access the 82C54's registers
; Line 1232
	*** 0013f7	33 c0 			xor	ax,ax
	*** 0013f9	ba 48 03 		mov	dx,840	;0348H
	*** 0013fc	ee 			out	dx, al

;|***   _outp(OBS_BASE+CCR, CTC0 | LSBMSB | MODE2 | BINARY);// program the 82C54's mode
; Line 1233
	*** 0013fd	b8 34 00 		mov	ax,52	;0034H
	*** 001400	ba 4f 03 		mov	dx,847	;034fH
	*** 001403	ee 			out	dx, al

;|***   _outp(OBS_BASE+12, 0x64);                        // load divisor LSB (100 or 0x0064)
; Line 1234
	*** 001404	b8 64 00 		mov	ax,100	;0064H
	*** 001407	ba 4c 03 		mov	dx,844	;034cH
	*** 00140a	ee 			out	dx, al

;|***   _outp(OBS_BASE+12, 0x00);                        // load divisor MSB
; Line 1235
	*** 00140b	33 c0 			xor	ax,ax
	*** 00140d	ee 			out	dx, al

;|***                                                    // 10 KHz / 100 = 100 Hz frame rate
;|***   old_dmm32a_vect = _dos_getvect(11-8+0x70);       // save old irq11 vector
; Line 1237
	*** 00140e	6a 73 			push	115	;0073H
	*** 001410	9a 00 00 00 00 		call	FAR PTR __dos_getvect
	*** 001415	83 c4 02 		add	sp,2
	*** 001418	a3 00 00 		mov	WORD PTR ?old_dmm32a_vect@@3P7AXXZE,ax	;old_dmm32a_vect
	*** 00141b	89 16 02 00 		mov	WORD PTR ?old_dmm32a_vect@@3P7AXXZE+2,dx	;old_dmm32a_vect
;|***   _dos_setvect(11-8+0x70, isr_dmm32a);             // install dmm32a isr vector
; Line 1238
	*** 00141f	68 00 00 		push	SEG ?isr_dmm32a@@ZAXXZ	;isr_dmm32a
	*** 001422	68 00 00 		push	OFFSET ?isr_dmm32a@@ZAXXZ	;isr_dmm32a
	*** 001425	6a 73 			push	115	;0073H
	*** 001427	9a 00 00 00 00 		call	FAR PTR __dos_setvect
	*** 00142c	83 c4 06 		add	sp,6
;|***   _outp(0xa1, _inp(0xa1) & 0xf7);                  // unmask irq11 at pic
; Line 1239
	*** 00142f	e4 a1 			in	al,161	;00a1H
	*** 001431	25 f7 00 		and	ax,247	;00f7H
	*** 001434	e6 a1 			out	161	;00a1H, al

;|*** 
;|***   _outp(OBS_BASE+ICR, ADINTE | DINTE | TINTE);// enable adc, dio and timer interrupts, old ln200
; Line 1241
	*** 001436	b8 e0 00 		mov	ax,224	;00e0H
	*** 001439	ba 49 03 		mov	dx,841	;0349H
	*** 00143c	ee 			out	dx, al

;|***   //_outp(OBS_BASE+ICR, ADINTE | TINTE);      // enable adc and timer interrupts. old ln200
;|***   _enable();
; Line 1243
	*** 00143d	fb 			sti	
;|***   }
; Line 1244
	*** 00143e	cb 			ret	
	*** 00143f	90 			nop	

?configure_dmm32a@@ZAXXZ	ENDP
	PUBLIC	?trigger_dmm32a@@ZAXXZ	; trigger_dmm32a
?trigger_dmm32a@@ZAXXZ	PROC FAR	; trigger_dmm32a
;|***   
;|*** 
;|*** void trigger_dmm32a(void)  
;|***   {
;|***   while(_inp(OBS_BASE+ARR) & WAIT);        // wait for the adc inputs to settle
; Line 1249
					$FC3847:
	*** 001440	ba 4b 03 		mov	dx,843	;034bH
	*** 001443	ec 			in	al,dx
	*** 001444	a8 80 			test	al,128	;0080H
	*** 001446	75 f8 			jne	$FC3847
;|***   _outp(OBS_BASE, 0);                      // start the scan of the onboard sensors
; Line 1250
	*** 001448	33 c0 			xor	ax,ax
	*** 00144a	ba 40 03 		mov	dx,832	;0340H
	*** 00144d	ee 			out	dx, al

;|***   }
; Line 1251
	*** 00144e	cb 			ret	
	*** 00144f	90 			nop	

?trigger_dmm32a@@ZAXXZ	ENDP
	PUBLIC	?isr_dmm32a@@ZAXXZ	; isr_dmm32a
?isr_dmm32a@@ZAXXZ	PROC FAR	; isr_dmm32a
;|***   
;|***   
;|*** void interrupt isr_dmm32a(void)
;|***   {
; Line 1255
	*** 001450	60 			pusha
	*** 001451	1e 			push	ds
	*** 001452	06 			push	es
	*** 001453	8b ec 			mov	bp,sp
	*** 001455	1e 			push	ds
	*** 001456	b8 00 00 		mov	ax,DGROUP
	*** 001459	8e d8 			mov	ds,ax
	ASSUME DS: DGROUP
	*** 00145b	fc 			cld	
;	register si = i
;	lsb = -4
;	msb = -6
;|***   // the dmm32 A board will generate two types of interrupts:
;|***   // 1) 82C54 ctc0 timeouts, TINT, the 100 Hz frame timer
;|***   // 2) adc scan complete, ADINT, when onboard sensor data is ready
;|***   
;|***   unsigned i;
;|***   unsigned lsb = 0;
;|***   unsigned msb = 0;
;|*** 
;|***   // section 1, a TINT has occurred, the 100 Hz ctc0 signals the beginning of a new frame
;|***   if(_inp(OBS_BASE+ISR) & TINT)
; Line 1265
	*** 00145c	ba 49 03 		mov	dx,841	;0349H
	*** 00145f	ec 			in	al,dx
	*** 001460	a8 20 			test	al,32	;0020H
	*** 001462	74 0a 			je	$I3854
;|***     {
;|***     frame++;                                             // update the frame counter
; Line 1267
	*** 001464	83 06 00 00 01 		add	WORD PTR ?frame@@3KE,1	;frame
	*** 001469	83 16 02 00 00 		adc	WORD PTR ?frame@@3KE+2,0	;frame
;|***     }
;|***   
;|***   // section 2, an ADINT has occurred, the onboard sensor data is ready
;|***   if(_inp(OBS_BASE+ISR) & ADINT)
; Line 1271
					$I3854:
	*** 00146e	ec 			in	al,dx
	*** 00146f	a8 80 			test	al,128	;0080H
	*** 001471	74 5d 			je	$I3855
;|***     {
;|***     time_stamp(&obs_time);
; Line 1273
	*** 001473	68 00 00 		push	SEG ?obs_time@@3UTIMER@@E	;obs_time
	*** 001476	68 00 00 		push	OFFSET ?obs_time@@3UTIMER@@E	;obs_time
	*** 001479	0e 			push	cs
	*** 00147a	e8 00 00 		call	NEAR PTR ?time_stamp@@ZAXPEUTIMER@@@Z	; time_stamp
	*** 00147d	83 c4 04 		add	sp,4
;|***     for(i=0; i<32; i++) obs_array[i] = _inpw(OBS_BASE);  // read the data from the dmm32a fifo
; Line 1274
	*** 001480	33 f6 			xor	si,si
					$F3856:
	*** 001482	ba 40 03 		mov	dx,832	;0340H
	*** 001485	ed 			in	ax,dx
	*** 001486	8b de 			mov	bx,si
	*** 001488	89 80 00 00 		mov	WORD PTR ?obs_array@@3QIII[bx][si],ax	;obs_array
	*** 00148c	46 			inc	si
	*** 00148d	83 fe 20 		cmp	si,32	;0020H
	*** 001490	72 f0 			jb	$F3856
;|***     _fmemcpy(obs_buffer, obs_array, sizeof(obs_array));  // buffer the data
; Line 1275
	*** 001492	bf 00 00 		mov	di,OFFSET DGROUP:?obs_buffer@@3QIEI	;obs_buffer
	*** 001495	be 00 00 		mov	si,OFFSET DGROUP:?obs_array@@3QIII	;obs_array
	*** 001498	8c d8 			mov	ax,ds
	*** 00149a	8e c0 			mov	es,ax
	*** 00149c	b9 20 00 		mov	cx,32	;0020H
	*** 00149f	f3 			rep
	*** 0014a0	a5 			movsw
;|***     obs_new_data = 1;                                    // flag the system new data available
; Line 1276
	*** 0014a1	c7 06 00 00 01 00 	mov	WORD PTR ?obs_new_data@@3IE,1	;obs_new_data
;|***     obs_data_frame = frame;                              // record the frame number
; Line 1277
	*** 0014a7	a1 00 00 		mov	ax,WORD PTR ?frame@@3KE	;frame
	*** 0014aa	8b 16 02 00 		mov	dx,WORD PTR ?frame@@3KE+2	;frame
	*** 0014ae	a3 00 00 		mov	WORD PTR ?obs_data_frame@@3KE,ax	;obs_data_frame
	*** 0014b1	89 16 02 00 		mov	WORD PTR ?obs_data_frame@@3KE+2,dx	;obs_data_frame
;|***         
;|***     _outp(OBS_BASE+FCR, FIFORST);                       // reset the fifo
; Line 1279
	*** 0014b5	b8 02 00 		mov	ax,2
	*** 0014b8	ba 47 03 		mov	dx,839	;0347H
	*** 0014bb	ee 			out	dx, al

;|***     _outp(OBS_BASE+LCR,  0);                            // reset the range of channels to scan
; Line 1280
	*** 0014bc	33 c0 			xor	ax,ax
	*** 0014be	ba 42 03 		mov	dx,834	;0342H
	*** 0014c1	ee 			out	dx, al

;|***     _outp(OBS_BASE+HCR,  31);
; Line 1281
	*** 0014c2	b8 1f 00 		mov	ax,31	;001fH
	*** 0014c5	ba 43 03 		mov	dx,835	;0343H
	*** 0014c8	ee 			out	dx, al

;|***     _outp(OBS_BASE+FCR, SCANEN);                           // enable scan interrupts
; Line 1282
	*** 0014c9	b8 04 00 		mov	ax,4
	*** 0014cc	ba 47 03 		mov	dx,839	;0347H
	*** 0014cf	ee 			out	dx, al

;|***     }
;|***     
;|***   if(_inp(OBS_BASE+ISR) & DINT)        // a pulse was detected at dio LATCH  input
; Line 1285
					$I3855:
	*** 0014d0	ba 49 03 		mov	dx,841	;0349H
	*** 0014d3	ec 			in	al,dx
	*** 0014d4	a8 40 			test	al,64	;0040H
	*** 0014d6	74 15 			je	$I3859
;|***     {
;|***     query_ln200();
; Line 1287
	*** 0014d8	0e 			push	cs
	*** 0014d9	e8 00 00 		call	NEAR PTR ?query_ln200@@ZAXXZ	; query_ln200
;|***     _outp(OBS_BASE+MCR, PAGE1);       // switch to page 1 for dio access
; Line 1288
	*** 0014dc	b8 01 00 		mov	ax,1
	*** 0014df	ba 48 03 		mov	dx,840	;0348H
	*** 0014e2	ee 			out	dx, al

;|***     _inp(OBS_BASE+PORTA);                // read data at port a and discard, resets ACK output
; Line 1289
	*** 0014e3	ba 4c 03 		mov	dx,844	;034cH
	*** 0014e6	ec 			in	al,dx
;|***     _outp(OBS_BASE+MCR, PAGE0);       // switch back to page 0
; Line 1290
	*** 0014e7	33 c0 			xor	ax,ax
	*** 0014e9	ba 48 03 		mov	dx,840	;0348H
	*** 0014ec	ee 			out	dx, al

;|***     }
;|***   
;|***   _outp(OBS_BASE+MCR, INTRST);                           // reset the dmm32's interrupt circuit    
; Line 1293
					$I3859:
	*** 0014ed	b8 08 00 		mov	ax,8
	*** 0014f0	ba 48 03 		mov	dx,840	;0348H
	*** 0014f3	ee 			out	dx, al

;|*** 
;|***   _outp(0xa0, 0x20);                                     // slave EOI
; Line 1295
	*** 0014f4	b8 20 00 		mov	ax,32	;0020H
	*** 0014f7	e6 a0 			out	160	;00a0H, al

;|***   _outp(0x20, 0x20);                                     // master EOI  
; Line 1296
	*** 0014f9	8b d0 			mov	dx,ax
	*** 0014fb	ee 			out	dx, al

;|***   }
; Line 1297
	*** 0014fc	8b e5 			mov	sp,bp
	*** 0014fe	07 			pop	es
	*** 0014ff	1f 			pop	ds
	ASSUME DS: DGROUP
	*** 001500	61 			popa
	*** 001501	cf 			iret	

?isr_dmm32a@@ZAXXZ	ENDP
	PUBLIC	?configure_dmm32b@@ZAXXZ	; configure_dmm32b
?configure_dmm32b@@ZAXXZ	PROC FAR	; configure_dmm32b
;|***   
;|*** 
;|*** void configure_dmm32b(void)
;|***   {//io = 0x380, irq=12, bottom board, reads the mux boxes and the prop slip ring/dynos
;|***   _disable();
; Line 1302
	*** 001502	fa 			cli	
;|*** 
;|***   _outp(DYNO_BASE+FCR, FIFORST);                         // reset the adc fifo
; Line 1304
	*** 001503	b8 02 00 		mov	ax,2
	*** 001506	ba 87 03 		mov	dx,903	;0387H
	*** 001509	ee 			out	dx, al

;|***   _outp(DYNO_BASE+LCR,  0);                              // set the range of channels to scan
; Line 1305
	*** 00150a	33 c0 			xor	ax,ax
	*** 00150c	ba 82 03 		mov	dx,898	;0382H
	*** 00150f	ee 			out	dx, al

;|***   _outp(DYNO_BASE+HCR,  7);                              // initially set for 8 channels for mux boxes
; Line 1306
	*** 001510	b8 07 00 		mov	ax,7
	*** 001513	ba 83 03 		mov	dx,899	;0383H
	*** 001516	ee 			out	dx, al

;|***   _outp(DYNO_BASE+FCR, SCANEN);                          // enable adc scan interrupts
; Line 1307
	*** 001517	b8 04 00 		mov	ax,4
	*** 00151a	ba 87 03 		mov	dx,903	;0387H
	*** 00151d	ee 			out	dx, al

;|***   _outp(DYNO_BASE+ACR, KHZ200 | BIPOLAR5 | GAIN1);       // 200KHz scans, +-5Volt inputs
; Line 1308
	*** 00151e	b8 30 00 		mov	ax,48	;0030H
	*** 001521	ba 8b 03 		mov	dx,907	;038bH
	*** 001524	ee 			out	dx, al

;|***   while(_inp(DYNO_BASE+ARR) & WAIT);                     // wait for adc inputs to settle
; Line 1309
					$FC3863:
	*** 001525	ec 			in	al,dx
	*** 001526	a8 80 			test	al,128	;0080H
	*** 001528	75 fb 			jne	$FC3863
;|*** 
;|***   _outp(DYNO_BASE+MCR, PAGE1);                           // set the 8255 dio ports for outputs, mode0
; Line 1311
	*** 00152a	b8 01 00 		mov	ax,1
	*** 00152d	ba 88 03 		mov	dx,904	;0388H
	*** 001530	ee 			out	dx, al

;|***   _outp(DYNO_BASE+CCR, 0x80);
; Line 1312
	*** 001531	b8 80 00 		mov	ax,128	;0080H
	*** 001534	ba 8f 03 		mov	dx,911	;038fH
	*** 001537	ee 			out	dx, al

;|***   _outp(DYNO_BASE+MCR, PAGE0);
; Line 1313
	*** 001538	33 c0 			xor	ax,ax
	*** 00153a	ba 88 03 		mov	dx,904	;0388H
	*** 00153d	ee 			out	dx, al

;|*** 
;|***   old_dmm32b_vect = _dos_getvect(12-8+0x70);             // save old irq12 isr vector
; Line 1315
	*** 00153e	6a 74 			push	116	;0074H
	*** 001540	9a 00 00 00 00 		call	FAR PTR __dos_getvect
	*** 001545	83 c4 02 		add	sp,2
	*** 001548	a3 00 00 		mov	WORD PTR ?old_dmm32b_vect@@3P7AXXZE,ax	;old_dmm32b_vect
	*** 00154b	89 16 02 00 		mov	WORD PTR ?old_dmm32b_vect@@3P7AXXZE+2,dx	;old_dmm32b_vect
;|***   _dos_setvect(12-8+0x70, isr_dmm32b);                   // install new isr_dmm32b vector
; Line 1316
	*** 00154f	68 00 00 		push	SEG ?isr_dmm32b@@ZAXXZ	;isr_dmm32b
	*** 001552	68 00 00 		push	OFFSET ?isr_dmm32b@@ZAXXZ	;isr_dmm32b
	*** 001555	6a 74 			push	116	;0074H
	*** 001557	9a 00 00 00 00 		call	FAR PTR __dos_setvect
	*** 00155c	83 c4 06 		add	sp,6
;|***   _outp(0xa1, _inp(0xa1) & 0xef);                        // unmask irq12 at pic
; Line 1317
	*** 00155f	e4 a1 			in	al,161	;00a1H
	*** 001561	25 ef 00 		and	ax,239	;00efH
	*** 001564	e6 a1 			out	161	;00a1H, al

;|*** 
;|***   _outp(DYNO_BASE+CTCCR, _inp(DYNO_BASE+CTCCR) | 0x02);  // set 8254 ctc0 for 10 MHz input
; Line 1319
	*** 001566	ba 8a 03 		mov	dx,906	;038aH
	*** 001569	ec 			in	al,dx
	*** 00156a	0c 02 			or	al,2
	*** 00156c	2a e4 			sub	ah,ah
	*** 00156e	ee 			out	dx, al

;|***   _outp(DYNO_BASE+MCR, PAGE2);                           // set ctc0 for falling edge trigger
; Line 1320
	*** 00156f	b8 02 00 		mov	ax,2
	*** 001572	ba 88 03 		mov	dx,904	;0388H
	*** 001575	ee 			out	dx, al

;|***   _outp(DYNO_BASE+CCR , 1);
; Line 1321
	*** 001576	b8 01 00 		mov	ax,1
	*** 001579	ba 8f 03 		mov	dx,911	;038fH
	*** 00157c	ee 			out	dx, al

;|***   _outp(DYNO_BASE+MCR, PAGE0);
; Line 1322
	*** 00157d	33 c0 			xor	ax,ax
	*** 00157f	ba 88 03 		mov	dx,904	;0388H
	*** 001582	ee 			out	dx, al

;|***   _outp(DYNO_BASE+ICR, ADINTE | TINTE);                  // enable adc & ctc0 timer interrupts
; Line 1323
	*** 001583	b8 a0 00 		mov	ax,160	;00a0H
	*** 001586	ba 89 03 		mov	dx,905	;0389H
	*** 001589	ee 			out	dx, al

;|*** 
;|***   _enable();
; Line 1325
	*** 00158a	fb 			sti	
;|***   }
; Line 1326
	*** 00158b	cb 			ret	

?configure_dmm32b@@ZAXXZ	ENDP
	PUBLIC	?trigger_dmm32b@@ZAXXZ	; trigger_dmm32b
?trigger_dmm32b@@ZAXXZ	PROC FAR	; trigger_dmm32b
;|*** 
;|*** 
;|*** void trigger_dmm32b(void)  
;|***   {                                  // start dmm32b for the entire mux/scan/read routine
;|***   reading_prop = 0;                  // start with mux box scans, not prop scans
;|***   mux_addr = 0;
; Line 1332
	*** 00158c	33 c0 			xor	ax,ax
	*** 00158e	a3 00 00 		mov	WORD PTR ?reading_prop@@3IE,ax	;reading_prop
	*** 001591	a3 00 00 		mov	WORD PTR ?mux_addr@@3IE,ax	;mux_addr
;|*** 
;|***   _disable();                        // initialize the mux address and put it on the wires
; Line 1334
	*** 001594	fa 			cli	
;|***   _outp(DYNO_BASE+MCR, PAGE1);
; Line 1335
	*** 001595	b8 01 00 		mov	ax,1
	*** 001598	ba 88 03 		mov	dx,904	;0388H
	*** 00159b	ee 			out	dx, al

;|***   _outp(DYNO_BASE+PORTA , mux_addr);
; Line 1336
	*** 00159c	33 c0 			xor	ax,ax
	*** 00159e	ba 8c 03 		mov	dx,908	;038cH
	*** 0015a1	ee 			out	dx, al

;|***   _outp(DYNO_BASE+MCR, PAGE0);
; Line 1337
	*** 0015a2	ba 88 03 		mov	dx,904	;0388H
	*** 0015a5	ee 			out	dx, al

;|*** 
;|***   // start a 200 usec settling period for the mux box data 
;|***   // with a 10MHz input to ctc0 and desired delay of 200 usec the divisor = 2000 = 0x07d0
;|***   _outp(DYNO_BASE+15, CTC0 | LSBMSB | MODE0 | BINARY);   // program ctc0
; Line 1341
	*** 0015a6	b8 30 00 		mov	ax,48	;0030H
	*** 0015a9	ba 8f 03 		mov	dx,911	;038fH
	*** 0015ac	ee 			out	dx, al

;|***   _outp(DYNO_BASE+12, 0xd0);                             // load divisor LSB
; Line 1342
	*** 0015ad	b8 d0 00 		mov	ax,208	;00d0H
	*** 0015b0	ba 8c 03 		mov	dx,908	;038cH
	*** 0015b3	ee 			out	dx, al

;|***   _outp(DYNO_BASE+12, 0x07);                             // load divisor MSB
; Line 1343
	*** 0015b4	b8 07 00 		mov	ax,7
	*** 0015b7	ee 			out	dx, al

;|***   _outp(DYNO_BASE+ICR, ADINTE | TINTE);                  // enable adc and timer interrupts
; Line 1344
	*** 0015b8	b8 a0 00 		mov	ax,160	;00a0H
	*** 0015bb	ba 89 03 		mov	dx,905	;0389H
	*** 0015be	ee 			out	dx, al

;|***   _enable();
; Line 1345
	*** 0015bf	fb 			sti	
;|***   // ctc0 will generate a TINT interrupt 200usec from now
;|***   // we will trigger a scan of the mux boards in the dmm32b isr when the TINT interrupt occurs
;|***   }
; Line 1348
	*** 0015c0	cb 			ret	
	*** 0015c1	90 			nop	

?trigger_dmm32b@@ZAXXZ	ENDP
	PUBLIC	?isr_dmm32b@@ZAXXZ	; isr_dmm32b
?isr_dmm32b@@ZAXXZ	PROC FAR	; isr_dmm32b
;|***     
;|*** 
;|*** void interrupt isr_dmm32b(void)
;|***   {
; Line 1352
	*** 0015c2	60 			pusha
	*** 0015c3	1e 			push	ds
	*** 0015c4	06 			push	es
	*** 0015c5	8b ec 			mov	bp,sp
	*** 0015c7	83 ec 04 		sub	sp,4
	*** 0015ca	1e 			push	ds
	*** 0015cb	b8 00 00 		mov	ax,DGROUP
	*** 0015ce	8e d8 			mov	ds,ax
	ASSUME DS: DGROUP
	*** 0015d0	fc 			cld	
;	register bx = i
;	lsb = -4
;	msb = -6
;	prop_pos = -4
;|***   // two modes of operation
;|***   // 1) reading the prop dynos      (no multiplexing)
;|***   // 2) reading the mux boxes dynos (with multiplexing)
;|***   //
;|***   // for each mode there are two types of interrupts
;|***   // a) settling time complete (TINT, 82C54 ctc0 timeouts)
;|***   // b) adc scan complete (ADINT)
;|***   
;|***   unsigned int i;
;|***   unsigned int lsb = 0;
;|***   unsigned int msb = 0;
;|***   long int     prop_pos = 0;
; Line 1364
	*** 0015d1	2b c0 			sub	ax,ax
	*** 0015d3	89 46 fe 		mov	WORD PTR [bp-2],ax
	*** 0015d6	89 46 fc 		mov	WORD PTR [bp-4],ax	;lsb
;|***   
;|***   // mode 1, reading prop dynos
;|***   if(reading_prop)
; Line 1367
	*** 0015d9	39 06 00 00 		cmp	WORD PTR ?reading_prop@@3IE,ax	;reading_prop
	*** 0015dd	75 03 			jne	$JCC5597
	*** 0015df	e9 02 01 		jmp	$I3873
					$JCC5597:
;|***     {
;|***     if(_inp(DYNO_BASE+ISR) & TINT)                        // settling time is complete so 
; Line 1369
	*** 0015e2	ba 89 03 		mov	dx,905	;0389H
	*** 0015e5	ec 			in	al,dx
	*** 0015e6	a8 20 			test	al,32	;0020H
	*** 0015e8	74 16 			je	$I3874
;|***       {                                                   // trigger a scan the prop dynos
;|***       _outp(DYNO_BASE+ICR, ADINTE & ~TINTE);              // disable further timer interrupts
; Line 1371
	*** 0015ea	b8 80 00 		mov	ax,128	;0080H
	*** 0015ed	ee 			out	dx, al

;|***       _outp(DYNO_BASE+FCR, _inp(DYNO_BASE+FCR) | FIFORST);// reset the fifo
; Line 1372
	*** 0015ee	ba 87 03 		mov	dx,903	;0387H
	*** 0015f1	ec 			in	al,dx
	*** 0015f2	0c 02 			or	al,2
	*** 0015f4	ee 			out	dx, al

;|***       while(_inp(DYNO_BASE+ARR) & WAIT);                  // ensure the adc is ready      
; Line 1373
					$FC3876:
	*** 0015f5	ba 8b 03 		mov	dx,907	;038bH
	*** 0015f8	ec 			in	al,dx
	*** 0015f9	a8 80 			test	al,128	;0080H
	*** 0015fb	75 f8 			jne	$FC3876
	*** 0015fd	e9 f8 00 		jmp	$L4263
					$I3874:
;|***       _outp(DYNO_BASE, 0);                                // trigger the scan
;|***       // we will read the prop dyno adc's when an ADINT interrupt occurs about 30 usec from now
;|***       }
;|***     else                                                  // not a TINT, must be an ADINT
;|***       {                                                   
;|***       if(_inp(DYNO_BASE+ISR) & ADINT)                     // time to read the prop data
; Line 1379
	*** 001600	ec 			in	al,dx
	*** 001601	a8 80 			test	al,128	;0080H
	*** 001603	75 03 			jne	$JCC5635
	*** 001605	e9 b3 01 		jmp	$I3884
					$JCC5635:
;|***         {
;|***         time_stamp(&prop_adc_time);
; Line 1381
	*** 001608	68 00 00 		push	SEG ?prop_adc_time@@3UTIMER@@E	;prop_adc_time
	*** 00160b	68 00 00 		push	OFFSET ?prop_adc_time@@3UTIMER@@E	;prop_adc_time
	*** 00160e	0e 			push	cs
	*** 00160f	e8 00 00 		call	NEAR PTR ?time_stamp@@ZAXPEUTIMER@@@Z	; time_stamp
	*** 001612	83 c4 04 		add	sp,4
;|***         if(te5650IsCapture()==1)
; Line 1382
	*** 001615	9a 00 00 00 00 		call	FAR PTR _te5650IsCapture
	*** 00161a	48 			dec	ax
	*** 00161b	75 0c 			jne	$I3880
;|***           {
;|***           te5650CapturePos(&prop_index); // get prop index
; Line 1384
	*** 00161d	1e 			push	ds
	*** 00161e	68 00 00 		push	OFFSET DGROUP:?prop_index@@3JE	;prop_index
	*** 001621	9a 00 00 00 00 		call	FAR PTR _te5650CapturePos
	*** 001626	83 c4 04 		add	sp,4
;|***           }
;|***         te5650ActPos(&prop_pos);                             // get prop position
; Line 1386
					$I3880:
	*** 001629	8d 46 fc 		lea	ax,WORD PTR [bp-4]	;lsb
	*** 00162c	16 			push	ss
	*** 00162d	50 			push	ax
	*** 00162e	9a 00 00 00 00 		call	FAR PTR _te5650ActPos
	*** 001633	83 c4 04 		add	sp,4
;|***         prop_report = prop_pos;
; Line 1387
	*** 001636	8b 46 fc 		mov	ax,WORD PTR [bp-4]	;lsb
	*** 001639	8b 56 fe 		mov	dx,WORD PTR [bp-2]
	*** 00163c	a3 00 00 		mov	WORD PTR ?prop_report@@3JE,ax	;prop_report
	*** 00163f	89 16 02 00 		mov	WORD PTR ?prop_report@@3JE+2,dx	;prop_report
;|***         index_report = prop_index;
; Line 1388
	*** 001643	a1 00 00 		mov	ax,WORD PTR ?prop_index@@3JE	;prop_index
	*** 001646	8b 16 02 00 		mov	dx,WORD PTR ?prop_index@@3JE+2	;prop_index
	*** 00164a	a3 00 00 		mov	WORD PTR ?index_report@@3JE,ax	;index_report
	*** 00164d	89 16 02 00 		mov	WORD PTR ?index_report@@3JE+2,dx	;index_report
;|***         time_stamp(&prop_position_time);
; Line 1389
	*** 001651	68 00 00 		push	SEG ?prop_position_time@@3UTIMER@@E	;prop_position_time
	*** 001654	68 00 00 		push	OFFSET ?prop_position_time@@3UTIMER@@E	;prop_position_time
	*** 001657	0e 			push	cs
	*** 001658	e8 00 00 		call	NEAR PTR ?time_stamp@@ZAXPEUTIMER@@@Z	; time_stamp
	*** 00165b	83 c4 04 		add	sp,4
;|***         time_stamp(&prop_rpm_time);
; Line 1390
	*** 00165e	68 00 00 		push	SEG ?prop_rpm_time@@3UTIMER@@E	;prop_rpm_time
	*** 001661	68 00 00 		push	OFFSET ?prop_rpm_time@@3UTIMER@@E	;prop_rpm_time
	*** 001664	0e 			push	cs
	*** 001665	e8 00 00 		call	NEAR PTR ?time_stamp@@ZAXPEUTIMER@@@Z	; time_stamp
	*** 001668	83 c4 04 		add	sp,4
;|***         prop_position_absolute_current = prop_pos;
;|***         prop_position = (prop_pos - prop_index) - 7980;  // 5/13/2005 jtm
; Line 1392
	*** 00166b	8b 46 fc 		mov	ax,WORD PTR [bp-4]	;lsb
	*** 00166e	8b 56 fe 		mov	dx,WORD PTR [bp-2]
	*** 001671	a3 00 00 		mov	WORD PTR ?prop_position_absolute_current@@3JE,ax	;prop_position_absolute_current
	*** 001674	89 16 02 00 		mov	WORD PTR ?prop_position_absolute_current@@3JE+2,dx	;prop_position_absolute_current
	*** 001678	2b 06 00 00 		sub	ax,WORD PTR ?prop_index@@3JE	;prop_index
	*** 00167c	1b 16 02 00 		sbb	dx,WORD PTR ?prop_index@@3JE+2	;prop_index
	*** 001680	2d 2c 1f 		sub	ax,7980	;1f2cH
	*** 001683	83 da 00 		sbb	dx,0
	*** 001686	a3 00 00 		mov	WORD PTR ?prop_position@@3JE,ax	;prop_position
	*** 001689	89 16 02 00 		mov	WORD PTR ?prop_position@@3JE+2,dx	;prop_position
;|***         
;|***         for(i=0; i<6; i++)                                // read and buffer the dyno data  
; Line 1394
	*** 00168d	33 f6 			xor	si,si
					$F3881:
;|***           {
;|***           prop_array[i] = _inpw(DYNO_BASE);
; Line 1396
	*** 00168f	ba 80 03 		mov	dx,896	;0380H
	*** 001692	ed 			in	ax,dx
	*** 001693	8b de 			mov	bx,si
	*** 001695	89 80 00 00 		mov	WORD PTR ?prop_array@@3QIII[bx][si],ax	;prop_array
	*** 001699	46 			inc	si
	*** 00169a	83 fe 06 		cmp	si,6
	*** 00169d	72 f0 			jb	$F3881
;|***           }
;|***         _fmemcpy(prop_buffer, prop_array, sizeof(prop_array));
; Line 1398
	*** 00169f	bf 00 00 		mov	di,OFFSET DGROUP:?prop_buffer@@3QIEI	;prop_buffer
	*** 0016a2	be 00 00 		mov	si,OFFSET DGROUP:?prop_array@@3QIII	;prop_array
	*** 0016a5	8c d8 			mov	ax,ds
	*** 0016a7	8e c0 			mov	es,ax
	*** 0016a9	b9 06 00 		mov	cx,6
	*** 0016ac	f3 			rep
	*** 0016ad	a5 			movsw
;|***                                                                                                 
;|***         prop_new_data = 1;                                // flag new data is available
;|***         prop_data_frame = frame;                          // record the frame number      
; Line 1401
	*** 0016ae	a1 00 00 		mov	ax,WORD PTR ?frame@@3KE	;frame
	*** 0016b1	8b 16 02 00 		mov	dx,WORD PTR ?frame@@3KE+2	;frame
	*** 0016b5	a3 00 00 		mov	WORD PTR ?prop_data_frame@@3KE,ax	;prop_data_frame
	*** 0016b8	89 16 02 00 		mov	WORD PTR ?prop_data_frame@@3KE+2,dx	;prop_data_frame
;|***         
;|***         reading_prop = 0;                                 // set to scan mux boxes next
; Line 1403
	*** 0016bc	c7 06 00 00 00 00 	mov	WORD PTR ?reading_prop@@3IE,0	;reading_prop
;|***         _outp(DYNO_BASE+FCR, _inp(DYNO_BASE+FCR) | FIFORST); // reset the fifo
; Line 1404
	*** 0016c2	ba 87 03 		mov	dx,903	;0387H
	*** 0016c5	ec 			in	al,dx
	*** 0016c6	0c 02 			or	al,2
	*** 0016c8	2a e4 			sub	ah,ah
	*** 0016ca	ee 			out	dx, al

;|***         _outp(DYNO_BASE+LCR,  0);                         // set the range of channels to scan
; Line 1405
	*** 0016cb	33 c0 			xor	ax,ax
	*** 0016cd	ba 82 03 		mov	dx,898	;0382H
	*** 0016d0	ee 			out	dx, al

;|***         _outp(DYNO_BASE+HCR,  7);
; Line 1406
	*** 0016d1	b8 07 00 		mov	ax,7
	*** 0016d4	ba 83 03 		mov	dx,899	;0383H
	*** 0016d7	ee 			out	dx, al

;|***         
;|***         data_ready = 1;
; Line 1408
	*** 0016d8	b8 01 00 		mov	ax,1
	*** 0016db	a3 00 00 		mov	WORD PTR ?prop_new_data@@3IE,ax	;prop_new_data
	*** 0016de	a3 00 00 		mov	WORD PTR ?data_ready@@3IE,ax	;data_ready
;|***         }
;|***       }
;|***     } // end of the prop section
;|***   
;|***   
;|***   // mode 2, reading mux boxes 
;|***   else
; Line 1415
	*** 0016e1	e9 d7 00 		jmp	$I3884
					$I3873:
;|***     {
;|***     if(_inp(DYNO_BASE+ISR) & TINT)                        // the settling time is complete
; Line 1417
	*** 0016e4	ba 89 03 		mov	dx,905	;0389H
	*** 0016e7	ec 			in	al,dx
	*** 0016e8	a8 20 			test	al,32	;0020H
	*** 0016ea	74 14 			je	$I3885
;|***       {                                                   // so start a mux box scan
;|***       _outp(DYNO_BASE+ICR, ADINTE & ~TINTE);              // disable further TINT interrupts
; Line 1419
	*** 0016ec	b8 80 00 		mov	ax,128	;0080H
	*** 0016ef	ee 			out	dx, al

;|***       while(_inp(DYNO_BASE+ARR) & WAIT);                  // wait for adc ready
; Line 1420
					$FC3887:
	*** 0016f0	ba 8b 03 		mov	dx,907	;038bH
	*** 0016f3	ec 			in	al,dx
	*** 0016f4	a8 80 			test	al,128	;0080H
	*** 0016f6	75 f8 			jne	$FC3887
;|***       _outp(DYNO_BASE, 0);                                // trigger the scan
; Line 1421
					$L4263:
	*** 0016f8	33 c0 			xor	ax,ax
	*** 0016fa	ba 80 03 		mov	dx,896	;0380H
	*** 0016fd	e9 ba 00 		jmp	$L4262
					$I3885:
;|***       // we will read the mux box scan about 40 usec from now when an ADINT irq occurs
;|***       }
;|***       
;|***     else                                                  
;|***       {
;|***       if(_inp(DYNO_BASE+ISR) & ADINT)                     // the adc data is ready
; Line 1427
	*** 001700	ec 			in	al,dx
	*** 001701	a8 80 			test	al,128	;0080H
	*** 001703	75 03 			jne	$JCC5891
	*** 001705	e9 b3 00 		jmp	$I3884
					$JCC5891:
;|***         {
;|***         for(i=0; i<8; i++)                                // read the data  
; Line 1429
	*** 001708	33 db 			xor	bx,bx
					$F3891:
;|***           {
;|***           dyno_array[i + (mux_addr*8)] = _inpw(DYNO_BASE);
; Line 1431
	*** 00170a	ba 80 03 		mov	dx,896	;0380H
	*** 00170d	ed 			in	ax,dx
	*** 00170e	8b 36 00 00 		mov	si,WORD PTR ?mux_addr@@3IE	;mux_addr
	*** 001712	c1 e6 03 		shl	si,3
	*** 001715	03 f3 			add	si,bx
	*** 001717	03 f6 			add	si,si
	*** 001719	43 			inc	bx
	*** 00171a	89 84 00 00 		mov	WORD PTR ?dyno_array@@3QIII[si],ax	;dyno_array
	*** 00171e	83 fb 08 		cmp	bx,8
	*** 001721	72 e7 			jb	$F3891
;|***           }
;|***         
;|***         mux_addr++;                                       // set mux address for the next scan
;|***         
;|***         if(mux_addr < 16)                                 // not done scanning all addresses
; Line 1436
	*** 001723	ff 06 00 00 		inc	WORD PTR ?mux_addr@@3IE	;mux_addr
	*** 001727	83 3e 00 00 10 		cmp	WORD PTR ?mux_addr@@3IE,16	;0010H	;mux_addr
	*** 00172c	73 10 			jae	$I3894
;|***           {
;|***           _outp(DYNO_BASE+MCR, PAGE1);                    // put address on the dio port
; Line 1438
	*** 00172e	b8 01 00 		mov	ax,1
	*** 001731	ba 88 03 		mov	dx,904	;0388H
	*** 001734	ee 			out	dx, al

;|***           _outp(DYNO_BASE+PORTA , mux_addr);
; Line 1439
	*** 001735	a1 00 00 		mov	ax,WORD PTR ?mux_addr@@3IE	;mux_addr
	*** 001738	ba 8c 03 		mov	dx,908	;038cH
	*** 00173b	eb 5e 			jmp	SHORT $L4264
	*** 00173d	90 			nop	
					$I3894:
;|***           
;|***           // start another 200 usec settling period
;|***           _outp(DYNO_BASE+MCR, PAGE0);                         // access the 82C54 timer
;|***           _outp(DYNO_BASE+15, CTC0 | LSBMSB | MODE0 | BINARY); // set up ctc0
;|***           _outp(DYNO_BASE+12, 0xd0);                           // divisor LSB (2000 or 0x07d0)
;|***           _outp(DYNO_BASE+12, 0x07);                           // divisor MSB 
;|***           _outp(DYNO_BASE+ICR, ADINTE | TINTE);                // enable adc & timer interrupts
;|***           // we will scan the mux data again when ctc0 generates a TINT irq 200 usec from now
;|***           }
;|***           
;|***         else                                            // all mux addresses have been scanned
;|***           {
;|***           time_stamp(&dyno_time);
; Line 1452
	*** 00173e	68 00 00 		push	SEG ?dyno_time@@3UTIMER@@E	;dyno_time
	*** 001741	68 00 00 		push	OFFSET ?dyno_time@@3UTIMER@@E	;dyno_time
	*** 001744	0e 			push	cs
	*** 001745	e8 00 00 		call	NEAR PTR ?time_stamp@@ZAXPEUTIMER@@@Z	; time_stamp
;|***           
;|***           _fmemcpy(dyno_buffer, dyno_array, sizeof(dyno_array));      // buffer the data
; Line 1454
	*** 001748	bf 00 00 		mov	di,OFFSET DGROUP:?dyno_buffer@@3QIEI	;dyno_buffer
	*** 00174b	be 00 00 		mov	si,OFFSET DGROUP:?dyno_array@@3QIII	;dyno_array
	*** 00174e	8c d8 			mov	ax,ds
	*** 001750	8e c0 			mov	es,ax
	*** 001752	b9 80 00 		mov	cx,128	;0080H
	*** 001755	f3 			rep
	*** 001756	a5 			movsw
;|***           dyno_data_frame = frame;                                    // set system flags
; Line 1455
	*** 001757	a1 00 00 		mov	ax,WORD PTR ?frame@@3KE	;frame
	*** 00175a	8b 16 02 00 		mov	dx,WORD PTR ?frame@@3KE+2	;frame
	*** 00175e	a3 00 00 		mov	WORD PTR ?dyno_data_frame@@3KE,ax	;dyno_data_frame
	*** 001761	89 16 02 00 		mov	WORD PTR ?dyno_data_frame@@3KE+2,dx	;dyno_data_frame
;|***           dyno_new_data = 1;
;|***           
;|***           mux_addr = 0;                                   // reset the mux addess for next frame 
; Line 1458
	*** 001765	c7 06 00 00 00 00 	mov	WORD PTR ?mux_addr@@3IE,0	;mux_addr
;|***           _outp(DYNO_BASE+MCR, PAGE1);
; Line 1459
	*** 00176b	b8 01 00 		mov	ax,1
	*** 00176e	ba 88 03 		mov	dx,904	;0388H
	*** 001771	ee 			out	dx, al

;|***           _outp(DYNO_BASE+PORTA, mux_addr);
; Line 1460
	*** 001772	33 c0 			xor	ax,ax
	*** 001774	ba 8c 03 		mov	dx,908	;038cH
	*** 001777	ee 			out	dx, al

;|***           _outp(DYNO_BASE+MCR, PAGE0);
; Line 1461
	*** 001778	ba 88 03 		mov	dx,904	;0388H
	*** 00177b	ee 			out	dx, al

;|***           
;|***           reading_prop = 1;                                   // do a prop scan next
; Line 1463
	*** 00177c	b9 01 00 		mov	cx,1
	*** 00177f	89 0e 00 00 		mov	WORD PTR ?dyno_new_data@@3IE,cx	;dyno_new_data
	*** 001783	89 0e 00 00 		mov	WORD PTR ?reading_prop@@3IE,cx	;reading_prop
;|***           _outp(DYNO_BASE+FCR, _inp(DYNO_BASE+FCR) | FIFORST);// reset the fifo
; Line 1464
	*** 001787	ba 87 03 		mov	dx,903	;0387H
	*** 00178a	ec 			in	al,dx
	*** 00178b	0c 02 			or	al,2
	*** 00178d	ee 			out	dx, al

;|***           _outp(DYNO_BASE+LCR, 16);                           // set range of prop channels
; Line 1465
	*** 00178e	b8 10 00 		mov	ax,16	;0010H
	*** 001791	ba 82 03 		mov	dx,898	;0382H
	*** 001794	ee 			out	dx, al

;|***           _outp(DYNO_BASE+HCR, 21);
; Line 1466
	*** 001795	b8 15 00 		mov	ax,21	;0015H
	*** 001798	ba 83 03 		mov	dx,899	;0383H
					$L4264:
	*** 00179b	ee 			out	dx, al

;|*** 
;|***           // start another 200 usec settling period
;|***           _outp(DYNO_BASE+MCR, PAGE0);                        // access the 82C54's registers
; Line 1469
	*** 00179c	33 c0 			xor	ax,ax
	*** 00179e	ba 88 03 		mov	dx,904	;0388H
	*** 0017a1	ee 			out	dx, al

;|***           _outp(DYNO_BASE+15, CTC0 | LSBMSB | MODE0 | BINARY);// set up ctc0
; Line 1470
	*** 0017a2	b8 30 00 		mov	ax,48	;0030H
	*** 0017a5	ba 8f 03 		mov	dx,911	;038fH
	*** 0017a8	ee 			out	dx, al

;|***           _outp(DYNO_BASE+12, 0xd0);                          // load divisor LSB (2000 or 0x07d0)
; Line 1471
	*** 0017a9	b8 d0 00 		mov	ax,208	;00d0H
	*** 0017ac	ba 8c 03 		mov	dx,908	;038cH
	*** 0017af	ee 			out	dx, al

;|***           _outp(DYNO_BASE+12, 0x07);                          // load divisor MSB
; Line 1472
	*** 0017b0	b8 07 00 		mov	ax,7
	*** 0017b3	ee 			out	dx, al

;|***           _outp(DYNO_BASE+ICR, ADINTE | TINTE);               // enable adc & timer interrupts
; Line 1473
	*** 0017b4	b8 a0 00 		mov	ax,160	;00a0H
	*** 0017b7	ba 89 03 		mov	dx,905	;0389H
					$L4262:
	*** 0017ba	ee 			out	dx, al

;|***           // we will scan the prop dynos when ctc0 generates a TINT irq 200 usec from now
;|***           }
;|***         }
;|***       }
;|***     } // end mux box section
; Line 1478
					$I3884:
;|*** 
;|***   _outp(DYNO_BASE+MCR, INTRST); // reset the dmm32's interrupt circuit    
; Line 1480
	*** 0017bb	b8 08 00 		mov	ax,8
	*** 0017be	ba 88 03 		mov	dx,904	;0388H
	*** 0017c1	ee 			out	dx, al

;|***   _outp(0xa0, 0x20);            // slave  EOI
; Line 1481
	*** 0017c2	b8 20 00 		mov	ax,32	;0020H
	*** 0017c5	e6 a0 			out	160	;00a0H, al

;|***   _outp(0x20, 0x20);            // master EOI  
; Line 1482
	*** 0017c7	8b d0 			mov	dx,ax
	*** 0017c9	ee 			out	dx, al

;|***   // end dmm32b isr
;|***   }
; Line 1484
	*** 0017ca	8b e5 			mov	sp,bp
	*** 0017cc	07 			pop	es
	*** 0017cd	1f 			pop	ds
	ASSUME DS: DGROUP
	*** 0017ce	61 			popa
	*** 0017cf	cf 			iret	

?isr_dmm32b@@ZAXXZ	ENDP
	PUBLIC	?sys_timer_isr@@ZAXXZ	; sys_timer_isr
?sys_timer_isr@@ZAXXZ	PROC FAR	; sys_timer_isr
;|***   
;|*** 
;|*** void interrupt sys_timer_isr(void) 
;|***   {                                // every pc timer tick (approx 55 msec)
; Line 1488
	*** 0017d0	60 			pusha
	*** 0017d1	1e 			push	ds
	*** 0017d2	06 			push	es
	*** 0017d3	8b ec 			mov	bp,sp
	*** 0017d5	1e 			push	ds
	*** 0017d6	b8 00 00 		mov	ax,DGROUP
	*** 0017d9	8e d8 			mov	ds,ax
	ASSUME DS: DGROUP
	*** 0017db	fc 			cld	
;|***   sys_timer.high++;                // increment the high long word of the obc system timer
; Line 1489
	*** 0017dc	8e 06 00 00 		mov	es,WORD PTR $T4071
	*** 0017e0	26 83 06 00 00 01 	add	WORD PTR es:?sys_timer@@3UTIMER@@E,1	;sys_timer
	*** 0017e6	26 83 16 02 00 00 	adc	WORD PTR es:?sys_timer@@3UTIMER@@E+2,0	;sys_timer
;|***   _chain_intr(rtc_vect);           // chain back into the pc's original rtc isr
; Line 1490
	*** 0017ec	ff 36 02 00 		push	WORD PTR ?rtc_vect@@3P7AXXZE+2	;rtc_vect
	*** 0017f0	ff 36 00 00 		push	WORD PTR ?rtc_vect@@3P7AXXZE	;rtc_vect
	*** 0017f4	9a 00 00 00 00 		call	FAR PTR __chain_intr
;|***   }
; Line 1491
	*** 0017f9	8b e5 			mov	sp,bp
	*** 0017fb	07 			pop	es
	*** 0017fc	1f 			pop	ds
	ASSUME DS: DGROUP
	*** 0017fd	61 			popa
	*** 0017fe	cf 			iret	

?sys_timer_isr@@ZAXXZ	ENDP
	PUBLIC	?terminate@@ZAXXZ	; terminate
?terminate@@ZAXXZ	PROC FAR	; terminate
;|***   
;|*** 
;|*** void terminate(void)
;|***   {
; Line 1495
	*** 0017ff	c8 52 00 00 		enter	82,0
;	s = -82
;|***   char s[81];
;|***   
;|***   _getch();
; Line 1498
	*** 001803	9a 00 00 00 00 		call	FAR PTR __getch
;|***   _disable();
; Line 1499
	*** 001808	fa 			cli	
;|***   shutdown_tech80();
; Line 1500
	*** 001809	0e 			push	cs
	*** 00180a	e8 00 00 		call	NEAR PTR ?shutdown_tech80@@ZAXXZ	; shutdown_tech80
;|***   shutdown_enet();
; Line 1501
	*** 00180d	0e 			push	cs
	*** 00180e	e8 00 00 		call	NEAR PTR ?shutdown_enet@@ZAXXZ	; shutdown_enet
;|***   shutdown_com1();
; Line 1502
	*** 001811	9a 00 00 00 00 		call	FAR PTR ?shutdown_com1@@ZAXXZ	; shutdown_com1
;|***   shutdown_com2();
; Line 1503
	*** 001816	9a 00 00 00 00 		call	FAR PTR ?shutdown_com2@@ZAXXZ	; shutdown_com2
;|***   shutdown_dmm32a();
; Line 1504
	*** 00181b	0e 			push	cs
	*** 00181c	e8 00 00 		call	NEAR PTR ?shutdown_dmm32a@@ZAXXZ	; shutdown_dmm32a
;|***   shutdown_dmm32b();
; Line 1505
	*** 00181f	0e 			push	cs
	*** 001820	e8 00 00 		call	NEAR PTR ?shutdown_dmm32b@@ZAXXZ	; shutdown_dmm32b
;|***   shutdown_escc();
; Line 1506
	*** 001823	0e 			push	cs
	*** 001824	e8 00 00 		call	NEAR PTR ?shutdown_escc@@ZAXXZ	; shutdown_escc
;|***   shutdown_sys_timer();
; Line 1507
	*** 001827	0e 			push	cs
	*** 001828	e8 00 00 		call	NEAR PTR ?shutdown_sys_timer@@ZAXXZ	; shutdown_sys_timer
;|***   _enable();
; Line 1508
	*** 00182b	fb 			sti	
;|***   
;|***   // put the times on screen
;|***         sprintf(s, "%s%8lu %5u%s%8lu", "Frame start:   ",
;|***           frame_time.high, frame_time.low, "    Frame # ", frame);
; Line 1512
	*** 00182c	ff 36 02 00 		push	WORD PTR ?frame@@3KE+2	;frame
	*** 001830	ff 36 00 00 		push	WORD PTR ?frame@@3KE	;frame
	*** 001834	1e 			push	ds
	*** 001835	68 00 00 		push	OFFSET DGROUP:$SG3901
	*** 001838	8e 06 00 00 		mov	es,WORD PTR $T4071
	*** 00183c	26 ff 36 04 00 		push	WORD PTR es:?frame_time@@3UTIMER@@E+4	;frame_time
	*** 001841	26 ff 36 02 00 		push	WORD PTR es:?frame_time@@3UTIMER@@E+2	;frame_time
	*** 001846	26 ff 36 00 00 		push	WORD PTR es:?frame_time@@3UTIMER@@E	;frame_time
	*** 00184b	1e 			push	ds
	*** 00184c	68 00 00 		push	OFFSET DGROUP:$SG3902
	*** 00184f	1e 			push	ds
	*** 001850	68 00 00 		push	OFFSET DGROUP:$SG3903
	*** 001853	8d 46 ae 		lea	ax,WORD PTR [bp-82]	;s
	*** 001856	16 			push	ss
	*** 001857	50 			push	ax
	*** 001858	9a 00 00 00 00 		call	FAR PTR _sprintf
	*** 00185d	83 c4 1a 		add	sp,26	;001aH
;|***         PC_DispStr(0,6, (unsigned char *)s, DISP_FGND_BLACK + DISP_BGND_LIGHT_GRAY);  
; Line 1513
	*** 001860	6a 70 			push	112	;0070H
	*** 001862	8d 46 ae 		lea	ax,WORD PTR [bp-82]	;s
	*** 001865	16 			push	ss
	*** 001866	50 			push	ax
	*** 001867	6a 06 			push	6
	*** 001869	6a 00 			push	0
	*** 00186b	0e 			push	cs
	*** 00186c	e8 00 00 		call	NEAR PTR ?PC_DispStr@@ZAXEEPIEE@Z	; PC_DispStr
	*** 00186f	83 c4 0a 		add	sp,10	;000aH
;|*** 
;|***         sprintf(s, "%s%8lu %5u", "OBS data:      ",
;|***           obs_time.high, obs_time.low);
; Line 1516
	*** 001872	8e 06 00 00 		mov	es,WORD PTR $T4071
	*** 001876	26 ff 36 04 00 		push	WORD PTR es:?obs_time@@3UTIMER@@E+4	;obs_time
	*** 00187b	26 ff 36 02 00 		push	WORD PTR es:?obs_time@@3UTIMER@@E+2	;obs_time
	*** 001880	26 ff 36 00 00 		push	WORD PTR es:?obs_time@@3UTIMER@@E	;obs_time
	*** 001885	1e 			push	ds
	*** 001886	68 00 00 		push	OFFSET DGROUP:$SG3905
	*** 001889	1e 			push	ds
	*** 00188a	68 00 00 		push	OFFSET DGROUP:$SG3906
	*** 00188d	8d 46 ae 		lea	ax,WORD PTR [bp-82]	;s
	*** 001890	16 			push	ss
	*** 001891	50 			push	ax
	*** 001892	9a 00 00 00 00 		call	FAR PTR _sprintf
	*** 001897	83 c4 12 		add	sp,18	;0012H
;|***         PC_DispStr(0,7, (unsigned char *)s, DISP_FGND_BLACK + DISP_BGND_LIGHT_GRAY);
; Line 1517
	*** 00189a	6a 70 			push	112	;0070H
	*** 00189c	8d 46 ae 		lea	ax,WORD PTR [bp-82]	;s
	*** 00189f	16 			push	ss
	*** 0018a0	50 			push	ax
	*** 0018a1	6a 07 			push	7
	*** 0018a3	6a 00 			push	0
	*** 0018a5	0e 			push	cs
	*** 0018a6	e8 00 00 		call	NEAR PTR ?PC_DispStr@@ZAXEEPIEE@Z	; PC_DispStr
	*** 0018a9	83 c4 0a 		add	sp,10	;000aH
;|*** 
;|***         sprintf(s, "%s%8lu %5u", "Dyno data:     ",
;|***           dyno_time.high, dyno_time.low);
; Line 1520
	*** 0018ac	8e 06 00 00 		mov	es,WORD PTR $T4071
	*** 0018b0	26 ff 36 04 00 		push	WORD PTR es:?dyno_time@@3UTIMER@@E+4	;dyno_time
	*** 0018b5	26 ff 36 02 00 		push	WORD PTR es:?dyno_time@@3UTIMER@@E+2	;dyno_time
	*** 0018ba	26 ff 36 00 00 		push	WORD PTR es:?dyno_time@@3UTIMER@@E	;dyno_time
	*** 0018bf	1e 			push	ds
	*** 0018c0	68 00 00 		push	OFFSET DGROUP:$SG3908
	*** 0018c3	1e 			push	ds
	*** 0018c4	68 00 00 		push	OFFSET DGROUP:$SG3909
	*** 0018c7	8d 46 ae 		lea	ax,WORD PTR [bp-82]	;s
	*** 0018ca	16 			push	ss
	*** 0018cb	50 			push	ax
	*** 0018cc	9a 00 00 00 00 		call	FAR PTR _sprintf
	*** 0018d1	83 c4 12 		add	sp,18	;0012H
;|***         PC_DispStr(0,8, (unsigned char *)s, DISP_FGND_BLACK + DISP_BGND_LIGHT_GRAY);
; Line 1521
	*** 0018d4	6a 70 			push	112	;0070H
	*** 0018d6	8d 46 ae 		lea	ax,WORD PTR [bp-82]	;s
	*** 0018d9	16 			push	ss
	*** 0018da	50 			push	ax
	*** 0018db	6a 08 			push	8
	*** 0018dd	6a 00 			push	0
	*** 0018df	0e 			push	cs
	*** 0018e0	e8 00 00 		call	NEAR PTR ?PC_DispStr@@ZAXEEPIEE@Z	; PC_DispStr
	*** 0018e3	83 c4 0a 		add	sp,10	;000aH
;|*** 
;|***         sprintf(s, "%s%8lu %5u", "Prop adc:      ",
;|***           prop_adc_time.high, prop_adc_time.low);
; Line 1524
	*** 0018e6	8e 06 00 00 		mov	es,WORD PTR $T4071
	*** 0018ea	26 ff 36 04 00 		push	WORD PTR es:?prop_adc_time@@3UTIMER@@E+4	;prop_adc_time
	*** 0018ef	26 ff 36 02 00 		push	WORD PTR es:?prop_adc_time@@3UTIMER@@E+2	;prop_adc_time
	*** 0018f4	26 ff 36 00 00 		push	WORD PTR es:?prop_adc_time@@3UTIMER@@E	;prop_adc_time
	*** 0018f9	1e 			push	ds
	*** 0018fa	68 00 00 		push	OFFSET DGROUP:$SG3911
	*** 0018fd	1e 			push	ds
	*** 0018fe	68 00 00 		push	OFFSET DGROUP:$SG3912
	*** 001901	8d 46 ae 		lea	ax,WORD PTR [bp-82]	;s
	*** 001904	16 			push	ss
	*** 001905	50 			push	ax
	*** 001906	9a 00 00 00 00 		call	FAR PTR _sprintf
	*** 00190b	83 c4 12 		add	sp,18	;0012H
;|***         PC_DispStr(0,9, (unsigned char *)s, DISP_FGND_BLACK + DISP_BGND_LIGHT_GRAY);
; Line 1525
	*** 00190e	6a 70 			push	112	;0070H
	*** 001910	8d 46 ae 		lea	ax,WORD PTR [bp-82]	;s
	*** 001913	16 			push	ss
	*** 001914	50 			push	ax
	*** 001915	6a 09 			push	9
	*** 001917	6a 00 			push	0
	*** 001919	0e 			push	cs
	*** 00191a	e8 00 00 		call	NEAR PTR ?PC_DispStr@@ZAXEEPIEE@Z	; PC_DispStr
	*** 00191d	83 c4 0a 		add	sp,10	;000aH
;|*** 
;|***         sprintf(s, "%s%8lu %5u", "Prop position: ",
;|***           prop_position_time.high, prop_position_time.low);
; Line 1528
	*** 001920	8e 06 00 00 		mov	es,WORD PTR $T4071
	*** 001924	26 ff 36 04 00 		push	WORD PTR es:?prop_position_time@@3UTIMER@@E+4	;prop_position_time
	*** 001929	26 ff 36 02 00 		push	WORD PTR es:?prop_position_time@@3UTIMER@@E+2	;prop_position_time
	*** 00192e	26 ff 36 00 00 		push	WORD PTR es:?prop_position_time@@3UTIMER@@E	;prop_position_time
	*** 001933	1e 			push	ds
	*** 001934	68 00 00 		push	OFFSET DGROUP:$SG3914
	*** 001937	1e 			push	ds
	*** 001938	68 00 00 		push	OFFSET DGROUP:$SG3915
	*** 00193b	8d 46 ae 		lea	ax,WORD PTR [bp-82]	;s
	*** 00193e	16 			push	ss
	*** 00193f	50 			push	ax
	*** 001940	9a 00 00 00 00 		call	FAR PTR _sprintf
	*** 001945	83 c4 12 		add	sp,18	;0012H
;|***         PC_DispStr(0,10, (unsigned char *)s, DISP_FGND_BLACK + DISP_BGND_LIGHT_GRAY);
; Line 1529
	*** 001948	6a 70 			push	112	;0070H
	*** 00194a	8d 46 ae 		lea	ax,WORD PTR [bp-82]	;s
	*** 00194d	16 			push	ss
	*** 00194e	50 			push	ax
	*** 00194f	6a 0a 			push	10	;000aH
	*** 001951	6a 00 			push	0
	*** 001953	0e 			push	cs
	*** 001954	e8 00 00 		call	NEAR PTR ?PC_DispStr@@ZAXEEPIEE@Z	; PC_DispStr
	*** 001957	83 c4 0a 		add	sp,10	;000aH
;|*** 
;|***         sprintf(s, "%s%8lu %5u", "Commands rcvd: ",
;|***           cmds_time.high, cmds_time.low);
; Line 1532
	*** 00195a	8e 06 00 00 		mov	es,WORD PTR $T4071
	*** 00195e	26 ff 36 04 00 		push	WORD PTR es:?cmds_time@@3UTIMER@@E+4	;cmds_time
	*** 001963	26 ff 36 02 00 		push	WORD PTR es:?cmds_time@@3UTIMER@@E+2	;cmds_time
	*** 001968	26 ff 36 00 00 		push	WORD PTR es:?cmds_time@@3UTIMER@@E	;cmds_time
	*** 00196d	1e 			push	ds
	*** 00196e	68 00 00 		push	OFFSET DGROUP:$SG3917
	*** 001971	1e 			push	ds
	*** 001972	68 00 00 		push	OFFSET DGROUP:$SG3918
	*** 001975	8d 46 ae 		lea	ax,WORD PTR [bp-82]	;s
	*** 001978	16 			push	ss
	*** 001979	50 			push	ax
	*** 00197a	9a 00 00 00 00 		call	FAR PTR _sprintf
	*** 00197f	83 c4 12 		add	sp,18	;0012H
;|***         PC_DispStr(0,11, (unsigned char *)s, DISP_FGND_BLACK + DISP_BGND_LIGHT_GRAY);
; Line 1533
	*** 001982	6a 70 			push	112	;0070H
	*** 001984	8d 46 ae 		lea	ax,WORD PTR [bp-82]	;s
	*** 001987	16 			push	ss
	*** 001988	50 			push	ax
	*** 001989	6a 0b 			push	11	;000bH
	*** 00198b	6a 00 			push	0
	*** 00198d	0e 			push	cs
	*** 00198e	e8 00 00 		call	NEAR PTR ?PC_DispStr@@ZAXEEPIEE@Z	; PC_DispStr
	*** 001991	83 c4 0a 		add	sp,10	;000aH
;|*** 
;|***         sprintf(s, "%s%8lu %5u", "ADCP rcvd:     ",
;|***           adcp_time.high, adcp_time.low);
; Line 1536
	*** 001994	8e 06 00 00 		mov	es,WORD PTR $T4071
	*** 001998	26 ff 36 04 00 		push	WORD PTR es:?adcp_time@@3UTIMER@@E+4	;adcp_time
	*** 00199d	26 ff 36 02 00 		push	WORD PTR es:?adcp_time@@3UTIMER@@E+2	;adcp_time
	*** 0019a2	26 ff 36 00 00 		push	WORD PTR es:?adcp_time@@3UTIMER@@E	;adcp_time
	*** 0019a7	1e 			push	ds
	*** 0019a8	68 00 00 		push	OFFSET DGROUP:$SG3920
	*** 0019ab	1e 			push	ds
	*** 0019ac	68 00 00 		push	OFFSET DGROUP:$SG3921
	*** 0019af	8d 46 ae 		lea	ax,WORD PTR [bp-82]	;s
	*** 0019b2	16 			push	ss
	*** 0019b3	50 			push	ax
	*** 0019b4	9a 00 00 00 00 		call	FAR PTR _sprintf
	*** 0019b9	83 c4 12 		add	sp,18	;0012H
;|***         PC_DispStr(0,12, (unsigned char *)s, DISP_FGND_BLACK + DISP_BGND_LIGHT_GRAY);
; Line 1537
	*** 0019bc	6a 70 			push	112	;0070H
	*** 0019be	8d 46 ae 		lea	ax,WORD PTR [bp-82]	;s
	*** 0019c1	16 			push	ss
	*** 0019c2	50 			push	ax
	*** 0019c3	6a 0c 			push	12	;000cH
	*** 0019c5	6a 00 			push	0
	*** 0019c7	0e 			push	cs
	*** 0019c8	e8 00 00 		call	NEAR PTR ?PC_DispStr@@ZAXEEPIEE@Z	; PC_DispStr
	*** 0019cb	83 c4 0a 		add	sp,10	;000aH
;|*** 
;|***         sprintf(s, "%s%8lu %5u", "DS rcvd:       ",
;|***           ds_time.high, ds_time.low);
; Line 1540
	*** 0019ce	8e 06 00 00 		mov	es,WORD PTR $T4071
	*** 0019d2	26 ff 36 04 00 		push	WORD PTR es:?ds_time@@3UTIMER@@E+4	;ds_time
	*** 0019d7	26 ff 36 02 00 		push	WORD PTR es:?ds_time@@3UTIMER@@E+2	;ds_time
	*** 0019dc	26 ff 36 00 00 		push	WORD PTR es:?ds_time@@3UTIMER@@E	;ds_time
	*** 0019e1	1e 			push	ds
	*** 0019e2	68 00 00 		push	OFFSET DGROUP:$SG3923
	*** 0019e5	1e 			push	ds
	*** 0019e6	68 00 00 		push	OFFSET DGROUP:$SG3924
	*** 0019e9	8d 46 ae 		lea	ax,WORD PTR [bp-82]	;s
	*** 0019ec	16 			push	ss
	*** 0019ed	50 			push	ax
	*** 0019ee	9a 00 00 00 00 		call	FAR PTR _sprintf
	*** 0019f3	83 c4 12 		add	sp,18	;0012H
;|***         PC_DispStr(0,13, (unsigned char *)s, DISP_FGND_BLACK + DISP_BGND_LIGHT_GRAY);
; Line 1541
	*** 0019f6	6a 70 			push	112	;0070H
	*** 0019f8	8d 46 ae 		lea	ax,WORD PTR [bp-82]	;s
	*** 0019fb	16 			push	ss
	*** 0019fc	50 			push	ax
	*** 0019fd	6a 0d 			push	13	;000dH
	*** 0019ff	6a 00 			push	0
	*** 001a01	0e 			push	cs
	*** 001a02	e8 00 00 		call	NEAR PTR ?PC_DispStr@@ZAXEEPIEE@Z	; PC_DispStr
	*** 001a05	83 c4 0a 		add	sp,10	;000aH
;|***         
;|***         sprintf(s, "%s%8lu %5u%s%8lu ", "LN200 rcvd:    ",
;|***           ln200_time.high, ln200_time.low, "    LN200 # ", ln200_rx_num);
; Line 1544
	*** 001a08	ff 36 02 00 		push	WORD PTR ?ln200_rx_num@@3KE+2	;ln200_rx_num
	*** 001a0c	ff 36 00 00 		push	WORD PTR ?ln200_rx_num@@3KE	;ln200_rx_num
	*** 001a10	1e 			push	ds
	*** 001a11	68 00 00 		push	OFFSET DGROUP:$SG3926
	*** 001a14	8e 06 00 00 		mov	es,WORD PTR $T4071
	*** 001a18	26 ff 36 04 00 		push	WORD PTR es:?ln200_time@@3UTIMER@@E+4	;ln200_time
	*** 001a1d	26 ff 36 02 00 		push	WORD PTR es:?ln200_time@@3UTIMER@@E+2	;ln200_time
	*** 001a22	26 ff 36 00 00 		push	WORD PTR es:?ln200_time@@3UTIMER@@E	;ln200_time
	*** 001a27	1e 			push	ds
	*** 001a28	68 00 00 		push	OFFSET DGROUP:$SG3927
	*** 001a2b	1e 			push	ds
	*** 001a2c	68 00 00 		push	OFFSET DGROUP:$SG3928
	*** 001a2f	8d 46 ae 		lea	ax,WORD PTR [bp-82]	;s
	*** 001a32	16 			push	ss
	*** 001a33	50 			push	ax
	*** 001a34	9a 00 00 00 00 		call	FAR PTR _sprintf
	*** 001a39	83 c4 1a 		add	sp,26	;001aH
;|***         PC_DispStr(0,14, (unsigned char *)s, DISP_FGND_BLACK + DISP_BGND_LIGHT_GRAY);
; Line 1545
	*** 001a3c	6a 70 			push	112	;0070H
	*** 001a3e	8d 46 ae 		lea	ax,WORD PTR [bp-82]	;s
	*** 001a41	16 			push	ss
	*** 001a42	50 			push	ax
	*** 001a43	6a 0e 			push	14	;000eH
	*** 001a45	6a 00 			push	0
	*** 001a47	0e 			push	cs
	*** 001a48	e8 00 00 		call	NEAR PTR ?PC_DispStr@@ZAXEEPIEE@Z	; PC_DispStr
	*** 001a4b	83 c4 0a 		add	sp,10	;000aH
;|***         
;|***         sprintf(s, "%s%lu", "Received packets: ", packets_rcvd);          
; Line 1547
	*** 001a4e	ff 36 02 00 		push	WORD PTR ?packets_rcvd@@3KE+2	;packets_rcvd
	*** 001a52	ff 36 00 00 		push	WORD PTR ?packets_rcvd@@3KE	;packets_rcvd
	*** 001a56	1e 			push	ds
	*** 001a57	68 00 00 		push	OFFSET DGROUP:$SG3930
	*** 001a5a	1e 			push	ds
	*** 001a5b	68 00 00 		push	OFFSET DGROUP:$SG3931
	*** 001a5e	8d 46 ae 		lea	ax,WORD PTR [bp-82]	;s
	*** 001a61	16 			push	ss
	*** 001a62	50 			push	ax
	*** 001a63	9a 00 00 00 00 		call	FAR PTR _sprintf
	*** 001a68	83 c4 10 		add	sp,16	;0010H
;|***         PC_DispStr(0,15, (unsigned char *)s, DISP_FGND_BLACK + DISP_BGND_LIGHT_GRAY);
; Line 1548
	*** 001a6b	6a 70 			push	112	;0070H
	*** 001a6d	8d 46 ae 		lea	ax,WORD PTR [bp-82]	;s
	*** 001a70	16 			push	ss
	*** 001a71	50 			push	ax
	*** 001a72	6a 0f 			push	15	;000fH
	*** 001a74	6a 00 			push	0
	*** 001a76	0e 			push	cs
	*** 001a77	e8 00 00 		call	NEAR PTR ?PC_DispStr@@ZAXEEPIEE@Z	; PC_DispStr
	*** 001a7a	83 c4 0a 		add	sp,10	;000aH
;|*** 
;|***         sprintf(s, "%s%lu", "Ax0 count:        ", ax0_counter);          
; Line 1550
	*** 001a7d	ff 36 02 00 		push	WORD PTR ?ax0_counter@@3KE+2	;ax0_counter
	*** 001a81	ff 36 00 00 		push	WORD PTR ?ax0_counter@@3KE	;ax0_counter
	*** 001a85	1e 			push	ds
	*** 001a86	68 00 00 		push	OFFSET DGROUP:$SG3933
	*** 001a89	1e 			push	ds
	*** 001a8a	68 00 00 		push	OFFSET DGROUP:$SG3934
	*** 001a8d	8d 46 ae 		lea	ax,WORD PTR [bp-82]	;s
	*** 001a90	16 			push	ss
	*** 001a91	50 			push	ax
	*** 001a92	9a 00 00 00 00 		call	FAR PTR _sprintf
	*** 001a97	83 c4 10 		add	sp,16	;0010H
;|***         PC_DispStr(0,16, (unsigned char *)s, DISP_FGND_BLACK + DISP_BGND_LIGHT_GRAY);
; Line 1551
	*** 001a9a	6a 70 			push	112	;0070H
	*** 001a9c	8d 46 ae 		lea	ax,WORD PTR [bp-82]	;s
	*** 001a9f	16 			push	ss
	*** 001aa0	50 			push	ax
	*** 001aa1	6a 10 			push	16	;0010H
	*** 001aa3	6a 00 			push	0
	*** 001aa5	0e 			push	cs
	*** 001aa6	e8 00 00 		call	NEAR PTR ?PC_DispStr@@ZAXEEPIEE@Z	; PC_DispStr
	*** 001aa9	83 c4 0a 		add	sp,10	;000aH
;|***         
;|***         sprintf(s, "%s%lu", "Ax1 count:        ", ax1_counter);          
; Line 1553
	*** 001aac	ff 36 02 00 		push	WORD PTR ?ax1_counter@@3KE+2	;ax1_counter
	*** 001ab0	ff 36 00 00 		push	WORD PTR ?ax1_counter@@3KE	;ax1_counter
	*** 001ab4	1e 			push	ds
	*** 001ab5	68 00 00 		push	OFFSET DGROUP:$SG3936
	*** 001ab8	1e 			push	ds
	*** 001ab9	68 00 00 		push	OFFSET DGROUP:$SG3937
	*** 001abc	8d 46 ae 		lea	ax,WORD PTR [bp-82]	;s
	*** 001abf	16 			push	ss
	*** 001ac0	50 			push	ax
	*** 001ac1	9a 00 00 00 00 		call	FAR PTR _sprintf
	*** 001ac6	83 c4 10 		add	sp,16	;0010H
;|***         PC_DispStr(0,17, (unsigned char *)s, DISP_FGND_BLACK + DISP_BGND_LIGHT_GRAY);
; Line 1554
	*** 001ac9	6a 70 			push	112	;0070H
	*** 001acb	8d 46 ae 		lea	ax,WORD PTR [bp-82]	;s
	*** 001ace	16 			push	ss
	*** 001acf	50 			push	ax
	*** 001ad0	6a 11 			push	17	;0011H
	*** 001ad2	6a 00 			push	0
	*** 001ad4	0e 			push	cs
	*** 001ad5	e8 00 00 		call	NEAR PTR ?PC_DispStr@@ZAXEEPIEE@Z	; PC_DispStr
	*** 001ad8	83 c4 0a 		add	sp,10	;000aH
;|***         
;|***         sprintf(s, "%s%lu", "Discards:         ", discards);          
; Line 1556
	*** 001adb	ff 36 02 00 		push	WORD PTR ?discards@@3KE+2	;discards
	*** 001adf	ff 36 00 00 		push	WORD PTR ?discards@@3KE	;discards
	*** 001ae3	1e 			push	ds
	*** 001ae4	68 00 00 		push	OFFSET DGROUP:$SG3939
	*** 001ae7	1e 			push	ds
	*** 001ae8	68 00 00 		push	OFFSET DGROUP:$SG3940
	*** 001aeb	8d 46 ae 		lea	ax,WORD PTR [bp-82]	;s
	*** 001aee	16 			push	ss
	*** 001aef	50 			push	ax
	*** 001af0	9a 00 00 00 00 		call	FAR PTR _sprintf
	*** 001af5	83 c4 10 		add	sp,16	;0010H
;|***         PC_DispStr(0,18, (unsigned char *)s, DISP_FGND_BLACK + DISP_BGND_LIGHT_GRAY);
; Line 1557
	*** 001af8	6a 70 			push	112	;0070H
	*** 001afa	8d 46 ae 		lea	ax,WORD PTR [bp-82]	;s
	*** 001afd	16 			push	ss
	*** 001afe	50 			push	ax
	*** 001aff	6a 12 			push	18	;0012H
	*** 001b01	6a 00 			push	0
	*** 001b03	0e 			push	cs
	*** 001b04	e8 00 00 		call	NEAR PTR ?PC_DispStr@@ZAXEEPIEE@Z	; PC_DispStr
	*** 001b07	83 c4 0a 		add	sp,10	;000aH
;|*** 
;|***         sprintf(s, "%s%lu", "Receiver calls:   ", receiver_calls);          
; Line 1559
	*** 001b0a	ff 36 02 00 		push	WORD PTR ?receiver_calls@@3KE+2	;receiver_calls
	*** 001b0e	ff 36 00 00 		push	WORD PTR ?receiver_calls@@3KE	;receiver_calls
	*** 001b12	1e 			push	ds
	*** 001b13	68 00 00 		push	OFFSET DGROUP:$SG3942
	*** 001b16	1e 			push	ds
	*** 001b17	68 00 00 		push	OFFSET DGROUP:$SG3943
	*** 001b1a	8d 46 ae 		lea	ax,WORD PTR [bp-82]	;s
	*** 001b1d	16 			push	ss
	*** 001b1e	50 			push	ax
	*** 001b1f	9a 00 00 00 00 		call	FAR PTR _sprintf
	*** 001b24	83 c4 10 		add	sp,16	;0010H
;|***         PC_DispStr(0,19, (unsigned char *)s, DISP_FGND_BLACK + DISP_BGND_LIGHT_GRAY);
; Line 1560
	*** 001b27	6a 70 			push	112	;0070H
	*** 001b29	8d 46 ae 		lea	ax,WORD PTR [bp-82]	;s
	*** 001b2c	16 			push	ss
	*** 001b2d	50 			push	ax
	*** 001b2e	6a 13 			push	19	;0013H
	*** 001b30	6a 00 			push	0
	*** 001b32	0e 			push	cs
	*** 001b33	e8 00 00 		call	NEAR PTR ?PC_DispStr@@ZAXEEPIEE@Z	; PC_DispStr
;|*** 
;|***   }
; Line 1562
	*** 001b36	c9 			leave	
	*** 001b37	cb 			ret	

?terminate@@ZAXXZ	ENDP
	PUBLIC	?shutdown_sys_timer@@ZAXXZ	; shutdown_sys_timer
?shutdown_sys_timer@@ZAXXZ	PROC FAR	; shutdown_sys_timer
;|*** 
;|*** void shutdown_sys_timer(void)
;|***   {  // restore pc's default system timer isr
;|***   _disable();
; Line 1566
	*** 001b38	fa 			cli	
;|***   _dos_setvect(0x08, rtc_vect);
; Line 1567
	*** 001b39	ff 36 02 00 		push	WORD PTR ?rtc_vect@@3P7AXXZE+2	;rtc_vect
	*** 001b3d	ff 36 00 00 		push	WORD PTR ?rtc_vect@@3P7AXXZE	;rtc_vect
	*** 001b41	6a 08 			push	8
	*** 001b43	9a 00 00 00 00 		call	FAR PTR __dos_setvect
	*** 001b48	83 c4 06 		add	sp,6
;|***   _enable();
; Line 1568
	*** 001b4b	fb 			sti	
;|***   }
; Line 1569
	*** 001b4c	cb 			ret	
	*** 001b4d	90 			nop	

?shutdown_sys_timer@@ZAXXZ	ENDP
	PUBLIC	?shutdown_enet@@ZAXXZ	; shutdown_enet
?shutdown_enet@@ZAXXZ	PROC FAR	; shutdown_enet
;|*** 
;|*** void shutdown_enet(void)
;|***   {
;|*** /*  while(handle > 0)  // use with at/lantic pkt driver
;|***     {
;|***     release_type(handle);
;|***     handle--;
;|***     }
;|***     
;|*** */    
;|***   terminate(handle);  // use with the ne2000 driver
; Line 1580
	*** 001b4e	ff 36 00 00 		push	WORD PTR ?handle@@3HE	;handle
	*** 001b52	9a 00 00 00 00 		call	FAR PTR ?terminate@@ZAHH@Z	; terminate
	*** 001b57	83 c4 02 		add	sp,2
;|***   }    
; Line 1581
	*** 001b5a	cb 			ret	
	*** 001b5b	90 			nop	

?shutdown_enet@@ZAXXZ	ENDP
	PUBLIC	?shutdown_tech80@@ZAXXZ	; shutdown_tech80
?shutdown_tech80@@ZAXXZ	PROC FAR	; shutdown_tech80
;|***   
;|***   
;|*** void shutdown_tech80(void)
;|***   {
;|***   te5650SetMotor(0);
; Line 1586
	*** 001b5c	6a 00 			push	0
	*** 001b5e	9a 00 00 00 00 		call	FAR PTR _te5650SetMotor
	*** 001b63	83 c4 02 		add	sp,2
;|***   }
; Line 1587
	*** 001b66	cb 			ret	
	*** 001b67	90 			nop	

?shutdown_tech80@@ZAXXZ	ENDP
	PUBLIC	?shutdown_dmm32a@@ZAXXZ	; shutdown_dmm32a
?shutdown_dmm32a@@ZAXXZ	PROC FAR	; shutdown_dmm32a
;|*** 
;|*** void shutdown_dmm32a(void)
;|***   {                                           // onboard sensors, irq 11
;|***   _outp(OBS_BASE+ICR, 0x00);                  // disable interrupts on the dmm32
; Line 1591
	*** 001b68	33 c0 			xor	ax,ax
	*** 001b6a	ba 49 03 		mov	dx,841	;0349H
	*** 001b6d	ee 			out	dx, al

;|***   _disable();
; Line 1592
	*** 001b6e	fa 			cli	
;|***   _outp(OBS_BASE+MCR, 0x20);                  // apply dmm32 master reset
; Line 1593
	*** 001b6f	b8 20 00 		mov	ax,32	;0020H
	*** 001b72	ba 48 03 		mov	dx,840	;0348H
	*** 001b75	ee 			out	dx, al

;|***   _outp(0xa1, _inp(0xa1) | ~0xf7);            // mask off irq 11 at the pic
; Line 1594
	*** 001b76	e4 a1 			in	al,161	;00a1H
	*** 001b78	0d 08 ff 		or	ax,-248	;ff08H
	*** 001b7b	e6 a1 			out	161	;00a1H, al

;|***   _dos_setvect(11-8+0x70, old_dmm32a_vect);   // rehook previous irq handler
; Line 1595
	*** 001b7d	ff 36 02 00 		push	WORD PTR ?old_dmm32a_vect@@3P7AXXZE+2	;old_dmm32a_vect
	*** 001b81	ff 36 00 00 		push	WORD PTR ?old_dmm32a_vect@@3P7AXXZE	;old_dmm32a_vect
	*** 001b85	6a 73 			push	115	;0073H
	*** 001b87	9a 00 00 00 00 		call	FAR PTR __dos_setvect
	*** 001b8c	83 c4 06 		add	sp,6
;|***   _enable();
; Line 1596
	*** 001b8f	fb 			sti	
;|***   }
; Line 1597
	*** 001b90	cb 			ret	
	*** 001b91	90 			nop	

?shutdown_dmm32a@@ZAXXZ	ENDP
	PUBLIC	?shutdown_dmm32b@@ZAXXZ	; shutdown_dmm32b
?shutdown_dmm32b@@ZAXXZ	PROC FAR	; shutdown_dmm32b
;|*** 
;|*** 
;|*** void shutdown_dmm32b(void)
;|***   {                                           // dyno, irq 12
;|***   _outp(DYNO_BASE+ICR, 0x00);                 // disable interrupts on the dmm32
; Line 1602
	*** 001b92	33 c0 			xor	ax,ax
	*** 001b94	ba 89 03 		mov	dx,905	;0389H
	*** 001b97	ee 			out	dx, al

;|***   _disable();
; Line 1603
	*** 001b98	fa 			cli	
;|***   _outp(DYNO_BASE+MCR, 0x20);                 // apply dmm32 master reset
; Line 1604
	*** 001b99	b8 20 00 		mov	ax,32	;0020H
	*** 001b9c	ba 88 03 		mov	dx,904	;0388H
	*** 001b9f	ee 			out	dx, al

;|***   _outp(0xa1, _inp(0xa1) | ~0xef);            // mask off irq 12 at the pic
; Line 1605
	*** 001ba0	e4 a1 			in	al,161	;00a1H
	*** 001ba2	0d 10 ff 		or	ax,-240	;ff10H
	*** 001ba5	e6 a1 			out	161	;00a1H, al

;|***   _dos_setvect(12-8+0x70, old_dmm32b_vect);   // rehook previous irq handler
; Line 1606
	*** 001ba7	ff 36 02 00 		push	WORD PTR ?old_dmm32b_vect@@3P7AXXZE+2	;old_dmm32b_vect
	*** 001bab	ff 36 00 00 		push	WORD PTR ?old_dmm32b_vect@@3P7AXXZE	;old_dmm32b_vect
	*** 001baf	6a 74 			push	116	;0074H
	*** 001bb1	9a 00 00 00 00 		call	FAR PTR __dos_setvect
	*** 001bb6	83 c4 06 		add	sp,6
;|***   _enable();
; Line 1607
	*** 001bb9	fb 			sti	
;|***   }
; Line 1608
	*** 001bba	cb 			ret	
	*** 001bbb	90 			nop	

?shutdown_dmm32b@@ZAXXZ	ENDP
	PUBLIC	?shutdown_escc@@ZAXXZ	; shutdown_escc
?shutdown_escc@@ZAXXZ	PROC FAR	; shutdown_escc
;|*** 
;|*** 
;|*** 
;|***   
;|*** void shutdown_escc(void)
;|***   {
;|***   escc1.kill_port(channela);
; Line 1615
	*** 001bbc	ff 36 00 00 		push	WORD PTR ?channela@@3IE	;channela
	*** 001bc0	68 00 00 		push	SEG ?escc1@@3VCescc@@E	;escc1
	*** 001bc3	68 00 00 		push	OFFSET ?escc1@@3VCescc@@E	;escc1
	*** 001bc6	9a 00 00 00 00 		call	FAR PTR ?kill_port@Cescc@@RECII@Z	; Cescc::kill_port
;|***   escc1.kill_port(channelb);
; Line 1616
	*** 001bcb	ff 36 00 00 		push	WORD PTR ?channelb@@3IE	;channelb
	*** 001bcf	68 00 00 		push	SEG ?escc1@@3VCescc@@E	;escc1
	*** 001bd2	68 00 00 		push	OFFSET ?escc1@@3VCescc@@E	;escc1
	*** 001bd5	9a 00 00 00 00 		call	FAR PTR ?kill_port@Cescc@@RECII@Z	; Cescc::kill_port
;|***   }
; Line 1617
	*** 001bda	cb 			ret	
	*** 001bdb	90 			nop	

?shutdown_escc@@ZAXXZ	ENDP
CBA_TEXT      ENDS
CONST      SEGMENT
$T4223	DD	03f172e5ar   ;	.59055102
CONST      ENDS
CBA_TEXT      SEGMENT
	ASSUME	CS: CBA_TEXT
	PUBLIC	?build_packet@@ZAXXZ	; build_packet
?build_packet@@ZAXXZ	PROC FAR	; build_packet
;|***   
;|*** 
;|*** 
;|*** void build_packet(void)
;|***   {
; Line 1622
	*** 001bdc	c8 24 00 00 		enter	36,0
	*** 001be0	57 			push	di
	*** 001be1	56 			push	si
;	prop_delta_time = -48
;	i = -2
;	j = -2
;	value = -6
;	register si = checksum16
;	checksum32 = -6
;	udp_pseudo = -26
;	prop_delta_position = -36
;	prop_delta_time_high = -40
;	prop_delta_time_low = -44
;|***   unsigned i,j,value;
;|***   unsigned checksum16 = 0;
;|***   unsigned long checksum32 = 0;
;|***   unsigned char udp_pseudo[20];
;|***   long prop_delta_position = 0;
;|***   //unsigned long prop_delta_time_high = 0;
;|***   long prop_delta_time_high = 0;
;|***   //unsigned long prop_delta_time_low = 0;
;|***   long prop_delta_time_low = 0;
;|***   unsigned long prop_delta_time = 0;
;|*** 
;|***   _fmemset(data_pkt, 0, sizeof(data_pkt));
; Line 1634
	*** 001be2	33 c0 			xor	ax,ax
	*** 001be4	bb 00 00 		mov	bx,OFFSET DGROUP:?data_pkt@@3QIEI	;data_pkt
	*** 001be7	b9 f5 02 		mov	cx,757	;02f5H
	*** 001bea	8b fb 			mov	di,bx
	*** 001bec	1e 			push	ds
	*** 001bed	07 			pop	es
	*** 001bee	f3 			rep
	*** 001bef	ab 			stosw
;|***   
;|***   _disable();             // turn off other services while we copy data
; Line 1636
	*** 001bf0	fa 			cli	
;|***   
;|***   sys.packet_number++;
; Line 1638
	*** 001bf1	8e 06 00 00 		mov	es,WORD PTR $T4071
	*** 001bf5	26 ff 06 02 00 		inc	WORD PTR es:?sys@@3USYS@@E+2	;sys
;|***   sys.frame = frame - 1;  // previous frame number, not this one
; Line 1639
	*** 001bfa	8b 0e 00 00 		mov	cx,WORD PTR ?frame@@3KE	;frame
	*** 001bfe	8b 16 02 00 		mov	dx,WORD PTR ?frame@@3KE+2	;frame
	*** 001c02	83 e9 01 		sub	cx,1
	*** 001c05	1b d0 			sbb	dx,ax
	*** 001c07	26 89 0e 04 00 		mov	WORD PTR es:?sys@@3USYS@@E+4,cx	;sys
	*** 001c0c	26 89 16 06 00 		mov	WORD PTR es:?sys@@3USYS@@E+6,dx	;sys
;|***   sys.fs_status = 0;
; Line 1640
	*** 001c11	26 a3 08 00 		mov	WORD PTR es:?sys@@3USYS@@E+8,ax	;sys
;|***   sys.fs_status = (read_port(FSHIGH) << 8) | read_port(FSLOW);
; Line 1641
	*** 001c15	6a 03 			push	3
	*** 001c17	9a 00 00 00 00 		call	FAR PTR ?read_port@@ZAIH@Z	; read_port
	*** 001c1c	83 c4 02 		add	sp,2
	*** 001c1f	6a 00 			push	0
	*** 001c21	8b f0 			mov	si,ax
	*** 001c23	9a 00 00 00 00 		call	FAR PTR ?read_port@@ZAIH@Z	; read_port
	*** 001c28	83 c4 02 		add	sp,2
	*** 001c2b	8b ce 			mov	cx,si
	*** 001c2d	8a e9 			mov	ch,cl
	*** 001c2f	2a c9 			sub	cl,cl
	*** 001c31	0b c1 			or	ax,cx
	*** 001c33	8e 06 00 00 		mov	es,WORD PTR $T4071
	*** 001c37	26 a3 08 00 		mov	WORD PTR es:?sys@@3USYS@@E+8,ax	;sys
;|***   sys.op_status = 0;
;|***   sys.time_high = frame_time.high;
; Line 1643
	*** 001c3b	26 a1 00 00 		mov	ax,WORD PTR es:?frame_time@@3UTIMER@@E	;frame_time
	*** 001c3f	26 8b 16 02 00 		mov	dx,WORD PTR es:?frame_time@@3UTIMER@@E+2	;frame_time
	*** 001c44	26 a3 0c 00 		mov	WORD PTR es:?sys@@3USYS@@E+12,ax	;sys
	*** 001c48	26 89 16 0e 00 		mov	WORD PTR es:?sys@@3USYS@@E+14,dx	;sys
;|***   sys.time_low  = frame_time.low;
; Line 1644
	*** 001c4d	26 a1 04 00 		mov	ax,WORD PTR es:?frame_time@@3UTIMER@@E+4	;frame_time
	*** 001c51	26 a3 10 00 		mov	WORD PTR es:?sys@@3USYS@@E+16,ax	;sys
;|***   
;|***   obs.new_data = obs_new_data;
; Line 1646
	*** 001c55	a1 00 00 		mov	ax,WORD PTR ?obs_new_data@@3IE	;obs_new_data
	*** 001c58	26 a3 00 00 		mov	WORD PTR es:?obs@@3UOBS@@E,ax	;obs
;|***   obs_new_data = 0;
;|***   obs.frame = obs_data_frame;
; Line 1648
	*** 001c5c	a1 00 00 		mov	ax,WORD PTR ?obs_data_frame@@3KE	;obs_data_frame
	*** 001c5f	8b 16 02 00 		mov	dx,WORD PTR ?obs_data_frame@@3KE+2	;obs_data_frame
	*** 001c63	26 a3 02 00 		mov	WORD PTR es:?obs@@3UOBS@@E+2,ax	;obs
	*** 001c67	26 89 16 04 00 		mov	WORD PTR es:?obs@@3UOBS@@E+4,dx	;obs
;|***   obs.time_high = obs_time.high;
; Line 1649
	*** 001c6c	26 a1 00 00 		mov	ax,WORD PTR es:?obs_time@@3UTIMER@@E	;obs_time
	*** 001c70	26 8b 16 02 00 		mov	dx,WORD PTR es:?obs_time@@3UTIMER@@E+2	;obs_time
	*** 001c75	26 a3 06 00 		mov	WORD PTR es:?obs@@3UOBS@@E+6,ax	;obs
	*** 001c79	26 89 16 08 00 		mov	WORD PTR es:?obs@@3UOBS@@E+8,dx	;obs
;|***   obs.time_low  = obs_time.low;
; Line 1650
	*** 001c7e	26 a1 04 00 		mov	ax,WORD PTR es:?obs_time@@3UTIMER@@E+4	;obs_time
	*** 001c82	26 a3 0a 00 		mov	WORD PTR es:?obs@@3UOBS@@E+10,ax	;obs
;|***   _fmemcpy(&obs.data, &obs_buffer, sizeof(obs.data));  
; Line 1651
	*** 001c86	bf 0c 00 		mov	di,OFFSET ?obs@@3UOBS@@E+12	;obs
	*** 001c89	be 00 00 		mov	si,OFFSET DGROUP:?obs_buffer@@3QIEI	;obs_buffer
	*** 001c8c	b9 20 00 		mov	cx,32	;0020H
	*** 001c8f	f3 			rep
	*** 001c90	a5 			movsw
;|***   
;|***   dyno.new_data = dyno_new_data;
; Line 1653
	*** 001c91	a1 00 00 		mov	ax,WORD PTR ?dyno_new_data@@3IE	;dyno_new_data
	*** 001c94	26 a3 00 00 		mov	WORD PTR es:?dyno@@3UDYNO@@E,ax	;dyno
;|***   dyno_new_data = 0;
;|***   dyno.frame = dyno_data_frame;
; Line 1655
	*** 001c98	a1 00 00 		mov	ax,WORD PTR ?dyno_data_frame@@3KE	;dyno_data_frame
	*** 001c9b	8b 16 02 00 		mov	dx,WORD PTR ?dyno_data_frame@@3KE+2	;dyno_data_frame
	*** 001c9f	26 a3 02 00 		mov	WORD PTR es:?dyno@@3UDYNO@@E+2,ax	;dyno
	*** 001ca3	26 89 16 04 00 		mov	WORD PTR es:?dyno@@3UDYNO@@E+4,dx	;dyno
;|***   dyno.time_high = dyno_time.high;
; Line 1656
	*** 001ca8	26 a1 00 00 		mov	ax,WORD PTR es:?dyno_time@@3UTIMER@@E	;dyno_time
	*** 001cac	26 8b 16 02 00 		mov	dx,WORD PTR es:?dyno_time@@3UTIMER@@E+2	;dyno_time
	*** 001cb1	26 a3 06 00 		mov	WORD PTR es:?dyno@@3UDYNO@@E+6,ax	;dyno
	*** 001cb5	26 89 16 08 00 		mov	WORD PTR es:?dyno@@3UDYNO@@E+8,dx	;dyno
;|***   dyno.time_low  = dyno_time.low;
; Line 1657
	*** 001cba	26 a1 04 00 		mov	ax,WORD PTR es:?dyno_time@@3UTIMER@@E+4	;dyno_time
	*** 001cbe	26 a3 0a 00 		mov	WORD PTR es:?dyno@@3UDYNO@@E+10,ax	;dyno
;|***   _fmemcpy(&dyno.data, &dyno_buffer, sizeof(dyno.data));  
; Line 1658
	*** 001cc2	bf 0c 00 		mov	di,OFFSET ?dyno@@3UDYNO@@E+12	;dyno
	*** 001cc5	be 00 00 		mov	si,OFFSET DGROUP:?dyno_buffer@@3QIEI	;dyno_buffer
	*** 001cc8	b9 80 00 		mov	cx,128	;0080H
	*** 001ccb	f3 			rep
	*** 001ccc	a5 			movsw
;|***   
;|***   prop.new_data = prop_new_data;
; Line 1660
	*** 001ccd	a1 00 00 		mov	ax,WORD PTR ?prop_new_data@@3IE	;prop_new_data
	*** 001cd0	26 a3 00 00 		mov	WORD PTR es:?prop@@3UPROP@@E,ax	;prop
;|***   prop_new_data = 0;
; Line 1661
	*** 001cd4	33 c0 			xor	ax,ax
	*** 001cd6	26 a3 0a 00 		mov	WORD PTR es:?sys@@3USYS@@E+10,ax	;sys
	*** 001cda	a3 00 00 		mov	WORD PTR ?obs_new_data@@3IE,ax	;obs_new_data
	*** 001cdd	a3 00 00 		mov	WORD PTR ?dyno_new_data@@3IE,ax	;dyno_new_data
	*** 001ce0	a3 00 00 		mov	WORD PTR ?prop_new_data@@3IE,ax	;prop_new_data
;|***   prop.frame = prop_data_frame;
; Line 1662
	*** 001ce3	a1 00 00 		mov	ax,WORD PTR ?prop_data_frame@@3KE	;prop_data_frame
	*** 001ce6	8b 16 02 00 		mov	dx,WORD PTR ?prop_data_frame@@3KE+2	;prop_data_frame
	*** 001cea	26 a3 02 00 		mov	WORD PTR es:?prop@@3UPROP@@E+2,ax	;prop
	*** 001cee	26 89 16 04 00 		mov	WORD PTR es:?prop@@3UPROP@@E+4,dx	;prop
;|***   prop.rpm_time_high = prop_rpm_time.high;
; Line 1663
	*** 001cf3	26 a1 00 00 		mov	ax,WORD PTR es:?prop_rpm_time@@3UTIMER@@E	;prop_rpm_time
	*** 001cf7	26 8b 16 02 00 		mov	dx,WORD PTR es:?prop_rpm_time@@3UTIMER@@E+2	;prop_rpm_time
	*** 001cfc	26 a3 06 00 		mov	WORD PTR es:?prop@@3UPROP@@E+6,ax	;prop
	*** 001d00	26 89 16 08 00 		mov	WORD PTR es:?prop@@3UPROP@@E+8,dx	;prop
;|***   prop.rpm_time_low  = prop_rpm_time.low;
; Line 1664
	*** 001d05	26 a1 04 00 		mov	ax,WORD PTR es:?prop_rpm_time@@3UTIMER@@E+4	;prop_rpm_time
	*** 001d09	26 a3 0a 00 		mov	WORD PTR es:?prop@@3UPROP@@E+10,ax	;prop
;|***   prop.position_time_high = prop_position_time.high;
; Line 1665
	*** 001d0d	26 a1 00 00 		mov	ax,WORD PTR es:?prop_position_time@@3UTIMER@@E	;prop_position_time
	*** 001d11	26 8b 16 02 00 		mov	dx,WORD PTR es:?prop_position_time@@3UTIMER@@E+2	;prop_position_time
	*** 001d16	89 46 e2 		mov	WORD PTR [bp-30],ax
	*** 001d19	89 56 e4 		mov	WORD PTR [bp-28],dx
	*** 001d1c	26 a3 0c 00 		mov	WORD PTR es:?prop@@3UPROP@@E+12,ax	;prop
	*** 001d20	26 89 16 0e 00 		mov	WORD PTR es:?prop@@3UPROP@@E+14,dx	;prop
;|***   prop.position_time_low  = prop_position_time.low;
; Line 1666
	*** 001d25	26 a1 04 00 		mov	ax,WORD PTR es:?prop_position_time@@3UTIMER@@E+4	;prop_position_time
	*** 001d29	89 46 e0 		mov	WORD PTR [bp-32],ax
	*** 001d2c	26 a3 10 00 		mov	WORD PTR es:?prop@@3UPROP@@E+16,ax	;prop
;|***   while(prop_position < 0) prop_position += 10160;  // normalize the prop position
; Line 1667
	*** 001d30	83 3e 02 00 00 		cmp	WORD PTR ?prop_position@@3JE+2,0	;prop_position
	*** 001d35	7d 2c 			jge	$L4212
	*** 001d37	6a 00 			push	0
	*** 001d39	68 b0 27 		push	10160	;27b0H
	*** 001d3c	6a 00 			push	0
	*** 001d3e	68 b0 27 		push	10160	;27b0H
	*** 001d41	b8 af 27 		mov	ax,10159	;27afH
	*** 001d44	99 			cwd	
	*** 001d45	2b 06 00 00 		sub	ax,WORD PTR ?prop_position@@3JE	;prop_position
	*** 001d49	1b 16 02 00 		sbb	dx,WORD PTR ?prop_position@@3JE+2	;prop_position
	*** 001d4d	52 			push	dx
	*** 001d4e	50 			push	ax
	*** 001d4f	9a 00 00 00 00 		call	FAR PTR __aFuldiv
	*** 001d54	52 			push	dx
	*** 001d55	50 			push	ax
	*** 001d56	9a 00 00 00 00 		call	FAR PTR __aFulmul
	*** 001d5b	01 06 00 00 		add	WORD PTR ?prop_position@@3JE,ax	;prop_position
	*** 001d5f	11 16 02 00 		adc	WORD PTR ?prop_position@@3JE+2,dx	;prop_position
					$L4212:
;|***   while(prop_position > 10159) prop_position -= 10160;
; Line 1668
	*** 001d63	83 3e 02 00 00 		cmp	WORD PTR ?prop_position@@3JE+2,0	;prop_position
	*** 001d68	7c 30 			jl	$FB3974
	*** 001d6a	7f 08 			jg	$L4226
	*** 001d6c	81 3e 00 00 af 27 	cmp	WORD PTR ?prop_position@@3JE,10159	;27afH	;prop_position
	*** 001d72	76 26 			jbe	$FB3974
					$L4226:
	*** 001d74	6a ff 			push	-1	;ffffH
	*** 001d76	68 50 d8 		push	-10160	;d850H
	*** 001d79	6a 00 			push	0
	*** 001d7b	68 b0 27 		push	10160	;27b0H
	*** 001d7e	ff 36 02 00 		push	WORD PTR ?prop_position@@3JE+2	;prop_position
	*** 001d82	ff 36 00 00 		push	WORD PTR ?prop_position@@3JE	;prop_position
	*** 001d86	9a 00 00 00 00 		call	FAR PTR __aFuldiv
	*** 001d8b	52 			push	dx
	*** 001d8c	50 			push	ax
	*** 001d8d	9a 00 00 00 00 		call	FAR PTR __aFulmul
	*** 001d92	01 06 00 00 		add	WORD PTR ?prop_position@@3JE,ax	;prop_position
	*** 001d96	11 16 02 00 		adc	WORD PTR ?prop_position@@3JE+2,dx	;prop_position
					$FB3974:
;|***   prop.position = prop_position;
; Line 1669
	*** 001d9a	a1 00 00 		mov	ax,WORD PTR ?prop_position@@3JE	;prop_position
	*** 001d9d	8b 16 02 00 		mov	dx,WORD PTR ?prop_position@@3JE+2	;prop_position
	*** 001da1	8e 06 00 00 		mov	es,WORD PTR $T4071
	*** 001da5	26 a3 1a 00 		mov	WORD PTR es:?prop@@3UPROP@@E+26,ax	;prop
	*** 001da9	26 89 16 1c 00 		mov	WORD PTR es:?prop@@3UPROP@@E+28,dx	;prop
;|***   
;|***   prop_delta_position = prop_position_absolute_current - prop_position_absolute_previous;
;|*** 
;|*** /*
;|***   prop_delta_time_high = prop_position_time.high - prop_position_time_previous.high;
;|***   prop_delta_time_low = prop_position_time.low - prop_position_time_previous.low;
;|***   if(prop_delta_time_low < 0)
;|***     {
;|***     prop_delta_time_high--;
;|***     prop_delta_time_low += 65536;
;|***     }
;|***   prop_delta_time = (65535 * prop_delta_time_high) + prop_delta_time_low;
;|***   
;|***   if(prop_delta_time != 0)
;|***      prop.rpm = (int) (rpm_sf * ((float)prop_delta_position / (float)prop_delta_time));
;|*** */
;|***   
;|***   prop.rpm = (int) ((float)prop_delta_position * 0.590551f);
; Line 1687
	*** 001dae	a1 00 00 		mov	ax,WORD PTR ?prop_position_absolute_current@@3JE	;prop_position_absolute_current
	*** 001db1	8b 16 02 00 		mov	dx,WORD PTR ?prop_position_absolute_current@@3JE+2	;prop_position_absolute_current
	*** 001db5	2b 06 00 00 		sub	ax,WORD PTR ?prop_position_absolute_previous@@3JE	;prop_position_absolute_previous
	*** 001db9	1b 16 02 00 		sbb	dx,WORD PTR ?prop_position_absolute_previous@@3JE+2	;prop_position_absolute_previous
	*** 001dbd	89 56 de 		mov	WORD PTR [bp-34],dx
	*** 001dc0	89 46 dc 		mov	WORD PTR [bp-36],ax	;prop_delta_position
	*** 001dc3	8d 5e dc 		lea	bx,WORD PTR [bp-36]	;prop_delta_position
	*** 001dc6	9a 00 00 00 00 		call	FAR PTR __aFfldl
	*** 001dcb	bb 00 00 		mov	bx,OFFSET DGROUP:$T4223
	*** 001dce	9a 00 00 00 00 		call	FAR PTR __aFfmuls
	*** 001dd3	9a 00 00 00 00 		call	FAR PTR __aFdcvt
	*** 001dd8	9a 00 00 00 00 		call	FAR PTR __aFftol
	*** 001ddd	8e 06 00 00 		mov	es,WORD PTR $T4071
	*** 001de1	26 a3 18 00 		mov	WORD PTR es:?prop@@3UPROP@@E+24,ax	;prop
;|***   
;|***   prop_position_absolute_previous = prop_position_absolute_current;
; Line 1689
	*** 001de5	a1 00 00 		mov	ax,WORD PTR ?prop_position_absolute_current@@3JE	;prop_position_absolute_current
	*** 001de8	8b 16 02 00 		mov	dx,WORD PTR ?prop_position_absolute_current@@3JE+2	;prop_position_absolute_current
	*** 001dec	a3 00 00 		mov	WORD PTR ?prop_position_absolute_previous@@3JE,ax	;prop_position_absolute_previous
	*** 001def	89 16 02 00 		mov	WORD PTR ?prop_position_absolute_previous@@3JE+2,dx	;prop_position_absolute_previous
;|***   prop_position_time_previous.high = prop_position_time.high;
; Line 1690
	*** 001df3	8b 46 e2 		mov	ax,WORD PTR [bp-30]
	*** 001df6	8b 56 e4 		mov	dx,WORD PTR [bp-28]
	*** 001df9	26 a3 00 00 		mov	WORD PTR es:?prop_position_time_previous@@3UTIMER@@E,ax	;prop_position_time_previous
	*** 001dfd	26 89 16 02 00 		mov	WORD PTR es:?prop_position_time_previous@@3UTIMER@@E+2,dx	;prop_position_time_previous
;|***   prop_position_time_previous.low  = prop_position_time.low;
; Line 1691
	*** 001e02	8b 46 e0 		mov	ax,WORD PTR [bp-32]
	*** 001e05	26 a3 04 00 		mov	WORD PTR es:?prop_position_time_previous@@3UTIMER@@E+4,ax	;prop_position_time_previous
;|*** 
;|***   prop.adc_time_high = prop_adc_time.high;
; Line 1693
	*** 001e09	26 a1 00 00 		mov	ax,WORD PTR es:?prop_adc_time@@3UTIMER@@E	;prop_adc_time
	*** 001e0d	26 8b 16 02 00 		mov	dx,WORD PTR es:?prop_adc_time@@3UTIMER@@E+2	;prop_adc_time
	*** 001e12	26 a3 12 00 		mov	WORD PTR es:?prop@@3UPROP@@E+18,ax	;prop
	*** 001e16	26 89 16 14 00 		mov	WORD PTR es:?prop@@3UPROP@@E+20,dx	;prop
;|***   prop.adc_time_low  = prop_adc_time.low;
; Line 1694
	*** 001e1b	26 a1 04 00 		mov	ax,WORD PTR es:?prop_adc_time@@3UTIMER@@E+4	;prop_adc_time
	*** 001e1f	26 a3 16 00 		mov	WORD PTR es:?prop@@3UPROP@@E+22,ax	;prop
;|***   _fmemcpy(&prop.data, &prop_buffer, sizeof(prop.data));  
; Line 1695
	*** 001e23	bf 1e 00 		mov	di,OFFSET ?prop@@3UPROP@@E+30	;prop
	*** 001e26	be 00 00 		mov	si,OFFSET DGROUP:?prop_buffer@@3QIEI	;prop_buffer
	*** 001e29	b9 06 00 		mov	cx,6
	*** 001e2c	f3 			rep
	*** 001e2d	a5 			movsw
;|***   
;|***   ln200.new_data = ln200_new_data;
; Line 1697
	*** 001e2e	a1 00 00 		mov	ax,WORD PTR ?ln200_new_data@@3IE	;ln200_new_data
	*** 001e31	26 a3 00 00 		mov	WORD PTR es:?ln200@@3ULN200@@E,ax	;ln200
;|***   ln200_new_data = 0;
;|***   ln200.frame = ln200_data_frame;
; Line 1699
	*** 001e35	a1 00 00 		mov	ax,WORD PTR ?ln200_data_frame@@3KE	;ln200_data_frame
	*** 001e38	8b 16 02 00 		mov	dx,WORD PTR ?ln200_data_frame@@3KE+2	;ln200_data_frame
	*** 001e3c	26 a3 02 00 		mov	WORD PTR es:?ln200@@3ULN200@@E+2,ax	;ln200
	*** 001e40	26 89 16 04 00 		mov	WORD PTR es:?ln200@@3ULN200@@E+4,dx	;ln200
;|***   ln200.time_high = ln200_time.high;
; Line 1700
	*** 001e45	26 a1 00 00 		mov	ax,WORD PTR es:?ln200_time@@3UTIMER@@E	;ln200_time
	*** 001e49	26 8b 16 02 00 		mov	dx,WORD PTR es:?ln200_time@@3UTIMER@@E+2	;ln200_time
	*** 001e4e	26 a3 06 00 		mov	WORD PTR es:?ln200@@3ULN200@@E+6,ax	;ln200
	*** 001e52	26 89 16 08 00 		mov	WORD PTR es:?ln200@@3ULN200@@E+8,dx	;ln200
;|***   ln200.time_low  = ln200_time.low;
; Line 1701
	*** 001e57	26 a1 04 00 		mov	ax,WORD PTR es:?ln200_time@@3UTIMER@@E+4	;ln200_time
	*** 001e5b	26 a3 0a 00 		mov	WORD PTR es:?ln200@@3ULN200@@E+10,ax	;ln200
;|***   _fmemcpy(&ln200.data, &ln200_buffer, sizeof(ln200.data));  
; Line 1702
	*** 001e5f	bf 0c 00 		mov	di,OFFSET ?ln200@@3ULN200@@E+12	;ln200
	*** 001e62	be 00 00 		mov	si,OFFSET DGROUP:?ln200_buffer@@3QIEI	;ln200_buffer
	*** 001e65	b9 10 00 		mov	cx,16	;0010H
	*** 001e68	f3 			rep
	*** 001e69	a5 			movsw
;|***                                       
;|***   echo.new_data = echo_new_data;
; Line 1704
	*** 001e6a	a1 00 00 		mov	ax,WORD PTR ?echo_new_data@@3IE	;echo_new_data
	*** 001e6d	26 a3 00 00 		mov	WORD PTR es:?echo@@3UECHO@@E,ax	;echo
;|***   echo_new_data = 0;
;|***   echo.frame = echo_data_frame;
; Line 1706
	*** 001e71	a1 00 00 		mov	ax,WORD PTR ?echo_data_frame@@3KE	;echo_data_frame
	*** 001e74	8b 16 02 00 		mov	dx,WORD PTR ?echo_data_frame@@3KE+2	;echo_data_frame
	*** 001e78	26 a3 02 00 		mov	WORD PTR es:?echo@@3UECHO@@E+2,ax	;echo
	*** 001e7c	26 89 16 04 00 		mov	WORD PTR es:?echo@@3UECHO@@E+4,dx	;echo
;|***   echo.time_high = cmds_time.high;
; Line 1707
	*** 001e81	26 a1 00 00 		mov	ax,WORD PTR es:?cmds_time@@3UTIMER@@E	;cmds_time
	*** 001e85	26 8b 16 02 00 		mov	dx,WORD PTR es:?cmds_time@@3UTIMER@@E+2	;cmds_time
	*** 001e8a	26 a3 06 00 		mov	WORD PTR es:?echo@@3UECHO@@E+6,ax	;echo
	*** 001e8e	26 89 16 08 00 		mov	WORD PTR es:?echo@@3UECHO@@E+8,dx	;echo
;|***   echo.time_low  = cmds_time.low;
; Line 1708
	*** 001e93	26 a1 04 00 		mov	ax,WORD PTR es:?cmds_time@@3UTIMER@@E+4	;cmds_time
	*** 001e97	26 a3 0a 00 		mov	WORD PTR es:?echo@@3UECHO@@E+10,ax	;echo
;|***   _fmemcpy(&echo.data, &commands, sizeof(echo.data));  
; Line 1709
	*** 001e9b	b8 00 00 		mov	ax,SEG ?commands@@3UCOMMANDS@@E	;commands
	*** 001e9e	1e 			push	ds
	*** 001e9f	bf 0c 00 		mov	di,OFFSET ?echo@@3UECHO@@E+12	;echo
	*** 001ea2	be 00 00 		mov	si,OFFSET ?commands@@3UCOMMANDS@@E	;commands
	*** 001ea5	8e d8 			mov	ds,ax
	ASSUME DS: SEG ?commands@@3UCOMMANDS@@E
	*** 001ea7	b9 12 00 		mov	cx,18	;0012H
	*** 001eaa	f3 			rep
	*** 001eab	a5 			movsw
	*** 001eac	1f 			pop	ds
	ASSUME DS: DGROUP
;|***   
;|***   ds.new_data = ds_new_data;
; Line 1711
	*** 001ead	a1 00 00 		mov	ax,WORD PTR ?ds_new_data@@3IE	;ds_new_data
	*** 001eb0	26 a3 00 00 		mov	WORD PTR es:?ds@@3UDS@@E,ax	;ds
;|***   ds_new_data = 0;
;|***   ds.frame = ds_data_frame;
; Line 1713
	*** 001eb4	a1 00 00 		mov	ax,WORD PTR ?ds_data_frame@@3KE	;ds_data_frame
	*** 001eb7	8b 16 02 00 		mov	dx,WORD PTR ?ds_data_frame@@3KE+2	;ds_data_frame
	*** 001ebb	26 a3 02 00 		mov	WORD PTR es:?ds@@3UDS@@E+2,ax	;ds
	*** 001ebf	26 89 16 04 00 		mov	WORD PTR es:?ds@@3UDS@@E+4,dx	;ds
;|***   ds.time_high = ds_time.high;
; Line 1714
	*** 001ec4	26 a1 00 00 		mov	ax,WORD PTR es:?ds_time@@3UTIMER@@E	;ds_time
	*** 001ec8	26 8b 16 02 00 		mov	dx,WORD PTR es:?ds_time@@3UTIMER@@E+2	;ds_time
	*** 001ecd	26 a3 06 00 		mov	WORD PTR es:?ds@@3UDS@@E+6,ax	;ds
	*** 001ed1	26 89 16 08 00 		mov	WORD PTR es:?ds@@3UDS@@E+8,dx	;ds
;|***   ds.time_low  = ds_time.low;
; Line 1715
	*** 001ed6	26 a1 04 00 		mov	ax,WORD PTR es:?ds_time@@3UTIMER@@E+4	;ds_time
	*** 001eda	26 a3 0a 00 		mov	WORD PTR es:?ds@@3UDS@@E+10,ax	;ds
;|***   _fmemcpy(&ds.data, &ds_buffer, sizeof(ds.data));  
; Line 1716
	*** 001ede	bf 0c 00 		mov	di,OFFSET ?ds@@3UDS@@E+12	;ds
	*** 001ee1	be 00 00 		mov	si,OFFSET DGROUP:?ds_buffer@@3QIEI	;ds_buffer
	*** 001ee4	b9 28 00 		mov	cx,40	;0028H
	*** 001ee7	f3 			rep
	*** 001ee8	a5 			movsw
;|***   
;|***   adcp.new_data = adcp_new_data;
; Line 1718
	*** 001ee9	a1 00 00 		mov	ax,WORD PTR ?adcp_new_data@@3IE	;adcp_new_data
	*** 001eec	26 a3 00 00 		mov	WORD PTR es:?adcp@@3UADCP@@E,ax	;adcp
;|***   adcp_new_data = 0;
;|***   adcp.frame = adcp_data_frame;
; Line 1720
	*** 001ef0	a1 00 00 		mov	ax,WORD PTR ?adcp_data_frame@@3KE	;adcp_data_frame
	*** 001ef3	8b 16 02 00 		mov	dx,WORD PTR ?adcp_data_frame@@3KE+2	;adcp_data_frame
	*** 001ef7	26 a3 02 00 		mov	WORD PTR es:?adcp@@3UADCP@@E+2,ax	;adcp
	*** 001efb	26 89 16 04 00 		mov	WORD PTR es:?adcp@@3UADCP@@E+4,dx	;adcp
;|***   adcp.time_high = adcp_time.high;
; Line 1721
	*** 001f00	26 a1 00 00 		mov	ax,WORD PTR es:?adcp_time@@3UTIMER@@E	;adcp_time
	*** 001f04	26 8b 16 02 00 		mov	dx,WORD PTR es:?adcp_time@@3UTIMER@@E+2	;adcp_time
	*** 001f09	26 a3 06 00 		mov	WORD PTR es:?adcp@@3UADCP@@E+6,ax	;adcp
	*** 001f0d	26 89 16 08 00 		mov	WORD PTR es:?adcp@@3UADCP@@E+8,dx	;adcp
;|***   adcp.time_low  = adcp_time.low;
; Line 1722
	*** 001f12	26 a1 04 00 		mov	ax,WORD PTR es:?adcp_time@@3UTIMER@@E+4	;adcp_time
	*** 001f16	26 a3 0a 00 		mov	WORD PTR es:?adcp@@3UADCP@@E+10,ax	;adcp
;|***   _fmemcpy(&adcp.data, &adcp_buffer, sizeof(adcp.data));  
; Line 1723
	*** 001f1a	bf 0c 00 		mov	di,OFFSET ?adcp@@3UADCP@@E+12	;adcp
	*** 001f1d	be 00 00 		mov	si,OFFSET DGROUP:?adcp_buffer@@3QIEI	;adcp_buffer
	*** 001f20	b9 6a 00 		mov	cx,106	;006aH
	*** 001f23	f3 			rep
	*** 001f24	a5 			movsw
	*** 001f25	a4 			movsb
;|*** 
;|***   gps.new_data = gps_new_data;
; Line 1725
	*** 001f26	a1 00 00 		mov	ax,WORD PTR ?gps_new_data@@3IE	;gps_new_data
	*** 001f29	26 a3 00 00 		mov	WORD PTR es:?gps@@3UGPS@@E,ax	;gps
;|***   gps_new_data = 0;
; Line 1726
	*** 001f2d	33 c0 			xor	ax,ax
	*** 001f2f	a3 00 00 		mov	WORD PTR ?ln200_new_data@@3IE,ax	;ln200_new_data
	*** 001f32	a3 00 00 		mov	WORD PTR ?echo_new_data@@3IE,ax	;echo_new_data
	*** 001f35	a3 00 00 		mov	WORD PTR ?ds_new_data@@3IE,ax	;ds_new_data
	*** 001f38	a3 00 00 		mov	WORD PTR ?adcp_new_data@@3IE,ax	;adcp_new_data
	*** 001f3b	a3 00 00 		mov	WORD PTR ?gps_new_data@@3IE,ax	;gps_new_data
;|***   gps.frame = gps_data_frame;
; Line 1727
	*** 001f3e	a1 00 00 		mov	ax,WORD PTR ?gps_data_frame@@3KE	;gps_data_frame
	*** 001f41	8b 16 02 00 		mov	dx,WORD PTR ?gps_data_frame@@3KE+2	;gps_data_frame
	*** 001f45	26 a3 02 00 		mov	WORD PTR es:?gps@@3UGPS@@E+2,ax	;gps
	*** 001f49	26 89 16 04 00 		mov	WORD PTR es:?gps@@3UGPS@@E+4,dx	;gps
;|***   gps.time_high = gps_time.high;
; Line 1728
	*** 001f4e	26 a1 00 00 		mov	ax,WORD PTR es:?gps_time@@3UTIMER@@E	;gps_time
	*** 001f52	26 8b 16 02 00 		mov	dx,WORD PTR es:?gps_time@@3UTIMER@@E+2	;gps_time
	*** 001f57	26 a3 06 00 		mov	WORD PTR es:?gps@@3UGPS@@E+6,ax	;gps
	*** 001f5b	26 89 16 08 00 		mov	WORD PTR es:?gps@@3UGPS@@E+8,dx	;gps
;|***   gps.time_low  = gps_time.low;
; Line 1729
	*** 001f60	26 a1 04 00 		mov	ax,WORD PTR es:?gps_time@@3UTIMER@@E+4	;gps_time
	*** 001f64	26 a3 0a 00 		mov	WORD PTR es:?gps@@3UGPS@@E+10,ax	;gps
;|***   _fmemcpy(&gps.data, &gps_buffer, sizeof(gps.data));    
; Line 1730
	*** 001f68	bf 0c 00 		mov	di,OFFSET ?gps@@3UGPS@@E+12	;gps
	*** 001f6b	be 00 00 		mov	si,OFFSET DGROUP:?gps_buffer@@3QIEI	;gps_buffer
	*** 001f6e	b9 28 00 		mov	cx,40	;0028H
	*** 001f71	f3 			rep
	*** 001f72	a5 			movsw
;|***   
;|***   _enable();
; Line 1732
	*** 001f73	fb 			sti	
;|***   
;|***   //_fmemcpy(data_pkt, micron_mac, 6);    // insert destination mac addr;
;|***   //_fmemcpy(data_pkt, control_mac, 6);    // insert destination mac addr;
;|***   _fmemcpy(data_pkt, broadcast_mac, 6);    // insert destination mac addr;
; Line 1736
	*** 001f74	b8 00 00 		mov	ax,OFFSET DGROUP:?data_pkt@@3QIEI	;data_pkt
	*** 001f77	8b f8 			mov	di,ax
	*** 001f79	be 00 00 		mov	si,OFFSET DGROUP:?broadcast_mac@@3QIEI	;broadcast_mac
	*** 001f7c	1e 			push	ds
	*** 001f7d	07 			pop	es
	*** 001f7e	a5 			movsw
	*** 001f7f	a5 			movsw
	*** 001f80	a5 			movsw
;|***   //_fmemcpy(data_pkt, shore_mac, 6);    // insert destination mac addr;
;|***   _fmemcpy(data_pkt+6, obc_mac, 6);     // insert source mac addr
; Line 1738
	*** 001f81	bf 06 00 		mov	di,OFFSET DGROUP:?data_pkt@@3QIEI+6	;data_pkt
	*** 001f84	be 00 00 		mov	si,OFFSET DGROUP:?obc_mac@@3QIEI	;obc_mac
	*** 001f87	8c d8 			mov	ax,ds
	*** 001f89	a5 			movsw
	*** 001f8a	a5 			movsw
	*** 001f8b	a5 			movsw
;|*** 
;|***   // for DIX insert packet type = 0x0800 (ip packet)
;|***   data_pkt[12] = 0x08;
; Line 1741
	*** 001f8c	c6 06 0c 00 08 		mov	BYTE PTR ?data_pkt@@3QIEI+12,8	;data_pkt
;|***   data_pkt[13] = 0x00;
;|*** 
;|***   // insert ip header
;|***   // insert version (4 bit) and header length (4 bit)
;|***   data_pkt[14] = 0x45; // version = 0, hdr len = 5 (ie: 5 x 32-bit words) 69
; Line 1746
	*** 001f91	c6 06 0e 00 45 		mov	BYTE PTR ?data_pkt@@3QIEI+14,69	;0045H	;data_pkt
;|*** 
;|***   // insert type of service (TOS) (8 bit)
;|***   data_pkt[15] = 0;
; Line 1749
	*** 001f96	32 c0 			xor	al,al
	*** 001f98	a2 0d 00 		mov	BYTE PTR ?data_pkt@@3QIEI+13,al	;data_pkt
	*** 001f9b	a2 0f 00 		mov	BYTE PTR ?data_pkt@@3QIEI+15,al	;data_pkt
;|*** 
;|***   // insert total length (16 bit)
;|***   data_pkt[16] = 0x05;  // high byte 1500 bytes to fit in Ethernet data field
; Line 1752
	*** 001f9e	c6 06 10 00 05 		mov	BYTE PTR ?data_pkt@@3QIEI+16,5	;data_pkt
;|***   data_pkt[17] = 0xdc;  // low byte  
; Line 1753
	*** 001fa3	c6 06 11 00 dc 		mov	BYTE PTR ?data_pkt@@3QIEI+17,220	;00dcH	;data_pkt
;|*** 
;|***   // insert id (16 bit)
;|***   data_pkt[18] = high_byte(ip_id); // high byte
; Line 1756
	*** 001fa8	ff 36 00 00 		push	WORD PTR ?ip_id@@3IE	;ip_id
	*** 001fac	0e 			push	cs
	*** 001fad	e8 00 00 		call	NEAR PTR ?high_byte@@ZAEI@Z	; high_byte
	*** 001fb0	83 c4 02 		add	sp,2
	*** 001fb3	a2 12 00 		mov	BYTE PTR ?data_pkt@@3QIEI+18,al	;data_pkt
;|***   data_pkt[19] = low_byte(ip_id);      // low byte
; Line 1757
	*** 001fb6	ff 36 00 00 		push	WORD PTR ?ip_id@@3IE	;ip_id
	*** 001fba	0e 			push	cs
	*** 001fbb	e8 00 00 		call	NEAR PTR ?low_byte@@ZAEI@Z	; low_byte
	*** 001fbe	83 c4 02 		add	sp,2
	*** 001fc1	a2 13 00 		mov	BYTE PTR ?data_pkt@@3QIEI+19,al	;data_pkt
;|***   ip_id++;
; Line 1758
	*** 001fc4	ff 06 00 00 		inc	WORD PTR ?ip_id@@3IE	;ip_id
;|*** 
;|***   // insert flags (3 bit) and fragment offset (13 bit)
;|***   data_pkt[20] = 0;
;|***   data_pkt[21] = 0;
;|*** 
;|***   // insert time to live (TTL) (8 bit)
;|***   data_pkt[22] = 64;
; Line 1765
	*** 001fc8	c6 06 16 00 40 		mov	BYTE PTR ?data_pkt@@3QIEI+22,64	;0040H	;data_pkt
;|*** 
;|***   // insert protocol (8 bit)
;|***   data_pkt[23] = 17;  // UDP = 17
; Line 1768
	*** 001fcd	c6 06 17 00 11 		mov	BYTE PTR ?data_pkt@@3QIEI+23,17	;0011H	;data_pkt
;|*** 
;|***   // insert dummy ip checksum
;|***   data_pkt[24] = 0;
;|***   data_pkt[25] = 0;
; Line 1772
	*** 001fd2	32 c0 			xor	al,al
	*** 001fd4	a2 14 00 		mov	BYTE PTR ?data_pkt@@3QIEI+20,al	;data_pkt
	*** 001fd7	a2 15 00 		mov	BYTE PTR ?data_pkt@@3QIEI+21,al	;data_pkt
	*** 001fda	a2 18 00 		mov	BYTE PTR ?data_pkt@@3QIEI+24,al	;data_pkt
	*** 001fdd	a2 19 00 		mov	BYTE PTR ?data_pkt@@3QIEI+25,al	;data_pkt
;|*** 
;|***   // insert source ip address (32 bit)
;|***   data_pkt[26] = 192;
;|***   data_pkt[27] = 168;
;|***   data_pkt[28] = 1;
;|***   data_pkt[29] = 4;
; Line 1778
	*** 001fe0	c6 06 1d 00 04 		mov	BYTE PTR ?data_pkt@@3QIEI+29,4	;data_pkt
;|*** /*
;|***   // insert destination ip address (32 bit) sam
;|***   data_pkt[30] = 192;
;|***   data_pkt[31] = 168;
;|***   data_pkt[32] = 1;
;|***   data_pkt[33] = 8;
;|*** */
;|*** /*
;|***   // insert destination ip address (32 bit) jim
;|***   data_pkt[30] = 192;
;|***   data_pkt[31] = 168;
;|***   data_pkt[32] = 1;
;|***   data_pkt[33] = 5;
;|*** */
;|*** /*  // insert destination ip address (32 bit) shore
;|***   data_pkt[30] = 192;
;|***   data_pkt[31] = 168;
;|***   data_pkt[32] = 1;
;|***   data_pkt[33] = 30;
;|*** */
;|*** /*
;|***   // insert destination ip address (32 bit) control
;|***   data_pkt[30] = 192;
;|***   data_pkt[31] = 168;
;|***   data_pkt[32] = 1;
;|***   data_pkt[33] = 8;
;|*** */  
;|***   // insert destination ip address (32 bit) broadcast ip
;|***   data_pkt[30] = 192;
; Line 1807
	*** 001fe5	b0 c0 			mov	al,192	;00c0H
	*** 001fe7	a2 1a 00 		mov	BYTE PTR ?data_pkt@@3QIEI+26,al	;data_pkt
	*** 001fea	a2 1e 00 		mov	BYTE PTR ?data_pkt@@3QIEI+30,al	;data_pkt
;|***   data_pkt[31] = 168;
; Line 1808
	*** 001fed	b0 a8 			mov	al,168	;00a8H
	*** 001fef	a2 1b 00 		mov	BYTE PTR ?data_pkt@@3QIEI+27,al	;data_pkt
	*** 001ff2	a2 1f 00 		mov	BYTE PTR ?data_pkt@@3QIEI+31,al	;data_pkt
;|***   data_pkt[32] = 1;
; Line 1809
	*** 001ff5	b0 01 			mov	al,1
	*** 001ff7	a2 1c 00 		mov	BYTE PTR ?data_pkt@@3QIEI+28,al	;data_pkt
	*** 001ffa	a2 20 00 		mov	BYTE PTR ?data_pkt@@3QIEI+32,al	;data_pkt
;|***   data_pkt[33] = 255;
; Line 1810
	*** 001ffd	c6 06 21 00 ff 		mov	BYTE PTR ?data_pkt@@3QIEI+33,255	;00ffH	;data_pkt
;|*** 
;|***   // insert true ip header checksum
;|***   // checksum is the 1's complement of the 16-bit 1's complement sum
;|***   // each pair of 8-bit bytes is first converted to a 16-bit word which
;|***   // must be converted from 2's complement to 1's complememt representation
;|***   checksum32=0;        // use 32-bit to capture the 1's complement carry bit
; Line 1816
	*** 002002	2b c0 			sub	ax,ax
	*** 002004	89 46 fc 		mov	WORD PTR [bp-4],ax
	*** 002007	89 46 fa 		mov	WORD PTR [bp-6],ax	;value
;|***   for(j=14;j<34;)
; Line 1817
	*** 00200a	c7 46 fe 0e 00 		mov	WORD PTR [bp-2],14	;000eH	;i
	*** 00200f	8b 76 fe 		mov	si,WORD PTR [bp-2]	;i
					$FC3978:
;|***     {
;|***     value = (data_pkt[j] << 8) + data_pkt[j+1];  // form next 16-bit word
;|***     //if(value < 0) value -= 1;                    // convert to 1's complement
;|***     checksum32 += value;                         // add it to the checksum and
;|***     if(checksum32 > 0x0000ffff)                  // perform end-around carry
; Line 1822
	*** 002012	8a a4 00 00 		mov	ah,BYTE PTR ?data_pkt@@3QIEI[si]	;data_pkt
	*** 002016	2a c0 			sub	al,al
	*** 002018	8a 8c 01 00 		mov	cl,BYTE PTR ?data_pkt@@3QIEI[si+1]	;data_pkt
	*** 00201c	2a ed 			sub	ch,ch
	*** 00201e	03 c1 			add	ax,cx
	*** 002020	2b d2 			sub	dx,dx
	*** 002022	01 46 fa 		add	WORD PTR [bp-6],ax	;value
	*** 002025	11 56 fc 		adc	WORD PTR [bp-4],dx
	*** 002028	39 56 fc 		cmp	WORD PTR [bp-4],dx
	*** 00202b	74 0e 			je	$I3980
;|***       {                                          // if required
;|***       checksum32 = (checksum32 & 0x0000ffff) + 1;
; Line 1824
	*** 00202d	8b 46 fa 		mov	ax,WORD PTR [bp-6]	;value
	*** 002030	05 01 00 		add	ax,1
	*** 002033	13 d2 			adc	dx,dx
	*** 002035	89 46 fa 		mov	WORD PTR [bp-6],ax	;value
	*** 002038	89 56 fc 		mov	WORD PTR [bp-4],dx
;|***       }
;|***     j = j+2;
; Line 1826
					$I3980:
;|***     }
; Line 1827
	*** 00203b	83 c6 02 		add	si,2
	*** 00203e	83 fe 22 		cmp	si,34	;0022H
	*** 002041	72 cf 			jb	$FC3978
;|***   checksum16 = (unsigned)(checksum32 & 0x0000ffff); // convert back to 16-bit
;|***   checksum16 = ~checksum16;                      // take the 1's complement
;|***   data_pkt[24] = high_byte(checksum16);          // and insert into header
; Line 1830
	*** 002043	8b 46 fa 		mov	ax,WORD PTR [bp-6]	;value
	*** 002046	f7 d0 			not	ax
	*** 002048	50 			push	ax
	*** 002049	8b f0 			mov	si,ax
	*** 00204b	0e 			push	cs
	*** 00204c	e8 00 00 		call	NEAR PTR ?high_byte@@ZAEI@Z	; high_byte
	*** 00204f	83 c4 02 		add	sp,2
	*** 002052	a2 18 00 		mov	BYTE PTR ?data_pkt@@3QIEI+24,al	;data_pkt
;|***   data_pkt[25] = low_byte(checksum16);
; Line 1831
	*** 002055	56 			push	si
	*** 002056	0e 			push	cs
	*** 002057	e8 00 00 		call	NEAR PTR ?low_byte@@ZAEI@Z	; low_byte
	*** 00205a	83 c4 02 		add	sp,2
	*** 00205d	a2 19 00 		mov	BYTE PTR ?data_pkt@@3QIEI+25,al	;data_pkt
;|*** 
;|***   // insert udp packet into ip data field (up to 1480 bytes)
;|***   // start with the udp header
;|***   // insert udp source port
;|***   data_pkt[34] = high_byte(UDP_SOURCE_PORT);
; Line 1836
	*** 002060	68 57 13 		push	4951	;1357H
	*** 002063	0e 			push	cs
	*** 002064	e8 00 00 		call	NEAR PTR ?high_byte@@ZAEI@Z	; high_byte
	*** 002067	83 c4 02 		add	sp,2
	*** 00206a	a2 22 00 		mov	BYTE PTR ?data_pkt@@3QIEI+34,al	;data_pkt
;|***   data_pkt[35] = low_byte(UDP_SOURCE_PORT);
; Line 1837
	*** 00206d	68 57 13 		push	4951	;1357H
	*** 002070	0e 			push	cs
	*** 002071	e8 00 00 		call	NEAR PTR ?low_byte@@ZAEI@Z	; low_byte
	*** 002074	83 c4 02 		add	sp,2
	*** 002077	a2 23 00 		mov	BYTE PTR ?data_pkt@@3QIEI+35,al	;data_pkt
;|*** 
;|***   // insert udp destination port
;|***   data_pkt[36] = high_byte(UDP_DEST_PORT);
; Line 1840
	*** 00207a	68 56 13 		push	4950	;1356H
	*** 00207d	0e 			push	cs
	*** 00207e	e8 00 00 		call	NEAR PTR ?high_byte@@ZAEI@Z	; high_byte
	*** 002081	83 c4 02 		add	sp,2
	*** 002084	a2 24 00 		mov	BYTE PTR ?data_pkt@@3QIEI+36,al	;data_pkt
;|***   data_pkt[37] = low_byte(UDP_DEST_PORT);
; Line 1841
	*** 002087	68 56 13 		push	4950	;1356H
	*** 00208a	0e 			push	cs
	*** 00208b	e8 00 00 		call	NEAR PTR ?low_byte@@ZAEI@Z	; low_byte
	*** 00208e	83 c4 02 		add	sp,2
	*** 002091	a2 25 00 		mov	BYTE PTR ?data_pkt@@3QIEI+37,al	;data_pkt
;|*** 
;|***   // insert udp length
;|***   data_pkt[38] = high_byte(UDP_LENGTH);
; Line 1844
	*** 002094	68 c8 05 		push	1480	;05c8H
	*** 002097	0e 			push	cs
	*** 002098	e8 00 00 		call	NEAR PTR ?high_byte@@ZAEI@Z	; high_byte
	*** 00209b	83 c4 02 		add	sp,2
	*** 00209e	a2 26 00 		mov	BYTE PTR ?data_pkt@@3QIEI+38,al	;data_pkt
;|***   data_pkt[39] = low_byte(UDP_LENGTH);
; Line 1845
	*** 0020a1	68 c8 05 		push	1480	;05c8H
	*** 0020a4	0e 			push	cs
	*** 0020a5	e8 00 00 		call	NEAR PTR ?low_byte@@ZAEI@Z	; low_byte
	*** 0020a8	83 c4 02 		add	sp,2
	*** 0020ab	a2 27 00 		mov	BYTE PTR ?data_pkt@@3QIEI+39,al	;data_pkt
;|*** 
;|***   // insert dummy udp checksum
;|***   // must wait until after udp data is loaded
;|***   // to calculate the real udp checksum
;|***   data_pkt[40] = 0;
;|***   data_pkt[41] = 0;
; Line 1851
	*** 0020ae	32 c0 			xor	al,al
	*** 0020b0	a2 28 00 		mov	BYTE PTR ?data_pkt@@3QIEI+40,al	;data_pkt
	*** 0020b3	a2 29 00 		mov	BYTE PTR ?data_pkt@@3QIEI+41,al	;data_pkt
;|***   
;|***   /*
;|***   // insert dummy udp data
;|***   for(i=42; i<1514; i++) // insert packet data
;|***     {
;|***     data_pkt[i] = (unsigned char) i & 0xf;
;|***     }
;|***   */
;|***   
;|***   // insert real obc data
;|***   i = 42;
;|***   
;|***   _fmemcpy(&data_pkt[i], &sys,  sizeof(sys));
; Line 1864
	*** 0020b6	b8 00 00 		mov	ax,SEG ?sys@@3USYS@@E	;sys
	*** 0020b9	1e 			push	ds
	*** 0020ba	bf 2a 00 		mov	di,OFFSET DGROUP:?data_pkt@@3QIEI+42	;data_pkt
	*** 0020bd	be 00 00 		mov	si,OFFSET ?sys@@3USYS@@E	;sys
	*** 0020c0	1e 			push	ds
	*** 0020c1	07 			pop	es
	*** 0020c2	8e d8 			mov	ds,ax
	ASSUME DS: SEG ?sys@@3USYS@@E
	*** 0020c4	b9 09 00 		mov	cx,9
	*** 0020c7	f3 			rep
	*** 0020c8	a5 			movsw
	*** 0020c9	1f 			pop	ds
	ASSUME DS: DGROUP
;|***   i += sizeof(sys);
;|*** 
;|***   _fmemcpy(&data_pkt[i], &obs, sizeof(obs));
; Line 1867
	*** 0020ca	b8 00 00 		mov	ax,SEG ?obs@@3UOBS@@E	;obs
	*** 0020cd	1e 			push	ds
	*** 0020ce	bf 3c 00 		mov	di,OFFSET DGROUP:?data_pkt@@3QIEI+60	;data_pkt
	*** 0020d1	be 00 00 		mov	si,OFFSET ?obs@@3UOBS@@E	;obs
	*** 0020d4	1e 			push	ds
	*** 0020d5	07 			pop	es
	*** 0020d6	8e d8 			mov	ds,ax
	ASSUME DS: SEG ?obs@@3UOBS@@E
	*** 0020d8	b9 26 00 		mov	cx,38	;0026H
	*** 0020db	f3 			rep
	*** 0020dc	a5 			movsw
	*** 0020dd	1f 			pop	ds
	ASSUME DS: DGROUP
;|***   i += sizeof(obs);
;|***   
;|***   _fmemcpy(&data_pkt[i], &dyno, sizeof(dyno));
; Line 1870
	*** 0020de	b8 00 00 		mov	ax,SEG ?dyno@@3UDYNO@@E	;dyno
	*** 0020e1	1e 			push	ds
	*** 0020e2	bf 88 00 		mov	di,OFFSET DGROUP:?data_pkt@@3QIEI+136	;data_pkt
	*** 0020e5	be 00 00 		mov	si,OFFSET ?dyno@@3UDYNO@@E	;dyno
	*** 0020e8	1e 			push	ds
	*** 0020e9	07 			pop	es
	*** 0020ea	8e d8 			mov	ds,ax
	ASSUME DS: SEG ?dyno@@3UDYNO@@E
	*** 0020ec	b9 86 00 		mov	cx,134	;0086H
	*** 0020ef	f3 			rep
	*** 0020f0	a5 			movsw
	*** 0020f1	1f 			pop	ds
	ASSUME DS: DGROUP
;|***   i += sizeof(dyno);
;|***   
;|***   _fmemcpy(&data_pkt[i], &prop, sizeof(prop));
; Line 1873
	*** 0020f2	b8 00 00 		mov	ax,SEG ?prop@@3UPROP@@E	;prop
	*** 0020f5	1e 			push	ds
	*** 0020f6	bf 94 01 		mov	di,OFFSET DGROUP:?data_pkt@@3QIEI+404	;data_pkt
	*** 0020f9	be 00 00 		mov	si,OFFSET ?prop@@3UPROP@@E	;prop
	*** 0020fc	1e 			push	ds
	*** 0020fd	07 			pop	es
	*** 0020fe	8e d8 			mov	ds,ax
	ASSUME DS: SEG ?prop@@3UPROP@@E
	*** 002100	b9 15 00 		mov	cx,21	;0015H
	*** 002103	f3 			rep
	*** 002104	a5 			movsw
	*** 002105	1f 			pop	ds
	ASSUME DS: DGROUP
;|***   i += sizeof(prop);
;|***   
;|***   _fmemcpy(&data_pkt[i], &ln200, sizeof(ln200));
; Line 1876
	*** 002106	b8 00 00 		mov	ax,SEG ?ln200@@3ULN200@@E	;ln200
	*** 002109	1e 			push	ds
	*** 00210a	bf be 01 		mov	di,OFFSET DGROUP:?data_pkt@@3QIEI+446	;data_pkt
	*** 00210d	be 00 00 		mov	si,OFFSET ?ln200@@3ULN200@@E	;ln200
	*** 002110	1e 			push	ds
	*** 002111	07 			pop	es
	*** 002112	8e d8 			mov	ds,ax
	ASSUME DS: SEG ?ln200@@3ULN200@@E
	*** 002114	b9 16 00 		mov	cx,22	;0016H
	*** 002117	f3 			rep
	*** 002118	a5 			movsw
	*** 002119	1f 			pop	ds
	ASSUME DS: DGROUP
;|***   i += sizeof(ln200);
;|***   
;|***   _fmemcpy(&data_pkt[i], &echo, sizeof(echo));
; Line 1879
	*** 00211a	b8 00 00 		mov	ax,SEG ?echo@@3UECHO@@E	;echo
	*** 00211d	1e 			push	ds
	*** 00211e	bf ea 01 		mov	di,OFFSET DGROUP:?data_pkt@@3QIEI+490	;data_pkt
	*** 002121	be 00 00 		mov	si,OFFSET ?echo@@3UECHO@@E	;echo
	*** 002124	1e 			push	ds
	*** 002125	07 			pop	es
	*** 002126	8e d8 			mov	ds,ax
	ASSUME DS: SEG ?echo@@3UECHO@@E
	*** 002128	b9 18 00 		mov	cx,24	;0018H
	*** 00212b	f3 			rep
	*** 00212c	a5 			movsw
	*** 00212d	1f 			pop	ds
	ASSUME DS: DGROUP
;|***   i += sizeof(echo);
;|***   
;|***   _fmemcpy(&data_pkt[i], &ds, sizeof(ds));
; Line 1882
	*** 00212e	b8 00 00 		mov	ax,SEG ?ds@@3UDS@@E	;ds
	*** 002131	1e 			push	ds
	*** 002132	bf 1a 02 		mov	di,OFFSET DGROUP:?data_pkt@@3QIEI+538	;data_pkt
	*** 002135	be 00 00 		mov	si,OFFSET ?ds@@3UDS@@E	;ds
	*** 002138	1e 			push	ds
	*** 002139	07 			pop	es
	*** 00213a	8e d8 			mov	ds,ax
	ASSUME DS: SEG ?ds@@3UDS@@E
	*** 00213c	b9 2e 00 		mov	cx,46	;002eH
	*** 00213f	f3 			rep
	*** 002140	a5 			movsw
	*** 002141	1f 			pop	ds
	ASSUME DS: DGROUP
;|***   i += sizeof(ds);
;|***   
;|***   _fmemcpy(&data_pkt[i], &adcp, sizeof(adcp));
; Line 1885
	*** 002142	b8 00 00 		mov	ax,SEG ?adcp@@3UADCP@@E	;adcp
	*** 002145	1e 			push	ds
	*** 002146	bf 76 02 		mov	di,OFFSET DGROUP:?data_pkt@@3QIEI+630	;data_pkt
	*** 002149	be 00 00 		mov	si,OFFSET ?adcp@@3UADCP@@E	;adcp
	*** 00214c	1e 			push	ds
	*** 00214d	07 			pop	es
	*** 00214e	8e d8 			mov	ds,ax
	ASSUME DS: SEG ?adcp@@3UADCP@@E
	*** 002150	b9 70 00 		mov	cx,112	;0070H
	*** 002153	f3 			rep
	*** 002154	a5 			movsw
	*** 002155	a4 			movsb
	*** 002156	1f 			pop	ds
	ASSUME DS: DGROUP
;|***   i += sizeof(adcp);
;|***   
;|***   _fmemcpy(&data_pkt[i], &gps, sizeof(gps));
; Line 1888
	*** 002157	b8 00 00 		mov	ax,SEG ?gps@@3UGPS@@E	;gps
	*** 00215a	1e 			push	ds
	*** 00215b	bf 57 03 		mov	di,OFFSET DGROUP:?data_pkt@@3QIEI+855	;data_pkt
	*** 00215e	be 00 00 		mov	si,OFFSET ?gps@@3UGPS@@E	;gps
	*** 002161	1e 			push	ds
	*** 002162	07 			pop	es
	*** 002163	8e d8 			mov	ds,ax
	ASSUME DS: SEG ?gps@@3UGPS@@E
	*** 002165	b9 2e 00 		mov	cx,46	;002eH
	*** 002168	f3 			rep
	*** 002169	a5 			movsw
	*** 00216a	1f 			pop	ds
	ASSUME DS: DGROUP
	*** 00216b	b9 04 00 		mov	cx,4
	*** 00216e	8d 7e e6 		lea	di,WORD PTR [bp-26]	;udp_pseudo
	*** 002171	be 1a 00 		mov	si,OFFSET DGROUP:?data_pkt@@3QIEI+26	;data_pkt
	*** 002174	16 			push	ss
	*** 002175	07 			pop	es
	*** 002176	f3 			rep
	*** 002177	a5 			movsw
;|***   i += sizeof(gps);
;|*** 
;|***   // now calculate and insert the real upd checksum
;|***   // from the udp pseudo-header and true header
;|***   for(j=0;j<8;j++) udp_pseudo[j] = data_pkt[j+26];  // source & dest ip addr
;|***   udp_pseudo[8] = 0;
; Line 1894
	*** 002178	c6 46 ee 00 		mov	BYTE PTR [bp-18],0
;|***   udp_pseudo[9] = data_pkt[23];  // protocol id
; Line 1895
	*** 00217c	a0 17 00 		mov	al,BYTE PTR ?data_pkt@@3QIEI+23	;data_pkt
	*** 00217f	88 46 ef 		mov	BYTE PTR [bp-17],al
;|***   udp_pseudo[10] = data_pkt[38];  // udp len high
; Line 1896
	*** 002182	a0 26 00 		mov	al,BYTE PTR ?data_pkt@@3QIEI+38	;data_pkt
	*** 002185	88 46 f0 		mov	BYTE PTR [bp-16],al
;|***   udp_pseudo[11] = data_pkt[39];  // udp len low
; Line 1897
	*** 002188	a0 27 00 		mov	al,BYTE PTR ?data_pkt@@3QIEI+39	;data_pkt
	*** 00218b	88 46 f1 		mov	BYTE PTR [bp-15],al
;|*** 
;|***   // calculate the 1's complement checksum
;|***   checksum32 = 0;
; Line 1900
	*** 00218e	2b c0 			sub	ax,ax
	*** 002190	89 46 fc 		mov	WORD PTR [bp-4],ax
	*** 002193	89 46 fa 		mov	WORD PTR [bp-6],ax	;value
;|***   for(j=0;j<12;)
; Line 1901
	*** 002196	33 f6 			xor	si,si
					$FC3986:
;|***     {
;|***     value = (udp_pseudo[j] << 8) + udp_pseudo[j+1];
;|***     //if(value < 0) value -= 1;                    // convert to 1's complement
;|***     checksum32 += value;                         // add them up
;|***     if(checksum32 > 0x0000ffff)                  // perform end-around carry
; Line 1906
	*** 002198	8a 62 e6 		mov	ah,BYTE PTR [bp-26][si]
	*** 00219b	2a c0 			sub	al,al
	*** 00219d	8a 4a e7 		mov	cl,BYTE PTR [bp-25][si]
	*** 0021a0	2a ed 			sub	ch,ch
	*** 0021a2	03 c1 			add	ax,cx
	*** 0021a4	2b d2 			sub	dx,dx
	*** 0021a6	01 46 fa 		add	WORD PTR [bp-6],ax	;value
	*** 0021a9	11 56 fc 		adc	WORD PTR [bp-4],dx
	*** 0021ac	39 56 fc 		cmp	WORD PTR [bp-4],dx
	*** 0021af	74 0e 			je	$I3988
;|***       {
;|***       checksum32 = (checksum32 & 0x0000ffff) + 1;
; Line 1908
	*** 0021b1	8b 46 fa 		mov	ax,WORD PTR [bp-6]	;value
	*** 0021b4	05 01 00 		add	ax,1
	*** 0021b7	13 d2 			adc	dx,dx
	*** 0021b9	89 46 fa 		mov	WORD PTR [bp-6],ax	;value
	*** 0021bc	89 56 fc 		mov	WORD PTR [bp-4],dx
;|***       }
;|***     j = j+2;
; Line 1910
					$I3988:
;|***     }
; Line 1911
	*** 0021bf	83 c6 02 		add	si,2
	*** 0021c2	83 fe 0c 		cmp	si,12	;000cH
	*** 0021c5	72 d1 			jb	$FC3986
;|*** 
;|***   // true udp header and data next
;|***   for(j=34;j<1514;)  // true udp header and data
; Line 1914
	*** 0021c7	be 22 00 		mov	si,34	;0022H
					$FC3990:
;|***     {
;|***     value = (data_pkt[j] << 8) + data_pkt[j+1];
;|***     //if(value < 0) value -= 1;                    // convert it to 1's complement
;|***     checksum32 += value;                         // add them up
;|***     if(checksum32 > 0x0000ffff)                  // perform end-around carry
; Line 1919
	*** 0021ca	8a a4 00 00 		mov	ah,BYTE PTR ?data_pkt@@3QIEI[si]	;data_pkt
	*** 0021ce	2a c0 			sub	al,al
	*** 0021d0	8a 8c 01 00 		mov	cl,BYTE PTR ?data_pkt@@3QIEI[si+1]	;data_pkt
	*** 0021d4	2a ed 			sub	ch,ch
	*** 0021d6	03 c1 			add	ax,cx
	*** 0021d8	2b d2 			sub	dx,dx
	*** 0021da	01 46 fa 		add	WORD PTR [bp-6],ax	;value
	*** 0021dd	11 56 fc 		adc	WORD PTR [bp-4],dx
	*** 0021e0	39 56 fc 		cmp	WORD PTR [bp-4],dx
	*** 0021e3	74 0e 			je	$I3992
;|***       {
;|***       checksum32 = (checksum32 & 0x0000ffff) + 1;
; Line 1921
	*** 0021e5	8b 46 fa 		mov	ax,WORD PTR [bp-6]	;value
	*** 0021e8	05 01 00 		add	ax,1
	*** 0021eb	13 d2 			adc	dx,dx
	*** 0021ed	89 46 fa 		mov	WORD PTR [bp-6],ax	;value
	*** 0021f0	89 56 fc 		mov	WORD PTR [bp-4],dx
;|***       }
;|***     j = j+2;
; Line 1923
					$I3992:
;|***     }
; Line 1924
	*** 0021f3	83 c6 02 		add	si,2
	*** 0021f6	81 fe ea 05 		cmp	si,1514	;05eaH
	*** 0021fa	72 ce 			jb	$FC3990
;|***   checksum16 = (unsigned)(checksum32 & 0x0000ffff); // convert back to 16-bit
;|***   checksum16 = ~checksum16;                      // take the 1's complement
;|***   if(checksum16 == 0) checksum16 = 0xffff;       // only for udp/tcp
; Line 1927
	*** 0021fc	8b 76 fa 		mov	si,WORD PTR [bp-6]	;value
	*** 0021ff	f7 d6 			not	si
	*** 002201	0b f6 			or	si,si
	*** 002203	75 03 			jne	$I3994
	*** 002205	be ff ff 		mov	si,-1	;ffffH
;|***   data_pkt[40] = high_byte(checksum16);
; Line 1928
					$I3994:
	*** 002208	56 			push	si
	*** 002209	0e 			push	cs
	*** 00220a	e8 00 00 		call	NEAR PTR ?high_byte@@ZAEI@Z	; high_byte
	*** 00220d	83 c4 02 		add	sp,2
	*** 002210	a2 28 00 		mov	BYTE PTR ?data_pkt@@3QIEI+40,al	;data_pkt
;|***   data_pkt[41] = low_byte(checksum16);
; Line 1929
	*** 002213	56 			push	si
	*** 002214	0e 			push	cs
	*** 002215	e8 00 00 		call	NEAR PTR ?low_byte@@ZAEI@Z	; low_byte
	*** 002218	83 c4 02 		add	sp,2
	*** 00221b	a2 29 00 		mov	BYTE PTR ?data_pkt@@3QIEI+41,al	;data_pkt
;|*** 
;|***    // end build_packet()
;|***   }
; Line 1932
	*** 00221e	5e 			pop	si
	*** 00221f	5f 			pop	di
	*** 002220	c9 			leave	
	*** 002221	cb 			ret	

?build_packet@@ZAXXZ	ENDP
	PUBLIC	?high_byte@@ZAEI@Z	; high_byte
?high_byte@@ZAEI@Z	PROC FAR	; high_byte
;|*** 
;|*** 
;|*** unsigned char high_byte(unsigned int word)
;|***   {
; Line 1936
	*** 002222	55 			push	bp
	*** 002223	8b ec 			mov	bp,sp
;	word = 6
;|***   return (unsigned char) ((word>>8)&0xff);
; Line 1937
	*** 002225	8a 46 07 		mov	al,BYTE PTR [bp+7]
;|***   }
; Line 1938
	*** 002228	c9 			leave	
	*** 002229	cb 			ret	

?high_byte@@ZAEI@Z	ENDP
	PUBLIC	?low_byte@@ZAEI@Z	; low_byte
?low_byte@@ZAEI@Z	PROC FAR	; low_byte
;|*** 
;|*** 
;|*** 
;|*** unsigned char low_byte(unsigned int word)
;|***   {
; Line 1943
	*** 00222a	55 			push	bp
	*** 00222b	8b ec 			mov	bp,sp
;	word = 6
;|***   return (unsigned char) (word&0xff);
; Line 1944
	*** 00222d	8a 46 06 		mov	al,BYTE PTR [bp+6]	;word
;|***   }
; Line 1945
	*** 002230	c9 			leave	
	*** 002231	cb 			ret	

?low_byte@@ZAEI@Z	ENDP
	PUBLIC	?init_screen@@ZAXXZ	; init_screen
?init_screen@@ZAXXZ	PROC FAR	; init_screen
;|***     
;|*** 
;|*** void init_screen(void)
;|*** {
; Line 1949
	*** 002232	c8 52 00 00 		enter	82,0
;	s = -82
;|***   char s[81];
;|*** 
;|***   PC_DispClrScr(DISP_FGND_LIGHT_GRAY + DISP_BGND_RED);
; Line 1952
	*** 002236	6a 47 			push	71	;0047H
	*** 002238	0e 			push	cs
	*** 002239	e8 00 00 		call	NEAR PTR ?PC_DispClrScr@@ZAXE@Z	; PC_DispClrScr
	*** 00223c	83 c4 02 		add	sp,2
;|*** 
;|***   sprintf(s, "%s", 
;|*** "                       Autonomous Model Onboard Computer                        ");
; Line 1955
	*** 00223f	1e 			push	ds
	*** 002240	68 00 00 		push	OFFSET DGROUP:$SG4004
	*** 002243	1e 			push	ds
	*** 002244	68 00 00 		push	OFFSET DGROUP:$SG4005
	*** 002247	8d 46 ae 		lea	ax,WORD PTR [bp-82]	;s
	*** 00224a	16 			push	ss
	*** 00224b	50 			push	ax
	*** 00224c	9a 00 00 00 00 		call	FAR PTR _sprintf
	*** 002251	83 c4 0c 		add	sp,12	;000cH
;|***   PC_DispStr(0,0, (unsigned char *)s, DISP_FGND_BLACK + DISP_BGND_LIGHT_GRAY);
; Line 1956
	*** 002254	6a 70 			push	112	;0070H
	*** 002256	8d 46 ae 		lea	ax,WORD PTR [bp-82]	;s
	*** 002259	16 			push	ss
	*** 00225a	50 			push	ax
	*** 00225b	6a 00 			push	0
	*** 00225d	6a 00 			push	0
	*** 00225f	0e 			push	cs
	*** 002260	e8 00 00 		call	NEAR PTR ?PC_DispStr@@ZAXEEPIEE@Z	; PC_DispStr
	*** 002263	83 c4 0a 		add	sp,10	;000aH
;|*** 
;|***   sprintf(s, "%s", 
;|*** "                               NSWC-CD Code 5600                                ");
; Line 1959
	*** 002266	1e 			push	ds
	*** 002267	68 00 00 		push	OFFSET DGROUP:$SG4007
	*** 00226a	1e 			push	ds
	*** 00226b	68 00 00 		push	OFFSET DGROUP:$SG4008
	*** 00226e	8d 46 ae 		lea	ax,WORD PTR [bp-82]	;s
	*** 002271	16 			push	ss
	*** 002272	50 			push	ax
	*** 002273	9a 00 00 00 00 		call	FAR PTR _sprintf
	*** 002278	83 c4 0c 		add	sp,12	;000cH
;|***   PC_DispStr(0,1, (unsigned char *)s, DISP_FGND_BLACK + DISP_BGND_LIGHT_GRAY);  
; Line 1960
	*** 00227b	6a 70 			push	112	;0070H
	*** 00227d	8d 46 ae 		lea	ax,WORD PTR [bp-82]	;s
	*** 002280	16 			push	ss
	*** 002281	50 			push	ax
	*** 002282	6a 01 			push	1
	*** 002284	6a 00 			push	0
	*** 002286	0e 			push	cs
	*** 002287	e8 00 00 		call	NEAR PTR ?PC_DispStr@@ZAXEEPIEE@Z	; PC_DispStr
	*** 00228a	83 c4 0a 		add	sp,10	;000aH
;|***     
;|***   sprintf(s, "%s",
;|*** "                             March 8, 2004 Rev 0.8                              ");
; Line 1963
	*** 00228d	1e 			push	ds
	*** 00228e	68 00 00 		push	OFFSET DGROUP:$SG4010
	*** 002291	1e 			push	ds
	*** 002292	68 00 00 		push	OFFSET DGROUP:$SG4011
	*** 002295	8d 46 ae 		lea	ax,WORD PTR [bp-82]	;s
	*** 002298	16 			push	ss
	*** 002299	50 			push	ax
	*** 00229a	9a 00 00 00 00 		call	FAR PTR _sprintf
	*** 00229f	83 c4 0c 		add	sp,12	;000cH
;|***   PC_DispStr(0,2, (unsigned char *)s, DISP_FGND_BLACK + DISP_BGND_LIGHT_GRAY);
; Line 1964
	*** 0022a2	6a 70 			push	112	;0070H
	*** 0022a4	8d 46 ae 		lea	ax,WORD PTR [bp-82]	;s
	*** 0022a7	16 			push	ss
	*** 0022a8	50 			push	ax
	*** 0022a9	6a 02 			push	2
	*** 0022ab	6a 00 			push	0
	*** 0022ad	0e 			push	cs
	*** 0022ae	e8 00 00 		call	NEAR PTR ?PC_DispStr@@ZAXEEPIEE@Z	; PC_DispStr
;|***   
;|*** }
; Line 1966
	*** 0022b1	c9 			leave	
	*** 0022b2	cb 			ret	
	*** 0022b3	90 			nop	

?init_screen@@ZAXXZ	ENDP
	PUBLIC	?prep_ln200_command@@ZAXXZ	; prep_ln200_command
?prep_ln200_command@@ZAXXZ	PROC FAR	; prep_ln200_command
;|*** 
;|*** 
;|*** void prep_ln200_command(void)
;|***   {
; Line 1970
	*** 0022b4	c8 0e 00 00 		enter	14,0
	*** 0022b8	57 			push	di
	*** 0022b9	56 			push	si
;	i = -2
;	heading = -4
;	latitude_valid = -6
;	boresights_valid = -8
;	heading_valid = -10
;	bit = -12
;	mode = -14
;	latitude = -16
;	x_axis = -18
;	y_axis = -20
;	z_axis = -22
;	icmd = -14
;|***   #define YES 1
;|***   //#define X_AXIS 0.0f
;|***   #define X_AXIS -0.48f
;|***   #define Y_AXIS 0.0f
;|***   #define Z_AXIS 0.0f
;|***   #define LATITUDE 38.7f
;|*** 
;|***   int i;
;|***   int heading;
;|***   unsigned latitude_valid;
;|***   unsigned boresights_valid;
;|***   unsigned heading_valid;
;|***   unsigned bit = 0;
;|***   unsigned mode = 0;
;|***   int      latitude;
;|***   int      x_axis;
;|***   int      y_axis;
;|***   int      z_axis;
;|***   
;|***   unsigned icmd[7];
;|***   
;|***   heading = (int) (-52.0 * 182.044);
;|***   latitude = (int) (LATITUDE * 182.044); // LN200 operating latitude,+-degrees, see ln200 ICD
;|***   x_axis = (int) (X_AXIS * 182.044);     // LN200 boresight rotations,+-degrees
;|***   y_axis = (int) (Y_AXIS * 182.044);
;|***   z_axis = (int) (Z_AXIS * 182.044);
;|***   
;|***   
;|***   //mode = 0;      //LN200 modes are 0 (free inertial) and 1 (fast leveling)
;|***   //mode = 1;
;|***     
;|***   latitude_valid  = YES;               // latitude valid?
;|***   heading_valid = YES;                 // heading valid?
;|***   boresights_valid = YES;              // boresight rotations valid?
;|***   bit = NO;                            // run Built In Test?
;|***   
;|***   mode = commands.ln200_mode;
;|***   //latitude = commands.latitude;
;|***   //heading  = commands.heading;
;|***   
;|***   icmd[0]=0x0000;                      // assemble the command word icmd[]
;|***   icmd[0]=icmd[0]|mode;
;|***   icmd[0]=icmd[0]|(boresights_valid<<3);
;|***   icmd[0]=icmd[0]|(bit<<4);
;|***   icmd[0]=icmd[0]|(latitude_valid<<8);
;|***   icmd[0]=icmd[0]|(heading_valid<<9);
; Line 2016
	*** 0022ba	8e 06 00 00 		mov	es,WORD PTR $T4071
	*** 0022be	26 a1 10 00 		mov	ax,WORD PTR es:?commands@@3UCOMMANDS@@E+16	;commands
	*** 0022c2	0d 08 03 		or	ax,776	;0308H
	*** 0022c5	89 46 f2 		mov	WORD PTR [bp-14],ax	;mode
;|***   icmd[1]=latitude;
; Line 2017
	*** 0022c8	c7 46 f4 85 1b 		mov	WORD PTR [bp-12],7045	;1b85H	;bit
;|***   icmd[2]=heading;
; Line 2018
	*** 0022cd	c7 46 f6 06 db 		mov	WORD PTR [bp-10],-9466	;db06H	;heading_valid
;|***   icmd[3]=x_axis;
; Line 2019
	*** 0022d2	c7 46 f8 a9 ff 		mov	WORD PTR [bp-8],-87	;ffa9H	;boresights_valid
;|***   icmd[4]=y_axis;
;|***   icmd[5]=z_axis;
;|***   icmd[6]=0x0;                      // calculate icmd[] checksum
; Line 2022
	*** 0022d7	33 c0 			xor	ax,ax
	*** 0022d9	89 46 fa 		mov	WORD PTR [bp-6],ax	;latitude_valid
	*** 0022dc	89 46 fc 		mov	WORD PTR [bp-4],ax	;heading
	*** 0022df	89 46 fe 		mov	WORD PTR [bp-2],ax	;i
	*** 0022e2	8d 5e f2 		lea	bx,WORD PTR [bp-14]	;mode
;|***   for (i=0;i<6;i++)                 // sum icmd[0] to icmd[5]
; Line 2023
					$F4032:
;|***     icmd[6]=icmd[6]+icmd[i];
; Line 2024
	*** 0022e5	8b 07 			mov	ax,WORD PTR [bx]
	*** 0022e7	83 c3 02 		add	bx,2
	*** 0022ea	01 46 fe 		add	WORD PTR [bp-2],ax	;i
	*** 0022ed	8d 46 fe 		lea	ax,WORD PTR [bp-2]	;i
	*** 0022f0	3b d8 			cmp	bx,ax
	*** 0022f2	72 f1 			jb	$F4032
;|***   icmd[6]=~icmd[6];                 // then take bit-wise 1's complement
; Line 2025
	*** 0022f4	f7 56 fe 		not	WORD PTR [bp-2]	;i
;|*** 
;|***   _fmemcpy(ln200_command, icmd, 14);
; Line 2027
	*** 0022f7	bf 00 00 		mov	di,OFFSET DGROUP:?ln200_command@@3QIDI	;ln200_command
	*** 0022fa	8d 76 f2 		lea	si,WORD PTR [bp-14]	;mode
	*** 0022fd	8c d8 			mov	ax,ds
	*** 0022ff	8e c0 			mov	es,ax
	*** 002301	b9 07 00 		mov	cx,7
	*** 002304	f3 			rep
	*** 002305	a5 			movsw
;|***   } // end prep_ln200_command()
; Line 2028
	*** 002306	5e 			pop	si
	*** 002307	5f 			pop	di
	*** 002308	c9 			leave	
	*** 002309	cb 			ret	

?prep_ln200_command@@ZAXXZ	ENDP
	PUBLIC	?time_stamp@@ZAXPEUTIMER@@@Z	; time_stamp
?time_stamp@@ZAXPEUTIMER@@@Z	PROC FAR	; time_stamp
;|***   
;|*** 
;|*** void time_stamp(struct TIMER * t_struct)
;|***   {  // uses the pc's internal timer, resolution ~880 nsec
; Line 2032
	*** 00230a	55 			push	bp
	*** 00230b	8b ec 			mov	bp,sp
	*** 00230d	56 			push	si
;	t_struct = 6
;	register bx = lsb
;	msb = -4
	*** 00230e	8b 76 06 		mov	si,WORD PTR [bp+6]	;t_struct
;|***   unsigned int lsb;
;|***   unsigned int msb;
;|***   
;|***    _outp(0x43, 0xd2);
; Line 2036
	*** 002311	b8 d2 00 		mov	ax,210	;00d2H
	*** 002314	e6 43 			out	67	;0043H, al

;|***    lsb = _inp(0x40);
; Line 2037
	*** 002316	e4 40 			in	al,64	;0040H
	*** 002318	8a d8 			mov	bl,al
	*** 00231a	2a ff 			sub	bh,bh
;|***    msb = _inp(0x40);
;|***    t_struct->low = ~((msb << 8) | lsb);
; Line 2039
	*** 00231c	e4 40 			in	al,64	;0040H
	*** 00231e	8a e0 			mov	ah,al
	*** 002320	2a c0 			sub	al,al
	*** 002322	0b c3 			or	ax,bx
	*** 002324	f7 d0 			not	ax
	*** 002326	8e 46 08 		mov	es,WORD PTR [bp+8]
	*** 002329	26 89 44 04 		mov	WORD PTR es:[si+4],ax
;|***    t_struct->high = sys_timer.high;
; Line 2040
	*** 00232d	8c c0 			mov	ax,es
	*** 00232f	8e 06 00 00 		mov	es,WORD PTR $T4071
	*** 002333	26 8b 0e 00 00 		mov	cx,WORD PTR es:?sys_timer@@3UTIMER@@E	;sys_timer
	*** 002338	26 8b 16 02 00 		mov	dx,WORD PTR es:?sys_timer@@3UTIMER@@E+2	;sys_timer
	*** 00233d	8e c0 			mov	es,ax
	*** 00233f	26 89 0c 		mov	WORD PTR es:[si],cx
	*** 002342	26 89 54 02 		mov	WORD PTR es:[si+2],dx
;|***    }
; Line 2041
	*** 002346	5e 			pop	si
	*** 002347	c9 			leave	
	*** 002348	cb 			ret	
	*** 002349	90 			nop	

?time_stamp@@ZAXPEUTIMER@@@Z	ENDP
	PUBLIC	?heartbeat@@ZAXXZ	; heartbeat
?heartbeat@@ZAXXZ	PROC FAR	; heartbeat
;|*** 
;|*** void heartbeat(void)
;|***   {
;|***   write_bit(HEARTBEAT, (!read_bit(HEARTBEAT)));
; Line 2045
	*** 00234a	6a 11 			push	17	;0011H
	*** 00234c	9a 00 00 00 00 		call	FAR PTR ?read_bit@@ZAHH@Z	; read_bit
	*** 002351	83 c4 02 		add	sp,2
	*** 002354	3d 01 00 		cmp	ax,1
	*** 002357	1b c0 			sbb	ax,ax
	*** 002359	f7 d8 			neg	ax
	*** 00235b	50 			push	ax
	*** 00235c	6a 11 			push	17	;0011H
	*** 00235e	9a 00 00 00 00 		call	FAR PTR ?write_bit@@ZAXHH@Z	; write_bit
	*** 002363	83 c4 04 		add	sp,4
;|***   }
; Line 2046
	*** 002366	cb 			ret	
	*** 002367	90 			nop	

?heartbeat@@ZAXXZ	ENDP

_aak	PROC FAR
; Line 2047
	*** 002368	68 00 00 		push	SEG ?escc1@@3VCescc@@E	;escc1
	*** 00236b	68 00 00 		push	OFFSET ?escc1@@3VCescc@@E	;escc1
	*** 00236e	9a 00 00 00 00 		call	FAR PTR ??1Cescc@@REC@XZ	; Cescc::~Cescc
	*** 002373	cb 			ret	

_aak	ENDP

_aal	PROC FAR
	*** 002374	68 00 00 		push	SEG _aak
	*** 002377	68 00 00 		push	OFFSET _aak
	*** 00237a	9a 00 00 00 00 		call	FAR PTR __fatexit
	*** 00237f	83 c4 04 		add	sp,4
	*** 002382	cb 			ret	
	*** 002383	90 			nop	

_aal	ENDP

_aan	PROC FAR
	*** 002384	0e 			push	cs
	*** 002385	e8 00 00 		call	NEAR PTR _aaj
	*** 002388	0e 			push	cs
	*** 002389	e8 00 00 		call	NEAR PTR _aal
	*** 00238c	cb 			ret	
	*** 00238d	90 			nop	

_aan	ENDP
	PUBLIC	?dec@@ZAAEVios@@AEV1@@Z	; dec
?dec@@ZAAEVios@@AEV1@@Z	PROC FAR	; dec COMDAT
;|*** /***
;|*** *ios.h - definitions/declarations for the ios class.
;|*** *
;|*** *   Copyright (c) 1990-1992, Microsoft Corporation.  All rights reserved.
;|*** *
;|*** *Purpose:
;|*** *   This file defines the classes, values, macros, and functions
;|*** *   used by the ios class.
;|*** *   [AT&T C++]
;|*** *
;|*** ****/
;|*** 
;|*** #ifndef _INC_IOS
;|*** #define _INC_IOS
;|*** 
;|*** 
;|*** #ifdef M_I86HM
;|*** #define _HFAR_ __far
;|*** #else 
;|*** #define _HFAR_
;|*** #endif 
;|*** 
;|*** #ifndef NULL
;|*** #define NULL    0
;|*** #endif 
;|*** 
;|*** #ifndef EOF
;|*** #define EOF (-1)
;|*** #endif 
;|*** 
;|*** // Force word packing to avoid possible -Zp override
;|*** #pragma pack(2)
;|*** 
;|*** #pragma warning(disable:4505)       // disable unwanted /W4 warning
;|*** // #pragma warning(default:4505)    // use this to reenable, if necessary
;|*** 
;|*** class streambuf;
;|*** class ostream;
;|*** 
;|*** class ios {
;|*** 
;|*** public:
;|***     enum io_state {  goodbit = 0x00,
;|***              eofbit  = 0x01,
;|***              failbit = 0x02,
;|***              badbit  = 0x04 };
;|*** 
;|***     enum open_mode { in        = 0x01,
;|***              out       = 0x02,
;|***              ate       = 0x04,
;|***              app       = 0x08,
;|***              trunc     = 0x10,
;|***              nocreate  = 0x20,
;|***              noreplace = 0x40,
;|***              binary    = 0x80 };    // CONSIDER: not in latest spec.
;|*** 
;|***     enum seek_dir { beg=0, cur=1, end=2 };
;|*** 
;|***     enum {  skipws     = 0x0001,
;|***         left       = 0x0002,
;|***         right      = 0x0004,
;|***         internal   = 0x0008,
;|***         dec        = 0x0010,
;|***         oct        = 0x0020,
;|***         hex        = 0x0040,
;|***         showbase   = 0x0080,
;|***         showpoint  = 0x0100,
;|***         uppercase  = 0x0200,
;|***         showpos    = 0x0400,
;|***         scientific = 0x0800,
;|***         fixed      = 0x1000,
;|***         unitbuf    = 0x2000,
;|***         stdio      = 0x4000
;|***                  };
;|*** 
;|***     static const long basefield;    // dec | oct | hex
;|***     static const long adjustfield;  // left | right | internal
;|***     static const long floatfield;   // scientific | fixed
;|*** 
;|***     ios(streambuf*);            // differs from ANSI
;|***     virtual ~ios();
;|*** 
;|***     inline long flags() const;
;|***     inline long flags(long _l);
;|*** 
;|***     inline long setf(long _f,long _m);
;|***     inline long setf(long _l);
;|***     inline long unsetf(long _l);
;|*** 
;|***     inline int width() const;
;|***     inline int width(int _i);
;|*** 
;|***     inline ostream* tie(ostream* _os);
;|***     inline ostream* tie() const;
;|*** 
;|***     inline char fill() const;
;|***     inline char fill(char _c);
;|*** 
;|***     inline int precision(int _i);
;|***     inline int precision() const;
;|*** 
;|***     inline int rdstate() const;
;|***     inline void clear(int _i = 0);
;|*** 
;|*** //  inline operator void*() const;
;|***     operator void *() const { if(state&(badbit|failbit) ) return 0; return (void *)this; }
;|***     inline int operator!() const;
;|*** 
;|***     inline int  good() const;
;|***     inline int  eof() const;
;|***     inline int  fail() const;
;|***     inline int  bad() const;
;|*** 
;|***     inline streambuf* rdbuf() const;
;|*** 
;|***     inline long _HFAR_ & iword(int) const;
;|***     inline void _HFAR_ * _HFAR_ & pword(int) const;
;|*** 
;|***     static long bitalloc();
;|***     static int xalloc();
;|***     static void sync_with_stdio();
;|*** 
;|*** protected:
;|***     ios();
;|***     ios(const ios&);            // treat as private
;|***     ios& operator=(const ios&);
;|***     void init(streambuf*);
;|*** 
;|***     enum { skipping, tied };
;|***     streambuf*  bp;
;|*** 
;|***     int     state;
;|***     int     ispecial;           // not used
;|***     int     ospecial;           // not used
;|***     int     isfx_special;       // not used
;|***     int     osfx_special;       // not used
;|***     int     x_delbuf;           // if set, rdbuf() deleted by ~ios
;|*** 
;|***     ostream* x_tie;
;|***     long    x_flags;
;|***     int     x_precision;
;|***     int     x_width;
;|***     char    x_fill;
;|*** 
;|***     static void (*stdioflush)();    // not used
;|*** public:
;|***     int delbuf() const { return x_delbuf; }
;|***     void    delbuf(int _i) { x_delbuf = _i; }
;|*** 
;|*** private:
;|***     static long x_maxbit;
;|***     static long _HFAR_ * x_statebuf;  // used by xalloc()
;|***     static int x_curindex;
;|*** // consider: make interal static to ios::sync_with_stdio()
;|***     static int sunk_with_stdio;     // make sure sync_with done only once
;|*** };
;|*** 
;|*** inline ios& dec(ios& _strm) { _strm.setf(ios::dec,ios::basefield); return _strm; }
; Line 158
	*** 000000	55 			push	bp
	*** 000001	8b ec 			mov	bp,sp
;	_strm = 6
	*** 000003	c4 5e 06 		les	bx,DWORD PTR [bp+6]	;_strm
	*** 000006	a1 00 00 		mov	ax,WORD PTR ?basefield@ios@@2JF	;ios::basefield
	*** 000009	8b 16 02 00 		mov	dx,WORD PTR ?basefield@ios@@2JF+2	;ios::basefield
	*** 00000d	f7 d0 			not	ax
	*** 00000f	f7 d2 			not	dx
	*** 000011	26 23 47 18 		and	ax,WORD PTR es:[bx+24]
	*** 000015	26 23 57 1a 		and	dx,WORD PTR es:[bx+26]
	*** 000019	8a 0e 00 00 		mov	cl,BYTE PTR ?basefield@ios@@2JF	;ios::basefield
	*** 00001d	83 e1 10 		and	cx,16	;0010H
	*** 000020	0b c1 			or	ax,cx
	*** 000022	26 89 47 18 		mov	WORD PTR es:[bx+24],ax
	*** 000026	26 89 57 1a 		mov	WORD PTR es:[bx+26],dx
	*** 00002a	8b c3 			mov	ax,bx
	*** 00002c	8c c2 			mov	dx,es
	*** 00002e	c9 			leave	
	*** 00002f	cb 			ret	

?dec@@ZAAEVios@@AEV1@@Z	ENDP
	PUBLIC	?hex@@ZAAEVios@@AEV1@@Z	; hex
?hex@@ZAAEVios@@AEV1@@Z	PROC FAR	; hex COMDAT
;|*** inline ios& hex(ios& _strm) { _strm.setf(ios::hex,ios::basefield); return _strm; }
; Line 159
	*** 000000	55 			push	bp
	*** 000001	8b ec 			mov	bp,sp
;	_strm = 6
	*** 000003	c4 5e 06 		les	bx,DWORD PTR [bp+6]	;_strm
	*** 000006	a1 00 00 		mov	ax,WORD PTR ?basefield@ios@@2JF	;ios::basefield
	*** 000009	8b 16 02 00 		mov	dx,WORD PTR ?basefield@ios@@2JF+2	;ios::basefield
	*** 00000d	f7 d0 			not	ax
	*** 00000f	f7 d2 			not	dx
	*** 000011	26 23 47 18 		and	ax,WORD PTR es:[bx+24]
	*** 000015	26 23 57 1a 		and	dx,WORD PTR es:[bx+26]
	*** 000019	8a 0e 00 00 		mov	cl,BYTE PTR ?basefield@ios@@2JF	;ios::basefield
	*** 00001d	83 e1 40 		and	cx,64	;0040H
	*** 000020	0b c1 			or	ax,cx
	*** 000022	26 89 47 18 		mov	WORD PTR es:[bx+24],ax
	*** 000026	26 89 57 1a 		mov	WORD PTR es:[bx+26],dx
	*** 00002a	8b c3 			mov	ax,bx
	*** 00002c	8c c2 			mov	dx,es
	*** 00002e	c9 			leave	
	*** 00002f	cb 			ret	

?hex@@ZAAEVios@@AEV1@@Z	ENDP
	PUBLIC	?endl@@ZAAEVostream@@AEV1@@Z	; endl
?endl@@ZAAEVostream@@AEV1@@Z	PROC FAR	; endl COMDAT
;|*** /***
;|*** *ostream.h - definitions/declarations for the ostream class
;|*** *
;|*** *   Copyright (c) 1991-1992, Microsoft Corporation.  All rights reserved.
;|*** *
;|*** *Purpose:
;|*** *   This file defines the classes, values, macros, and functions
;|*** *   used by the ostream class.
;|*** *   [AT&T C++]
;|*** *
;|*** ****/
;|*** 
;|*** #ifndef _INC_OSTREAM
;|*** #define _INC_OSTREAM
;|*** 
;|*** #include <ios.h>
;|*** 
;|*** // Force word packing to avoid possible -Zp override
;|*** #pragma pack(2)
;|*** 
;|*** #pragma warning(disable:4505)       // disable unwanted /W4 warning
;|*** // #pragma warning(default:4505)    // use this to reenable, if necessary
;|*** 
;|*** #ifdef M_I86HM
;|*** #define _HFAR_ __far
;|*** #else 
;|*** #define _HFAR_
;|*** #endif 
;|*** 
;|*** typedef long streamoff, streampos;
;|*** 
;|*** class ostream : virtual public ios {
;|*** 
;|*** public:
;|***     ostream(streambuf*);
;|***     virtual ~ostream();
;|*** 
;|***     ostream& flush();
;|***     int  opfx();
;|***     void osfx();
;|*** 
;|*** inline  ostream& operator<<(ostream& (*f)(ostream&));
;|*** inline  ostream& operator<<(ios& (*f)(ios&));
;|***     ostream& operator<<(const char _HFAR_ *);
;|*** inline  ostream& operator<<(const unsigned char _HFAR_ *);
;|*** inline  ostream& operator<<(const signed char _HFAR_ *);
;|*** inline  ostream& operator<<(char);
;|***     ostream& operator<<(unsigned char);
;|*** inline  ostream& operator<<(signed char);
;|***     ostream& operator<<(short);
;|***     ostream& operator<<(unsigned short);
;|***     ostream& operator<<(int);
;|***     ostream& operator<<(unsigned int);
;|***     ostream& operator<<(long);
;|***     ostream& operator<<(unsigned long);
;|*** inline  ostream& operator<<(float);
;|***     ostream& operator<<(double);
;|***     ostream& operator<<(long double);
;|***     ostream& operator<<(const void _HFAR_ *);
;|***     ostream& operator<<(streambuf*);
;|*** inline  ostream& put(char);
;|***     ostream& put(unsigned char);
;|*** inline  ostream& put(signed char);
;|***     ostream& write(const char _HFAR_ *,int);
;|*** inline  ostream& write(const unsigned char _HFAR_ *,int);
;|*** inline  ostream& write(const signed char _HFAR_ *,int);
;|***     ostream& seekp(streampos);
;|***     ostream& seekp(streamoff,ios::seek_dir);
;|***     streampos tellp();
;|*** 
;|*** protected:
;|***     ostream();
;|***     ostream(const ostream&);    // treat as private
;|***     ostream& operator=(streambuf*); // treat as private
;|***     ostream& operator=(const ostream& _os) {return operator=(_os.rdbuf()); }
;|***     int do_opfx(int);       // not used
;|***     void do_osfx();         // not used
;|*** 
;|*** private:
;|***     ostream(ios&);
;|***     ostream& writepad(const char _HFAR_ *, const char _HFAR_ *);
;|***     int x_floatused;
;|*** };
;|*** 
;|*** inline ostream& ostream::operator<<(ostream& (*f)(ostream&)) { (*f)(*this); return *this; }
;|*** inline ostream& ostream::operator<<(ios& (*f)(ios& )) { (*f)(*this); return *this; }
;|*** 
;|*** inline  ostream& ostream::operator<<(char c) { return operator<<((unsigned char) c); }
;|*** inline  ostream& ostream::operator<<(signed char c) { return operator<<((unsigned char) c); }
;|*** 
;|*** inline  ostream& ostream::operator<<(const unsigned char _HFAR_ * s) { return operator<<((const char _HFAR_ *) s); }
;|*** inline  ostream& ostream::operator<<(const signed char _HFAR_ * s) { return operator<<((const char _HFAR_ *) s); }
;|*** 
;|*** inline  ostream& ostream::operator<<(float f) { x_floatused = 1; return operator<<((double) f); }
;|*** 
;|*** inline  ostream& ostream::put(char c) { return put((unsigned char) c); }
;|*** inline  ostream& ostream::put(signed char c) { return put((unsigned char) c); }
;|*** 
;|*** inline  ostream& ostream::write(const unsigned char _HFAR_ * s, int n) { return write((char _HFAR_ *) s, n); }
;|*** inline  ostream& ostream::write(const signed char _HFAR_ * s, int n) { return write((char _HFAR_ *) s, n); }
;|*** 
;|*** 
;|*** class ostream_withassign : public ostream {
;|***     public:
;|***         ostream_withassign();
;|***         ostream_withassign(streambuf* _is);
;|***         ~ostream_withassign();
;|***     ostream& operator=(const ostream& _os) { return ostream::operator=(_os.rdbuf()); }
;|***     ostream& operator=(streambuf* _sb) { return ostream::operator=(_sb); }
;|*** };
;|*** 
;|*** #ifndef _WINDLL
;|*** extern ostream_withassign cout;
;|*** extern ostream_withassign cerr;
;|*** extern ostream_withassign clog;
;|*** #endif 
;|*** 
;|*** inline ostream& flush(ostream& _outs) { return _outs.flush(); }
;|*** inline ostream& endl(ostream& _outs) { return _outs << '\n' << flush; }
; Line 119
	*** 000000	c8 04 00 00 		enter	4,0
	*** 000004	57 			push	di
	*** 000005	56 			push	si
;	_outs = 6
	*** 000006	6a 0a 			push	10	;000aH
	*** 000008	ff 76 08 		push	WORD PTR [bp+8]
	*** 00000b	ff 76 06 		push	WORD PTR [bp+6]	;_outs
	*** 00000e	9a 00 00 00 00 		call	FAR PTR ??6ostream@@RECAEV0@E@Z	; ostream::operator<<
	*** 000013	52 			push	dx
	*** 000014	50 			push	ax
	*** 000015	8b f0 			mov	si,ax
	*** 000017	8b fa 			mov	di,dx
	*** 000019	9a 00 00 00 00 		call	FAR PTR ?flush@@ZAAEVostream@@AEV1@@Z	; flush
	*** 00001e	83 c4 04 		add	sp,4
	*** 000021	8b c6 			mov	ax,si
	*** 000023	8b d7 			mov	dx,di
	*** 000025	5e 			pop	si
	*** 000026	5f 			pop	di
	*** 000027	c9 			leave	
	*** 000028	cb 			ret	

?endl@@ZAAEVostream@@AEV1@@Z	ENDP
	PUBLIC	?flush@@ZAAEVostream@@AEV1@@Z	; flush
?flush@@ZAAEVostream@@AEV1@@Z	PROC FAR	; flush COMDAT
;|*** inline ostream& flush(ostream& _outs) { return _outs.flush(); }
; Line 118
	*** 000000	55 			push	bp
	*** 000001	8b ec 			mov	bp,sp
;	_outs = 6
	*** 000003	ff 76 08 		push	WORD PTR [bp+8]
	*** 000006	ff 76 06 		push	WORD PTR [bp+6]	;_outs
	*** 000009	9a 00 00 00 00 		call	FAR PTR ?flush@ostream@@RECAEV1@XZ	; ostream::flush
	*** 00000e	c9 			leave	
	*** 00000f	cb 			ret	

?flush@@ZAAEVostream@@AEV1@@Z	ENDP
CBA_TEXT	ENDS
END
