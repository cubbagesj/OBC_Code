;	Static Name Aliases
;
;	$S4099__aam	EQU	_aam
;	$S4107__aao	EQU	_aao
;	$S3855_?toggle@?1??wait_for_time_tick@@ZAXXZ@4IE	EQU	?toggle@?1??wait_for_time_tick@@ZAXXZ@4IE
;	$S4074_?do_once@?1??prep_ln200_command@@ZAXXZ@4IE	EQU	?do_once@?1??prep_ln200_command@@ZAXXZ@4IE
	TITLE   c:\cb8\dmmtest.cpp
	.286p
INCLUDELIB      LLIBCE
INCLUDELIB	OLDNAMES.LIB
DMMTEST_TEXT	SEGMENT  WORD PUBLIC 'CODE'
DMMTEST_TEXT	ENDS
_DATA	SEGMENT  WORD PUBLIC 'DATA'
_DATA	ENDS
CONST	SEGMENT  WORD PUBLIC 'CONST'
CONST	ENDS
_BSS	SEGMENT  WORD PUBLIC 'BSS'
_BSS	ENDS
XIFCB	SEGMENT  WORD PUBLIC 'DATA'
XIFCB	ENDS
XIFU	SEGMENT  WORD PUBLIC 'DATA'
XIFU	ENDS
XIFL	SEGMENT  WORD PUBLIC 'DATA'
XIFL	ENDS
XIFM	SEGMENT  WORD PUBLIC 'DATA'
XIFM	ENDS
XIFCE	SEGMENT  WORD PUBLIC 'DATA'
XIFCE	ENDS
XOB	SEGMENT  WORD PUBLIC 'BSS'
XOB	ENDS
XO	SEGMENT  WORD PUBLIC 'BSS'
XO	ENDS
XOE	SEGMENT  WORD PUBLIC 'BSS'
XOE	ENDS
DMMTEST13_DATA	SEGMENT  PARA PUBLIC 'FAR_DATA'
DMMTEST13_DATA	ENDS
DGROUP	GROUP	CONST, _BSS, _DATA
	ASSUME DS: DGROUP, SS: DGROUP
PUBLIC  ?prop@@3UPROP@@E
PUBLIC  ?adcp@@3UADCP@@E
PUBLIC  ?pcm_sent@@3IE
PUBLIC  ?data_ready@@3IE
PUBLIC  ?ln200@@3ULN200@@E
PUBLIC  ?send_message@@3HE
PUBLIC  ?obc_mac@@3QIEI
PUBLIC  ?micron_mac@@3QIEI
PUBLIC  ?control_mac@@3QIEI
PUBLIC  ?broadcast_mac@@3QIEI
PUBLIC  ?shore_mac@@3QIEI
PUBLIC  ?cmd_buffer@@3QEEE
PUBLIC  ?gps@@3UGPS@@E
PUBLIC  ?sys@@3USYS@@E
PUBLIC  ?sys_frame@@3KE
PUBLIC  ?sys_status@@3IE
PUBLIC  ?commands@@3UCOMMANDS@@E
PUBLIC  ?mux_addr@@3IE
PUBLIC  ?time_since_last_command@@3HE
PUBLIC  ?sys_timer@@3UTIMER@@E
PUBLIC  ?frame_time@@3UTIMER@@E
PUBLIC  ?obs@@3UOBS@@E
PUBLIC  ?obs_time@@3UTIMER@@E
PUBLIC  ?dyno_time@@3UTIMER@@E
PUBLIC  ?prop_rpm_time@@3UTIMER@@E
PUBLIC  ?prop_position_time@@3UTIMER@@E
PUBLIC  ?prop_position_time_previous@@3UTIMER@@E
PUBLIC  ?prop_adc_time@@3UTIMER@@E
PUBLIC  ?prop_position@@3JE
PUBLIC  ?ln200_time@@3UTIMER@@E
PUBLIC  ?echo@@3UECHO@@E
PUBLIC  ?cmds_time@@3UTIMER@@E
PUBLIC  ?ds_time@@3UTIMER@@E
PUBLIC  ?prop_index@@3JE
PUBLIC  ?adcp_time@@3UTIMER@@E
PUBLIC  ?prop_position_absolute_current@@3JE
PUBLIC  ?gps_time@@3UTIMER@@E
PUBLIC  ?prop_position_absolute_previous@@3JE
PUBLIC  ?dyno@@3UDYNO@@E
PUBLIC  ?settings@@3Uescc_regs@@E
PUBLIC  ?escc1@@3VCescc@@E
PUBLIC  ?ln200_rx_num@@3KE
PUBLIC  ?stern1_cmd@@3IE
PUBLIC  ?ds@@3UDS@@E
PUBLIC  ?stern2_cmd@@3IE
PUBLIC  ?fore_cmd@@3IE
PUBLIC  ?rudder_cmd@@3IE
PUBLIC  ?prop_cmd@@3IE
EXTRN	__acrtused:ABS
EXTRN	__fltused:ABS
EXTRN	?write_bit@@ZAXHH@Z:FAR
EXTRN	_te5650CaptureIndex:FAR
EXTRN	_memcpy:FAR
EXTRN	??6ostream@@RECAEV0@E@Z:FAR
EXTRN	_te5650CapturePos:FAR
EXTRN	?set_tx_type@Cescc@@RECIII@Z:FAR
EXTRN	??6ostream@@RECAEV0@F@Z:FAR
EXTRN	_te5650MotorOff:FAR
EXTRN	??6ostream@@RECAEV0@H@Z:FAR
EXTRN	_te5650SetAxis:FAR
EXTRN	??6ostream@@RECAEV0@I@Z:FAR
EXTRN	__AHINCR:FAR
EXTRN	?read_port@@ZAIH@Z:FAR
EXTRN	__chain_intr:FAR
EXTRN	??0Cescc@@REC@XZ:FAR
EXTRN	__disable:FAR
EXTRN	??1Cescc@@REC@XZ:FAR
EXTRN	__aFeldw:FAR
EXTRN	??6ostream@@RECAEV0@N@Z:FAR
EXTRN	__aFdcvt:FAR
EXTRN	__aFfmuld:FAR
EXTRN	_te5650SetMotor:FAR
EXTRN	_te5650PhasesPolarity:FAR
EXTRN	__aFfstdp:FAR
EXTRN	?set_clock_generator@Cescc@@RECXIKI@Z:FAR
EXTRN	_system:FAR
EXTRN	__aFflds:FAR
EXTRN	_te5650InitServo:FAR
EXTRN	__aFfldl:FAR
EXTRN	__aFfmul:FAR
EXTRN	?receiver@@ZAXIIIIIIIIIIIII@Z:FAR
EXTRN	_te5650InitSw:FAR
EXTRN	__aFftol:FAR
EXTRN	?add_port@Cescc@@RECIIIIII@Z:FAR
EXTRN	?driver_info@@ZAHI@Z:FAR
EXTRN	?kill_port@Cescc@@RECII@Z:FAR
EXTRN	?init_port@Cescc@@RECIIIPEUescc_regs@@II@Z:FAR
EXTRN	__dos_setvect:FAR
EXTRN	?init_com1@@ZAXXZ:FAR
EXTRN	_sprintf:FAR
EXTRN	_te5650IsCapture:FAR
EXTRN	_te5650ActPos:FAR
EXTRN	?init_com2@@ZAXXZ:FAR
EXTRN	__getch:FAR
EXTRN	?init_com4@@ZAXXZ:FAR
EXTRN	?tx_port@Cescc@@RECIIPEDI@Z:FAR
EXTRN	?flush@ostream@@RECAEV1@XZ:FAR
EXTRN	__enable:FAR
EXTRN	?shutdown_com1@@ZAXXZ:FAR
EXTRN	_te5650Update:FAR
EXTRN	_exit:FAR
EXTRN	__inp:FAR
EXTRN	__fmemcpy:FAR
EXTRN	?shutdown_com2@@ZAXXZ:FAR
EXTRN	__inpw:FAR
EXTRN	?access_type@@ZAHHHHPEDIP7AXIIIIIIIIIIIII@Z@Z:FAR
EXTRN	?shutdown_com4@@ZAXXZ:FAR
EXTRN	__kbhit:FAR
EXTRN	?clear_rx_buffer@Cescc@@RECII@Z:FAR
EXTRN	__outp:FAR
EXTRN	?send_pkt@@ZAHPEEI@Z:FAR
EXTRN	_te5650ResetCapture:FAR
EXTRN	?clear_tx_buffer@Cescc@@RECII@Z:FAR
EXTRN	?terminate@@ZAHH@Z:FAR
EXTRN	__dos_getvect:FAR
EXTRN	??6ostream@@RECAEV0@PFD@Z:FAR
EXTRN	?init_io@@ZAXI@Z:FAR
EXTRN	?read_bit@@ZAHH@Z:FAR
EXTRN	__fmemset:FAR
EXTRN	__fatexit:FAR
EXTRN	?handle@@3HE:WORD
EXTRN	?packets_rcvd@@3KE:DWORD
EXTRN	?ax0_counter@@3KE:DWORD
EXTRN	?ax1_counter@@3KE:DWORD
EXTRN	?discards@@3KE:DWORD
EXTRN	?receiver_calls@@3KE:DWORD
EXTRN	?basefield@ios@@2JF:DWORD
EXTRN	?x_statebuf@ios@@0PEJE:DWORD
EXTRN	?cout@@3Vostream_withassign@@E:BYTE
_DATA      SEGMENT
?pcm_sent@@3IE	DW	00H
?send_message@@3HE	DW	00H
?obc_mac@@3QIEI	DB	00H
	DB	01H
	DB	045H
	DB	00H
	DB	07aH
	DB	0b0H
?micron_mac@@3QIEI	DB	08H
	DB	00H
	DB	017H
	DB	08H
	DB	087H
	DB	04dH
?control_mac@@3QIEI	DB	00H
	DB	01H
	DB	045H
	DB	00H
	DB	08aH
	DB	021H
?broadcast_mac@@3QIEI	DB	0ffH
	DB	0ffH
	DB	0ffH
	DB	0ffH
	DB	0ffH
	DB	0ffH
?shore_mac@@3QIEI	DB	00H
	DB	0eH
	DB	0a6H
	DB	0b6H
	DB	0c0H
	DB	04eH
?sys_frame@@3KE	DD	00H
?sys_status@@3IE	DW	00H
?mux_addr@@3IE	DW	00H
?prop_position@@3JE	DD	00H
?prop_index@@3JE	DD	00H
?prop_position_absolute_current@@3JE	DD	00H
?prop_position_absolute_previous@@3JE	DD	00H
?ln200_rx_num@@3KE	DD	00H
?time_since_last_command@@3HE	DW	00H
?stern1_cmd@@3IE	DW	00H
?stern2_cmd@@3IE	DW	00H
?fore_cmd@@3IE	DW	00H
?rudder_cmd@@3IE	DW	00H
?prop_cmd@@3IE	DW	00H
?data_ready@@3IE	DW	00H
$SG3744	DB	'Stern1:    %04x',  00H
$SG3752	DB	'Stern2:    %04x',  00H
$SG3766	DB	'Rudder:    %04x',  00H
$SG3774	DB	'Prop:      %04x  %04x',  00H
$SG3776	DB	'Ballast:   %04x',  00H
$SG3800	DB	'te5650InitSw:    ',  00H
$SG3801	DB	'te5650InitServo: ',  00H
$SG3802	DB	'te5650SetAxis:   ',  00H
$SG3803	DB	'te5650SetAxis:   ',  00H
$SG3810	DB	'c:\packet\pktdrv\ne2000 0x7e 10 0x300',  00H
$SG3811	DB	'Access_type() error: ',  00H
$SG3812	DB	'Handle: ',  00H
$SG3813	DB	'Driver_info() error: ',  00H
$SG3814	DB	'Rpm_sf: ',  00H
$SG3817	DB	'Channel A = ',  00H
$SG3818	DB	'Channel B = ',  00H
$SG3819	DB	'initializing channel a',  00H
$SG3821	DB	'Intialize Channel A OK.',  00H
$SG3823	DB	'Initialize Channel A FAILED!',  00H
$SG3825	DB	'Channel A rx buffer cleared OK.  ',  00H
$SG3827	DB	'Channel A rx buffer clear FAILED!',  00H
$SG3829	DB	'Channel A tx buffer cleared OK.',  00H
$SG3831	DB	'Channel A tx buffer clear FAILED!',  00H
$SG3833	DB	'Channel A set to Transparent Mode.  ',  00H
$SG3835	DB	'Channel A Transparent Mode not set!  Channel not open!',  00H
$SG3837	DB	'Intialize Channel B OK.',  00H
$SG3839	DB	'Initialize Channel B FAILED!',  00H
$SG3841	DB	'Channel B rx buffer cleared OK.  ',  00H
$SG3843	DB	'Channel B rx buffer clear FAILED!',  00H
$SG3845	DB	'Channel B tx buffer cleared OK.',  00H
$SG3847	DB	'Channel B tx buffer clear FAILED!',  00H
$SG3849	DB	'Channel B set to Transparent Mode.  ',  00H
$SG3851	DB	'Channel B Transparent Mode not set!  Channel not open!',  00H
	ORG	$+1
$S3855_?toggle@?1??wait_for_time_tick@@ZAXXZ@4IE	DW	00H
$SG3862	DB	'Pitch:   %04x  %10.2f deg',  00H
$SG3864	DB	'Roll:    %04x  %10.2f deg',  00H
$SG3866	DB	'Heading: %04x  %10.2f deg',  00H
$SG3868	DB	'Stern 1: %04x',  00H
$SG3870	DB	'Stern 2: %04x',  00H
$SG3872	DB	'Rudder:  %04x',  00H
$SG3874	DB	'Fore:    %04x',  00H
$SG3876	DB	'RawPos:    %08ld',  00H
$SG3878	DB	'RawIndex:    %08ld',  00H
$SG3880	DB	'PPos:    %08d',  00H
$SG3947	DB	'    Frame # ',  00H
$SG3948	DB	'Frame start:   ',  00H
$SG3949	DB	'%s%8lu %5u%s%8lu',  00H
$SG3951	DB	'OBS data:      ',  00H
$SG3952	DB	'%s%8lu %5u',  00H
$SG3954	DB	'Dyno data:     ',  00H
$SG3955	DB	'%s%8lu %5u',  00H
$SG3957	DB	'Prop adc:      ',  00H
$SG3958	DB	'%s%8lu %5u',  00H
$SG3960	DB	'Prop position: ',  00H
$SG3961	DB	'%s%8lu %5u',  00H
$SG3963	DB	'Commands rcvd: ',  00H
$SG3964	DB	'%s%8lu %5u',  00H
$SG3966	DB	'ADCP rcvd:     ',  00H
$SG3967	DB	'%s%8lu %5u',  00H
$SG3969	DB	'DS rcvd:       ',  00H
$SG3970	DB	'%s%8lu %5u',  00H
$SG3972	DB	'    LN200 # ',  00H
$SG3973	DB	'LN200 rcvd:    ',  00H
$SG3974	DB	'%s%8lu %5u%s%8lu ',  00H
$SG3976	DB	'Received packets: ',  00H
$SG3977	DB	'%s%lu',  00H
$SG3979	DB	'Ax0 count:        ',  00H
$SG3980	DB	'%s%lu',  00H
$SG3982	DB	'Ax1 count:        ',  00H
$SG3983	DB	'%s%lu',  00H
$SG3985	DB	'Discards:         ',  00H
$SG3986	DB	'%s%lu',  00H
$SG3988	DB	'Receiver calls:   ',  00H
$SG3989	DB	'%s%lu',  00H
$SG4050	DB	'                       Autonomous Model Onboard Computer    '
	DB	'                    ',  00H
$SG4051	DB	'%s',  00H
$SG4053	DB	'                               NSWC-CD Code 5600            '
	DB	'                    ',  00H
$SG4054	DB	'%s',  00H
$SG4056	DB	'                             March 8, 2004 Rev 0.8          '
	DB	'                    ',  00H
$SG4057	DB	'%s',  00H
	ORG	$+1
$S4074_?do_once@?1??prep_ln200_command@@ZAXXZ@4IE	DW	01H
_DATA      ENDS
XIFU      SEGMENT
$S4107__aao	DD	_aan
XIFU      ENDS
_BSS      SEGMENT
	ORG	$+3498
PUBLIC  ?com2_tx@@3IE
?com2_tx@@3IE	DW 01H DUP (?)
	ORG	$-838
PUBLIC  ?ds_buffer@@3QIEI
?ds_buffer@@3QIEI	DW 028H DUP (?)
_BSS      ENDS
DMMTEST13_DATA      SEGMENT
	ORG	$+2370
?prop@@3UPROP@@E	DW 015H DUP (?)
DMMTEST13_DATA      ENDS
_BSS      SEGMENT
	ORG	$+758
PUBLIC  ?com4_tx@@3IE
?com4_tx@@3IE	DW 01H DUP (?)
	ORG	$-760
PUBLIC  ?adcp_new_data@@3IE
?adcp_new_data@@3IE	DW 01H DUP (?)
PUBLIC  ?adcp_data_frame@@3KE
?adcp_data_frame@@3KE	DW 02H DUP (?)
_BSS      ENDS
XO      SEGMENT
$S4099__aam	DW 02H DUP (?)
XO      ENDS
_BSS      SEGMENT
PUBLIC  ?adcp_array@@3QIEI
?adcp_array@@3QIEI	DB 0d5H DUP (?)
	ORG	$+1
PUBLIC  ?adcp_buffer@@3QIEI
?adcp_buffer@@3QIEI	DB 0d5H DUP (?)
	ORG	$+1
PUBLIC  ?adcp_test@@3QIEI
?adcp_test@@3QIEI	DB 0d5H DUP (?)
	ORG	$+1
PUBLIC  ?gps_new_data@@3IE
?gps_new_data@@3IE	DW 01H DUP (?)
PUBLIC  ?gps_data_frame@@3KE
?gps_data_frame@@3KE	DW 02H DUP (?)
_BSS      ENDS
DMMTEST13_DATA      SEGMENT
	ORG	$+220
?adcp@@3UADCP@@E	DB 0e1H DUP (?)
DMMTEST13_DATA      ENDS
_BSS      SEGMENT
PUBLIC  ?gps_array@@3QIII
?gps_array@@3QIII	DW 04H DUP (?)
PUBLIC  ?gps_buffer@@3QIEI
?gps_buffer@@3QIEI	DW 028H DUP (?)
	ORG	$-3484
PUBLIC  ?pcm@@3QIDI
?pcm@@3QIDI	DW 078H DUP (?)
	ORG	$+3262
PUBLIC  ?ip_id@@3IE
?ip_id@@3IE	DW 01H DUP (?)
	ORG	$-3264
PUBLIC  ?s@@3QIDI
?s@@3QIDI	DB 051H DUP (?)
_BSS      ENDS
DMMTEST13_DATA      SEGMENT
	ORG	$-445
?ln200@@3ULN200@@E	DW 016H DUP (?)
DMMTEST13_DATA      ENDS
_BSS      SEGMENT
	ORG	$+1
PUBLIC  ?acoustic_message@@3QIDI
?acoustic_message@@3QIDI	DW 06H DUP (?)
_BSS      ENDS
DMMTEST13_DATA      SEGMENT
	ORG	$-2456
?cmd_buffer@@3QEEE	DW 03ecH DUP (?)
	ORG	$+850
?gps@@3UGPS@@E	DW 02eH DUP (?)
	ORG	$-942
?sys@@3USYS@@E	DW 09H DUP (?)
DMMTEST13_DATA      ENDS
_BSS      SEGMENT
PUBLIC  ?channela@@3IE
?channela@@3IE	DW 01H DUP (?)
PUBLIC  ?channelb@@3IE
?channelb@@3IE	DW 01H DUP (?)
PUBLIC  ?frame@@3KE
?frame@@3KE	DW 02H DUP (?)
PUBLIC  ?next_frame@@3KE
?next_frame@@3KE	DW 02H DUP (?)
PUBLIC  ?reading_prop@@3IE
?reading_prop@@3IE	DW 01H DUP (?)
_BSS      ENDS
DMMTEST13_DATA      SEGMENT
	ORG	$+430
?commands@@3UCOMMANDS@@E	DW 012H DUP (?)
DMMTEST13_DATA      ENDS
_BSS      SEGMENT
PUBLIC  ?data_pkt@@3QIEI
?data_pkt@@3QIEI	DW 02f5H DUP (?)
PUBLIC  ?obs_new_data@@3IE
?obs_new_data@@3IE	DW 01H DUP (?)
PUBLIC  ?obs_data_frame@@3KE
?obs_data_frame@@3KE	DW 02H DUP (?)
PUBLIC  ?obs_array@@3QIII
?obs_array@@3QIII	DW 020H DUP (?)
PUBLIC  ?obs_buffer@@3QIEI
?obs_buffer@@3QIEI	DW 020H DUP (?)
_BSS      ENDS
DMMTEST13_DATA      SEGMENT
	ORG	$+458
?sys_timer@@3UTIMER@@E	DW 03H DUP (?)
DMMTEST13_DATA      ENDS
_BSS      SEGMENT
PUBLIC  ?dyno_new_data@@3IE
?dyno_new_data@@3IE	DW 01H DUP (?)
_BSS      ENDS
DMMTEST13_DATA      SEGMENT
?frame_time@@3UTIMER@@E	DW 03H DUP (?)
	ORG	$-936
?obs@@3UOBS@@E	DW 026H DUP (?)
DMMTEST13_DATA      ENDS
_BSS      SEGMENT
PUBLIC  ?dyno_data_frame@@3KE
?dyno_data_frame@@3KE	DW 02H DUP (?)
_BSS      ENDS
DMMTEST13_DATA      SEGMENT
	ORG	$+860
?obs_time@@3UTIMER@@E	DW 03H DUP (?)
DMMTEST13_DATA      ENDS
_BSS      SEGMENT
PUBLIC  ?dyno_array@@3QIII
?dyno_array@@3QIII	DW 080H DUP (?)
_BSS      ENDS
DMMTEST13_DATA      SEGMENT
?dyno_time@@3UTIMER@@E	DW 03H DUP (?)
DMMTEST13_DATA      ENDS
_BSS      SEGMENT
PUBLIC  ?dyno_buffer@@3QIEI
?dyno_buffer@@3QIEI	DW 080H DUP (?)
_BSS      ENDS
DMMTEST13_DATA      SEGMENT
?prop_rpm_time@@3UTIMER@@E	DW 03H DUP (?)
DMMTEST13_DATA      ENDS
_BSS      SEGMENT
PUBLIC  ?prop_new_data@@3IE
?prop_new_data@@3IE	DW 01H DUP (?)
_BSS      ENDS
DMMTEST13_DATA      SEGMENT
?prop_position_time@@3UTIMER@@E	DW 03H DUP (?)
DMMTEST13_DATA      ENDS
_BSS      SEGMENT
PUBLIC  ?prop_data_frame@@3KE
?prop_data_frame@@3KE	DW 02H DUP (?)
_BSS      ENDS
DMMTEST13_DATA      SEGMENT
?prop_position_time_previous@@3UTIMER@@E	DW 03H DUP (?)
DMMTEST13_DATA      ENDS
_BSS      SEGMENT
PUBLIC  ?prop_rpm@@3HE
?prop_rpm@@3HE	DW 01H DUP (?)
_BSS      ENDS
DMMTEST13_DATA      SEGMENT
?prop_adc_time@@3UTIMER@@E	DW 03H DUP (?)
?ln200_time@@3UTIMER@@E	DW 03H DUP (?)
DMMTEST13_DATA      ENDS
_BSS      SEGMENT
PUBLIC  ?prop_report@@3JE
?prop_report@@3JE	DW 02H DUP (?)
_BSS      ENDS
DMMTEST13_DATA      SEGMENT
	ORG	$-512
?echo@@3UECHO@@E	DW 018H DUP (?)
	ORG	$+464
?cmds_time@@3UTIMER@@E	DW 03H DUP (?)
DMMTEST13_DATA      ENDS
_BSS      SEGMENT
PUBLIC  ?index_report@@3JE
?index_report@@3JE	DW 02H DUP (?)
_BSS      ENDS
DMMTEST13_DATA      SEGMENT
?ds_time@@3UTIMER@@E	DW 03H DUP (?)
?adcp_time@@3UTIMER@@E	DW 03H DUP (?)
?gps_time@@3UTIMER@@E	DW 03H DUP (?)
DMMTEST13_DATA      ENDS
_BSS      SEGMENT
PUBLIC  ?rpm_sf@@3ME
?rpm_sf@@3ME	DW 02H DUP (?)
	ORG	$+950
PUBLIC  ?old_dmm32a_vect@@3P7AXXZE
?old_dmm32a_vect@@3P7AXXZE	DW 02H DUP (?)
	ORG	$-954
PUBLIC  ?prop_array@@3QIII
?prop_array@@3QIII	DW 06H DUP (?)
_BSS      ENDS
DMMTEST13_DATA      SEGMENT
	ORG	$-926
?dyno@@3UDYNO@@E	DW 086H DUP (?)
DMMTEST13_DATA      ENDS
_BSS      SEGMENT
PUBLIC  ?prop_buffer@@3QIEI
?prop_buffer@@3QIEI	DW 06H DUP (?)
	ORG	$+930
PUBLIC  ?old_dmm32b_vect@@3P7AXXZE
?old_dmm32b_vect@@3P7AXXZE	DW 02H DUP (?)
	ORG	$-934
PUBLIC  ?ln200_new_data@@3IE
?ln200_new_data@@3IE	DW 01H DUP (?)
PUBLIC  ?ln200_data_frame@@3KE
?ln200_data_frame@@3KE	DW 02H DUP (?)
	ORG	$+928
PUBLIC  ?rtc_vect@@3P7AXXZE
?rtc_vect@@3P7AXXZE	DW 02H DUP (?)
	ORG	$-932
PUBLIC  ?ln200_buffer@@3QIEI
?ln200_buffer@@3QIEI	DW 010H DUP (?)
_BSS      ENDS
DMMTEST13_DATA      SEGMENT
	ORG	$+658
?settings@@3Uescc_regs@@E	DW 01fH DUP (?)
DMMTEST13_DATA      ENDS
_BSS      SEGMENT
PUBLIC  ?ln200_command@@3QIDI
?ln200_command@@3QIDI	DW 07H DUP (?)
_BSS      ENDS
DMMTEST13_DATA      SEGMENT
?escc1@@3VCescc@@E	DW 0d1H DUP (?)
DMMTEST13_DATA      ENDS
_BSS      SEGMENT
PUBLIC  ?echo_new_data@@3IE
?echo_new_data@@3IE	DW 01H DUP (?)
PUBLIC  ?echo_data_frame@@3KE
?echo_data_frame@@3KE	DW 02H DUP (?)
_BSS      ENDS
DMMTEST13_DATA      SEGMENT
	ORG	$-968
?ds@@3UDS@@E	DW 02eH DUP (?)
DMMTEST13_DATA      ENDS
_BSS      SEGMENT
PUBLIC  ?echo_array@@3QIII
?echo_array@@3QIII	DW 08H DUP (?)
PUBLIC  ?echo_buffer@@3QIEI
?echo_buffer@@3QIEI	DW 08H DUP (?)
PUBLIC  ?ds_new_data@@3IE
?ds_new_data@@3IE	DW 01H DUP (?)
PUBLIC  ?ds_data_frame@@3KE
?ds_data_frame@@3KE	DW 02H DUP (?)
	ORG	$+842
PUBLIC  ?com1_tx@@3IE
?com1_tx@@3IE	DW 01H DUP (?)
	ORG	$-844
PUBLIC  ?ds_array@@3QIII
?ds_array@@3QIII	DW 04H DUP (?)
_BSS      ENDS
DMMTEST_TEXT      SEGMENT
	ASSUME	CS: DMMTEST_TEXT
	PUBLIC	?PC_DispChar@@ZAXEEEE@Z	; PC_DispChar
?PC_DispChar@@ZAXEEEE@Z	PROC FAR	; PC_DispChar
;|*** // dmmtest.cpp
;|*** // 2/18/2004
;|*** 
;|*** /* modified 9/25/2007 jtm for TB model
;|***    1) implement starboard and port prop control using tech80 ch 1&2
;|***    2) report starbord rpm on OBS MCV channel, port rpm on MCI channel
;|*** */
;|*** 
;|*** #include <bios.h>
;|*** #include <time.h>
;|*** #include <process.h>
;|*** #include <stdlib.h>
;|*** #include "dmmtest.h"
;|*** #include "esccauto.h"
;|*** #include "dmm32.h"
;|*** #include "rs232.h"
;|*** #include "uio48.h"
;|*** #include "ether.h"
;|*** #include "pc.c"
;|*** #include "commands.h"
;|*** #include <conio.h>
;|*** #include <stdio.h>
;|*** #include <iostream.h>
;|*** #include <dos.h>
;|*** #include <string.h>
;|*** extern "C"
;|***  {
;|***  #include "c:\tech80\c\te5650.h"
;|***  }
;|*** 
;|*** //char pcm[96]; // old decom
;|*** char pcm[2*PCMLEN];  // new decom
;|*** unsigned pcm_sent = 0;
;|*** char s[81];
;|*** 
;|*** char acoustic_message[12];        // 8/9/06 JTM char string to send to shore thru acoustic modem
;|*** int  send_message = 0;          // flag indicates valid acoustic message is ready to send
;|*** 
;|*** //unsigned char obc_mac[6]    =  {0x00, 0x01, 0x45, 0x00, 0x7a, 0x73};
;|*** //unsigned char obc_mac[6]    =  {0x00, 0x01, 0x45, 0x00, 0x7a, 0xa0};
;|*** //unsigned char obc_mac[6]    =  {0x00, 0x01, 0x45, 0x00, 0x7a, 0xbb};
;|*** //unsigned char obc_mac[6]    =  {0x00, 0x01, 0x45, 0x00, 0x7a, 0x9a};
;|*** unsigned char obc_mac[6]    =  {0x00, 0x01, 0x45, 0x00, 0x7a, 0xb0};
;|*** unsigned char micron_mac[6] =  {0x08, 0x00, 0x17, 0x08, 0x87, 0x4d};
;|*** unsigned char control_mac[6] = {0x00, 0x01, 0x45, 0x00, 0x8a, 0x21};
;|*** unsigned char broadcast_mac[6] = {0xff, 0xff, 0xff, 0xff, 0xff, 0xff};
;|*** unsigned char shore_mac[6] =   {0x00, 0x0e, 0xa6, 0xb6, 0xc0, 0x4e};
;|*** 
;|*** unsigned char far cmd_buffer[2008]; // command packet buffer
;|*** 
;|*** long unsigned sys_frame = 0;
;|*** unsigned int  sys_status = 0;
;|*** 
;|*** unsigned channela, channelb;
;|*** unsigned long frame, next_frame;
;|*** unsigned reading_prop;
;|*** unsigned mux_addr = 0;
;|*** 
;|*** unsigned char data_pkt[1514];
;|*** 
;|*** unsigned      obs_new_data;
;|*** unsigned long obs_data_frame;
;|*** unsigned      obs_array[32];
;|*** unsigned char obs_buffer[64];
;|*** 
;|*** unsigned      dyno_new_data;
;|*** unsigned long dyno_data_frame;
;|*** unsigned      dyno_array[128];
;|*** unsigned char dyno_buffer[256];
;|*** 
;|*** unsigned      prop_new_data;
;|*** unsigned long prop_data_frame;
;|*** int           prop_rpm;
;|*** long int      prop_position = 0;
;|*** long int      prop_report;  // for on-screen
;|*** long int      index_report;
;|*** long int      prop_index = 0;
;|*** long int      prop_position_absolute_current = 0;
;|*** long int      prop_position_absolute_previous = 0;
; Line 79
	*** 000000	c8 06 00 00 		enter	6,0
	*** 000004	57 			push	di
	*** 000005	56 			push	si
;	pscr = -4
;	offset = -6
;	color = 12
;	c = 10
;	y = 8
;	x = 6
;|*** float         rpm_sf;
;|*** unsigned      prop_array[6];
;|*** unsigned char prop_buffer[12];
;|*** 
;|*** unsigned      ln200_new_data;
; Line 84
	*** 000006	b0 50 			mov	al,80	;0050H
	*** 000008	f6 66 08 		mul	BYTE PTR [bp+8]	;y
	*** 00000b	8a 4e 06 		mov	cl,BYTE PTR [bp+6]	;x
	*** 00000e	2a ed 			sub	ch,ch
	*** 000010	03 c1 			add	ax,cx
	*** 000012	d1 e0 			shl	ax,1
	*** 000014	89 46 fa 		mov	WORD PTR [bp-6],ax	;offset
;|*** unsigned long ln200_data_frame;
; Line 85
	*** 000017	8b 46 fa 		mov	ax,WORD PTR [bp-6]	;offset
	*** 00001a	2b d2 			sub	dx,dx
	*** 00001c	2d 00 00 		sub	ax,0
	*** 00001f	81 da 00 48 		sbb	dx,18432	;4800H
	*** 000023	89 46 fc 		mov	WORD PTR [bp-4],ax	;pscr
	*** 000026	89 56 fe 		mov	WORD PTR [bp-2],dx
;|*** unsigned char ln200_buffer[32];
; Line 86
	*** 000029	8a 46 0a 		mov	al,BYTE PTR [bp+10]	;c
	*** 00002c	c4 5e fc 		les	bx,DWORD PTR [bp-4]	;pscr
	*** 00002f	ff 46 fc 		inc	WORD PTR [bp-4]	;pscr
	*** 000032	26 88 07 		mov	BYTE PTR es:[bx],al
;|*** char          ln200_command[14];
; Line 87
	*** 000035	8a 46 0c 		mov	al,BYTE PTR [bp+12]	;color
	*** 000038	c4 5e fc 		les	bx,DWORD PTR [bp-4]	;pscr
	*** 00003b	26 88 07 		mov	BYTE PTR es:[bx],al
;|*** unsigned long ln200_rx_num = 0;
; Line 88
	*** 00003e	e9 00 00 		jmp	$EX1505
					$EX1505:
	*** 000041	5e 			pop	si
	*** 000042	5f 			pop	di
	*** 000043	c9 			leave	
	*** 000044	cb 			ret	

?PC_DispChar@@ZAXEEEE@Z	ENDP
	PUBLIC	?PC_DispClrCol@@ZAXEE@Z	; PC_DispClrCol
?PC_DispClrCol@@ZAXEE@Z	PROC FAR	; PC_DispClrCol
;|*** 
;|*** unsigned      echo_new_data;
;|*** unsigned long echo_data_frame;
;|*** unsigned      echo_array[8];
;|*** unsigned char echo_buffer[16];
;|*** 
;|*** unsigned      ds_new_data;
;|*** unsigned long ds_data_frame;
;|*** unsigned      ds_array[4];
;|*** unsigned char ds_buffer[80];
;|*** 
;|*** unsigned      adcp_new_data;
;|*** unsigned long adcp_data_frame;
;|*** //unsigned char adcp_array[88];
;|*** unsigned char adcp_array[213];
;|*** //unsigned char adcp_buffer[88];
;|*** unsigned char adcp_buffer[213];
;|*** //unsigned char adcp_test[88];
;|*** unsigned char adcp_test[213];
;|*** 
;|*** unsigned      gps_new_data;
;|*** unsigned long gps_data_frame;
; Line 110
	*** 000045	c8 06 00 00 		enter	6,0
	*** 000049	57 			push	di
	*** 00004a	56 			push	si
;	pscr = -4
;	i = -6
;	color = 8
;	x = 6
;|*** unsigned      gps_array[4];
;|*** unsigned char gps_buffer[80];
;|*** 
;|*** struct SYS
;|***   {
; Line 115
	*** 00004b	8a 46 06 		mov	al,BYTE PTR [bp+6]	;x
	*** 00004e	2a e4 			sub	ah,ah
	*** 000050	2b d2 			sub	dx,dx
	*** 000052	2d 00 00 		sub	ax,0
	*** 000055	81 da 00 24 		sbb	dx,9216	;2400H
	*** 000059	d1 e0 			shl	ax,1
	*** 00005b	d1 d2 			rcl	dx,1
	*** 00005d	89 46 fc 		mov	WORD PTR [bp-4],ax	;pscr
	*** 000060	89 56 fe 		mov	WORD PTR [bp-2],dx
;|***   unsigned int  packet_type;
; Line 116
	*** 000063	c6 46 fa 00 		mov	BYTE PTR [bp-6],0	;i
	*** 000067	e9 03 00 		jmp	$F1526
					$FC1527:
	*** 00006a	fe 46 fa 		inc	BYTE PTR [bp-6]	;i
					$F1526:
	*** 00006d	80 7e fa 19 		cmp	BYTE PTR [bp-6],25	;0019H	;i
	*** 000071	72 03 			jb	$JCC113
	*** 000073	e9 1b 00 		jmp	$FB1528
					$JCC113:
;|***   unsigned int  packet_number;
; Line 117
	*** 000076	c4 5e fc 		les	bx,DWORD PTR [bp-4]	;pscr
	*** 000079	ff 46 fc 		inc	WORD PTR [bp-4]	;pscr
	*** 00007c	26 c6 07 20 		mov	BYTE PTR es:[bx],32	;0020H
;|***   unsigned long frame;
; Line 118
	*** 000080	8a 46 08 		mov	al,BYTE PTR [bp+8]	;color
	*** 000083	c4 5e fc 		les	bx,DWORD PTR [bp-4]	;pscr
	*** 000086	26 88 07 		mov	BYTE PTR es:[bx],al
;|***   unsigned int  fs_status;
; Line 119
	*** 000089	81 46 fc a0 00 		add	WORD PTR [bp-4],160	;00a0H	;pscr
;|***   unsigned int  op_status;
; Line 120
	*** 00008e	e9 d9 ff 		jmp	$FC1527
					$FB1528:
;|***   unsigned long time_high;
; Line 121
	*** 000091	e9 00 00 		jmp	$EX1517
					$EX1517:
	*** 000094	5e 			pop	si
	*** 000095	5f 			pop	di
	*** 000096	c9 			leave	
	*** 000097	cb 			ret	

?PC_DispClrCol@@ZAXEE@Z	ENDP
	PUBLIC	?PC_DispClrRow@@ZAXEE@Z	; PC_DispClrRow
?PC_DispClrRow@@ZAXEE@Z	PROC FAR	; PC_DispClrRow
;|***   unsigned int  time_low;
;|***   } sys;
;|***   
;|*** 
;|*** struct OBS
;|***   {
;|***   unsigned int  new_data;
;|***   long unsigned frame;
;|***   unsigned long time_high;
;|***   unsigned int  time_low;
;|***   unsigned int  data[32];
;|***   } obs;  
;|***   
;|*** 
;|*** struct DYNO
;|***   {
;|***   unsigned int  new_data;
;|***   long unsigned frame;
;|***   unsigned long time_high;
;|***   unsigned int  time_low;
;|***   unsigned int  data[128];
;|***   } dyno;
; Line 143
	*** 000098	c8 06 00 00 		enter	6,0
	*** 00009c	57 			push	di
	*** 00009d	56 			push	si
;	pscr = -4
;	i = -6
;	color = 8
;	y = 6
;|***   
;|*** 
;|*** struct PROP
;|***   {
;|***   unsigned int  new_data;
; Line 148
	*** 00009e	8a 46 06 		mov	al,BYTE PTR [bp+6]	;y
	*** 0000a1	2a e4 			sub	ah,ah
	*** 0000a3	b9 a0 00 		mov	cx,160	;00a0H
	*** 0000a6	f7 e1 			mul	cx
	*** 0000a8	2d 00 00 		sub	ax,0
	*** 0000ab	81 da 00 48 		sbb	dx,18432	;4800H
	*** 0000af	89 46 fc 		mov	WORD PTR [bp-4],ax	;pscr
	*** 0000b2	89 56 fe 		mov	WORD PTR [bp-2],dx
;|***   long unsigned frame;
; Line 149
	*** 0000b5	c6 46 fa 00 		mov	BYTE PTR [bp-6],0	;i
	*** 0000b9	e9 03 00 		jmp	$F1540
					$FC1541:
	*** 0000bc	fe 46 fa 		inc	BYTE PTR [bp-6]	;i
					$F1540:
	*** 0000bf	80 7e fa 50 		cmp	BYTE PTR [bp-6],80	;0050H	;i
	*** 0000c3	72 03 			jb	$JCC195
	*** 0000c5	e9 19 00 		jmp	$FB1542
					$JCC195:
;|***   unsigned long rpm_time_high;
; Line 150
	*** 0000c8	c4 5e fc 		les	bx,DWORD PTR [bp-4]	;pscr
	*** 0000cb	ff 46 fc 		inc	WORD PTR [bp-4]	;pscr
	*** 0000ce	26 c6 07 20 		mov	BYTE PTR es:[bx],32	;0020H
;|***   unsigned int  rpm_time_low;
; Line 151
	*** 0000d2	8a 46 08 		mov	al,BYTE PTR [bp+8]	;color
	*** 0000d5	c4 5e fc 		les	bx,DWORD PTR [bp-4]	;pscr
	*** 0000d8	ff 46 fc 		inc	WORD PTR [bp-4]	;pscr
	*** 0000db	26 88 07 		mov	BYTE PTR es:[bx],al
;|***   unsigned long position_time_high;
; Line 152
	*** 0000de	e9 db ff 		jmp	$FC1541
					$FB1542:
;|***   unsigned int  position_time_low;
; Line 153
	*** 0000e1	e9 00 00 		jmp	$EX1531
					$EX1531:
	*** 0000e4	5e 			pop	si
	*** 0000e5	5f 			pop	di
	*** 0000e6	c9 			leave	
	*** 0000e7	cb 			ret	

?PC_DispClrRow@@ZAXEE@Z	ENDP
	PUBLIC	?PC_DispClrScr@@ZAXE@Z	; PC_DispClrScr
?PC_DispClrScr@@ZAXE@Z	PROC FAR	; PC_DispClrScr
;|***   unsigned long adc_time_high;
;|***   unsigned int  adc_time_low;
;|***   int           rpm;
;|***   long int      position;
;|***   unsigned int  data[6];    
;|***   } prop;
;|***   
;|*** 
;|*** struct LN200
;|***   {
;|***   unsigned int  new_data;
;|***   long unsigned frame;
;|***   unsigned long time_high;
;|***   unsigned int  time_low;
;|***   int  data[16];
;|***   } ln200;
;|*** 
;|***   
;|*** struct COMMANDS  // new 12/8/2004
; Line 172
	*** 0000e8	c8 06 00 00 		enter	6,0
	*** 0000ec	57 			push	di
	*** 0000ed	56 			push	si
;	pscr = -4
;	i = -6
;	color = 6
;|***   {
;|***   unsigned int  sync_word;
;|***   unsigned int  mode;
;|***   //unsigned int  rpm;
;|***   // changed for TB model 9/26/2007 jtm
; Line 177
	*** 0000ee	c7 46 fc 00 00 		mov	WORD PTR [bp-4],0	;pscr
	*** 0000f3	c7 46 fe 00 b8 		mov	WORD PTR [bp-2],-18432	;b800H
;|***   unsigned int  stbd_rpm;
; Line 178
	*** 0000f8	c7 46 fa 00 00 		mov	WORD PTR [bp-6],0	;i
	*** 0000fd	e9 03 00 		jmp	$F1552
					$FC1553:
	*** 000100	ff 46 fa 		inc	WORD PTR [bp-6]	;i
					$F1552:
	*** 000103	81 7e fa d0 07 		cmp	WORD PTR [bp-6],2000	;07d0H	;i
	*** 000108	72 03 			jb	$JCC264
	*** 00010a	e9 19 00 		jmp	$FB1554
					$JCC264:
;|***   unsigned int  rudder;
; Line 179
	*** 00010d	c4 5e fc 		les	bx,DWORD PTR [bp-4]	;pscr
	*** 000110	ff 46 fc 		inc	WORD PTR [bp-4]	;pscr
	*** 000113	26 c6 07 20 		mov	BYTE PTR es:[bx],32	;0020H
;|***   unsigned int  stern1;
; Line 180
	*** 000117	8a 46 06 		mov	al,BYTE PTR [bp+6]	;color
	*** 00011a	c4 5e fc 		les	bx,DWORD PTR [bp-4]	;pscr
	*** 00011d	ff 46 fc 		inc	WORD PTR [bp-4]	;pscr
	*** 000120	26 88 07 		mov	BYTE PTR es:[bx],al
;|***   unsigned int  stern2;
; Line 181
	*** 000123	e9 da ff 		jmp	$FC1553
					$FB1554:
;|***   unsigned int  fore;  
; Line 182
	*** 000126	e9 00 00 		jmp	$EX1544
					$EX1544:
	*** 000129	5e 			pop	si
	*** 00012a	5f 			pop	di
	*** 00012b	c9 			leave	
	*** 00012c	cb 			ret	

?PC_DispClrScr@@ZAXE@Z	ENDP
	PUBLIC	?PC_DispStr@@ZAXEEPIEE@Z	; PC_DispStr
?PC_DispStr@@ZAXEEPIEE@Z	PROC FAR	; PC_DispStr
;|***   unsigned int  ballast;
;|***   unsigned int  ln200_mode;
;|***   unsigned int  ln200_init_heading;
;|***   unsigned int  ln200_init_latitude;
;|*** /*  
;|***   unsigned int  adcp_reset;
;|***   unsigned int  adcp_heading;
;|***   unsigned int  ds_send_message;
;|***   unsigned int  ds_dmgx;
;|***   unsigned int  ds_dmgy;
;|***   unsigned int  ds_dmgz;
;|***   unsigned int  spare1;
;|*** */
;|***   unsigned int  ds_send_message;   // new 8/9/06 JTM
;|***   unsigned int  ds_dmgx1;
;|***   unsigned int  ds_dmgx2;
;|***   unsigned int  ds_dmgy1;
;|***   unsigned int  ds_dmgy2;
;|***   unsigned int  ds_dmgz1;
;|***   
;|***   // changed for TB model port prop 9/25/2007 jtm
;|***   //unsigned int  ds_dmgz2;
;|***   unsigned int  port_rpm;
;|***   } commands;  
;|*** 
;|*** int time_since_last_command = 0;
;|*** 
; Line 209
	*** 00012d	c8 06 00 00 		enter	6,0
	*** 000131	57 			push	di
	*** 000132	56 			push	si
;	pscr = -4
;	offset = -6
;	color = 14
;	s = 10
;	y = 8
;	x = 6
;|*** struct ECHO            // new 12/08/2004
;|***   {
;|***   unsigned int  new_data;
;|***   unsigned long frame;
;|***   unsigned long time_high;
; Line 214
	*** 000133	b0 50 			mov	al,80	;0050H
	*** 000135	f6 66 08 		mul	BYTE PTR [bp+8]	;y
	*** 000138	8a 4e 06 		mov	cl,BYTE PTR [bp+6]	;x
	*** 00013b	2a ed 			sub	ch,ch
	*** 00013d	03 c1 			add	ax,cx
	*** 00013f	d1 e0 			shl	ax,1
	*** 000141	89 46 fa 		mov	WORD PTR [bp-6],ax	;offset
;|***   unsigned int  time_low;
; Line 215
	*** 000144	8b 46 fa 		mov	ax,WORD PTR [bp-6]	;offset
	*** 000147	2b d2 			sub	dx,dx
	*** 000149	2d 00 00 		sub	ax,0
	*** 00014c	81 da 00 48 		sbb	dx,18432	;4800H
	*** 000150	89 46 fc 		mov	WORD PTR [bp-4],ax	;pscr
	*** 000153	89 56 fe 		mov	WORD PTR [bp-2],dx
;|***   unsigned char data[sizeof(commands)];
; Line 216
					$FC1570:
	*** 000156	c4 5e 0a 		les	bx,DWORD PTR [bp+10]	;s
	*** 000159	26 80 3f 00 		cmp	BYTE PTR es:[bx],0
	*** 00015d	75 03 			jne	$JCC349
	*** 00015f	e9 2c 00 		jmp	$FB1571
					$JCC349:
;|***   } echo;
; Line 217
	*** 000162	c4 5e 0a 		les	bx,DWORD PTR [bp+10]	;s
	*** 000165	83 46 0a 01 		add	WORD PTR [bp+10],1	;s
	*** 000169	72 03 			jb	$JCC361
	*** 00016b	e9 05 00 		jmp	$L4109
					$JCC361:
	*** 00016e	81 46 0c 00 00 		add	WORD PTR [bp+12],OFFSET __AHINCR
					$L4109:
	*** 000173	26 8a 07 		mov	al,BYTE PTR es:[bx]
	*** 000176	c4 5e fc 		les	bx,DWORD PTR [bp-4]	;pscr
	*** 000179	ff 46 fc 		inc	WORD PTR [bp-4]	;pscr
	*** 00017c	26 88 07 		mov	BYTE PTR es:[bx],al
;|*** 
; Line 218
	*** 00017f	8a 46 0e 		mov	al,BYTE PTR [bp+14]	;color
	*** 000182	c4 5e fc 		les	bx,DWORD PTR [bp-4]	;pscr
	*** 000185	ff 46 fc 		inc	WORD PTR [bp-4]	;pscr
	*** 000188	26 88 07 		mov	BYTE PTR es:[bx],al
;|*** struct DS
; Line 219
	*** 00018b	e9 c8 ff 		jmp	$FC1570
					$FB1571:
;|***   {
; Line 220
	*** 00018e	e9 00 00 		jmp	$EX1559
					$EX1559:
	*** 000191	5e 			pop	si
	*** 000192	5f 			pop	di
	*** 000193	c9 			leave	
	*** 000194	cb 			ret	

?PC_DispStr@@ZAXEEPIEE@Z	ENDP

_aaj	PROC FAR
;|*** // dmmtest.cpp
;|*** // 2/18/2004
;|*** 
;|*** /* modified 9/25/2007 jtm for TB model
;|***    1) implement starboard and port prop control using tech80 ch 1&2
;|***    2) report starbord rpm on OBS MCV channel, port rpm on MCI channel
;|*** */
;|*** 
;|*** #include <bios.h>
;|*** #include <time.h>
;|*** #include <process.h>
;|*** #include <stdlib.h>
;|*** #include "dmmtest.h"
;|*** #include "esccauto.h"
;|*** #include "dmm32.h"
;|*** #include "rs232.h"
;|*** #include "uio48.h"
;|*** #include "ether.h"
;|*** #include "pc.c"
;|*** #include "commands.h"
;|*** #include <conio.h>
;|*** #include <stdio.h>
;|*** #include <iostream.h>
;|*** #include <dos.h>
;|*** #include <string.h>
;|*** extern "C"
;|***  {
;|***  #include "c:\tech80\c\te5650.h"
;|***  }
;|*** 
;|*** //char pcm[96]; // old decom
;|*** char pcm[2*PCMLEN];  // new decom
;|*** unsigned pcm_sent = 0;
;|*** char s[81];
;|*** 
;|*** char acoustic_message[12];        // 8/9/06 JTM char string to send to shore thru acoustic modem
;|*** int  send_message = 0;          // flag indicates valid acoustic message is ready to send
;|*** 
;|*** //unsigned char obc_mac[6]    =  {0x00, 0x01, 0x45, 0x00, 0x7a, 0x73};
;|*** //unsigned char obc_mac[6]    =  {0x00, 0x01, 0x45, 0x00, 0x7a, 0xa0};
;|*** //unsigned char obc_mac[6]    =  {0x00, 0x01, 0x45, 0x00, 0x7a, 0xbb};
;|*** //unsigned char obc_mac[6]    =  {0x00, 0x01, 0x45, 0x00, 0x7a, 0x9a};
;|*** unsigned char obc_mac[6]    =  {0x00, 0x01, 0x45, 0x00, 0x7a, 0xb0};
;|*** unsigned char micron_mac[6] =  {0x08, 0x00, 0x17, 0x08, 0x87, 0x4d};
;|*** unsigned char control_mac[6] = {0x00, 0x01, 0x45, 0x00, 0x8a, 0x21};
;|*** unsigned char broadcast_mac[6] = {0xff, 0xff, 0xff, 0xff, 0xff, 0xff};
;|*** unsigned char shore_mac[6] =   {0x00, 0x0e, 0xa6, 0xb6, 0xc0, 0x4e};
;|*** 
;|*** unsigned char far cmd_buffer[2008]; // command packet buffer
;|*** 
;|*** long unsigned sys_frame = 0;
;|*** unsigned int  sys_status = 0;
;|*** 
;|*** unsigned channela, channelb;
;|*** unsigned long frame, next_frame;
;|*** unsigned reading_prop;
;|*** unsigned mux_addr = 0;
;|*** 
;|*** unsigned char data_pkt[1514];
;|*** 
;|*** unsigned      obs_new_data;
;|*** unsigned long obs_data_frame;
;|*** unsigned      obs_array[32];
;|*** unsigned char obs_buffer[64];
;|*** 
;|*** unsigned      dyno_new_data;
;|*** unsigned long dyno_data_frame;
;|*** unsigned      dyno_array[128];
;|*** unsigned char dyno_buffer[256];
;|*** 
;|*** unsigned      prop_new_data;
;|*** unsigned long prop_data_frame;
;|*** int           prop_rpm;
;|*** long int      prop_position = 0;
;|*** long int      prop_report;  // for on-screen
;|*** long int      index_report;
;|*** long int      prop_index = 0;
;|*** long int      prop_position_absolute_current = 0;
;|*** long int      prop_position_absolute_previous = 0;
;|*** float         rpm_sf;
;|*** unsigned      prop_array[6];
;|*** unsigned char prop_buffer[12];
;|*** 
;|*** unsigned      ln200_new_data;
;|*** unsigned long ln200_data_frame;
;|*** unsigned char ln200_buffer[32];
;|*** char          ln200_command[14];
;|*** unsigned long ln200_rx_num = 0;
;|*** 
;|*** unsigned      echo_new_data;
;|*** unsigned long echo_data_frame;
;|*** unsigned      echo_array[8];
;|*** unsigned char echo_buffer[16];
;|*** 
;|*** unsigned      ds_new_data;
;|*** unsigned long ds_data_frame;
;|*** unsigned      ds_array[4];
;|*** unsigned char ds_buffer[80];
;|*** 
;|*** unsigned      adcp_new_data;
;|*** unsigned long adcp_data_frame;
;|*** //unsigned char adcp_array[88];
;|*** unsigned char adcp_array[213];
;|*** //unsigned char adcp_buffer[88];
;|*** unsigned char adcp_buffer[213];
;|*** //unsigned char adcp_test[88];
;|*** unsigned char adcp_test[213];
;|*** 
;|*** unsigned      gps_new_data;
;|*** unsigned long gps_data_frame;
;|*** unsigned      gps_array[4];
;|*** unsigned char gps_buffer[80];
;|*** 
;|*** struct SYS
;|***   {
;|***   unsigned int  packet_type;
;|***   unsigned int  packet_number;
;|***   unsigned long frame;
;|***   unsigned int  fs_status;
;|***   unsigned int  op_status;
;|***   unsigned long time_high;
;|***   unsigned int  time_low;
;|***   } sys;
;|***   
;|*** 
;|*** struct OBS
;|***   {
;|***   unsigned int  new_data;
;|***   long unsigned frame;
;|***   unsigned long time_high;
;|***   unsigned int  time_low;
;|***   unsigned int  data[32];
;|***   } obs;  
;|***   
;|*** 
;|*** struct DYNO
;|***   {
;|***   unsigned int  new_data;
;|***   long unsigned frame;
;|***   unsigned long time_high;
;|***   unsigned int  time_low;
;|***   unsigned int  data[128];
;|***   } dyno;
;|***   
;|*** 
;|*** struct PROP
;|***   {
;|***   unsigned int  new_data;
;|***   long unsigned frame;
;|***   unsigned long rpm_time_high;
;|***   unsigned int  rpm_time_low;
;|***   unsigned long position_time_high;
;|***   unsigned int  position_time_low;
;|***   unsigned long adc_time_high;
;|***   unsigned int  adc_time_low;
;|***   int           rpm;
;|***   long int      position;
;|***   unsigned int  data[6];    
;|***   } prop;
;|***   
;|*** 
;|*** struct LN200
;|***   {
;|***   unsigned int  new_data;
;|***   long unsigned frame;
;|***   unsigned long time_high;
;|***   unsigned int  time_low;
;|***   int  data[16];
;|***   } ln200;
;|*** 
;|***   
;|*** struct COMMANDS  // new 12/8/2004
;|***   {
;|***   unsigned int  sync_word;
;|***   unsigned int  mode;
;|***   //unsigned int  rpm;
;|***   // changed for TB model 9/26/2007 jtm
;|***   unsigned int  stbd_rpm;
;|***   unsigned int  rudder;
;|***   unsigned int  stern1;
;|***   unsigned int  stern2;
;|***   unsigned int  fore;  
;|***   unsigned int  ballast;
;|***   unsigned int  ln200_mode;
;|***   unsigned int  ln200_init_heading;
;|***   unsigned int  ln200_init_latitude;
;|*** /*  
;|***   unsigned int  adcp_reset;
;|***   unsigned int  adcp_heading;
;|***   unsigned int  ds_send_message;
;|***   unsigned int  ds_dmgx;
;|***   unsigned int  ds_dmgy;
;|***   unsigned int  ds_dmgz;
;|***   unsigned int  spare1;
;|*** */
;|***   unsigned int  ds_send_message;   // new 8/9/06 JTM
;|***   unsigned int  ds_dmgx1;
;|***   unsigned int  ds_dmgx2;
;|***   unsigned int  ds_dmgy1;
;|***   unsigned int  ds_dmgy2;
;|***   unsigned int  ds_dmgz1;
;|***   
;|***   // changed for TB model port prop 9/25/2007 jtm
;|***   //unsigned int  ds_dmgz2;
;|***   unsigned int  port_rpm;
;|***   } commands;  
;|*** 
;|*** int time_since_last_command = 0;
;|*** 
;|*** struct ECHO            // new 12/08/2004
;|***   {
;|***   unsigned int  new_data;
;|***   unsigned long frame;
;|***   unsigned long time_high;
;|***   unsigned int  time_low;
;|***   unsigned char data[sizeof(commands)];
;|***   } echo;
;|*** 
;|*** struct DS
;|***   {
;|***   unsigned int  new_data;
;|***   long unsigned frame;
;|***   unsigned long time_high;
;|***   unsigned int  time_low;
;|***   unsigned char  data[80];
;|***   } ds;
;|***   
;|*** struct ADCP
;|***   {
;|***   unsigned int  new_data;
;|***   long unsigned frame;
;|***   unsigned long time_high;
;|***   unsigned int  time_low;
;|***   //unsigned char  data[88];  
;|***   unsigned char  data[213];  
;|***   } adcp;
;|*** 
;|*** struct GPS
;|***   {
;|***   unsigned int  new_data;
;|***   long unsigned frame;
;|***   unsigned long time_high;
;|***   unsigned int  time_low;
;|***   unsigned char  data[80];
;|***   } gps;
;|***  
;|*** struct TIMER
;|***   {
;|***   unsigned long high;
;|***   unsigned int  low;
;|***   }     sys_timer,
;|***         frame_time,
;|***         obs_time,
;|***         dyno_time,
;|***         prop_rpm_time,
;|***         prop_position_time,
;|***         prop_position_time_previous,
;|***         prop_adc_time,        
;|***         ln200_time,
;|***         cmds_time,
;|***         ds_time,
;|***         adcp_time,
;|***         gps_time;
;|*** 
;|*** void (interrupt far * old_dmm32a_vect)();
;|*** void (interrupt far * old_dmm32b_vect)();
;|*** void (interrupt far * rtc_vect)();
;|*** 
;|*** struct escc_regs settings;
;|*** Cescc escc1;
; Line 270
	*** 000195	c8 00 00 00 		enter	0,0
	*** 000199	57 			push	di
	*** 00019a	56 			push	si
	*** 00019b	68 00 00 		push	SEG ?escc1@@3VCescc@@E	;escc1
	*** 00019e	68 00 00 		push	OFFSET ?escc1@@3VCescc@@E	;escc1
	*** 0001a1	9a 00 00 00 00 		call	FAR PTR ??0Cescc@@REC@XZ	; Cescc::Cescc
	*** 0001a6	e9 00 00 		jmp	$EX3641
					$EX3641:
	*** 0001a9	5e 			pop	si
	*** 0001aa	5f 			pop	di
	*** 0001ab	c9 			leave	
	*** 0001ac	cb 			ret	

_aaj	ENDP
	PUBLIC	_main
_main	PROC FAR
;|*** 
;|*** unsigned stern1_cmd = 0;
;|*** unsigned stern2_cmd = 0;
;|*** unsigned fore_cmd   = 0;
;|*** unsigned rudder_cmd = 0;
;|*** unsigned prop_cmd   = 0;
;|*** unsigned com1_tx;
;|*** unsigned com2_tx;
;|*** unsigned com4_tx;
;|*** 
;|*** extern int handle;
;|*** extern unsigned long packets_rcvd;
;|*** extern unsigned long ax0_counter;
;|*** extern unsigned long ax1_counter;
;|*** extern unsigned long discards;
;|*** extern unsigned long receiver_calls;
;|*** extern unsigned char pc1_addr[6];
;|*** extern unsigned char pc2_addr[6];
;|*** extern unsigned char pc3_addr[6];
;|*** extern unsigned char jim_pc[6];
;|*** extern unsigned char control_mac[6];
;|*** extern unsigned char broadcast_addr[6];
;|*** unsigned int  ip_id;
;|*** unsigned data_ready = 0;
;|*** 
;|*** 
;|*** extern unsigned tx2_len;
;|*** extern unsigned tx2_counter;
;|*** extern unsigned tx2_index;
;|*** 
;|*** void main(void)
;|***   {
; Line 302
	*** 0001ad	c8 00 00 00 		enter	0,0
	*** 0001b1	57 			push	di
	*** 0001b2	56 			push	si
;|***   configure_obc();
; Line 303
	*** 0001b3	9a 00 00 00 00 		call	FAR PTR ?configure_obc@@ZAXXZ	; configure_obc
;|***   wait_for_time_tick();
; Line 304
	*** 0001b8	9a 00 00 00 00 		call	FAR PTR ?wait_for_time_tick@@ZAXXZ	; wait_for_time_tick
;|***   while(1)
; Line 305
					$FC3670:
;|***     {
; Line 306
;|***     get_frame_time();
; Line 307
	*** 0001bd	9a 00 00 00 00 		call	FAR PTR ?get_frame_time@@ZAXXZ	; get_frame_time
;|***     send_data_packet();
; Line 308
	*** 0001c2	9a 00 00 00 00 		call	FAR PTR ?send_data_packet@@ZAXXZ	; send_data_packet
;|***     start_data_collection();    
; Line 309
	*** 0001c7	9a 00 00 00 00 		call	FAR PTR ?start_data_collection@@ZAXXZ	; start_data_collection
;|***     apply_commands();
; Line 310
	*** 0001cc	9a 00 00 00 00 		call	FAR PTR ?apply_commands@@ZAXXZ	; apply_commands
;|***     heartbeat();
; Line 311
	*** 0001d1	9a 00 00 00 00 		call	FAR PTR ?heartbeat@@ZAXXZ	; heartbeat
;|***     send_acoustic_message();
; Line 312
	*** 0001d6	9a 00 00 00 00 		call	FAR PTR ?send_acoustic_message@@ZAXXZ	; send_acoustic_message
;|***     wait_for_time_tick();
; Line 313
	*** 0001db	9a 00 00 00 00 		call	FAR PTR ?wait_for_time_tick@@ZAXXZ	; wait_for_time_tick
;|***     if(_kbhit()) break;
; Line 314
	*** 0001e0	9a 00 00 00 00 		call	FAR PTR __kbhit
	*** 0001e5	3d 00 00 		cmp	ax,0
	*** 0001e8	75 03 			jne	$JCC488
	*** 0001ea	e9 03 00 		jmp	$I3672
					$JCC488:
	*** 0001ed	e9 03 00 		jmp	$FB3671
;|***     }
; Line 315
					$I3672:
	*** 0001f0	e9 ca ff 		jmp	$FC3670
					$FB3671:
;|***   terminate();
; Line 316
	*** 0001f3	9a 00 00 00 00 		call	FAR PTR ?terminate@@ZAXXZ	; terminate
;|***   exit(0);
; Line 317
	*** 0001f8	6a 00 			push	0
	*** 0001fa	9a 00 00 00 00 		call	FAR PTR _exit
	*** 0001ff	83 c4 02 		add	sp,2
;|***   }
; Line 318
	*** 000202	e9 00 00 		jmp	$EX3668
					$EX3668:
	*** 000205	5e 			pop	si
	*** 000206	5f 			pop	di
	*** 000207	c9 			leave	
	*** 000208	cb 			ret	

_main	ENDP
	PUBLIC	?send_acoustic_message@@ZAXXZ	; send_acoustic_message
?send_acoustic_message@@ZAXXZ	PROC FAR	; send_acoustic_message
;|*** 
;|*** 
;|*** void send_acoustic_message(void)
;|***   {
; Line 322
	*** 000209	c8 02 00 00 		enter	2,0
	*** 00020d	57 			push	di
	*** 00020e	56 			push	si
;|***   if(send_message != 0)
; Line 323
	*** 00020f	83 3e 00 00 00 		cmp	WORD PTR ?send_message@@3HE,0	;send_message
	*** 000214	75 03 			jne	$JCC532
	*** 000216	e9 43 00 		jmp	$I3675
					$JCC532:
;|***     {
; Line 324
;|***     send_message = 0;
; Line 325
	*** 000219	c7 06 00 00 00 00 	mov	WORD PTR ?send_message@@3HE,0	;send_message
;|***     //_fstrcpy(acoustic_message,"abcdef");
;|***     if(_inp(COM2_LSR) & TXB_EMPTY)  // if com2 tx is idle
; Line 327
	*** 00021f	68 fd 02 		push	765	;02fdH
	*** 000222	9a 00 00 00 00 		call	FAR PTR __inp
	*** 000227	83 c4 02 		add	sp,2
	*** 00022a	a8 60 			test	al,96	;0060H
	*** 00022c	75 03 			jne	$JCC556
	*** 00022e	e9 2b 00 		jmp	$I3676
					$JCC556:
;|***       {
; Line 328
;	i = -2
;|***       for(int i=0; i<sizeof(acoustic_message); i++)  // send the message
; Line 329
	*** 000231	c7 46 fe 00 00 		mov	WORD PTR [bp-2],0	;i
	*** 000236	e9 03 00 		jmp	$F3678
					$FC3679:
	*** 000239	ff 46 fe 		inc	WORD PTR [bp-2]	;i
					$F3678:
	*** 00023c	83 7e fe 0c 		cmp	WORD PTR [bp-2],12	;000cH	;i
	*** 000240	72 03 			jb	$JCC576
	*** 000242	e9 17 00 		jmp	$FB3680
					$JCC576:
;|***         {
; Line 330
;|***         _outp(COM2_TX, acoustic_message[i]);
; Line 331
	*** 000245	8b 5e fe 		mov	bx,WORD PTR [bp-2]	;i
	*** 000248	8a 87 00 00 		mov	al,BYTE PTR ?acoustic_message@@3QIDI[bx]	;acoustic_message
	*** 00024c	98 			cbw	
	*** 00024d	50 			push	ax
	*** 00024e	68 f8 02 		push	760	;02f8H
	*** 000251	9a 00 00 00 00 		call	FAR PTR __outp
	*** 000256	83 c4 04 		add	sp,4
;|***         }
; Line 332
	*** 000259	e9 dd ff 		jmp	$FC3679
					$FB3680:
;|***       }
; Line 333
;|***     }    
; Line 334
					$I3676:
;|***   }
; Line 335
					$I3675:
	*** 00025c	e9 00 00 		jmp	$EX3674
					$EX3674:
	*** 00025f	5e 			pop	si
	*** 000260	5f 			pop	di
	*** 000261	c9 			leave	
	*** 000262	cb 			ret	

?send_acoustic_message@@ZAXXZ	ENDP
	PUBLIC	?send_pcm@@ZAXXZ	; send_pcm
?send_pcm@@ZAXXZ	PROC FAR	; send_pcm
;|*** 
;|*** 
;|*** 
;|*** void send_pcm(void)
;|***   {
; Line 340
	*** 000263	c8 00 00 00 		enter	0,0
	*** 000267	57 			push	di
	*** 000268	56 			push	si
;|***   if(escc1.istxing[channelb]==0)
; Line 341
DMMTEST_TEXT      ENDS
CONST      SEGMENT
$T4111	DW SEG ?escc1@@3VCescc@@E 
CONST      ENDS
DMMTEST_TEXT      SEGMENT
	ASSUME	CS: DMMTEST_TEXT
	*** 000269	8e 06 00 00 		mov	es,WORD PTR $T4111
	*** 00026d	8b 1e 00 00 		mov	bx,WORD PTR ?channelb@@3IE	;channelb
	*** 000271	d1 e3 			shl	bx,1
	*** 000273	26 83 bf 92 01 00 	cmp	WORD PTR es:?escc1@@3VCescc@@E[bx+402],0	;escc1
	*** 000279	74 03 			je	$JCC633
	*** 00027b	e9 1b 00 		jmp	$I3683
					$JCC633:
;|***     {
; Line 342
;|***     //pack_pcm();    // old decom
;|***     new_pack_pcm();  // new decom
; Line 344
	*** 00027e	9a 00 00 00 00 		call	FAR PTR ?new_pack_pcm@@ZAXXZ	; new_pack_pcm
;|***     //escc1.tx_port(channelb, pcm, 96);            // old decom
;|***     escc1.tx_port(channelb, pcm, sizeof(pcm));  // new decom
; Line 346
	*** 000283	ff 36 00 00 		push	WORD PTR ?channelb@@3IE	;channelb
	*** 000287	1e 			push	ds
	*** 000288	68 00 00 		push	OFFSET DGROUP:?pcm@@3QIDI	;pcm
	*** 00028b	68 f0 00 		push	240	;00f0H
	*** 00028e	68 00 00 		push	SEG ?escc1@@3VCescc@@E	;escc1
	*** 000291	68 00 00 		push	OFFSET ?escc1@@3VCescc@@E	;escc1
	*** 000294	9a 00 00 00 00 		call	FAR PTR ?tx_port@Cescc@@RECIIPEDI@Z	; Cescc::tx_port
;|***     }
; Line 347
;|***   }
; Line 348
					$I3683:
	*** 000299	e9 00 00 		jmp	$EX3682
					$EX3682:
	*** 00029c	5e 			pop	si
	*** 00029d	5f 			pop	di
	*** 00029e	c9 			leave	
	*** 00029f	cb 			ret	

?send_pcm@@ZAXXZ	ENDP
	PUBLIC	?new_pack_pcm@@ZAXXZ	; new_pack_pcm
?new_pack_pcm@@ZAXXZ	PROC FAR	; new_pack_pcm
;|*** 
;|*** 
;|*** void new_pack_pcm(void)  // new decom  2008 jtm
;|***   {
; Line 352
	*** 0002a0	c8 f0 00 00 		enter	240,0
	*** 0002a4	57 			push	di
	*** 0002a5	56 			push	si
;	data = -240
;|***     
;|***   // The telemetry frame is 120 16-bit words
;|***   
;|***   int data[120];
;|***   
;|***   //data[0]  = 0xeb90;        // sync word
;|***   //data[0]  = 0x90eb;        // sync word
;|***   data[0]  = 0x7e7e;        // sync word
; Line 360
	*** 0002a6	c7 86 10 ff 7e 7e 	mov	WORD PTR [bp-240],32382	;7e7eH	;data
;|***   data[1]  = sys.fs_status;
; Line 361
	*** 0002ac	8e 06 00 00 		mov	es,WORD PTR $T4111
	*** 0002b0	26 a1 08 00 		mov	ax,WORD PTR es:?sys@@3USYS@@E+8	;sys
	*** 0002b4	89 86 12 ff 		mov	WORD PTR [bp-238],ax
;|***   //data[1]  = 0xaabb;
;|***   data[2]  = sys.op_status;
; Line 363
	*** 0002b8	26 a1 0a 00 		mov	ax,WORD PTR es:?sys@@3USYS@@E+10	;sys
	*** 0002bc	89 86 14 ff 		mov	WORD PTR [bp-236],ax
;|***   data[3]  = obs.data[0];  // depth 1
; Line 364
	*** 0002c0	8e 06 00 00 		mov	es,WORD PTR $T4111
	*** 0002c4	26 a1 0c 00 		mov	ax,WORD PTR es:?obs@@3UOBS@@E+12	;obs
	*** 0002c8	89 86 16 ff 		mov	WORD PTR [bp-234],ax
;|***   data[4]  = obs.data[1];  // depth 2
; Line 365
	*** 0002cc	26 a1 0e 00 		mov	ax,WORD PTR es:?obs@@3UOBS@@E+14	;obs
	*** 0002d0	89 86 18 ff 		mov	WORD PTR [bp-232],ax
;|***   data[5]  = obs.data[2];  // depth 3
; Line 366
	*** 0002d4	26 a1 10 00 		mov	ax,WORD PTR es:?obs@@3UOBS@@E+16	;obs
	*** 0002d8	89 86 1a ff 		mov	WORD PTR [bp-230],ax
;|***   data[6]  = obs.data[3];  // paddle wheel
; Line 367
	*** 0002dc	26 a1 12 00 		mov	ax,WORD PTR es:?obs@@3UOBS@@E+18	;obs
	*** 0002e0	89 86 1c ff 		mov	WORD PTR [bp-228],ax
;|***   data[7]  = obs.data[4];  // stern1 lvdt
; Line 368
	*** 0002e4	26 a1 14 00 		mov	ax,WORD PTR es:?obs@@3UOBS@@E+20	;obs
	*** 0002e8	89 86 1e ff 		mov	WORD PTR [bp-226],ax
;|***   data[8]  = obs.data[5];  // stern2 lvdt
; Line 369
	*** 0002ec	26 a1 16 00 		mov	ax,WORD PTR es:?obs@@3UOBS@@E+22	;obs
	*** 0002f0	89 86 20 ff 		mov	WORD PTR [bp-224],ax
;|***   data[9]  = obs.data[6];  // rudder lvdt
; Line 370
	*** 0002f4	26 a1 18 00 		mov	ax,WORD PTR es:?obs@@3UOBS@@E+24	;obs
	*** 0002f8	89 86 22 ff 		mov	WORD PTR [bp-222],ax
;|***   data[10] = obs.data[7];  // fore lvdt
; Line 371
	*** 0002fc	26 a1 1a 00 		mov	ax,WORD PTR es:?obs@@3UOBS@@E+26	;obs
	*** 000300	89 86 24 ff 		mov	WORD PTR [bp-220],ax
;|***   data[11] = obs.data[8];  // spare lvdt
; Line 372
	*** 000304	26 a1 1c 00 		mov	ax,WORD PTR es:?obs@@3UOBS@@E+28	;obs
	*** 000308	89 86 26 ff 		mov	WORD PTR [bp-218],ax
;|***   data[12] = obs.data[16];  // ebat volts
; Line 373
	*** 00030c	26 a1 2c 00 		mov	ax,WORD PTR es:?obs@@3UOBS@@E+44	;obs
	*** 000310	89 86 28 ff 		mov	WORD PTR [bp-216],ax
;|***   data[13] = obs.data[17];  // pbat volts
; Line 374
	*** 000314	26 a1 2e 00 		mov	ax,WORD PTR es:?obs@@3UOBS@@E+46	;obs
	*** 000318	89 86 2a ff 		mov	WORD PTR [bp-214],ax
;|***   data[14] = obs.data[18];  // prop volts
; Line 375
	*** 00031c	26 a1 30 00 		mov	ax,WORD PTR es:?obs@@3UOBS@@E+48	;obs
	*** 000320	89 86 2c ff 		mov	WORD PTR [bp-212],ax
;|***   data[15] = obs.data[19];  // prop amps
; Line 376
	*** 000324	26 a1 32 00 		mov	ax,WORD PTR es:?obs@@3UOBS@@E+50	;obs
	*** 000328	89 86 2e ff 		mov	WORD PTR [bp-210],ax
;|***   data[16] = obs.data[20];  // 5B module rpm (unsigned)
; Line 377
	*** 00032c	26 a1 34 00 		mov	ax,WORD PTR es:?obs@@3UOBS@@E+52	;obs
	*** 000330	89 86 30 ff 		mov	WORD PTR [bp-208],ax
;|***   data[17] = obs.data[21];  // prop discriminator
; Line 378
	*** 000334	26 a1 36 00 		mov	ax,WORD PTR es:?obs@@3UOBS@@E+54	;obs
	*** 000338	89 86 32 ff 		mov	WORD PTR [bp-206],ax
;|***   data[18] = obs.data[22];   // stern1 discriminator
; Line 379
	*** 00033c	26 a1 38 00 		mov	ax,WORD PTR es:?obs@@3UOBS@@E+56	;obs
	*** 000340	89 86 34 ff 		mov	WORD PTR [bp-204],ax
;|***   data[19] = obs.data[23];   // stern2 discriminator
; Line 380
	*** 000344	26 a1 3a 00 		mov	ax,WORD PTR es:?obs@@3UOBS@@E+58	;obs
	*** 000348	89 86 36 ff 		mov	WORD PTR [bp-202],ax
;|***   data[20] = obs.data[24];   // rudder discriminator
; Line 381
	*** 00034c	26 a1 3c 00 		mov	ax,WORD PTR es:?obs@@3UOBS@@E+60	;obs
	*** 000350	89 86 38 ff 		mov	WORD PTR [bp-200],ax
;|***   data[21] = obs.data[25];   // fore discriminator
; Line 382
	*** 000354	26 a1 3e 00 		mov	ax,WORD PTR es:?obs@@3UOBS@@E+62	;obs
	*** 000358	89 86 3a ff 		mov	WORD PTR [bp-198],ax
;|***   data[22] = obs.data[26];   // mode discriminator
; Line 383
	*** 00035c	26 a1 40 00 		mov	ax,WORD PTR es:?obs@@3UOBS@@E+64	;obs
	*** 000360	89 86 3c ff 		mov	WORD PTR [bp-196],ax
;|***   data[23] = obs.data[27];   // ballast discriminator
; Line 384
	*** 000364	26 a1 42 00 		mov	ax,WORD PTR es:?obs@@3UOBS@@E+66	;obs
	*** 000368	89 86 3e ff 		mov	WORD PTR [bp-194],ax
;|***   data[24] = obs.data[28];   // failsafe discriminator
; Line 385
	*** 00036c	26 a1 44 00 		mov	ax,WORD PTR es:?obs@@3UOBS@@E+68	;obs
	*** 000370	89 86 40 ff 		mov	WORD PTR [bp-192],ax
;|***   data[25] = obs.data[29];   // radio mode discriminator
; Line 386
	*** 000374	26 a1 46 00 		mov	ax,WORD PTR es:?obs@@3UOBS@@E+70	;obs
	*** 000378	89 86 42 ff 		mov	WORD PTR [bp-190],ax
;|***   data[26] = obs.data[30];   // key discriminator
; Line 387
	*** 00037c	26 a1 48 00 		mov	ax,WORD PTR es:?obs@@3UOBS@@E+72	;obs
	*** 000380	89 86 44 ff 		mov	WORD PTR [bp-188],ax
;|***   data[27] = prop.rpm;
; Line 388
	*** 000384	8e 06 00 00 		mov	es,WORD PTR $T4111
	*** 000388	26 a1 18 00 		mov	ax,WORD PTR es:?prop@@3UPROP@@E+24	;prop
	*** 00038c	89 86 46 ff 		mov	WORD PTR [bp-186],ax
;|***   data[28] = (int)prop.position;           
; Line 389
	*** 000390	26 a1 1a 00 		mov	ax,WORD PTR es:?prop@@3UPROP@@E+26	;prop
	*** 000394	89 86 48 ff 		mov	WORD PTR [bp-184],ax
;|***   data[29] = ln200.data[0];  // z linear accel 
; Line 390
	*** 000398	8e 06 00 00 		mov	es,WORD PTR $T4111
	*** 00039c	26 a1 0c 00 		mov	ax,WORD PTR es:?ln200@@3ULN200@@E+12	;ln200
	*** 0003a0	89 86 4a ff 		mov	WORD PTR [bp-182],ax
;|***   data[30] = ln200.data[1];  // y linear accel
; Line 391
	*** 0003a4	26 a1 0e 00 		mov	ax,WORD PTR es:?ln200@@3ULN200@@E+14	;ln200
	*** 0003a8	89 86 4c ff 		mov	WORD PTR [bp-180],ax
;|***   data[31] = ln200.data[2];  // x linear accel
; Line 392
	*** 0003ac	26 a1 10 00 		mov	ax,WORD PTR es:?ln200@@3ULN200@@E+16	;ln200
	*** 0003b0	89 86 4e ff 		mov	WORD PTR [bp-178],ax
;|***   data[32] = ln200.data[3];  // y angular rate
; Line 393
	*** 0003b4	26 a1 12 00 		mov	ax,WORD PTR es:?ln200@@3ULN200@@E+18	;ln200
	*** 0003b8	89 86 50 ff 		mov	WORD PTR [bp-176],ax
;|***   data[33] = ln200.data[4];  // x angular rate
; Line 394
	*** 0003bc	26 a1 14 00 		mov	ax,WORD PTR es:?ln200@@3ULN200@@E+20	;ln200
	*** 0003c0	89 86 52 ff 		mov	WORD PTR [bp-174],ax
;|***   data[34] = ln200.data[5];  // z angular rate
; Line 395
	*** 0003c4	26 a1 16 00 		mov	ax,WORD PTR es:?ln200@@3ULN200@@E+22	;ln200
	*** 0003c8	89 86 54 ff 		mov	WORD PTR [bp-172],ax
;|***   data[35] = ln200.data[6];  // y angular accel
; Line 396
	*** 0003cc	26 a1 18 00 		mov	ax,WORD PTR es:?ln200@@3ULN200@@E+24	;ln200
	*** 0003d0	89 86 56 ff 		mov	WORD PTR [bp-170],ax
;|***   data[36] = ln200.data[7];  // x angular accel
; Line 397
	*** 0003d4	26 a1 1a 00 		mov	ax,WORD PTR es:?ln200@@3ULN200@@E+26	;ln200
	*** 0003d8	89 86 58 ff 		mov	WORD PTR [bp-168],ax
;|***   data[37] = ln200.data[8];  // z angular accel
; Line 398
	*** 0003dc	26 a1 1c 00 		mov	ax,WORD PTR es:?ln200@@3ULN200@@E+28	;ln200
	*** 0003e0	89 86 5a ff 		mov	WORD PTR [bp-166],ax
;|***   data[38] = ln200.data[9];  // pitch
; Line 399
	*** 0003e4	26 a1 1e 00 		mov	ax,WORD PTR es:?ln200@@3ULN200@@E+30	;ln200
	*** 0003e8	89 86 5c ff 		mov	WORD PTR [bp-164],ax
;|***   data[39] = ln200.data[10]; // roll 
; Line 400
	*** 0003ec	26 a1 20 00 		mov	ax,WORD PTR es:?ln200@@3ULN200@@E+32	;ln200
	*** 0003f0	89 86 5e ff 		mov	WORD PTR [bp-162],ax
;|***   data[40] = ln200.data[11]; // heading 
; Line 401
	*** 0003f4	26 a1 22 00 		mov	ax,WORD PTR es:?ln200@@3ULN200@@E+34	;ln200
	*** 0003f8	89 86 60 ff 		mov	WORD PTR [bp-160],ax
;|***   data[41] = commands.mode;
; Line 402
	*** 0003fc	8e 06 00 00 		mov	es,WORD PTR $T4111
	*** 000400	26 a1 02 00 		mov	ax,WORD PTR es:?commands@@3UCOMMANDS@@E+2	;commands
	*** 000404	89 86 62 ff 		mov	WORD PTR [bp-158],ax
;|***   data[42] = commands.stbd_rpm;
; Line 403
	*** 000408	26 a1 04 00 		mov	ax,WORD PTR es:?commands@@3UCOMMANDS@@E+4	;commands
	*** 00040c	89 86 64 ff 		mov	WORD PTR [bp-156],ax
;|***   data[43] = commands.rudder;
; Line 404
	*** 000410	26 a1 06 00 		mov	ax,WORD PTR es:?commands@@3UCOMMANDS@@E+6	;commands
	*** 000414	89 86 66 ff 		mov	WORD PTR [bp-154],ax
;|***   data[44] = commands.stern1;
; Line 405
	*** 000418	26 a1 08 00 		mov	ax,WORD PTR es:?commands@@3UCOMMANDS@@E+8	;commands
	*** 00041c	89 86 68 ff 		mov	WORD PTR [bp-152],ax
;|***   data[45] = commands.stern2;
; Line 406
	*** 000420	26 a1 0a 00 		mov	ax,WORD PTR es:?commands@@3UCOMMANDS@@E+10	;commands
	*** 000424	89 86 6a ff 		mov	WORD PTR [bp-150],ax
;|***   data[46] = commands.fore;
; Line 407
	*** 000428	26 a1 0c 00 		mov	ax,WORD PTR es:?commands@@3UCOMMANDS@@E+12	;commands
	*** 00042c	89 86 6c ff 		mov	WORD PTR [bp-148],ax
;|***   data[47] = commands.ballast;
; Line 408
	*** 000430	26 a1 0e 00 		mov	ax,WORD PTR es:?commands@@3UCOMMANDS@@E+14	;commands
	*** 000434	89 86 6e ff 		mov	WORD PTR [bp-146],ax
;|***   data[48] = commands.ds_dmgx1;
; Line 409
	*** 000438	26 a1 18 00 		mov	ax,WORD PTR es:?commands@@3UCOMMANDS@@E+24	;commands
	*** 00043c	89 86 70 ff 		mov	WORD PTR [bp-144],ax
;|***   data[49] = commands.ds_dmgy1;
; Line 410
	*** 000440	26 a1 1c 00 		mov	ax,WORD PTR es:?commands@@3UCOMMANDS@@E+28	;commands
	*** 000444	89 86 72 ff 		mov	WORD PTR [bp-142],ax
;|***   data[50] = commands.ds_dmgz1;
; Line 411
	*** 000448	26 a1 20 00 		mov	ax,WORD PTR es:?commands@@3UCOMMANDS@@E+32	;commands
	*** 00044c	89 86 74 ff 		mov	WORD PTR [bp-140],ax
;|***   data[51] = commands.port_rpm;
; Line 412
	*** 000450	26 a1 22 00 		mov	ax,WORD PTR es:?commands@@3UCOMMANDS@@E+34	;commands
	*** 000454	89 86 76 ff 		mov	WORD PTR [bp-138],ax
;|***   memcpy(&data[52],&adcp.data[154],2); // y_vel_btm;
; Line 413
	*** 000458	6a 02 			push	2
	*** 00045a	68 00 00 		push	SEG ?adcp@@3UADCP@@E	;adcp
	*** 00045d	68 a6 00 		push	OFFSET ?adcp@@3UADCP@@E+166	;adcp
	*** 000460	8d 86 78 ff 		lea	ax,WORD PTR [bp-136]
	*** 000464	16 			push	ss
	*** 000465	50 			push	ax
	*** 000466	9a 00 00 00 00 		call	FAR PTR _memcpy
	*** 00046b	83 c4 0a 		add	sp,10	;000aH
;|***   memcpy(&data[53],&adcp.data[158],2); // z_vel_btm;
; Line 414
	*** 00046e	6a 02 			push	2
	*** 000470	68 00 00 		push	SEG ?adcp@@3UADCP@@E	;adcp
	*** 000473	68 aa 00 		push	OFFSET ?adcp@@3UADCP@@E+170	;adcp
	*** 000476	8d 86 7a ff 		lea	ax,WORD PTR [bp-134]
	*** 00047a	16 			push	ss
	*** 00047b	50 			push	ax
	*** 00047c	9a 00 00 00 00 		call	FAR PTR _memcpy
	*** 000481	83 c4 0a 		add	sp,10	;000aH
;|***   memcpy(&data[54],&adcp.data[156],2); // x_vel_btm;
; Line 415
	*** 000484	6a 02 			push	2
	*** 000486	68 00 00 		push	SEG ?adcp@@3UADCP@@E	;adcp
	*** 000489	68 a8 00 		push	OFFSET ?adcp@@3UADCP@@E+168	;adcp
	*** 00048c	8d 86 7c ff 		lea	ax,WORD PTR [bp-132]
	*** 000490	16 			push	ss
	*** 000491	50 			push	ax
	*** 000492	9a 00 00 00 00 		call	FAR PTR _memcpy
	*** 000497	83 c4 0a 		add	sp,10	;000aH
;|***   memcpy(&data[55],&adcp.data[146],2); // bm1_rng_to_btm;
; Line 416
	*** 00049a	6a 02 			push	2
	*** 00049c	68 00 00 		push	SEG ?adcp@@3UADCP@@E	;adcp
	*** 00049f	68 9e 00 		push	OFFSET ?adcp@@3UADCP@@E+158	;adcp
	*** 0004a2	8d 86 7e ff 		lea	ax,WORD PTR [bp-130]
	*** 0004a6	16 			push	ss
	*** 0004a7	50 			push	ax
	*** 0004a8	9a 00 00 00 00 		call	FAR PTR _memcpy
	*** 0004ad	83 c4 0a 		add	sp,10	;000aH
;|***   memcpy(&data[56],&adcp.data[148],2); // bm2_rng_to_btm;
; Line 417
	*** 0004b0	6a 02 			push	2
	*** 0004b2	68 00 00 		push	SEG ?adcp@@3UADCP@@E	;adcp
	*** 0004b5	68 a0 00 		push	OFFSET ?adcp@@3UADCP@@E+160	;adcp
	*** 0004b8	8d 46 80 		lea	ax,WORD PTR [bp-128]
	*** 0004bb	16 			push	ss
	*** 0004bc	50 			push	ax
	*** 0004bd	9a 00 00 00 00 		call	FAR PTR _memcpy
	*** 0004c2	83 c4 0a 		add	sp,10	;000aH
;|***   memcpy(&data[57],&adcp.data[150],2); // bm3_rng_to_btm;
; Line 418
	*** 0004c5	6a 02 			push	2
	*** 0004c7	68 00 00 		push	SEG ?adcp@@3UADCP@@E	;adcp
	*** 0004ca	68 a2 00 		push	OFFSET ?adcp@@3UADCP@@E+162	;adcp
	*** 0004cd	8d 46 82 		lea	ax,WORD PTR [bp-126]
	*** 0004d0	16 			push	ss
	*** 0004d1	50 			push	ax
	*** 0004d2	9a 00 00 00 00 		call	FAR PTR _memcpy
	*** 0004d7	83 c4 0a 		add	sp,10	;000aH
;|***   memcpy(&data[58],&adcp.data[152],2); // bm4_rng_to_btm;
; Line 419
	*** 0004da	6a 02 			push	2
	*** 0004dc	68 00 00 		push	SEG ?adcp@@3UADCP@@E	;adcp
	*** 0004df	68 a4 00 		push	OFFSET ?adcp@@3UADCP@@E+164	;adcp
	*** 0004e2	8d 46 84 		lea	ax,WORD PTR [bp-124]
	*** 0004e5	16 			push	ss
	*** 0004e6	50 			push	ax
	*** 0004e7	9a 00 00 00 00 		call	FAR PTR _memcpy
	*** 0004ec	83 c4 0a 		add	sp,10	;000aH
;|***   data[59] = 0;    // put stbd rpm here?
; Line 420
	*** 0004ef	c7 46 86 00 00 		mov	WORD PTR [bp-122],0
;|***   _fmemcpy(&data[60],&dyno.data,2*60);
; Line 421
	*** 0004f4	6a 78 			push	120	;0078H
	*** 0004f6	68 00 00 		push	SEG ?dyno@@3UDYNO@@E	;dyno
	*** 0004f9	68 0c 00 		push	OFFSET ?dyno@@3UDYNO@@E+12	;dyno
	*** 0004fc	8d 46 88 		lea	ax,WORD PTR [bp-120]
	*** 0004ff	16 			push	ss
	*** 000500	50 			push	ax
	*** 000501	9a 00 00 00 00 		call	FAR PTR __fmemcpy
	*** 000506	83 c4 0a 		add	sp,10	;000aH
;|***   _fmemcpy(pcm,&data[0],sizeof(pcm));
; Line 422
	*** 000509	68 f0 00 		push	240	;00f0H
	*** 00050c	8d 86 10 ff 		lea	ax,WORD PTR [bp-240]	;data
	*** 000510	16 			push	ss
	*** 000511	50 			push	ax
	*** 000512	1e 			push	ds
	*** 000513	68 00 00 		push	OFFSET DGROUP:?pcm@@3QIDI	;pcm
	*** 000516	9a 00 00 00 00 		call	FAR PTR __fmemcpy
	*** 00051b	83 c4 0a 		add	sp,10	;000aH
;|***   
;|***   // end new decom
;|***   }  
; Line 425
	*** 00051e	e9 00 00 		jmp	$EX3685
					$EX3685:
	*** 000521	5e 			pop	si
	*** 000522	5f 			pop	di
	*** 000523	c9 			leave	
	*** 000524	cb 			ret	

?new_pack_pcm@@ZAXXZ	ENDP
	PUBLIC	?pack_pcm@@ZAXXZ	; pack_pcm
?pack_pcm@@ZAXXZ	PROC FAR	; pack_pcm
;|*** 
;|***   
;|*** 
;|*** //  original decom unit  
;|*** void pack_pcm(void)
;|***   {
; Line 431
	*** 000525	c8 10 01 00 		enter	272,0
	*** 000529	57 			push	di
	*** 00052a	56 			push	si
;	jj = -264
;	data2 = -256
;	s_offset = -258
;	d_offset = -260
;	status_word = -262
;|***     
;|***   // Prepare pcm data to be sent up the telemetry link in biphase-m (76.8 KHz)
;|***   // The telemetry frame is 64 words x 12 bits.
;|***   //
;|***   // All ln200 and a/d data was first collected and stored in separate structures
;|***   // in a total of 48 16-bit words.  For pcm transmission, the data must be:
;|***   // 1) scaled, converted to offset-binary and placed in proper channel slots
;|***   // 2) shifted down from 16-bit to 12-bit (shift and mask) (keep high byte 0000 hex
;|***   // 3) converted from from lsb first to msb first for the bit synchronizer
;|***   // 4) repacked for the escc from 64 12-bit words to 96 8-bit bytes (shift and mask) for the escc 
;|***   
;|***   long int data2[64];
;|***   const int s_offset = 0x0800;
; Line 444
	*** 00052b	c7 86 fe fe 00 08 	mov	WORD PTR [bp-258],2048	;0800H	;s_offset
;|***   const int d_offset = 0x0800;
; Line 445
	*** 000531	c7 86 fc fe 00 08 	mov	WORD PTR [bp-260],2048	;0800H	;d_offset
;|***   unsigned int status_word;
;|***   
;|***     // first scale the numbers, add the offset, place in slots
;|***   data2[0] = 0x0faf;         // decom sync 1
; Line 449
	*** 000537	c7 86 00 ff af 0f 	mov	WORD PTR [bp-256],4015	;0fafH	;data2
	*** 00053d	c7 86 02 ff 00 00 	mov	WORD PTR [bp-254],0
;|***   data2[1] = 0x0321;         // decom sync 2
; Line 450
	*** 000543	c7 86 04 ff 21 03 	mov	WORD PTR [bp-252],801	;0321H
	*** 000549	c7 86 06 ff 00 00 	mov	WORD PTR [bp-250],0
;|***   data2[2] = 5 << 1;         // CB ID, 5 << 1
; Line 451
	*** 00054f	c7 86 08 ff 0a 00 	mov	WORD PTR [bp-248],10	;000aH
	*** 000555	c7 86 0a ff 00 00 	mov	WORD PTR [bp-246],0
;|*** 
;|*** 
;|***   //data2[4] = ((long)data[64] * 2)    + d_offset;        // 5 msb of prop position
;|***   //data2[3] = (data2[4] >> 12) * 2 + d_offset;    // 12 lsb of prop position 
;|***   //new 2/10/2005
;|***   //data2[4] = (prop.position * 2)    + d_offset;        // 5 msb of prop position
;|***   //data2[3] = (data2[4] >> 12) * 2 + d_offset;    // 12 lsb of prop position
;|*** 
;|***   
;|***   // in failsafe; fm failsafe is sc2 ch10, mm32 adc ch26
;|***   //data2[5] = (data[13] >> 4) & 0x0ff0; // ln200 status word high byte
;|***   //data2[6] = (data[13] << 4) & 0x0ff0; // ln200 status low
;|***   // add failsafe flags to ln200 status 5/29/01 jtm
;|***   //data2[6] = data2[6] | (in_fm_failsafe << 1) | (in_hw_failsafe << 2); 
;|***   //data2[5] = ((long)ln200.data[13] >> 4) & 0x0ff0; // ln200 status word high byte
;|***   //data2[6] = ((long)ln200.data[13] << 4) & 0x0ff0; // ln200 status low
;|***   // add failsafe flags to ln200 status
;|***   //??????????data2[6] = data2[6] | (in_fm_failsafe << 1) | (in_hw_failsafe << 2); 
;|*** 
;|***     
;|***   //data2[7] = (frame >> 4) & 0x0ffe; // most significant 11 bits of 16 bit frame counter
;|***   //data2[8] = (frame << 7) & 0x0f80; // least sig 5 bits of 16 bit frame counter, LEFT ADJUSTED
;|***   //new 2/10/2005
;|***   data2[7] = (sys.frame >> 4) & 0x0ffe; // most significant 11 bits of 16 bit frame counter
; Line 475
	*** 00055b	8e 06 00 00 		mov	es,WORD PTR $T4111
	*** 00055f	26 a1 04 00 		mov	ax,WORD PTR es:?sys@@3USYS@@E+4	;sys
	*** 000563	25 ef ff 		and	ax,-17	;ffefH
	*** 000566	c1 e8 04 		shr	ax,4
	*** 000569	89 86 1c ff 		mov	WORD PTR [bp-228],ax
	*** 00056d	c7 86 1e ff 00 00 	mov	WORD PTR [bp-226],0
;|***   data2[8] = (sys.frame << 7) & 0x0f80; // least sig 5 bits of 16 bit frame counter, LEFT ADJUSTED
; Line 476
	*** 000573	26 a0 04 00 		mov	al,BYTE PTR es:?sys@@3USYS@@E+4	;sys
	*** 000577	25 1f 00 		and	ax,31	;001fH
	*** 00057a	2b d2 			sub	dx,dx
	*** 00057c	d1 e0 			shl	ax,1
	*** 00057e	d1 d2 			rcl	dx,1
	*** 000580	d1 e0 			shl	ax,1
	*** 000582	d1 d2 			rcl	dx,1
	*** 000584	d1 e0 			shl	ax,1
	*** 000586	d1 d2 			rcl	dx,1
	*** 000588	d1 e0 			shl	ax,1
	*** 00058a	d1 d2 			rcl	dx,1
	*** 00058c	d1 e0 			shl	ax,1
	*** 00058e	d1 d2 			rcl	dx,1
	*** 000590	d1 e0 			shl	ax,1
	*** 000592	d1 d2 			rcl	dx,1
	*** 000594	d1 e0 			shl	ax,1
	*** 000596	d1 d2 			rcl	dx,1
	*** 000598	89 86 20 ff 		mov	WORD PTR [bp-224],ax
	*** 00059c	89 96 22 ff 		mov	WORD PTR [bp-222],dx
;|***     
;|*** 
;|***   //data2[10] = ((long)data[5] * 2)    + d_offset;       // z axis angular rate low
;|***   //data2[9]  = (data2[10] >> 12) * 2 + d_offset;  // high 
;|***   //new 2/10/2005
;|***   //  "R"
;|***   data2[10] = ((long)ln200.data[5] * 2)    + d_offset;       // z axis angular rate low
; Line 483
	*** 0005a0	8e 06 00 00 		mov	es,WORD PTR $T4111
	*** 0005a4	26 a1 16 00 		mov	ax,WORD PTR es:?ln200@@3ULN200@@E+22	;ln200
	*** 0005a8	99 			cwd	
	*** 0005a9	05 00 04 		add	ax,1024	;0400H
	*** 0005ac	83 d2 00 		adc	dx,0
	*** 0005af	d1 e0 			shl	ax,1
	*** 0005b1	d1 d2 			rcl	dx,1
	*** 0005b3	89 86 28 ff 		mov	WORD PTR [bp-216],ax
	*** 0005b7	89 96 2a ff 		mov	WORD PTR [bp-214],dx
;|***   data2[9]  = (data2[10] >> 12) * 2 + d_offset;  // high
; Line 484
	*** 0005bb	8b 86 28 ff 		mov	ax,WORD PTR [bp-216]
	*** 0005bf	8b 96 2a ff 		mov	dx,WORD PTR [bp-214]
	*** 0005c3	25 ff f7 		and	ax,-2049	;f7ffH
	*** 0005c6	83 e2 ff 		and	dx,-1	;ffffH
	*** 0005c9	8a c4 			mov	al,ah
	*** 0005cb	8a e2 			mov	ah,dl
	*** 0005cd	8a d6 			mov	dl,dh
	*** 0005cf	d0 e6 			shl	dh,1
	*** 0005d1	1a f6 			sbb	dh,dh
	*** 0005d3	d1 fa 			sar	dx,1
	*** 0005d5	d1 d8 			rcr	ax,1
	*** 0005d7	d1 fa 			sar	dx,1
	*** 0005d9	d1 d8 			rcr	ax,1
	*** 0005db	d1 fa 			sar	dx,1
	*** 0005dd	d1 d8 			rcr	ax,1
	*** 0005df	05 00 08 		add	ax,2048	;0800H
	*** 0005e2	83 d2 00 		adc	dx,0
	*** 0005e5	89 86 24 ff 		mov	WORD PTR [bp-220],ax
	*** 0005e9	89 96 26 ff 		mov	WORD PTR [bp-218],dx
;|***   
;|***   //data2[12] = ((long)data[3] * 2)    + d_offset;       // y axis angular rate low
;|***   //data2[11] = (data2[12] >> 12) * 2 + d_offset;  // high
;|***   //new 2/10/2005
;|***   //  "Q"
;|***   data2[12] = ((long)ln200.data[3] * 2)    + d_offset;       // y axis angular rate low
; Line 490
	*** 0005ed	26 a1 12 00 		mov	ax,WORD PTR es:?ln200@@3ULN200@@E+18	;ln200
	*** 0005f1	99 			cwd	
	*** 0005f2	05 00 04 		add	ax,1024	;0400H
	*** 0005f5	83 d2 00 		adc	dx,0
	*** 0005f8	d1 e0 			shl	ax,1
	*** 0005fa	d1 d2 			rcl	dx,1
	*** 0005fc	89 86 30 ff 		mov	WORD PTR [bp-208],ax
	*** 000600	89 96 32 ff 		mov	WORD PTR [bp-206],dx
;|***   data2[11] = (data2[12] >> 12) * 2 + d_offset;  // high
; Line 491
	*** 000604	8b 86 30 ff 		mov	ax,WORD PTR [bp-208]
	*** 000608	8b 96 32 ff 		mov	dx,WORD PTR [bp-206]
	*** 00060c	25 ff f7 		and	ax,-2049	;f7ffH
	*** 00060f	83 e2 ff 		and	dx,-1	;ffffH
	*** 000612	8a c4 			mov	al,ah
	*** 000614	8a e2 			mov	ah,dl
	*** 000616	8a d6 			mov	dl,dh
	*** 000618	d0 e6 			shl	dh,1
	*** 00061a	1a f6 			sbb	dh,dh
	*** 00061c	d1 fa 			sar	dx,1
	*** 00061e	d1 d8 			rcr	ax,1
	*** 000620	d1 fa 			sar	dx,1
	*** 000622	d1 d8 			rcr	ax,1
	*** 000624	d1 fa 			sar	dx,1
	*** 000626	d1 d8 			rcr	ax,1
	*** 000628	05 00 08 		add	ax,2048	;0800H
	*** 00062b	83 d2 00 		adc	dx,0
	*** 00062e	89 86 2c ff 		mov	WORD PTR [bp-212],ax
	*** 000632	89 96 2e ff 		mov	WORD PTR [bp-210],dx
;|***     
;|***   //data2[14] = ((long)data[4] * 2)    + d_offset;       // x axis angular rate low
;|***   //data2[13] = (data2[14] >> 12) * 2 + d_offset;  // high 
;|***   //new 2/10/2005
;|***   // "P"
;|***   data2[14] = ((long)ln200.data[4] * 2)    + d_offset;       // x axis angular rate low
; Line 497
	*** 000636	26 a1 14 00 		mov	ax,WORD PTR es:?ln200@@3ULN200@@E+20	;ln200
	*** 00063a	99 			cwd	
	*** 00063b	05 00 04 		add	ax,1024	;0400H
	*** 00063e	83 d2 00 		adc	dx,0
	*** 000641	d1 e0 			shl	ax,1
	*** 000643	d1 d2 			rcl	dx,1
	*** 000645	89 86 38 ff 		mov	WORD PTR [bp-200],ax
	*** 000649	89 96 3a ff 		mov	WORD PTR [bp-198],dx
;|***   data2[13] = (data2[14] >> 12) * 2 + d_offset;  // high
; Line 498
	*** 00064d	8b 86 38 ff 		mov	ax,WORD PTR [bp-200]
	*** 000651	8b 96 3a ff 		mov	dx,WORD PTR [bp-198]
	*** 000655	25 ff f7 		and	ax,-2049	;f7ffH
	*** 000658	83 e2 ff 		and	dx,-1	;ffffH
	*** 00065b	8a c4 			mov	al,ah
	*** 00065d	8a e2 			mov	ah,dl
	*** 00065f	8a d6 			mov	dl,dh
	*** 000661	d0 e6 			shl	dh,1
	*** 000663	1a f6 			sbb	dh,dh
	*** 000665	d1 fa 			sar	dx,1
	*** 000667	d1 d8 			rcr	ax,1
	*** 000669	d1 fa 			sar	dx,1
	*** 00066b	d1 d8 			rcr	ax,1
	*** 00066d	d1 fa 			sar	dx,1
	*** 00066f	d1 d8 			rcr	ax,1
	*** 000671	05 00 08 		add	ax,2048	;0800H
	*** 000674	83 d2 00 		adc	dx,0
	*** 000677	89 86 34 ff 		mov	WORD PTR [bp-204],ax
	*** 00067b	89 96 36 ff 		mov	WORD PTR [bp-202],dx
;|***     
;|***   //data2[16] = ((long)data[2] * 2)    + d_offset;       // x axis linear accel low
;|***   //data2[15] = (data2[16] >> 12) * 2 + d_offset;  // high
;|***   //new 2/10/2005
;|***   //data2[16] = ((long)ln200.data[2] * 2)    + d_offset;       // x axis linear accel low
;|***   //data2[15] = (data2[16] >> 12) * 2 + d_offset;  // high
;|***       
;|***   //data2[18] = ((long)data[1] * 2)    + d_offset;       // y axis linear accel low
;|***   //data2[17] = (data2[18] >> 12) * 2 + d_offset;  // high
;|***   //new 2/10/2005
;|***   //data2[18] = ((long)ln200.data[1] * 2)    + d_offset;       // y axis linear accel low
;|***   //data2[17] = (data2[18] >> 12) * 2 + d_offset;  // high
;|*** 
;|***     // compensate LN200 Z accel reading for standard gravity: (32.17405 / 2^-6 counts )
;|***   //data2[20] = (((long)data[0] + (32.17405 * 64)) * 2)    + d_offset;       // z axis linear accel
;|***   //data2[19] = (data2[20] >> 12) * 2 + d_offset;
;|***   //new 2/10/2005
;|***   //data2[20] = (((long)ln200.data[0] + ((long)(32.17405 * 64))) * 2)    + d_offset;       // z axis linear accel
;|***   //data2[19] =  (data2[20] >> 12) * 2 + d_offset;
;|***   
;|***   //  depth gauges moved to channels 42, 43, 44 2/17/2005 jtm
;|***   // depth gauge 1
;|***   //data2[22] = ((long)obs.data[0] * 2) + d_offset; // low part
;|***   //data2[21] = (data2[22] >> 12) * 2 + d_offset;   // high part  
;|***   data2[22] = 0;
; Line 523
	*** 00067f	2b c0 			sub	ax,ax
	*** 000681	89 86 5a ff 		mov	WORD PTR [bp-166],ax
	*** 000685	89 86 58 ff 		mov	WORD PTR [bp-168],ax
;|***   data2[21] = 0;
; Line 524
	*** 000689	2b c0 			sub	ax,ax
	*** 00068b	89 86 56 ff 		mov	WORD PTR [bp-170],ax
	*** 00068f	89 86 54 ff 		mov	WORD PTR [bp-172],ax
;|*** 
;|***   
;|***   // depth gauge 2
;|***   //data2[24] = ((long)obs.data[1] * 2) + d_offset;
;|***   //data2[23] = (data2[24] >> 12) * 2 + d_offset;
;|***   data2[24] = 0;
; Line 530
	*** 000693	2b c0 			sub	ax,ax
	*** 000695	89 86 62 ff 		mov	WORD PTR [bp-158],ax
	*** 000699	89 86 60 ff 		mov	WORD PTR [bp-160],ax
;|***   data2[23] = 0;
; Line 531
	*** 00069d	2b c0 			sub	ax,ax
	*** 00069f	89 86 5e ff 		mov	WORD PTR [bp-162],ax
	*** 0006a3	89 86 5c ff 		mov	WORD PTR [bp-164],ax
;|*** 
;|***   // depth gauge 3
;|***   //data2[26] = ((long)obs.data[2] * 2) + d_offset;
;|***   //data2[25] = (data2[26] >> 12) * 2 + d_offset;
;|***   data2[26] = 0;
; Line 536
	*** 0006a7	2b c0 			sub	ax,ax
	*** 0006a9	89 86 6a ff 		mov	WORD PTR [bp-150],ax
	*** 0006ad	89 86 68 ff 		mov	WORD PTR [bp-152],ax
;|***   data2[25] = 0;
; Line 537
	*** 0006b1	2b c0 			sub	ax,ax
	*** 0006b3	89 86 66 ff 		mov	WORD PTR [bp-154],ax
	*** 0006b7	89 86 64 ff 		mov	WORD PTR [bp-156],ax
;|*** 
;|***     
;|***  //  ln200 single channel scale factors
;|***  //  convert 16-bit LN200 native data to 12-bit pcm data
;|***  //  to provide desired full-scale range for each channel
;|***  //  scale factor = ln200 lsb value * 2^12 counts / desired full-scale range EUs
;|***  
;|***     // roll_accel (Pdot), ln200 lsb = 2^-4 deg/sec^2
;|***   //data2[27] = data[7];
;|***     // limit roll_accel to 12-bits and max +- 128 deg/sec^2 range
;|***   //if(data2[27] >  2047) data2[27] =  2047;
;|***   //if(data2[27] < -2048) data2[27] = -2048;
;|***   //data2[27] = data2[27] + s_offset;
;|***   //new 2/10/2005
;|***   //data2[27] = ln200.data[7];
;|***     // limit roll_accel to 12-bits and max +- 128 deg/sec^2 range
;|***   //if(data2[27] >  2047) data2[27] =  2047;
;|***   //if(data2[27] < -2048) data2[27] = -2048;
;|***   //data2[27] = data2[27] + s_offset;
;|***     
;|***     // pitch_accel (Qdot), lsb = 2^-6 deg/sec^2/count, range = +-70 deg/sec^2    
;|*** //  data2[28] = int(data[6]  * 0.457142857) + s_offset; // pitch_FAST_ACCEL
;|***   //data2[28] = data[6];
;|***   // limit pitch_accel to 12-bits and max +- 128 deg/sec^2 range  
;|***   //if(data2[28] >  8191) data2[28] =  8191;
;|***   //if(data2[28] < -8192) data2[28] = -8192;
;|***   //data2[28] = (data2[28] >> 2) + s_offset;
;|***   //new 2/10/2005
;|***   //data2[28] = (long)ln200.data[6];
;|***   // limit pitch_accel to 12-bits and max +- 128 deg/sec^2 range  
;|***   //if(data2[28] >  8191) data2[28] =  8191;
;|***   //if(data2[28] < -8192) data2[28] = -8192;
;|***   //data2[28] = (data2[28] >> 2) + s_offset;
;|*** 
;|***     // yaw_accel (Rdot), lsb = 2^-7 deg/sec^2/count, range = +-70 deg/sec^2    
;|***   //data2[29] = int(data[8]  * 0.228571429) + s_offset; // yaw_FAST_ACCEL
;|***   //data2[29] = data[8];
;|***   // limit yaw_accel to 12-bits and max +- 128 deg/sec^2 range  
;|***   //if(data2[29] >  16383) data2[29] =  16383;
;|***   //if(data2[29] < -16384) data2[29] = -16384;
;|***   //data2[29] = (data2[29] >> 3) + s_offset;
;|***   //new 2/10/2005
;|***   //data2[29] = (long)ln200.data[8];
;|***   // limit yaw_accel to 12-bits and max +- 128 deg/sec^2 range  
;|***   //if(data2[29] >  16383) data2[29] =  16383;
;|***   //if(data2[29] < -16384) data2[29] = -16384;
;|***   //data2[29] = (data2[29] >> 3) + s_offset;
;|***   
;|***   
;|***     // scale 16-bit data to 12-bit by dividing by 2^4
;|***   //data2[30] = (data[36] >> 4)      + s_offset; // prop_cmd
;|***   //data2[31] = (data[39] >> 4)      + s_offset; // fwd_cmd
;|***   //data2[32] = (data[37] >> 4)      + s_offset; // strn_cmd
;|***   //data2[33] = (data[38] >> 4)      + s_offset; // rudd_cmd
;|***   //data2[34] = (data[42] >> 4)      + s_offset; // failsafe
;|***   //data2[35] = (data[40] >> 4)      + s_offset; // cage/mode
;|***   //data2[36] = (data[16] >> 4)      + s_offset; // e_bat
;|***   //new 2/10/2005
;|***   data2[30] = ((long)obs.data[21] >> 4)      + s_offset; // prop_cmd
; Line 596
	*** 0006bb	8e 06 00 00 		mov	es,WORD PTR $T4111
	*** 0006bf	26 a1 36 00 		mov	ax,WORD PTR es:?obs@@3UOBS@@E+54	;obs
	*** 0006c3	c1 e8 04 		shr	ax,4
	*** 0006c6	2b d2 			sub	dx,dx
	*** 0006c8	05 00 08 		add	ax,2048	;0800H
	*** 0006cb	83 d2 00 		adc	dx,0
	*** 0006ce	89 86 78 ff 		mov	WORD PTR [bp-136],ax
	*** 0006d2	89 96 7a ff 		mov	WORD PTR [bp-134],dx
;|***   data2[31] = ((long)obs.data[25] >> 4)      + s_offset; // fwd_cmd
; Line 597
	*** 0006d6	26 a1 3e 00 		mov	ax,WORD PTR es:?obs@@3UOBS@@E+62	;obs
	*** 0006da	c1 e8 04 		shr	ax,4
	*** 0006dd	2b d2 			sub	dx,dx
	*** 0006df	05 00 08 		add	ax,2048	;0800H
	*** 0006e2	83 d2 00 		adc	dx,0
	*** 0006e5	89 86 7c ff 		mov	WORD PTR [bp-132],ax
	*** 0006e9	89 96 7e ff 		mov	WORD PTR [bp-130],dx
;|***   data2[32] = ((long)obs.data[22] >> 4)      + s_offset; // strn_cmd
; Line 598
	*** 0006ed	26 a1 38 00 		mov	ax,WORD PTR es:?obs@@3UOBS@@E+56	;obs
	*** 0006f1	c1 e8 04 		shr	ax,4
	*** 0006f4	2b d2 			sub	dx,dx
	*** 0006f6	05 00 08 		add	ax,2048	;0800H
	*** 0006f9	83 d2 00 		adc	dx,0
	*** 0006fc	89 46 80 		mov	WORD PTR [bp-128],ax
	*** 0006ff	89 56 82 		mov	WORD PTR [bp-126],dx
;|***   data2[33] = ((long)obs.data[24] >> 4)      + s_offset; // rudd_cmd
; Line 599
	*** 000702	26 a1 3c 00 		mov	ax,WORD PTR es:?obs@@3UOBS@@E+60	;obs
	*** 000706	c1 e8 04 		shr	ax,4
	*** 000709	2b d2 			sub	dx,dx
	*** 00070b	05 00 08 		add	ax,2048	;0800H
	*** 00070e	83 d2 00 		adc	dx,0
	*** 000711	89 46 84 		mov	WORD PTR [bp-124],ax
	*** 000714	89 56 86 		mov	WORD PTR [bp-122],dx
;|***   data2[34] = ((long)obs.data[28] >> 4)      + s_offset; // failsafe
; Line 600
	*** 000717	26 a1 44 00 		mov	ax,WORD PTR es:?obs@@3UOBS@@E+68	;obs
	*** 00071b	c1 e8 04 		shr	ax,4
	*** 00071e	2b d2 			sub	dx,dx
	*** 000720	05 00 08 		add	ax,2048	;0800H
	*** 000723	83 d2 00 		adc	dx,0
	*** 000726	89 46 88 		mov	WORD PTR [bp-120],ax
	*** 000729	89 56 8a 		mov	WORD PTR [bp-118],dx
;|***   data2[35] = ((long)obs.data[26] >> 4)      + s_offset; // cage/mode
; Line 601
	*** 00072c	26 a1 40 00 		mov	ax,WORD PTR es:?obs@@3UOBS@@E+64	;obs
	*** 000730	c1 e8 04 		shr	ax,4
	*** 000733	2b d2 			sub	dx,dx
	*** 000735	05 00 08 		add	ax,2048	;0800H
	*** 000738	83 d2 00 		adc	dx,0
	*** 00073b	89 46 8c 		mov	WORD PTR [bp-116],ax
	*** 00073e	89 56 8e 		mov	WORD PTR [bp-114],dx
;|***   data2[36] = ((long)obs.data[16] >> 4)      + s_offset; // e_bat
; Line 602
	*** 000741	26 a1 2c 00 		mov	ax,WORD PTR es:?obs@@3UOBS@@E+44	;obs
	*** 000745	c1 e8 04 		shr	ax,4
	*** 000748	2b d2 			sub	dx,dx
	*** 00074a	05 00 08 		add	ax,2048	;0800H
	*** 00074d	83 d2 00 		adc	dx,0
	*** 000750	89 46 90 		mov	WORD PTR [bp-112],ax
	*** 000753	89 56 92 		mov	WORD PTR [bp-110],dx
;|***   
;|***     // yaw, ln200 lsb = (2^-15) * 180 deg/count, range = +-180 deg    
;|***   //data2[37] = int(data[11] * 0.0625)      + s_offset; // yaw180
;|***   //data2[37] = (data[11] >> 4)      + s_offset; // yaw180
;|***   //new 2/10/2005
;|***   data2[37] = ((long)ln200.data[11] >> 4)      + s_offset; // yaw180  
; Line 608
	*** 000756	8e 06 00 00 		mov	es,WORD PTR $T4111
	*** 00075a	26 a1 22 00 		mov	ax,WORD PTR es:?ln200@@3ULN200@@E+34	;ln200
	*** 00075e	c1 f8 04 		sar	ax,4
	*** 000761	99 			cwd	
	*** 000762	05 00 08 		add	ax,2048	;0800H
	*** 000765	83 d2 00 		adc	dx,0
	*** 000768	89 46 94 		mov	WORD PTR [bp-108],ax
	*** 00076b	89 56 96 		mov	WORD PTR [bp-106],dx
;|*** 
;|***     // yaw_exp, lsb = (2^-15) * 180 deg/count, range = +-45 deg      
;|***     // deleted 2/21/2002 jtm
;|***   //data2[38] = int(data[11] * 0.0625)        + s_offset; // yaw_exp 8/03/01
;|***   //new 2/10/2005
;|***   //data2[38] = 0;
;|***   
;|***     // pitch_exp, ln200 lsb = (2^-15) * 180 deg/count, range = +-22.5 deg      
;|***     // deleted 2/21/2002 jtm    
;|***   //data2[39] = int(data[9]  * 0.25)         + s_offset; // pitch_exp  8/03/01
;|***   //new 2/10/2005
;|***   //data2[39] = 0;
;|***   
;|***     // roll, ln200 lsb = (2^-15) * 180 deg/count, range = +-180 deg      
;|***   //data2[40] = (data[10] >> 3) + s_offset; // roll
;|***   //new 2/10/2005
;|***   data2[40] = ((long)ln200.data[10] >> 3) + s_offset; // roll  
; Line 625
	*** 00076e	26 a1 20 00 		mov	ax,WORD PTR es:?ln200@@3ULN200@@E+32	;ln200
	*** 000772	c1 f8 03 		sar	ax,3
	*** 000775	99 			cwd	
	*** 000776	05 00 08 		add	ax,2048	;0800H
	*** 000779	83 d2 00 		adc	dx,0
	*** 00077c	89 46 a0 		mov	WORD PTR [bp-96],ax
	*** 00077f	89 56 a2 		mov	WORD PTR [bp-94],dx
;|*** 
;|***     // roll_rate_exp, lsb = 2^-6 deg/sec/count, range = +-14 deg/sec  
;|***     // deleted 2/21/2002 jtm    
;|***   //data2[41] = int(data[4]  * 2.285714286) + s_offset;
;|***   //data2[41] = 0;
;|***   
;|***     // pitch_rate_exp, lsb = 2^-8 deg/sec/count, range = +-14 deg/sec    
;|***     // deleted 2/21/2002 jtm    
;|***   //data2[42] = int(data[3]  * 0.571428571) + s_offset; // pitch_rate_exp
;|***   //data2[42] = 0;
;|***   
;|***   // new depth gauges 2/17/2005 jtm
;|***   data2[41] = ((long)obs.data[0] >> 4) + s_offset; // depth 1
; Line 638
	*** 000782	8e 06 00 00 		mov	es,WORD PTR $T4111
	*** 000786	26 a1 0c 00 		mov	ax,WORD PTR es:?obs@@3UOBS@@E+12	;obs
	*** 00078a	c1 e8 04 		shr	ax,4
	*** 00078d	2b d2 			sub	dx,dx
	*** 00078f	05 00 08 		add	ax,2048	;0800H
	*** 000792	83 d2 00 		adc	dx,0
	*** 000795	89 46 a4 		mov	WORD PTR [bp-92],ax
	*** 000798	89 56 a6 		mov	WORD PTR [bp-90],dx
;|***   data2[42] = ((long)obs.data[1] >> 4) + s_offset; // depth 2
; Line 639
	*** 00079b	26 a1 0e 00 		mov	ax,WORD PTR es:?obs@@3UOBS@@E+14	;obs
	*** 00079f	c1 e8 04 		shr	ax,4
	*** 0007a2	2b d2 			sub	dx,dx
	*** 0007a4	05 00 08 		add	ax,2048	;0800H
	*** 0007a7	83 d2 00 		adc	dx,0
	*** 0007aa	89 46 a8 		mov	WORD PTR [bp-88],ax
	*** 0007ad	89 56 aa 		mov	WORD PTR [bp-86],dx
;|***   data2[43] = ((long)obs.data[2] >> 4) + s_offset; // depth 3
; Line 640
	*** 0007b0	26 a1 10 00 		mov	ax,WORD PTR es:?obs@@3UOBS@@E+16	;obs
	*** 0007b4	c1 e8 04 		shr	ax,4
	*** 0007b7	2b d2 			sub	dx,dx
	*** 0007b9	05 00 08 		add	ax,2048	;0800H
	*** 0007bc	83 d2 00 		adc	dx,0
	*** 0007bf	89 46 ac 		mov	WORD PTR [bp-84],ax
	*** 0007c2	89 56 ae 		mov	WORD PTR [bp-82],dx
;|***   
;|***   
;|***   // new status bits
;|***   data2[44] = sys.fs_status & 0x0fff;
; Line 644
	*** 0007c5	8e 06 00 00 		mov	es,WORD PTR $T4111
	*** 0007c9	26 a1 08 00 		mov	ax,WORD PTR es:?sys@@3USYS@@E+8	;sys
	*** 0007cd	25 ff 0f 		and	ax,4095	;0fffH
	*** 0007d0	89 46 b0 		mov	WORD PTR [bp-80],ax
	*** 0007d3	c7 46 b2 00 00 		mov	WORD PTR [bp-78],0
;|***   //data2[45] = echo.data[1]  & 0x0fff;
;|***   data2[45] = commands.mode  & 0x0fff;
; Line 646
	*** 0007d8	8e 06 00 00 		mov	es,WORD PTR $T4111
	*** 0007dc	26 a1 02 00 		mov	ax,WORD PTR es:?commands@@3UCOMMANDS@@E+2	;commands
	*** 0007e0	25 ff 0f 		and	ax,4095	;0fffH
	*** 0007e3	89 46 b4 		mov	WORD PTR [bp-76],ax
	*** 0007e6	c7 46 b6 00 00 		mov	WORD PTR [bp-74],0
;|***     // yaw_rate_exp, lsb = 2^-9 deg/sec/count, range = +-14 deg/sec  
;|***     // deleted 2/21/2002 jtm
;|***   //data2[43] = int(data[5]  * 0.285714286) + s_offset; // yaw_rate_exp
;|***   //data2[43] = 0;
;|***   
;|***     // x_accel_exp, lsb = (2^-6) ft/sec^2/count, range = +-17 ft/sec^2      
;|***     // deleted 2/21/2002 jtm    
;|***   //data2[44] = int(data[2]  * 1.882352941) + s_offset; // x_accel_exp
;|***   //data2[44] = 0;
;|***     
;|***     // y_accel_exp, lsb = (2^-6) ft/sec^2/count, range = +-17 ft/sec^2        
;|***     // deleted 2/21/2002 jtm    
;|***   //data2[45] = int(data[1]  * 1.882352941) + s_offset; // y_accel_exp
;|***   //data2[45] = 0;
;|***   
;|***     // z_accel_exp, lsb = (2^-6) ft/sec^2/count, range = +-17 ft/sec^2
;|***     // NOTE:  LN200 reading is compensated for standard gravity: (32.17405 / 2^-6 counts)
;|***     // deleted 2/21/2002 jtm    
;|***   //data2[46] = int((data[0] + (32.17405 * 64)) * 1.882352941) + s_offset; // z_accel_exp
;|***   //data2[46] = 0;
;|***   
;|***     // Pdot_exp, lsb = 2^-4 deg/sec^2, range = +-17 deg/sec^2
;|***     // deleted 2/21/2002 jtm    
;|***   //data2[47] = int(data[7]  * 7.529411765) + s_offset; // Pdot_exp
;|***   //data2[47] = 0;
;|*** 
;|***   status_word = 0;
; Line 673
	*** 0007eb	c7 86 fa fe 00 00 	mov	WORD PTR [bp-262],0	;status_word
;|***   //data2[48] = status_word | !in_hw_failsafe << 11
;|***   //                        | (!(taking_data | taking_zeros) <<8)
;|***   //                        | 0x680
;|***   //                        | taking_data << 3
;|***   //                        | taking_zeros << 2
;|***   //                        | mode << 1
;|***   //                        | direction;
;|***   data2[48] = status_word;                          
; Line 681
	*** 0007f1	8b 86 fa fe 		mov	ax,WORD PTR [bp-262]	;status_word
	*** 0007f5	89 46 c0 		mov	WORD PTR [bp-64],ax
	*** 0007f8	c7 46 c2 00 00 		mov	WORD PTR [bp-62],0
;|*** 
;|***     // Qdot_exp, lsb = (2^-6) ft/sec^2/count, range = +-17 ft/sec^2                                
;|***     // deleted 2/21/2002 jtm    
;|***   //data2[49] = int(data[6] * 1.882352941) + s_offset; // Qdot_exp
;|***   //data2[49] = 0;
;|***   
;|***     // Rdot_exp, lsb = (2^-7) ft/sec^2/count, range = +-17 ft/sec^2        
;|***     // deleted 2/21/2002 jtm    
;|***   //data2[50] = int(data[8] * 0.941176471) + s_offset; // Rdot_exp
;|***   //data2[50] = 0;
;|***     
;|***     // depth3, bow sensor, data[47], obc ch 31, sc2 ch15, mm32 adc ch17
;|***     // deleted 2/21/2002 jtm    
;|***   //data2[51] = (data[47] * 0.074482759) + s_offset; // added 5/21/01 JTM
;|***   //data2[51] = 0;
;|***   
;|***     //fore plane lvdt
;|***   data2[52] = (long)obs.data[7];
; Line 699
	*** 0007fd	8e 06 00 00 		mov	es,WORD PTR $T4111
	*** 000801	26 a1 1a 00 		mov	ax,WORD PTR es:?obs@@3UOBS@@E+26	;obs
	*** 000805	89 46 d0 		mov	WORD PTR [bp-48],ax
	*** 000808	c7 46 d2 00 00 		mov	WORD PTR [bp-46],0
;|***   data2[52] = (data2[52] >> 4) + s_offset;
; Line 700
	*** 00080d	8b 46 d0 		mov	ax,WORD PTR [bp-48]
	*** 000810	8b 56 d2 		mov	dx,WORD PTR [bp-46]
	*** 000813	d1 fa 			sar	dx,1
	*** 000815	d1 d8 			rcr	ax,1
	*** 000817	d1 fa 			sar	dx,1
	*** 000819	d1 d8 			rcr	ax,1
	*** 00081b	d1 fa 			sar	dx,1
	*** 00081d	d1 d8 			rcr	ax,1
	*** 00081f	d1 fa 			sar	dx,1
	*** 000821	d1 d8 			rcr	ax,1
	*** 000823	05 00 08 		add	ax,2048	;0800H
	*** 000826	83 d2 00 		adc	dx,0
	*** 000829	89 46 d0 		mov	WORD PTR [bp-48],ax
	*** 00082c	89 56 d2 		mov	WORD PTR [bp-46],dx
;|*** 
;|***     //rudder lvdt
;|***   data2[53] = obs.data[6];
; Line 703
	*** 00082f	26 a1 18 00 		mov	ax,WORD PTR es:?obs@@3UOBS@@E+24	;obs
	*** 000833	89 46 d4 		mov	WORD PTR [bp-44],ax
	*** 000836	c7 46 d6 00 00 		mov	WORD PTR [bp-42],0
;|***   data2[53] = (data2[53] >> 4) + s_offset;
; Line 704
	*** 00083b	8b 46 d4 		mov	ax,WORD PTR [bp-44]
	*** 00083e	8b 56 d6 		mov	dx,WORD PTR [bp-42]
	*** 000841	d1 fa 			sar	dx,1
	*** 000843	d1 d8 			rcr	ax,1
	*** 000845	d1 fa 			sar	dx,1
	*** 000847	d1 d8 			rcr	ax,1
	*** 000849	d1 fa 			sar	dx,1
	*** 00084b	d1 d8 			rcr	ax,1
	*** 00084d	d1 fa 			sar	dx,1
	*** 00084f	d1 d8 			rcr	ax,1
	*** 000851	05 00 08 		add	ax,2048	;0800H
	*** 000854	83 d2 00 		adc	dx,0
	*** 000857	89 46 d4 		mov	WORD PTR [bp-44],ax
	*** 00085a	89 56 d6 		mov	WORD PTR [bp-42],dx
;|*** 
;|***     //stern lvdt
;|***   data2[54] = obs.data[4];  
; Line 707
	*** 00085d	26 a1 14 00 		mov	ax,WORD PTR es:?obs@@3UOBS@@E+20	;obs
	*** 000861	89 46 d8 		mov	WORD PTR [bp-40],ax
	*** 000864	c7 46 da 00 00 		mov	WORD PTR [bp-38],0
;|***   data2[54] = (data2[54] >> 4) + s_offset;
; Line 708
	*** 000869	8b 46 d8 		mov	ax,WORD PTR [bp-40]
	*** 00086c	8b 56 da 		mov	dx,WORD PTR [bp-38]
	*** 00086f	d1 fa 			sar	dx,1
	*** 000871	d1 d8 			rcr	ax,1
	*** 000873	d1 fa 			sar	dx,1
	*** 000875	d1 d8 			rcr	ax,1
	*** 000877	d1 fa 			sar	dx,1
	*** 000879	d1 d8 			rcr	ax,1
	*** 00087b	d1 fa 			sar	dx,1
	*** 00087d	d1 d8 			rcr	ax,1
	*** 00087f	05 00 08 		add	ax,2048	;0800H
	*** 000882	83 d2 00 		adc	dx,0
	*** 000885	89 46 d8 		mov	WORD PTR [bp-40],ax
	*** 000888	89 56 da 		mov	WORD PTR [bp-38],dx
;|***   
;|***     // stern tips lvdt
;|***   data2[55] = obs.data[5];
; Line 711
	*** 00088b	26 a1 16 00 		mov	ax,WORD PTR es:?obs@@3UOBS@@E+22	;obs
	*** 00088f	89 46 dc 		mov	WORD PTR [bp-36],ax
	*** 000892	c7 46 de 00 00 		mov	WORD PTR [bp-34],0
;|***   data2[55] = (data2[55] >> 4) + s_offset;
; Line 712
	*** 000897	8b 46 dc 		mov	ax,WORD PTR [bp-36]
	*** 00089a	8b 56 de 		mov	dx,WORD PTR [bp-34]
	*** 00089d	d1 fa 			sar	dx,1
	*** 00089f	d1 d8 			rcr	ax,1
	*** 0008a1	d1 fa 			sar	dx,1
	*** 0008a3	d1 d8 			rcr	ax,1
	*** 0008a5	d1 fa 			sar	dx,1
	*** 0008a7	d1 d8 			rcr	ax,1
	*** 0008a9	d1 fa 			sar	dx,1
	*** 0008ab	d1 d8 			rcr	ax,1
	*** 0008ad	05 00 08 		add	ax,2048	;0800H
	*** 0008b0	83 d2 00 		adc	dx,0
	*** 0008b3	89 46 dc 		mov	WORD PTR [bp-36],ax
	*** 0008b6	89 56 de 		mov	WORD PTR [bp-34],dx
;|*** 
;|***   
;|***    // prop_voltage, sc1 ch3, mm32 adc ch3; mc output is +- 5V, 40V/V; module is +-10V
;|***    // NOTE:  data is shifted by 3 instead of 4 because 5B module has
;|***    // +/-10 volt input instead of +/- 5 volt input.  ??????????
;|***   //data2[56] = (data[19] >> 4) + s_offset;
;|***   //new 2/10/2005
;|***   //data2[56] = ((long)obs.data[18] >> 4) + s_offset;  
;|***   // new 11/7/07 - for TB RPM
;|***   data2[60] = ((long)obs.data[18] >> 4) + s_offset;  
; Line 722
	*** 0008b9	26 a1 30 00 		mov	ax,WORD PTR es:?obs@@3UOBS@@E+48	;obs
	*** 0008bd	c1 e8 04 		shr	ax,4
	*** 0008c0	2b d2 			sub	dx,dx
	*** 0008c2	05 00 08 		add	ax,2048	;0800H
	*** 0008c5	83 d2 00 		adc	dx,0
	*** 0008c8	89 46 f0 		mov	WORD PTR [bp-16],ax
	*** 0008cb	89 56 f2 		mov	WORD PTR [bp-14],dx
;|***   
;|***   
;|***    // prop_current, sc1 ch2, mm32 adc ch2; mc output is +- 5V, 20V/V; module is +-10V
;|***    // NOTE:  data is shifted by 3 instead of 4 because 5B module has
;|***    // +/-10 volt input instead of +/- 5 volt input.  
;|***   //data2[57] = (data[18] >> 4) + s_offset;
;|***   //new 2/10/2005
;|***   // Used for TB port RPM
;|***   data2[57] = ((long)obs.data[19] >> 4) + s_offset;
; Line 731
	*** 0008ce	26 a1 32 00 		mov	ax,WORD PTR es:?obs@@3UOBS@@E+50	;obs
	*** 0008d2	c1 e8 04 		shr	ax,4
	*** 0008d5	2b d2 			sub	dx,dx
	*** 0008d7	05 00 08 		add	ax,2048	;0800H
	*** 0008da	83 d2 00 		adc	dx,0
	*** 0008dd	89 46 e4 		mov	WORD PTR [bp-28],ax
	*** 0008e0	89 56 e6 		mov	WORD PTR [bp-26],dx
;|*** 
;|***     // pitch, lsb = (2^-15) * 180 deg/count, range = +-90 deg        
;|***   //data2[58] = (data[9] >> 2) + s_offset; // pitch
;|***   //new 2/10/2005
;|***   data2[58] = ((long)ln200.data[9] >> 2) + s_offset; // pitch
; Line 736
	*** 0008e3	8e 06 00 00 		mov	es,WORD PTR $T4111
	*** 0008e7	26 a1 1e 00 		mov	ax,WORD PTR es:?ln200@@3ULN200@@E+30	;ln200
	*** 0008eb	c1 f8 02 		sar	ax,2
	*** 0008ee	99 			cwd	
	*** 0008ef	05 00 08 		add	ax,2048	;0800H
	*** 0008f2	83 d2 00 		adc	dx,0
	*** 0008f5	89 46 e8 		mov	WORD PTR [bp-24],ax
	*** 0008f8	89 56 ea 		mov	WORD PTR [bp-22],dx
;|*** 
;|*** 
;|***     // paddle_wheel, module is 500Hz 0-5Volt
;|*** /*
;|***   if(data[34] < 0) data[34] = 0;  
;|***   data2[59] = 2047 - ((data[34] >> 4) );
;|*** */  
;|***   data2[59] = obs.data[3];
; Line 744
	*** 0008fb	8e 06 00 00 		mov	es,WORD PTR $T4111
	*** 0008ff	26 a1 12 00 		mov	ax,WORD PTR es:?obs@@3UOBS@@E+18	;obs
	*** 000903	89 46 ec 		mov	WORD PTR [bp-20],ax
	*** 000906	c7 46 ee 00 00 		mov	WORD PTR [bp-18],0
;|***   if(data2[59] < 0) data2[59] = 0;    
; Line 745
	*** 00090b	83 7e ee 00 		cmp	WORD PTR [bp-18],0
	*** 00090f	7c 03 			jl	$JCC2319
	*** 000911	e9 08 00 		jmp	$I3713
					$JCC2319:
	*** 000914	2b c0 			sub	ax,ax
	*** 000916	89 46 ee 		mov	WORD PTR [bp-18],ax
	*** 000919	89 46 ec 		mov	WORD PTR [bp-20],ax
;|***   data2[59] = (data2[59] >> 4) + s_offset;
; Line 746
					$I3713:
	*** 00091c	8b 46 ec 		mov	ax,WORD PTR [bp-20]
	*** 00091f	8b 56 ee 		mov	dx,WORD PTR [bp-18]
	*** 000922	d1 fa 			sar	dx,1
	*** 000924	d1 d8 			rcr	ax,1
	*** 000926	d1 fa 			sar	dx,1
	*** 000928	d1 d8 			rcr	ax,1
	*** 00092a	d1 fa 			sar	dx,1
	*** 00092c	d1 d8 			rcr	ax,1
	*** 00092e	d1 fa 			sar	dx,1
	*** 000930	d1 d8 			rcr	ax,1
	*** 000932	05 00 08 		add	ax,2048	;0800H
	*** 000935	83 d2 00 		adc	dx,0
	*** 000938	89 46 ec 		mov	WORD PTR [bp-20],ax
	*** 00093b	89 56 ee 		mov	WORD PTR [bp-18],dx
;|*** 
;|***     // rpm, 2540 pulse/rev, module is 100KHz 0-5Volt
;|*** /*
;|***   if(data[35] < 0) data[35] = 0;  
;|***   data2[60] = 2047 - ((data[35] >> 4) );
;|*** */  
;|***   // Take out for TB RPM 11/7/07
;|***   //data2[60] = obs.data[20];
;|***   //if(data2[60] < 0) data2[60] = 0;  
;|***   //data2[60] = (data2[60] >> 4) + s_offset;  
;|***     
;|***     // depth1, stern port 
;|***     // deleted 2/21/2002 jtm  
;|***   //data2[61] = int(data[32] * 0.074482759) + s_offset;
;|***   //data2[61] = 0;
;|***   
;|***     // depth2, stern starboard
;|***     // deleted 2/21/2002 jtm  
;|***   //data2[62] = int(data[33] * 0.074482759) + s_offset;
;|***   //data2[62] = 0;
;|***     
;|***     // roll_rate, lsb = 2^-6, range = +-55 deg/sec
;|***     // deleted 2/21/2002 jtm    
;|***   //data2[63] = int(data[4]  * 0.581818182) + s_offset; // roll_rate
;|***   //data2[63] = 0;
;|***   
;|***   //The scaled and offset data is now stored in array pcm[] in 8 bit bytes.
;|***   //The following for-loop converts 2 16-bit data2[] words into 3 8-bit pcm[] bytes
;|***   //(shift and mask), and reverses the word msb for lsb,
;|***   
;|***   for(int jj=0; jj<32; jj++)
; Line 777
	*** 00093e	c7 86 f8 fe 00 00 	mov	WORD PTR [bp-264],0	;jj
	*** 000944	e9 04 00 		jmp	$F3715
					$FC3716:
	*** 000947	ff 86 f8 fe 		inc	WORD PTR [bp-264]	;jj
					$F3715:
	*** 00094b	83 be f8 fe 20 		cmp	WORD PTR [bp-264],32	;0020H	;jj
	*** 000950	7c 03 			jl	$JCC2384
	*** 000952	e9 2e 01 		jmp	$FB3717
					$JCC2384:
;|***     {
; Line 778
;	variable1 = -266
;	variable2 = -268
;	variable3 = -270
;	i = -272
;|***     pcm[3*jj] = 0;
; Line 779
	*** 000955	8b 9e f8 fe 		mov	bx,WORD PTR [bp-264]	;jj
	*** 000959	8b c3 			mov	ax,bx
	*** 00095b	d1 e3 			shl	bx,1
	*** 00095d	03 d8 			add	bx,ax
	*** 00095f	c6 87 00 00 00 		mov	BYTE PTR ?pcm@@3QIDI[bx],0	;pcm
;|***     pcm[3*jj+1] = 0;
; Line 780
	*** 000964	8b 9e f8 fe 		mov	bx,WORD PTR [bp-264]	;jj
	*** 000968	8b c3 			mov	ax,bx
	*** 00096a	d1 e3 			shl	bx,1
	*** 00096c	03 d8 			add	bx,ax
	*** 00096e	c6 87 01 00 00 		mov	BYTE PTR ?pcm@@3QIDI[bx+1],0	;pcm
;|***     pcm[3*jj+2] = 0;  
; Line 781
	*** 000973	8b 9e f8 fe 		mov	bx,WORD PTR [bp-264]	;jj
	*** 000977	8b c3 			mov	ax,bx
	*** 000979	d1 e3 			shl	bx,1
	*** 00097b	03 d8 			add	bx,ax
	*** 00097d	c6 87 02 00 00 		mov	BYTE PTR ?pcm@@3QIDI[bx+2],0	;pcm
;|***     
;|***     int variable1 = (int)(data2[2*jj] >> 4) & 0x00ff;
; Line 783
	*** 000982	8b b6 f8 fe 		mov	si,WORD PTR [bp-264]	;jj
	*** 000986	c1 e6 03 		shl	si,3
	*** 000989	8b 82 00 ff 		mov	ax,WORD PTR [bp-256][si]
	*** 00098d	8b 92 02 ff 		mov	dx,WORD PTR [bp-254][si]
	*** 000991	d1 fa 			sar	dx,1
	*** 000993	d1 d8 			rcr	ax,1
	*** 000995	d1 fa 			sar	dx,1
	*** 000997	d1 d8 			rcr	ax,1
	*** 000999	d1 fa 			sar	dx,1
	*** 00099b	d1 d8 			rcr	ax,1
	*** 00099d	d1 fa 			sar	dx,1
	*** 00099f	d1 d8 			rcr	ax,1
	*** 0009a1	2a e4 			sub	ah,ah
	*** 0009a3	89 86 f6 fe 		mov	WORD PTR [bp-266],ax	;variable1
;|***     int variable2 = (int)((data2[2*jj]<<4) & 0x00f0) | (int)((data2[2*jj+1]>>8)&0x000f);
; Line 784
	*** 0009a7	8b b6 f8 fe 		mov	si,WORD PTR [bp-264]	;jj
	*** 0009ab	c1 e6 03 		shl	si,3
	*** 0009ae	8b 82 04 ff 		mov	ax,WORD PTR [bp-252][si]
	*** 0009b2	8b 92 06 ff 		mov	dx,WORD PTR [bp-250][si]
	*** 0009b6	8a c4 			mov	al,ah
	*** 0009b8	8a e2 			mov	ah,dl
	*** 0009ba	8a d6 			mov	dl,dh
	*** 0009bc	d0 e6 			shl	dh,1
	*** 0009be	1a f6 			sbb	dh,dh
	*** 0009c0	25 0f 00 		and	ax,15	;000fH
	*** 0009c3	8b b6 f8 fe 		mov	si,WORD PTR [bp-264]	;jj
	*** 0009c7	c1 e6 03 		shl	si,3
	*** 0009ca	8a 8a 00 ff 		mov	cl,BYTE PTR [bp-256][si]
	*** 0009ce	83 e1 0f 		and	cx,15	;000fH
	*** 0009d1	c1 e1 04 		shl	cx,4
	*** 0009d4	0b c8 			or	cx,ax
	*** 0009d6	89 8e f4 fe 		mov	WORD PTR [bp-268],cx	;variable2
;|***     int variable3 = (int)data2[2*jj+1] & 0x00ff;
; Line 785
	*** 0009da	8b b6 f8 fe 		mov	si,WORD PTR [bp-264]	;jj
	*** 0009de	c1 e6 03 		shl	si,3
	*** 0009e1	8a 82 04 ff 		mov	al,BYTE PTR [bp-252][si]
	*** 0009e5	2a e4 			sub	ah,ah
	*** 0009e7	89 86 f2 fe 		mov	WORD PTR [bp-270],ax	;variable3
;|*** 
;|***                        
;|***     for(int i=0; i<8; i++)  // reverse the bytes bitwise msb to lsb
; Line 788
	*** 0009eb	c7 86 f0 fe 00 00 	mov	WORD PTR [bp-272],0	;i
	*** 0009f1	e9 04 00 		jmp	$F3726
					$FC3727:
	*** 0009f4	ff 86 f0 fe 		inc	WORD PTR [bp-272]	;i
					$F3726:
	*** 0009f8	83 be f0 fe 08 		cmp	WORD PTR [bp-272],8	;i
	*** 0009fd	7c 03 			jl	$JCC2557
	*** 0009ff	e9 7e 00 		jmp	$FB3728
					$JCC2557:
;|***       {
; Line 789
;|***       if(variable1 & 1<<i) pcm[3*jj]   = pcm[3*jj]   | 0x0080>>i; 
; Line 790
	*** 000a02	8a 8e f0 fe 		mov	cl,BYTE PTR [bp-272]	;i
	*** 000a06	b8 01 00 		mov	ax,1
	*** 000a09	d3 e0 			shl	ax,cl
	*** 000a0b	85 86 f6 fe 		test	ax,WORD PTR [bp-266]	;variable1
	*** 000a0f	75 03 			jne	$JCC2575
	*** 000a11	e9 17 00 		jmp	$I3729
					$JCC2575:
	*** 000a14	8a 8e f0 fe 		mov	cl,BYTE PTR [bp-272]	;i
	*** 000a18	b8 80 00 		mov	ax,128	;0080H
	*** 000a1b	d3 f8 			sar	ax,cl
	*** 000a1d	8b 9e f8 fe 		mov	bx,WORD PTR [bp-264]	;jj
	*** 000a21	8b cb 			mov	cx,bx
	*** 000a23	d1 e3 			shl	bx,1
	*** 000a25	03 d9 			add	bx,cx
	*** 000a27	08 87 00 00 		or	BYTE PTR ?pcm@@3QIDI[bx],al	;pcm
;|***       if(variable2 & 1<<i) pcm[3*jj+1] = pcm[3*jj+1] | 0x0080>>i;
; Line 791
					$I3729:
	*** 000a2b	8a 8e f0 fe 		mov	cl,BYTE PTR [bp-272]	;i
	*** 000a2f	b8 01 00 		mov	ax,1
	*** 000a32	d3 e0 			shl	ax,cl
	*** 000a34	85 86 f4 fe 		test	ax,WORD PTR [bp-268]	;variable2
	*** 000a38	75 03 			jne	$JCC2616
	*** 000a3a	e9 17 00 		jmp	$I3730
					$JCC2616:
	*** 000a3d	8a 8e f0 fe 		mov	cl,BYTE PTR [bp-272]	;i
	*** 000a41	b8 80 00 		mov	ax,128	;0080H
	*** 000a44	d3 f8 			sar	ax,cl
	*** 000a46	8b 9e f8 fe 		mov	bx,WORD PTR [bp-264]	;jj
	*** 000a4a	8b cb 			mov	cx,bx
	*** 000a4c	d1 e3 			shl	bx,1
	*** 000a4e	03 d9 			add	bx,cx
	*** 000a50	08 87 01 00 		or	BYTE PTR ?pcm@@3QIDI[bx+1],al	;pcm
;|***       if(variable3 & 1<<i) pcm[3*jj+2] = pcm[3*jj+2] | 0x0080>>i;
; Line 792
					$I3730:
	*** 000a54	8a 8e f0 fe 		mov	cl,BYTE PTR [bp-272]	;i
	*** 000a58	b8 01 00 		mov	ax,1
	*** 000a5b	d3 e0 			shl	ax,cl
	*** 000a5d	85 86 f2 fe 		test	ax,WORD PTR [bp-270]	;variable3
	*** 000a61	75 03 			jne	$JCC2657
	*** 000a63	e9 17 00 		jmp	$I3731
					$JCC2657:
	*** 000a66	8a 8e f0 fe 		mov	cl,BYTE PTR [bp-272]	;i
	*** 000a6a	b8 80 00 		mov	ax,128	;0080H
	*** 000a6d	d3 f8 			sar	ax,cl
	*** 000a6f	8b 9e f8 fe 		mov	bx,WORD PTR [bp-264]	;jj
	*** 000a73	8b cb 			mov	cx,bx
	*** 000a75	d1 e3 			shl	bx,1
	*** 000a77	03 d9 			add	bx,cx
	*** 000a79	08 87 02 00 		or	BYTE PTR ?pcm@@3QIDI[bx+2],al	;pcm
;|***       }
; Line 793
					$I3731:
	*** 000a7d	e9 74 ff 		jmp	$FC3727
					$FB3728:
;|***     }  
; Line 794
	*** 000a80	e9 c4 fe 		jmp	$FC3716
					$FB3717:
;|***     
;|***   }  
; Line 796
	*** 000a83	e9 00 00 		jmp	$EX3689
					$EX3689:
	*** 000a86	5e 			pop	si
	*** 000a87	5f 			pop	di
	*** 000a88	c9 			leave	
	*** 000a89	cb 			ret	

?pack_pcm@@ZAXXZ	ENDP
	PUBLIC	?get_frame_time@@ZAXXZ	; get_frame_time
?get_frame_time@@ZAXXZ	PROC FAR	; get_frame_time
;|*** 
;|*** 
;|*** void get_frame_time(void)
;|***   {
; Line 800
	*** 000a8a	c8 00 00 00 		enter	0,0
	*** 000a8e	57 			push	di
	*** 000a8f	56 			push	si
;|***   _disable();
; Line 801
	*** 000a90	9a 00 00 00 00 		call	FAR PTR __disable
;|***   time_stamp(&frame_time);
; Line 802
	*** 000a95	68 00 00 		push	SEG ?frame_time@@3UTIMER@@E	;frame_time
	*** 000a98	68 00 00 		push	OFFSET ?frame_time@@3UTIMER@@E	;frame_time
	*** 000a9b	9a 00 00 00 00 		call	FAR PTR ?time_stamp@@ZAXPEUTIMER@@@Z	; time_stamp
	*** 000aa0	83 c4 04 		add	sp,4
;|***   _enable();
; Line 803
	*** 000aa3	9a 00 00 00 00 		call	FAR PTR __enable
;|***   }
; Line 804
	*** 000aa8	e9 00 00 		jmp	$EX3733
					$EX3733:
	*** 000aab	5e 			pop	si
	*** 000aac	5f 			pop	di
	*** 000aad	c9 			leave	
	*** 000aae	cb 			ret	

?get_frame_time@@ZAXXZ	ENDP
	PUBLIC	?send_data_packet@@ZAXXZ	; send_data_packet
?send_data_packet@@ZAXXZ	PROC FAR	; send_data_packet
;|***   
;|***   
;|*** void send_data_packet(void)
;|***   {
; Line 808
	*** 000aaf	c8 04 00 00 		enter	4,0
	*** 000ab3	57 			push	di
	*** 000ab4	56 			push	si
;	lsb = -2
;	msb = -4
;|***   unsigned int lsb = 0;
; Line 809
	*** 000ab5	c7 46 fe 00 00 		mov	WORD PTR [bp-2],0	;lsb
;|***   unsigned int msb = 0;
; Line 810
	*** 000aba	c7 46 fc 00 00 		mov	WORD PTR [bp-4],0	;msb
;|***   
;|***   build_packet();
; Line 812
	*** 000abf	9a 00 00 00 00 		call	FAR PTR ?build_packet@@ZAXXZ	; build_packet
;|***   send_pkt(data_pkt, 1514);  // 1514 bytes total w/o checksum
; Line 813
	*** 000ac4	68 ea 05 		push	1514	;05eaH
	*** 000ac7	1e 			push	ds
	*** 000ac8	68 00 00 		push	OFFSET DGROUP:?data_pkt@@3QIEI	;data_pkt
	*** 000acb	9a 00 00 00 00 		call	FAR PTR ?send_pkt@@ZAHPEEI@Z	; send_pkt
	*** 000ad0	83 c4 06 		add	sp,6
;|***   }
; Line 814
	*** 000ad3	e9 00 00 		jmp	$EX3735
					$EX3735:
	*** 000ad6	5e 			pop	si
	*** 000ad7	5f 			pop	di
	*** 000ad8	c9 			leave	
	*** 000ad9	cb 			ret	

?send_data_packet@@ZAXXZ	ENDP
	PUBLIC	?apply_commands@@ZAXXZ	; apply_commands
?apply_commands@@ZAXXZ	PROC FAR	; apply_commands
;|***   
;|***   
;|*** void apply_commands(void)
;|***   {
; Line 818
	*** 000ada	c8 04 00 00 		enter	4,0
	*** 000ade	57 			push	di
	*** 000adf	56 			push	si
;	lsb = -2
;	msb = -4
;|***   unsigned int lsb = 0;
; Line 819
	*** 000ae0	c7 46 fe 00 00 		mov	WORD PTR [bp-2],0	;lsb
;|***   unsigned int msb = 0;
; Line 820
	*** 000ae5	c7 46 fc 00 00 		mov	WORD PTR [bp-4],0	;msb
;|*** 
;|*** /*
;|*** struct COMMANDS  // new 12/8/2004
;|***   {
;|***   unsigned int  sync_word;
;|***   unsigned int  mode;
;|***   unsigned int  rpm;
;|***   unsigned int  rudder;
;|***   unsigned int  stern1;
;|***   unsigned int  stern2;
;|***   unsigned int  fore;  
;|***   unsigned int  ballast;
;|***   unsigned int  ln200_mode;
;|***   unsigned int  ln200_init_heading;
;|***   unsigned int  ln200_init_latitude;
;|***   unsigned int  adcp_reset;
;|***   unsigned int  adcp_heading;
;|***   unsigned int  ds_send_message;
;|***   unsigned int  ds_dmgx;
;|***   unsigned int  ds_dmgy;
;|***   unsigned int  ds_dmgz;        
;|***   unsigned int  spare1;
;|***   } commands;  
;|*** */     
;|*** 
;|***   // get commands from buffered udp packet
;|***   _disable();
; Line 847
	*** 000aea	9a 00 00 00 00 		call	FAR PTR __disable
;|***   _fmemcpy(&commands, &cmd_buffer[42], sizeof(commands));
; Line 848
	*** 000aef	6a 24 			push	36	;0024H
	*** 000af1	68 00 00 		push	SEG ?cmd_buffer@@3QEEE	;cmd_buffer
	*** 000af4	68 2a 00 		push	OFFSET ?cmd_buffer@@3QEEE+42	;cmd_buffer
	*** 000af7	68 00 00 		push	SEG ?commands@@3UCOMMANDS@@E	;commands
	*** 000afa	68 00 00 		push	OFFSET ?commands@@3UCOMMANDS@@E	;commands
	*** 000afd	9a 00 00 00 00 		call	FAR PTR __fmemcpy
	*** 000b02	83 c4 0a 		add	sp,10	;000aH
;|***   _enable();
; Line 849
	*** 000b05	9a 00 00 00 00 		call	FAR PTR __enable
;|***   
;|***   // zero out the commands if no response from control for 1 second (100 frames) (new 8/24/2005 jtm)
;|***   if(++time_since_last_command > 100)  
; Line 852
	*** 000b0a	ff 06 00 00 		inc	WORD PTR ?time_since_last_command@@3HE	;time_since_last_command
	*** 000b0e	83 3e 00 00 64 		cmp	WORD PTR ?time_since_last_command@@3HE,100	;0064H	;time_since_last_command
	*** 000b13	7f 03 			jg	$JCC2835
	*** 000b15	e9 2e 00 		jmp	$I3742
					$JCC2835:
;|***     {                                
; Line 853
;|***     //commands.rpm = 0;
;|***     //changed for TB model 9/26/2007 jtm
;|***     commands.stbd_rpm = 0;
; Line 856
	*** 000b18	8e 06 00 00 		mov	es,WORD PTR $T4111
	*** 000b1c	26 c7 06 04 00 00 00 	mov	WORD PTR es:?commands@@3UCOMMANDS@@E+4,0	;commands
;|***     commands.port_rpm = 0;
; Line 857
	*** 000b23	26 c7 06 22 00 00 00 	mov	WORD PTR es:?commands@@3UCOMMANDS@@E+34,0	;commands
;|***     
;|***     commands.rudder = 0x800;
; Line 859
	*** 000b2a	26 c7 06 06 00 00 08 	mov	WORD PTR es:?commands@@3UCOMMANDS@@E+6,2048	;0800H	;commands
;|***     commands.stern1 = 0x800;
; Line 860
	*** 000b31	26 c7 06 08 00 00 08 	mov	WORD PTR es:?commands@@3UCOMMANDS@@E+8,2048	;0800H	;commands
;|***     commands.stern2 = 0x800;
; Line 861
	*** 000b38	26 c7 06 0a 00 00 08 	mov	WORD PTR es:?commands@@3UCOMMANDS@@E+10,2048	;0800H	;commands
;|***     commands.fore   = 0x800;
; Line 862
	*** 000b3f	26 c7 06 0c 00 00 08 	mov	WORD PTR es:?commands@@3UCOMMANDS@@E+12,2048	;0800H	;commands
;|***     }
; Line 863
;|*** 
;|*** /*  
;|***   //  blow the ERS if no response from control for 2 minutes
;|***   if(time_since_last_command > 12000)
;|***     {                                
;|***     commands.ballast = commands.ballast | ERS_BLOW;
;|***     time_since_last_command = 12000;
;|***     }
;|*** */
;|*** 
;|***   //  blow the ERS if no response from control for 5 seconds
;|***   if(packets_rcvd > 100 && time_since_last_command > 500)
; Line 875
					$I3742:
	*** 000b46	83 3e 02 00 00 		cmp	WORD PTR ?packets_rcvd@@3KE+2,0	;packets_rcvd
	*** 000b4b	76 03 			jbe	$JCC2891
	*** 000b4d	e9 0a 00 		jmp	$L4112
					$JCC2891:
	*** 000b50	83 3e 00 00 64 		cmp	WORD PTR ?packets_rcvd@@3KE,100	;0064H	;packets_rcvd
	*** 000b55	77 03 			ja	$JCC2901
	*** 000b57	e9 1c 00 		jmp	$I3743
					$JCC2901:
					$L4112:
	*** 000b5a	81 3e 00 00 f4 01 	cmp	WORD PTR ?time_since_last_command@@3HE,500	;01f4H	;time_since_last_command
	*** 000b60	7f 03 			jg	$JCC2912
	*** 000b62	e9 11 00 		jmp	$I3743
					$JCC2912:
;|***     {                                
; Line 876
;|***     commands.ballast = commands.ballast | ERS_BLOW;
; Line 877
	*** 000b65	8e 06 00 00 		mov	es,WORD PTR $T4111
	*** 000b69	26 81 0e 0e 00 00 04 	or	WORD PTR es:?commands@@3UCOMMANDS@@E+14,1024	;0400H	;commands
;|***     time_since_last_command = 500;
; Line 878
	*** 000b70	c7 06 00 00 f4 01 	mov	WORD PTR ?time_since_last_command@@3HE,500	;01f4H	;time_since_last_command
;|***     }
; Line 879
;|***     
;|***     
;|***   // apply commands
;|***   // stern1
;|***   sprintf(s, "Stern1:    %04x", commands.stern1);
; Line 884
					$I3743:
	*** 000b76	8e 06 00 00 		mov	es,WORD PTR $T4111
	*** 000b7a	26 ff 36 08 00 		push	WORD PTR es:?commands@@3UCOMMANDS@@E+8	;commands
	*** 000b7f	1e 			push	ds
	*** 000b80	68 00 00 		push	OFFSET DGROUP:$SG3744
	*** 000b83	1e 			push	ds
	*** 000b84	68 00 00 		push	OFFSET DGROUP:?s@@3QIDI	;s
	*** 000b87	9a 00 00 00 00 		call	FAR PTR _sprintf
	*** 000b8c	83 c4 0a 		add	sp,10	;000aH
;|***   PC_DispStr(20,16, (unsigned char *)s, DISP_FGND_BLACK + DISP_BGND_RED);
; Line 885
	*** 000b8f	6a 40 			push	64	;0040H
	*** 000b91	1e 			push	ds
	*** 000b92	68 00 00 		push	OFFSET DGROUP:?s@@3QIDI	;s
	*** 000b95	6a 10 			push	16	;0010H
	*** 000b97	6a 14 			push	20	;0014H
	*** 000b99	9a 00 00 00 00 		call	FAR PTR ?PC_DispStr@@ZAXEEPIEE@Z	; PC_DispStr
	*** 000b9e	83 c4 0a 		add	sp,10	;000aH
;|***   while(_inp(OBS_BASE+DACLSB) & 0x80);
; Line 886
					$FC3747:
	*** 000ba1	68 44 03 		push	836	;0344H
	*** 000ba4	9a 00 00 00 00 		call	FAR PTR __inp
	*** 000ba9	83 c4 02 		add	sp,2
	*** 000bac	a8 80 			test	al,128	;0080H
	*** 000bae	75 03 			jne	$JCC2990
	*** 000bb0	e9 03 00 		jmp	$FB3748
					$JCC2990:
	*** 000bb3	e9 eb ff 		jmp	$FC3747
					$FB3748:
;|***   _outp(OBS_BASE+DACLSB, commands.stern1 & 0xff);
; Line 887
	*** 000bb6	8e 06 00 00 		mov	es,WORD PTR $T4111
	*** 000bba	26 a0 08 00 		mov	al,BYTE PTR es:?commands@@3UCOMMANDS@@E+8	;commands
	*** 000bbe	2a e4 			sub	ah,ah
	*** 000bc0	50 			push	ax
	*** 000bc1	68 44 03 		push	836	;0344H
	*** 000bc4	9a 00 00 00 00 		call	FAR PTR __outp
	*** 000bc9	83 c4 04 		add	sp,4
;|***   _outp(OBS_BASE+DACMSB, (commands.stern1>>8) & 0x0f | STERN1_CHAN);
; Line 888
	*** 000bcc	8e 06 00 00 		mov	es,WORD PTR $T4111
	*** 000bd0	26 a0 09 00 		mov	al,BYTE PTR es:?commands@@3UCOMMANDS@@E+9	;commands
	*** 000bd4	25 0f 00 		and	ax,15	;000fH
	*** 000bd7	50 			push	ax
	*** 000bd8	68 45 03 		push	837	;0345H
	*** 000bdb	9a 00 00 00 00 		call	FAR PTR __outp
	*** 000be0	83 c4 04 		add	sp,4
;|***   while(_inp(OBS_BASE+DACLSB) & 0x80);
; Line 889
					$FC3750:
	*** 000be3	68 44 03 		push	836	;0344H
	*** 000be6	9a 00 00 00 00 		call	FAR PTR __inp
	*** 000beb	83 c4 02 		add	sp,2
	*** 000bee	a8 80 			test	al,128	;0080H
	*** 000bf0	75 03 			jne	$JCC3056
	*** 000bf2	e9 03 00 		jmp	$FB3751
					$JCC3056:
	*** 000bf5	e9 eb ff 		jmp	$FC3750
					$FB3751:
;|***   _inp( OBS_BASE+DACMSB);
; Line 890
	*** 000bf8	68 45 03 		push	837	;0345H
	*** 000bfb	9a 00 00 00 00 		call	FAR PTR __inp
	*** 000c00	83 c4 02 		add	sp,2
;|*** 
;|***   // stern2
;|***   sprintf(s, "Stern2:    %04x", commands.stern2);
; Line 893
	*** 000c03	8e 06 00 00 		mov	es,WORD PTR $T4111
	*** 000c07	26 ff 36 0a 00 		push	WORD PTR es:?commands@@3UCOMMANDS@@E+10	;commands
	*** 000c0c	1e 			push	ds
	*** 000c0d	68 00 00 		push	OFFSET DGROUP:$SG3752
	*** 000c10	1e 			push	ds
	*** 000c11	68 00 00 		push	OFFSET DGROUP:?s@@3QIDI	;s
	*** 000c14	9a 00 00 00 00 		call	FAR PTR _sprintf
	*** 000c19	83 c4 0a 		add	sp,10	;000aH
;|***   PC_DispStr(20,17, (unsigned char *)s, DISP_FGND_BLACK + DISP_BGND_RED);
; Line 894
	*** 000c1c	6a 40 			push	64	;0040H
	*** 000c1e	1e 			push	ds
	*** 000c1f	68 00 00 		push	OFFSET DGROUP:?s@@3QIDI	;s
	*** 000c22	6a 11 			push	17	;0011H
	*** 000c24	6a 14 			push	20	;0014H
	*** 000c26	9a 00 00 00 00 		call	FAR PTR ?PC_DispStr@@ZAXEEPIEE@Z	; PC_DispStr
	*** 000c2b	83 c4 0a 		add	sp,10	;000aH
;|***   while(_inp(OBS_BASE+DACLSB) & 0x80);
; Line 895
					$FC3755:
	*** 000c2e	68 44 03 		push	836	;0344H
	*** 000c31	9a 00 00 00 00 		call	FAR PTR __inp
	*** 000c36	83 c4 02 		add	sp,2
	*** 0 c39	a8 80 			test	al,128	;0080H
	*** 000c3b	75 03 			jne	$JCC3131
	*** 000c3d	e9 03 00 		jmp	$FB3756
					$JCC3131:
	*** 000c40	e9 eb ff 		jmp	$FC3755
					$FB3756:
;|***   _outp(OBS_BASE+DACLSB, commands.stern2 & 0xff);
; Line 896
	*** 000c43	8e 06 00 00 		mov	es,WORD PTR $T4111
	*** 000c47	26 a0 0a 00 		mov	al,BYTE PTR es:?commands@@3UCOMMANDS@@E+10	;commands
	*** 000c4b	2a e4 			sub	ah,ah
	*** 000c4d	50 			push	ax
	*** 000c4e	68 44 03 		push	836	;0344H
	*** 000c51	9a 00 00 00 00 		call	FAR PTR __outp
	*** 000c56	83 c4 04 		add	sp,4
;|***   _outp(OBS_BASE+DACMSB, (commands.stern2>>8) & 0x0f | STERN2_CHAN);
; Line 897
	*** 000c59	8e 06 00 00 		mov	es,WORD PTR $T4111
	*** 000c5d	26 a0 0b 00 		mov	al,BYTE PTR es:?commands@@3UCOMMANDS@@E+11	;commands
	*** 000c61	25 0f 00 		and	ax,15	;000fH
	*** 000c64	0c 40 			or	al,64	;0040H
	*** 000c66	50 			push	ax
	*** 000c67	68 45 03 		push	837	;0345H
	*** 000c6a	9a 00 00 00 00 		call	FAR PTR __outp
	*** 000c6f	83 c4 04 		add	sp,4
;|***   while(_inp(OBS_BASE+DACLSB) & 0x80);
; Line 898
					$FC3758:
	*** 000c72	68 44 03 		push	836	;0344H
	*** 000c75	9a 00 00 00 00 		call	FAR PTR __inp
	*** 000c7a	83 c4 02 		add	sp,2
	*** 000c7d	a8 80 			test	al,128	;0080H
	*** 000c7f	75 03 			jne	$JCC3199
	*** 000c81	e9 03 00 		jmp	$FB3759
					$JCC3199:
	*** 000c84	e9 eb ff 		jmp	$FC3758
					$FB3759:
;|***   _inp( OBS_BASE+DACMSB);
; Line 899
	*** 000c87	68 45 03 		push	837	;0345H
	*** 000c8a	9a 00 00 00 00 		call	FAR PTR __inp
	*** 000c8f	83 c4 02 		add	sp,2
;|***   
;|***   // forward
;|***   while(_inp(OBS_BASE+DACLSB) & 0x80);
; Line 902
					$FC3761:
	*** 000c92	68 44 03 		push	836	;0344H
	*** 000c95	9a 00 00 00 00 		call	FAR PTR __inp
	*** 000c9a	83 c4 02 		add	sp,2
	*** 000c9d	a8 80 			test	al,128	;0080H
	*** 000c9f	75 03 			jne	$JCC3231
	*** 000ca1	e9 03 00 		jmp	$FB3762
					$JCC3231:
	*** 000ca4	e9 eb ff 		jmp	$FC3761
					$FB3762:
;|***   _outp(OBS_BASE+DACLSB, commands.fore & 0xff);
; Line 903
	*** 000ca7	8e 06 00 00 		mov	es,WORD PTR $T4111
	*** 000cab	26 a0 0c 00 		mov	al,BYTE PTR es:?commands@@3UCOMMANDS@@E+12	;commands
	*** 000caf	2a e4 			sub	ah,ah
	*** 000cb1	50 			push	ax
	*** 000cb2	68 44 03 		push	836	;0344H
	*** 000cb5	9a 00 00 00 00 		call	FAR PTR __outp
	*** 000cba	83 c4 04 		add	sp,4
;|***   _outp(OBS_BASE+DACMSB, (commands.fore>>8) & 0x0f | FORE_CHAN);
; Line 904
	*** 000cbd	8e 06 00 00 		mov	es,WORD PTR $T4111
	*** 000cc1	26 8a 26 0d 00 		mov	ah,BYTE PTR es:?commands@@3UCOMMANDS@@E+13	;commands
	*** 000cc6	25 00 0f 		and	ax,3840	;0f00H
	*** 000cc9	0d ff c0 		or	ax,-16129	;c0ffH
	*** 000ccc	c1 e8 08 		shr	ax,8
	*** 000ccf	50 			push	ax
	*** 000cd0	68 45 03 		push	837	;0345H
	*** 000cd3	9a 00 00 00 00 		call	FAR PTR __outp
	*** 000cd8	83 c4 04 		add	sp,4
;|***   while(_inp(OBS_BASE+DACLSB) & 0x80);
; Line 905
					$FC3764:
	*** 000cdb	68 44 03 		push	836	;0344H
	*** 000cde	9a 00 00 00 00 		call	FAR PTR __inp
	*** 000ce3	83 c4 02 		add	sp,2
	*** 000ce6	a8 80 			test	al,128	;0080H
	*** 000ce8	75 03 			jne	$JCC3304
	*** 000cea	e9 03 00 		jmp	$FB3765
					$JCC3304:
	*** 000ced	e9 eb ff 		jmp	$FC3764
					$FB3765:
;|***   _inp( OBS_BASE+DACMSB);
; Line 906
	*** 000cf0	68 45 03 		push	837	;0345H
	*** 000cf3	9a 00 00 00 00 		call	FAR PTR __inp
	*** 000cf8	83 c4 02 		add	sp,2
;|***   
;|***   // rudder
;|***   sprintf(s, "Rudder:    %04x", commands.rudder);
; Line 909
	*** 000cfb	8e 06 00 00 		mov	es,WORD PTR $T4111
	*** 000cff	26 ff 36 06 00 		push	WORD PTR es:?commands@@3UCOMMANDS@@E+6	;commands
	*** 000d04	1e 			push	ds
	*** 000d05	68 00 00 		push	OFFSET DGROUP:$SG3766
	*** 000d08	1e 			push	ds
	*** 000d09	68 00 00 		push	OFFSET DGROUP:?s@@3QIDI	;s
	*** 000d0c	9a 00 00 00 00 		call	FAR PTR _sprintf
	*** 000d11	83 c4 0a 		add	sp,10	;000aH
;|***   PC_DispStr(20,19, (unsigned char *)s, DISP_FGND_BLACK + DISP_BGND_RED);
; Line 910
	*** 000d14	6a 40 			push	64	;0040H
	*** 000d16	1e 			push	ds
	*** 000d17	68 00 00 		push	OFFSET DGROUP:?s@@3QIDI	;s
	*** 000d1a	6a 13 			push	19	;0013H
	*** 000d1c	6a 14 			push	20	;0014H
	*** 000d1e	9a 00 00 00 00 		call	FAR PTR ?PC_DispStr@@ZAXEEPIEE@Z	; PC_DispStr
	*** 000d23	83 c4 0a 		add	sp,10	;000aH
;|***   while(_inp(OBS_BASE+DACLSB) & 0x80);
; Line 911
					$FC3769:
	*** 000d26	68 44 03 		push	836	;0344H
	*** 000d29	9a 00 00 00 00 		call	FAR PTR __inp
	*** 000d2e	83 c4 02 		add	sp,2
	*** 000d31	a8 80 			test	al,128	;0080H
	*** 000d33	75 03 			jne	$JCC3379
	*** 000d35	e9 03 00 		jmp	$FB3770
					$JCC3379:
	*** 000d38	e9 eb ff 		jmp	$FC3769
					$FB3770:
;|***   _outp(OBS_BASE+DACLSB, commands.rudder & 0xff);
; Line 912
	*** 000d3b	8e 06 00 00 		mov	es,WORD PTR $T4111
	*** 000d3f	26 a0 06 00 		mov	al,BYTE PTR es:?commands@@3UCOMMANDS@@E+6	;commands
	*** 000d43	2a e4 			sub	ah,ah
	*** 000d45	50 			push	ax
	*** 000d46	68 44 03 		push	836	;0344H
	*** 000d49	9a 00 00 00 00 		call	FAR PTR __outp
	*** 000d4e	83 c4 04 		add	sp,4
;|***   _outp(OBS_BASE+DACMSB, (commands.rudder>>8) & 0x0f | RUDDER_CHAN);
; Line 913
	*** 000d51	8e 06 00 00 		mov	es,WORD PTR $T4111
	*** 000d55	26 8a 26 07 00 		mov	ah,BYTE PTR es:?commands@@3UCOMMANDS@@E+7	;commands
	*** 000d5a	25 00 0f 		and	ax,3840	;0f00H
	*** 000d5d	0d ff 80 		or	ax,-32513	;80ffH
	*** 000d60	c1 e8 08 		shr	ax,8
	*** 000d63	50 			push	ax
	*** 000d64	68 45 03 		push	837	;0345H
	*** 000d67	9a 00 00 00 00 		call	FAR PTR __outp
	*** 000d6c	83 c4 04 		add	sp,4
;|***   while(_inp(OBS_BASE+DACLSB) & 0x80);
; Line 914
					$FC3772:
	*** 000d6f	68 44 03 		push	836	;0344H
	*** 000d72	9a 00 00 00 00 		call	FAR PTR __inp
	*** 000d77	83 c4 02 		add	sp,2
	*** 000d7a	a8 80 			test	al,128	;0080H
	*** 000d7c	75 03 			jne	$JCC3452
	*** 000d7e	e9 03 00 		jmp	$FB3773
					$JCC3452:
	*** 000d81	e9 eb ff 		jmp	$FC3772
					$FB3773:
;|***   _inp( OBS_BASE+DACMSB);
; Line 915
	*** 000d84	68 45 03 		push	837	;0345H
	*** 000d87	9a 00 00 00 00 		call	FAR PTR __inp
	*** 000d8c	83 c4 02 		add	sp,2
;|***   
;|***   // prop
;|***   // changed for TB model 9/26/2007 jtm
;|***   sprintf(s, "Prop:      %04x  %04x", commands.stbd_rpm, commands.port_rpm);
; Line 919
	*** 000d8f	8e 06 00 00 		mov	es,WORD PTR $T4111
	*** 000d93	26 ff 36 22 00 		push	WORD PTR es:?commands@@3UCOMMANDS@@E+34	;commands
	*** 000d98	26 ff 36 04 00 		push	WORD PTR es:?commands@@3UCOMMANDS@@E+4	;commands
	*** 000d9d	1e 			push	ds
	*** 000d9e	68 00 00 		push	OFFSET DGROUP:$SG3774
	*** 000da1	1e 			push	ds
	*** 000da2	68 00 00 		push	OFFSET DGROUP:?s@@3QIDI	;s
	*** 000da5	9a 00 00 00 00 		call	FAR PTR _sprintf
	*** 000daa	83 c4 0c 		add	sp,12	;000cH
;|***   PC_DispStr(20,18, (unsigned char *)s, DISP_FGND_BLACK + DISP_BGND_RED);
; Line 920
	*** 000dad	6a 40 			push	64	;0040H
	*** 000daf	1e 			push	ds
	*** 000db0	68 00 00 		push	OFFSET DGROUP:?s@@3QIDI	;s
	*** 000db3	6a 12 			push	18	;0012H
	*** 000db5	6a 14 			push	20	;0014H
	*** 000db7	9a 00 00 00 00 		call	FAR PTR ?PC_DispStr@@ZAXEEPIEE@Z	; PC_DispStr
	*** 000dbc	83 c4 0a 		add	sp,10	;000aH
;|***   te5650SetAxis(1, STBD_PROP);
; Line 921
	*** 000dbf	6a 01 			push	1
	*** 000dc1	6a 01 			push	1
	*** 000dc3	9a 00 00 00 00 		call	FAR PTR _te5650SetAxis
	*** 000dc8	83 c4 04 		add	sp,4
;|***   te5650SetMotor(commands.stbd_rpm);
; Line 922
	*** 000dcb	8e 06 00 00 		mov	es,WORD PTR $T4111
	*** 000dcf	26 ff 36 04 00 		push	WORD PTR es:?commands@@3UCOMMANDS@@E+4	;commands
	*** 000dd4	9a 00 00 00 00 		call	FAR PTR _te5650SetMotor
	*** 000dd9	83 c4 02 		add	sp,2
;|***   te5650Update();
; Line 923
	*** 000ddc	9a 00 00 00 00 		call	FAR PTR _te5650Update
;|***   // new for TB model 9/26/2007 jtm
;|***   te5650SetAxis(1, PORT_PROP);
; Line 925
	*** 000de1	6a 02 			push	2
	*** 000de3	6a 01 			push	1
	*** 000de5	9a 00 00 00 00 		call	FAR PTR _te5650SetAxis
	*** 000dea	83 c4 04 		add	sp,4
;|***   te5650SetMotor(commands.port_rpm);
; Line 926
	*** 000ded	8e 06 00 00 		mov	es,WORD PTR $T4111
	*** 000df1	26 ff 36 22 00 		push	WORD PTR es:?commands@@3UCOMMANDS@@E+34	;commands
	*** 000df6	9a 00 00 00 00 		call	FAR PTR _te5650SetMotor
	*** 000dfb	83 c4 02 		add	sp,2
;|***   te5650Update();  
; Line 927
	*** 000dfe	9a 00 00 00 00 		call	FAR PTR _te5650Update
;|***   
;|*** 
;|***   // ballast
;|***   // ers blow  
;|***   sprintf(s, "Ballast:   %04x", commands.ballast);
; Line 932
	*** 000e03	8e 06 00 00 		mov	es,WORD PTR $T4111
	*** 000e07	26 ff 36 0e 00 		push	WORD PTR es:?commands@@3UCOMMANDS@@E+14	;commands
	*** 000e0c	1e 			push	ds
	*** 000e0d	68 00 00 		push	OFFSET DGROUP:$SG3776
	*** 000e10	1e 			push	ds
	*** 000e11	68 00 00 		push	OFFSET DGROUP:?s@@3QIDI	;s
	*** 000e14	9a 00 00 00 00 		call	FAR PTR _sprintf
	*** 000e19	83 c4 0a 		add	sp,10	;000aH
;|***   PC_DispStr(20,20, (unsigned char *)s, DISP_FGND_BLACK + DISP_BGND_RED);
; Line 933
	*** 000e1c	6a 40 			push	64	;0040H
	*** 000e1e	1e 			push	ds
	*** 000e1f	68 00 00 		push	OFFSET DGROUP:?s@@3QIDI	;s
	*** 000e22	6a 14 			push	20	;0014H
	*** 000e24	6a 14 			push	20	;0014H
	*** 000e26	9a 00 00 00 00 		call	FAR PTR ?PC_DispStr@@ZAXEEPIEE@Z	; PC_DispStr
	*** 000e2b	83 c4 0a 		add	sp,10	;000aH
;|***   if(commands.ballast & ERS_BLOW)
; Line 934
	*** 000e2e	8e 06 00 00 		mov	es,WORD PTR $T4111
	*** 000e32	26 f6 06 0f 00 04 	test	BYTE PTR es:?commands@@3UCOMMANDS@@E+15,4	;commands
	*** 000e38	75 03 			jne	$JCC3640
	*** 000e3a	e9 60 00 		jmp	$I3778
					$JCC3640:
;|***     {
; Line 935
;|***     write_bit(PUMP,   PUMPOFF);
; Line 936
	*** 000e3d	6a 01 			push	1
	*** 000e3f	6a 10 			push	16	;0010H
	*** 000e41	9a 00 00 00 00 		call	FAR PTR ?write_bit@@ZAXHH@Z	; write_bit
	*** 000e46	83 c4 04 		add	sp,4
;|***     write_bit(VALVE1, VALVEOFF);
; Line 937
	*** 000e49	6a 01 			push	1
	*** 000e4b	6a 0a 			push	10	;000aH
	*** 000e4d	9a 00 00 00 00 		call	FAR PTR ?write_bit@@ZAXHH@Z	; write_bit
	*** 000e52	83 c4 04 		add	sp,4
;|***     write_bit(VALVE2, VALVEOFF);
; Line 938
	*** 000e55	6a 01 G @`k   :@      6a 0b 			push	11	;000bH
	*** 000e59	9a 00 00 00 00 		call	FAR PTR ?write_bit@@ZAXHH@Z	; write_bit
	*** 000e5e	83 c4 04 		add	sp,4
;|***     write_bit(VALVE3, VALVEOFF);
; Line 939
	*** 000e61	6a 01 			push	1
	*** 000e63	6a 0c 			push	12	;000cH
	*** 000e65	9a 00 00 00 00 		call	FAR PTR ?write_bit@@ZAXHH@Z	; write_bit
	*** 000e6a	83 c4 04 		add	sp,4
;|***     write_bit(VALVE4, VALVEOFF);
; Line 940
	*** 000e6d	6a 01 			push	1
	*** 000e6f	6a 0d 			push	13	;000dH
	*** 000e71	9a 00 00 00 00 		call	FAR PTR ?write_bit@@ZAXHH@Z	; write_bit
	*** 000e76	83 c4 04 		add	sp,4
;|***     write_bit(VALVE5, VALVEOFF);
; Line 941
	*** 000e79	6a 01 			push	1
	*** 000e7b	6a 0e 			push	14	;000eH
	*** 000e7d	9a 00 00 00 00 		call	FAR PTR ?write_bit@@ZAXHH@Z	; write_bit
	*** 000e82	83 c4 04 		add	sp,4
;|***     write_bit(VALVE6, VALVEOFF);
; Line 942
	*** 000e85	6a 01 			push	1
	*** 000e87	6a 0f 			push	15	;000fH
	*** 000e89	9a 00 00 00 00 		call	FAR PTR ?write_bit@@ZAXHH@Z	; write_bit
	*** 000e8e	83 c4 04 		add	sp,4
;|***     write_bit(ERS,    ERSBLOW);
; Line 943
	*** 000e91	6a 00 			push	0
	*** 000e93	6a 12 			push	18	;0012H
	*** 000e95	9a 00 00 00 00 		call	FAR PTR ?write_bit@@ZAXHH@Z	; write_bit
	*** 000e9a	83 c4 04 		add	sp,4
;|***     //return;
;|***     }
; Line 945
;|***   
;|***   // pfs blow
;|***   if(commands.ballast & PFS_BLOW)
; Line 948
					$I3778:
	*** 000e9d	8e 06 00 00 		mov	es,WORD PTR $T4111
	*** 000ea1	26 f6 06 0f 00 01 	test	BYTE PTR es:?commands@@3UCOMMANDS@@E+15,1	;commands
	*** 000ea7	75 03 			jne	$JCC3751
	*** 000ea9	e9 0c 00 		jmp	$I3779
					$JCC3751:
;|***     {
; Line 949
;|***     write_bit(PFSVENTBLOW, PFSBLOW);
; Line 950
	*** 000eac	6a 00 			push	0
	*** 000eae	6a 09 			push	9
	*** 000eb0	9a 00 00 00 00 		call	FAR PTR ?write_bit@@ZAXHH@Z	; write_bit
	*** 000eb5	83 c4 04 		add	sp,4
;|***     }
; Line 951
;|***   
;|***   // pfs flood
;|***   if(commands.ballast & PFS_FLOOD)
; Line 954
					$I3779:
	*** 000eb8	8e 06 00 00 		mov	es,WORD PTR $T4111
	*** 000ebc	26 f6 06 0f 00 02 	test	BYTE PTR es:?commands@@3UCOMMANDS@@E+15,2	;commands
	*** 000ec2	75 03 			jne	$JCC3778
	*** 000ec4	e9 0c 00 		jmp	$I3780
					$JCC3778:
;|***     {
; Line 955
;|***     write_bit(PFSVENTBLOW, PFSVENT);    
; Line 956
	*** 000ec7	6a 01 			push	1
	*** 000ec9	6a 09 			push	9
	*** 000ecb	9a 00 00 00 00 		call	FAR PTR ?write_bit@@ZAXHH@Z	; write_bit
	*** 000ed0	83 c4 04 		add	sp,4
;|***     }
; Line 957
;|***   
;|***   // turn pump and valves off if no blow/flood command
;|***   if(!(commands.ballast & 0x00ff))
; Line 960
					$I3780:
	*** 000ed3	8e 06 00 00 		mov	es,WORD PTR $T4111
	*** 000ed7	26 f6 06 0e 00 ff 	test	BYTE PTR es:?commands@@3UCOMMANDS@@E+14,255	;00ffH	;commands
	*** 000edd	74 03 			je	$JCC3805
	*** 000edf	e9 54 00 		jmp	$I3781
					$JCC3805:
;|***     {
; Line 961
;|***     write_bit(PUMP,   PUMPOFF);
; Line 962
	*** 000ee2	6a 01 			push	1
	*** 000ee4	6a 10 			push	16	;0010H
	*** 000ee6	9a 00 00 00 00 		call	FAR PTR ?write_bit@@ZAXHH@Z	; write_bit
	*** 000eeb	83 c4 04 		add	sp,4
;|***     write_bit(VALVE1, VALVEOFF);
; Line 963
	*** 000eee	6a 01 			push	1
	*** 000ef0	6a 0a 			push	10	;000aH
	*** 000ef2	9a 00 00 00 00 		call	FAR PTR ?write_bit@@ZAXHH@Z	; write_bit
	*** 000ef7	83 c4 04 		add	sp,4
;|***     write_bit(VALVE2, VALVEOFF);
; Line 964
	*** 000efa	6a 01 			push	1
	*** 000efc	6a 0b 			push	11	;000bH
	*** 000efe	9a 00 00 00 00 		call	FAR PTR ?write_bit@@ZAXHH@Z	; write_bit
	*** 000f03	83 c4 04 		add	sp,4
;|***     write_bit(VALVE3, VALVEOFF);
; Line 965
	*** 000f06	6a 01 			push	1
	*** 000f08	6a 0c 			push	12	;000cH
	*** 000f0a	9a 00 00 00 00 		call	FAR PTR ?write_bit@@ZAXHH@Z	; write_bit
	*** 000f0f	83 c4 04 		add	sp,4
;|***     write_bit(VALVE4, VALVEOFF);
; Line 966
	*** 000f12	6a 01 			push	1
	*** 000f14	6a 0d 			push	13	;000dH
	*** 000f16	9a 00 00 00 00 		call	FAR PTR ?write_bit@@ZAXHH@Z	; write_bit
	*** 000f1b	83 c4 04 		add	sp,4
;|***     write_bit(VALVE5, VALVEOFF);
; Line 967
	*** 000f1e	6a 01 			push	1
	*** 000f20	6a 0e 			push	14	;000eH
	*** 000f22	9a 00 00 00 00 		call	FAR PTR ?write_bit@@ZAXHH@Z	; write_bit
	*** 000f27	83 c4 04 		add	sp,4
;|***     write_bit(VALVE6, VALVEOFF);
; Line 968
	*** 000f2a	6a 01 			push	1
	*** 000f2c	6a 0f 			push	15	;000fH
	*** 000f2e	9a 00 00 00 00 		call	FAR PTR ?write_bit@@ZAXHH@Z	; write_bit
	*** 000f33	83 c4 04 		add	sp,4
;|***     //return;
;|***     }
; Line 970
;|*** 
;|***   // all blow is pump,1,4,5
;|***   if(commands.ballast & ALL_BLOW)
; Line 973
					$I3781:
	*** 000f36	8e 06 00 00 		mov	es,WORD PTR $T4111
	*** 000f3a	26 f6 06 0e 00 01 	test	BYTE PTR es:?commands@@3UCOMMANDS@@E+14,1	;commands
	*** 000f40	75 03 			jne	$JCC3904
	*** 000f42	e9 54 00 		jmp	$I3782
					$JCC3904:
;|***     {
; Line 974
;|***     write_bit(PUMP,   PUMPON);
; Line 975
	*** 000f45	6a 00 			push	0
	*** 000f47	6a 10 			push	16	;0010H
	*** 000f49	9a 00 00 00 00 		call	FAR PTR ?write_bit@@ZAXHH@Z	; write_bit
	*** 000f4e	83 c4 04 		add	sp,4
;|***     write_bit(VALVE1, VALVEON);
; Line 976
	*** 000f51	6a 00 			push	0
	*** 000f53	6a 0a 			push	10	;000aH
	*** 000f55	9a 00 00 00 00 		call	FAR PTR ?write_bit@@ZAXHH@Z	; write_bit
	*** 000f5a	83 c4 04 		add	sp,4
;|***     write_bit(VALVE2, VALVEOFF);
; Line 977
	*** 000f5d	6a 01 			push	1
	*** 000f5f	6a 0b 			push	11	;000bH
	*** 000f61	9a 00 00 00 00 		call	FAR PTR ?write_bit@@ZAXHH@Z	; write_bit
	*** 000f66	83 c4 04 		add	sp,4
;|***     write_bit(VALVE3, VALVEOFF);
; Line 978
	*** 000f69	6a 01 			push	1
	*** 000f6b	6a 0c 			push	12	;000cH
	*** 000f6d	9a 00 00 00 00 		call	FAR PTR ?write_bit@@ZAXHH@Z	; write_bit
	*** 000f72	83 c4 04 		add	sp,4
;|***     write_bit(VALVE4, VALVEON);
; Line 979
	*** 000f75	6a 00 			push	0
	*** 000f77	6a 0d 			push	13	;000dH
	*** 000f79	9a 00 00 00 00 		call	FAR PTR ?write_bit@@ZAXHH@Z	; write_bit
	*** 000f7e	83 c4 04 		add	sp,4
;|***     write_bit(VALVE5, VALVEON);
; Line 980
	*** 000f81	6a 00 			push	0
	*** 000f83	6a 0e 			push	14	;000eH
	*** 000f85	9a 00 00 00 00 		call	FAR PTR ?write_bit@@ZAXHH@Z	; write_bit
	*** 000f8a	83 c4 04 		add	sp,4
;|***     write_bit(VALVE6, VALVEOFF);
; Line 981
	*** 000f8d	6a 01 			push	1
	*** 000f8f	6a 0f 			push	15	;000fH
	*** 000f91	9a 00 00 00 00 		call	FAR PTR ?write_bit@@ZAXHH@Z	; write_bit
	*** 000f96	83 c4 04 		add	sp,4
;|***     //return;
;|***     }
; Line 983
;|*** 
;|***   // all flood is pump,2,3,6
;|***   if(commands.ballast & ALL_FLOOD)
; Line 986
					$I3782:
	*** 000f99	8e 06 00 00 		mov	es,WORD PTR $T4111
	*** 000f9d	26 f6 06 0e 00 02 	test	BYTE PTR es:?commands@@3UCOMMANDS@@E+14,2	;commands
	*** 000fa3	75 03 			jne	$JCC4003
	*** 000fa5	e9 54 00 		jmp	$I3783
					$JCC4003:
;|***     {
; Line 987
;|***     write_bit(PUMP,   PUMPON);
; Line 988
	*** 000fa8	6a 00 			push	0
	*** 000faa	6a 10 			push	16	;0010H
	*** 000fac	9a 00 00 00 00 		call	FAR PTR ?write_bit@@ZAXHH@Z	; write_bit
	*** 000fb1	83 c4 04 		add	sp,4
;|***     write_bit(VALVE1, VALVEOFF);
; Line 989
	*** 000fb4	6a 01 			push	1
	*** 000fb6	6a 0a 			push	10	;000aH
	*** 000fb8	9a 00 00 00 00 		call	FAR PTR ?write_bit@@ZAXHH@Z	; write_bit
	*** 000fbd	83 c4 04 		add	sp,4
;|***     write_bit(VALVE2, VALVEON);
; Line 990
	*** 000fc0	6a 00 			push	0
	*** 000fc2	6a 0b 			push	11	;000bH
	*** 000fc4	9a 00 00 00 00 		call	FAR PTR ?write_bit@@ZAXHH@Z	; write_bit
	*** 000fc9	83 c4 04 		add	sp,4
;|***     write_bit(VALVE3, VALVEON);
; Line 991
	*** 000fcc	6a 00 			push	0
	*** 000fce	6a 0c 			push	12	;000cH
	*** 000fd0	9a 00 00 00 00 		call	FAR PTR ?write_bit@@ZAXHH@Z	; write_bit
	*** 000fd5	83 c4 04 		add	sp,4
;|***     write_bit(VALVE4, VALVEOFF);
; Line 992
	*** 000fd8	6a 01 			push	1
	*** 000fda	6a 0d 			push	13	;000dH
	*** 000fdc	9a 00 00 00 00 		call	FAR PTR ?write_bit@@ZAXHH@Z	; write_bit
	*** 000fe1	83 c4 04 		add	sp,4
;|***     write_bit(VALVE5, VALVEOFF);
; Line 993
	*** 000fe4	6a 01 			push	1
	*** 000fe6	6a 0e 			push	14	;000eH
	*** 000fe8	9a 00 00 00 00 		call	FAR PTR ?write_bit@@ZAXHH@Z	; write_bit
	*** 000fed	83 c4 04 		add	sp,4
;|***     write_bit(VALVE6, VALVEON);
; Line 994
	*** 000ff0	6a 00 			push	0
	*** 000ff2	6a 0f 			push	15	;000fH
	*** 000ff4	9a 00 00 00 00 		call	FAR PTR ?write_bit@@ZAXHH@Z	; write_bit
	*** 000ff9	83 c4 04 		add	sp,4
;|***     //return;
;|***     }
; Line 996
;|***     
;|***   // trim forward is pump,2,5
;|***   if(commands.ballast & TRIM_FORWARD)
; Line 999
					$I3783:
	*** 000ffc	8e 06 00 00 		mov	es,WORD PTR $T4111
	*** 001000	26 f6 06 0e 00 04 	test	BYTE PTR es:?commands@@3UCOMMANDS@@E+14,4	;commands
	*** 001006	75 03 			jne	$JCC4102
	*** 001008	e9 54 00 		jmp	$I3784
					$JCC4102:
;|***     {
; Line 1000
;|***     write_bit(PUMP,   PUMPON);
; Line 1001
	*** 00100b	6a 00 			push	0
	*** 00100d	6a 10 			push	16	;0010H
	*** 00100f	9a 00 00 00 00 		call	FAR PTR ?write_bit@@ZAXHH@Z	; write_bit
	*** 001014	83 c4 04 		add	sp,4
;|***     write_bit(VALVE1, VALVEOFF);
; Line 1002
	*** 001017	6a 01 			push	1
	*** 001019	6a 0a 			push	10	;000aH
	*** 00101b	9a 00 00 00 00 		call	FAR PTR ?write_bit@@ZAXHH@Z	; write_bit
	*** 001020	83 c4 04 		add	sp,4
;|***     write_bit(VALVE2, VALVEON);
; Line 1003
	*** 001023	6a 00 			push	0
	*** 001025	6a 0b 			push	11	;000bH
	*** 001027	9a 00 00 00 00 		call	FAR PTR ?write_bit@@ZAXHH@Z	; write_bit
	*** 00102c	83 c4 04 		add	sp,4
;|***     write_bit(VALVE3, VALVEOFF);
; Line 1004
	*** 00102f	6a 01 			push	1
	*** 001031	6a 0c 			push	12	;000cH
	*** 001033	9a 00 00 00 00 		call	FAR PTR ?write_bit@@ZAXHH@Z	; write_bit
	*** 001038	83 c4 04 		add	sp,4
;|***     write_bit(VALVE4, VALVEOFF);
; Line 1005
	*** 00103b	6a 01 			push	1
	*** 00103d	6a 0d 			push	13	;000dH
	*** 00103f	9a 00 00 00 00 		call	FAR PTR ?write_bit@@ZAXHH@Z	; write_bit
	*** 001044	83 c4 04 		add	sp,4
;|***     write_bit(VALVE5, VALVEON);
; Line 1006
	*** 001047	6a 00 			push	0
	*** 001049	6a 0e 			push	14	;000eH
	*** 00104b	9a 00 00 00 00 		call	FAR PTR ?write_bit@@ZAXHH@Z	; write_bit
	*** 001050	83 c4 04 		add	sp,4
;|***     write_bit(VALVE6, VALVEOFF);
; Line 1007
	*** 001053	6a 01 			push	1
	*** 001055	6a 0f 			push	15	;000fH
	*** 001057	9a 00 00 00 00 		call	FAR PTR ?write_bit@@ZAXHH@Z	; write_bit
	*** 00105c	83 c4 04 		add	sp,4
;|***     //return;
;|***     }
; Line 1009
;|***     
;|***   // trim aft is pump,3,4
;|***   if(commands.ballast & TRIM_AFT)
; Line 1012
					$I3784:
	*** 00105f	8e 06 00 00 		mov	es,WORD PTR $T4111
	*** 001063	26 f6 06 0e 00 08 	test	BYTE PTR es:?commands@@3UCOMMANDS@@E+14,8	;commands
	*** 001069	75 03 			jne	$JCC4201
	*** 00106b	e9 54 00 		jmp	$I3785
					$JCC4201:
;|***     {
; Line 1013
;|***     write_bit(PUMP,   PUMPON);
; Line 1014
	*** 00106e	6a 00 			push	0
	*** 001070	6a 10 			push	16	;0010H
	*** 001072	9a 00 00 00 00 		call	FAR PTR ?write_bit@@ZAXHH@Z	; write_bit
	*** 001077	83 c4 04 		add	sp,4
;|***     write_bit(VALVE1, VALVEOFF);
; Line 1015
	*** 00107a	6a 01 			push	1
	*** 00107c	6a 0a 			push	10	;000aH
	*** 00107e	9a 00 00 00 00 		call	FAR PTR ?write_bit@@ZAXHH@Z	; write_bit
	*** 001083	83 c4 04 		add	sp,4
;|***     write_bit(VALVE2, VALVEOFF);
; Line 1016
	*** 001086	6a 01 			push	1
	*** 001088	6a 0b 			push	11	;000bH
	*** 00108a	9a 00 00 00 00 		call	FAR PTR ?write_bit@@ZAXHH@Z	; write_bit
	*** 00108f	83 c4 04 		add	sp,4
;|***     write_bit(VALVE3, VALVEON);
; Line 1017
	*** 001092	6a 00 			push	0
	*** 001094	6a 0c 			push	12	;000cH
	*** 001096	9a 00 00 00 00 		call	FAR PTR ?write_bit@@ZAXHH@Z	; write_bit
	*** 00109b	83 c4 04 		add	sp,4
;|***     write_bit(VALVE4, VALVEON);
; Line 1018
	*** 00109e	6a 00 			push	0
	*** 0010a0	6a 0d 			push	13	;000dH
	*** 0010a2	9a 00 00 00 00 		call	FAR PTR ?write_bit@@ZAXHH@Z	; write_bit
	*** 0010a7	83 c4 04 		add	sp,4
;|***     write_bit(VALVE5, VALVEOFF);
; Line 1019
	*** 0010aa	6a 01 			push	1
	*** 0010ac	6a 0e 			push	14	;000eH
	*** 0010ae	9a 00 00 00 00 		call	FAR PTR ?write_bit@@ZAXHH@Z	; write_bit
	*** 0010b3	83 c4 04 		add	sp,4
;|***     write_bit(VALVE6, VALVEOFF);
; Line 1020
	*** 0010b6	6a 01 			push	1
	*** 0010b8	6a 0f 			push	15	;000fH
	*** 0010ba	9a 00 00 00 00 		call	FAR PTR ?write_bit@@ZAXHH@Z	; write_bit
	*** 0010bf	83 c4 04 		add	sp,4
;|***     //return;
;|***     }
; Line 1022
;|***     
;|***   // forward blow
;|***   if(commands.ballast & FORWARD_BLOW)
; Line 1025
					$I3785:
	*** 0010c2	8e 06 00 00 		mov	es,WORD PTR $T4111
	*** 0010c6	26 f6 06 0e 00 10 	test	BYTE PTR es:?commands@@3UCOMMANDS@@E+14,16	;0010H	;commands
	*** 0010cc	75 03 			jne	$JCC4300
	*** 0010ce	e9 00 00 		jmp	$I3786
					$JCC4300:
;|***     {
; Line 1026
;|***     }
; Line 1027
;|***   
;|***   // forward flood
;|***   if(commands.ballast & FORWARD_FLOOD)
; Line 1030
					$I3786:
	*** 0010d1	8e 06 00 00 		mov	es,WORD PTR $T4111
	*** 0010d5	26 f6 06 0e 00 20 	test	BYTE PTR es:?commands@@3UCOMMANDS@@E+14,32	;0020H	;commands
	*** 0010db	75 03 			jne	$JCC4315
	*** 0010dd	e9 00 00 		jmp	$I3787
					$JCC4315:
;|***     {
; Line 1031
;|***     }
; Line 1032
;|***   
;|***   // aft blow
;|***   if(commands.ballast & AFT_BLOW)
; Line 1035
					$I3787:
	*** 0010e0	8e 06 00 00 		mov	es,WORD PTR $T4111
	*** 0010e4	26 f6 06 0e 00 40 	test	BYTE PTR es:?commands@@3UCOMMANDS@@E+14,64	;0040H	;commands
	*** 0010ea	75 03 			jne	$JCC4330
	*** 0010ec	e9 00 00 		jmp	$I3788
					$JCC4330:
;|***     {
; Line 1036
;|***     }
; Line 1037
;|***     
;|***   // aft flood
;|***   if(commands.ballast & AFT_FLOOD)
; Line 1040
					$I3788:
	*** 0010ef	8e 06 00 00 		mov	es,WORD PTR $T4111
	*** 0010f3	26 f6 06 0e 00 80 	test	BYTE PTR es:?commands@@3UCOMMANDS@@E+14,128	;0080H	;commands
	*** 0010f9	75 03 			jne	$JCC4345
	*** 0010fb	e9 00 00 		jmp	$I3789
					$JCC4345:
;|***     {
; Line 1041
;|***     }
; Line 1042
;|***    
;|***    
;|***   if(commands.ds_send_message != 0)
; Line 1045
					$I3789:
	*** 0010fe	8e 06 00 00 		mov	es,WORD PTR $T4111
	*** 001102	26 83 3e 16 00 00 	cmp	WORD PTR es:?commands@@3UCOMMANDS@@E+22,0	;commands
	*** 001108	75 03 			jne	$JCC4360
	*** 00110a	e9 18 00 		jmp	$I3790
					$JCC4360:
;|***     {
; Line 1046
;|***     send_message = 1;
; Line 1047
	*** 00110d	c7 06 00 00 01 00 	mov	WORD PTR ?send_message@@3HE,1	;send_message
;|***     //_fstrcpy(acoustic_message, "abcdef");
;|***     _fmemcpy(&acoustic_message, &commands.ds_dmgx1, sizeof(acoustic_message));
; Line 1049
	*** 001113	6a 0c 			push	12	;000cH
	*** 001115	06 			push	es
	*** 001116	68 18 00 		push	OFFSET ?commands@@3UCOMMANDS@@E+24	;commands
	*** 001119	1e 			push	ds
	*** 00111a	68 00 00 		push	OFFSET DGROUP:?acoustic_message@@3QIDI	;acoustic_message
	*** 00111d	9a 00 00 00 00 		call	FAR PTR __fmemcpy
	*** 001122	83 c4 0a 		add	sp,10	;000aH
;|***     }
; Line 1050
;|***   }
; Line 1051
					$I3790:
	*** 001125	e9 00 00 		jmp	$EX3739
					$EX3739:
	*** 001128	5e 			pop	si
	*** 001129	5f 			pop	di
	*** 00112a	c9 			leave	
	*** 00112b	cb 			ret	

?apply_commands@@ZAXXZ	ENDP
	PUBLIC	?configure_obc@@ZAXXZ	; configure_obc
?configure_obc@@ZAXXZ	PROC FAR	; configure_obc
;|***   
;|***         
;|***   
;|*** void configure_obc(void)
;|***   {
; Line 1056
	*** 00112c	c8 02 00 00 		enter	2,0
	*** 001130	57 			push	di
	*** 001131	56 			push	si
;	i = -2
;|***   unsigned i;
;|***   for(i=0; i<88; i++) adcp_test[i] = (unsigned char) i;
; Line 1058
	*** 001132	c7 46 fe 00 00 		mov	WORD PTR [bp-2],0	;i
	*** 001137	e9 03 00 		jmp	$F3794
					$FC3795:
	*** 00113a	ff 46 fe 		inc	WORD PTR [bp-2]	;i
					$F3794:
	*** 00113d	83 7e fe 58 		cmp	WORD PTR [bp-2],88	;0058H	;i
	*** 001141	72 03 			jb	$JCC4417
	*** 001143	e9 0d 00 		jmp	$FB3796
					$JCC4417:
	*** 001146	8a 46 fe 		mov	al,BYTE PTR [bp-2]	;i
	*** 001149	8b 5e fe 		mov	bx,WORD PTR [bp-2]	;i
	*** 00114c	88 87 00 00 		mov	BYTE PTR ?adcp_test@@3QIEI[bx],al	;adcp_test
	*** 001150	e9 e7 ff 		jmp	$FC3795
DMMTEST_TEXT      ENDS
CONST      SEGMENT
$T4113	DD	045dc32adr   ;	7046.3345
CONST      ENDS
DMMTEST_TEXT      SEGMENT
	ASSUME	CS: DMMTEST_TEXT
					$FB3796:
;|***   
;|***   rpm_sf = 60.0f * 1000000.0f / 0.838097f / 10160.0f;
; Line 1060
	*** 001153	a1 00 00 		mov	ax,WORD PTR $T4113
	*** 001156	8b 16 02 00 		mov	dx,WORD PTR $T4113+2
	*** 00115a	a3 00 00 		mov	WORD PTR ?rpm_sf@@3ME,ax	;rpm_sf
	*** 00115d	89 16 02 00 		mov	WORD PTR ?rpm_sf@@3ME+2,dx	;rpm_sf
;|***   
;|***   sys_timer.high = 0;
; Line 1062
	*** 001161	8e 06 00 00 		mov	es,WORD PTR $T4111
	*** 001165	2b c0 			sub	ax,ax
	*** 001167	26 a3 02 00 		mov	WORD PTR es:?sys_timer@@3UTIMER@@E+2,ax	;sys_timer
	*** 00116b	26 a3 00 00 		mov	WORD PTR es:?sys_timer@@3UTIMER@@E,ax	;sys_timer
;|***   sys_timer.low = 0;
; Line 1063
	*** 00116f	26 c7 06 04 00 00 00 	mov	WORD PTR es:?sys_timer@@3UTIMER@@E+4,0	;sys_timer
;|***   
;|***   frame = 0;
; Line 1065
	*** 001176	2b c0 			sub	ax,ax
	*** 001178	a3 02 00 		mov	WORD PTR ?frame@@3KE+2,ax	;frame
	*** 00117b	a3 00 00 		mov	WORD PTR ?frame@@3KE,ax	;frame
;|***   next_frame = frame;
; Line 1066
	*** 00117e	a1 00 00 		mov	ax,WORD PTR ?frame@@3KE	;frame
	*** 001181	8b 16 02 00 		mov	dx,WORD PTR ?frame@@3KE+2	;frame
	*** 001185	a3 00 00 		mov	WORD PTR ?next_frame@@3KE,ax	;next_frame
	*** 001188	89 16 02 00 		mov	WORD PTR ?next_frame@@3KE+2,dx	;next_frame
;|***   
;|***   sys.packet_type = 0xf0c1;   // obc data packet  //3
; Line 1068
	*** 00118c	8e 06 00 00 		mov	es,WORD PTR $T4111
	*** 001190	26 c7 06 00 00 c1 f0 	mov	WORD PTR es:?sys@@3USYS@@E,-3903	;f0c1H	;sys
;|***   sys.packet_number = 0xfffe;
; Line 1069
	*** 001197	26 c7 06 02 00 fe ff 	mov	WORD PTR es:?sys@@3USYS@@E+2,-2	;fffeH	;sys
;|***   sys.fs_status = 0;
; Line 1070
	*** 00119e	26 c7 06 08 00 00 00 	mov	WORD PTR es:?sys@@3USYS@@E+8,0	;sys
;|***   sys.op_status = 0;
; Line 1071
	*** 0011a5	26 c7 06 0a 00 00 00 	mov	WORD PTR es:?sys@@3USYS@@E+10,0	;sys
;|***   
;|***   obs.new_data = 0;
; Line 1073
	*** 0011ac	8e 06 00 00 		mov	es,WORD PTR $T4111
	*** 0011b0	26 c7 06 00 00 00 00 	mov	WORD PTR es:?obs@@3UOBS@@E,0	;obs
;|***   obs.frame = frame;
; Line 1074
	*** 0011b7	a1 00 00 		mov	ax,WORD PTR ?frame@@3KE	;frame
	*** 0011ba	8b 16 02 00 		mov	dx,WORD PTR ?frame@@3KE+2	;frame
	*** 0011be	26 a3 02 00 		mov	WORD PTR es:?obs@@3UOBS@@E+2,ax	;obs
	*** 0011c2	26 89 16 04 00 		mov	WORD PTR es:?obs@@3UOBS@@E+4,dx	;obs
;|***   
;|***   dyno.new_data = 0;
; Line 1076
	*** 0011c7	8e 06 00 00 		mov	es,WORD PTR $T4111
	*** 0011cb	26 c7 06 00 00 00 00 	mov	WORD PTR es:?dyno@@3UDYNO@@E,0	;dyno
;|***   obs.frame = frame;
; Line 1077
	*** 0011d2	a1 00 00 		mov	ax,WORD PTR ?frame@@3KE	;frame
	*** 0011d5	8b 16 02 00 		mov	dx,WORD PTR ?frame@@3KE+2	;frame
	*** 0011d9	8e 06 00 00 		mov	es,WORD PTR $T4111
	*** 0011dd	26 a3 02 00 		mov	WORD PTR es:?obs@@3UOBS@@E+2,ax	;obs
	*** 0011e1	26 89 16 04 00 		mov	WORD PTR es:?obs@@3UOBS@@E+4,dx	;obs
;|***   
;|***   prop.new_data = 0;
; Line 1079
	*** 0011e6	8e 06 00 00 		mov	es,WORD PTR $T4111
	*** 0011ea	26 c7 06 00 00 00 00 	mov	WORD PTR es:?prop@@3UPROP@@E,0	;prop
;|***   prop.frame = frame;
; Line 1080
	*** 0011f1	a1 00 00 		mov	ax,WORD PTR ?frame@@3KE	;frame
	*** 0011f4	8b 16 02 00 		mov	dx,WORD PTR ?frame@@3KE+2	;frame
	*** 0011f8	26 a3 02 00 		mov	WORD PTR es:?prop@@3UPROP@@E+2,ax	;prop
	*** 0011fc	26 89 16 04 00 		mov	WORD PTR es:?prop@@3UPROP@@E+4,dx	;prop
;|***   
;|***   ln200.new_data = 0;
; Line 1082
	*** 001201	8e 06 00 00 		mov	es,WORD PTR $T4111
	*** 001205	26 c7 06 00 00 00 00 	mov	WORD PTR es:?ln200@@3ULN200@@E,0	;ln200
;|***   ln200.frame = frame;
; Line 1083
	*** 00120c	a1 00 00 		mov	ax,WORD PTR ?frame@@3KE	;frame
	*** 00120f	8b 16 02 00 		mov	dx,WORD PTR ?frame@@3KE+2	;frame
	*** 001213	26 a3 02 00 		mov	WORD PTR es:?ln200@@3ULN200@@E+2,ax	;ln200
	*** 001217	26 89 16 04 00 		mov	WORD PTR es:?ln200@@3ULN200@@E+4,dx	;ln200
;|***   
;|***   echo.new_data = 0;
; Line 1085
	*** 00121c	8e 06 00 00 		mov	es,WORD PTR $T4111
	*** 001220	26 c7 06 00 00 00 00 	mov	WORD PTR es:?echo@@3UECHO@@E,0	;echo
;|***   echo.frame = frame;
; Line 1086
	*** 001227	a1 00 00 		mov	ax,WORD PTR ?frame@@3KE	;frame
	*** 00122a	8b 16 02 00 		mov	dx,WORD PTR ?frame@@3KE+2	;frame
	*** 00122e	26 a3 02 00 		mov	WORD PTR es:?echo@@3UECHO@@E+2,ax	;echo
	*** 001232	26 89 16 04 00 		mov	WORD PTR es:?echo@@3UECHO@@E+4,dx	;echo
;|***   
;|***   ds.new_data = 0;
; Line 1088
	*** 001237	8e 06 00 00 		mov	es,WORD PTR $T4111
	*** 00123b	26 c7 06 00 00 00 00 	mov	WORD PTR es:?ds@@3UDS@@E,0	;ds
;|***   ds.frame = frame;
; Line 1089
	*** 001242	a1 00 00 		mov	ax,WORD PTR ?frame@@3KE	;frame
	*** 001245	8b 16 02 00 		mov	dx,WORD PTR ?frame@@3KE+2	;frame
	*** 001249	26 a3 02 00 		mov	WORD PTR es:?ds@@3UDS@@E+2,ax	;ds
	*** 00124d	26 89 16 04 00 		mov	WORD PTR es:?ds@@3UDS@@E+4,dx	;ds
;|***   
;|***   adcp.new_data = 0;
; Line 1091
	*** 001252	8e 06 00 00 		mov	es,WORD PTR $T4111
	*** 001256	26 c7 06 00 00 00 00 	mov	WORD PTR es:?adcp@@3UADCP@@E,0	;adcp
;|***   adcp.frame = frame;
; Line 1092
	*** 00125d	a1 00 00 		mov	ax,WORD PTR ?frame@@3KE	;frame
	*** 001260	8b 16 02 00 		mov	dx,WORD PTR ?frame@@3KE+2	;frame
	*** 001264	26 a3 02 00 		mov	WORD PTR es:?adcp@@3UADCP@@E+2,ax	;adcp
	*** 001268	26 89 16 04 00 		mov	WORD PTR es:?adcp@@3UADCP@@E+4,dx	;adcp
;|***   
;|***   // new TB model 9/26/2007 jtm
;|***   
;|***   commands.stbd_rpm = 0;
; Line 1096
	*** 00126d	8e 06 00 00 		mov	es,WORD PTR $T4111
	*** 001271	26 c7 06 04 00 00 00 	mov	WORD PTR es:?commands@@3UCOMMANDS@@E+4,0	;commands
;|***   commands.port_rpm = 0;
; Line 1097
	*** 001278	26 c7 06 22 00 00 00 	mov	WORD PTR es:?commands@@3UCOMMANDS@@E+34,0	;commands
;|***   
;|***   init_io(0x120);
; Line 1099
	*** 00127f	68 20 01 		push	288	;0120H
	*** 001282	9a 00 00 00 00 		call	FAR PTR ?init_io@@ZAXI@Z	; init_io
	*** 001287	83 c4 02 		add	sp,2
;|***   write_bit(PUMP, PUMPOFF);
; Line 1100
	*** 00128a	6a 01 			push	1
	*** 00128c	6a 10 			push	16	;0010H
	*** 00128e	9a 00 00 00 00 		call	FAR PTR ?write_bit@@ZAXHH@Z	; write_bit
	*** 001293	83 c4 04 		add	sp,4
;|***   write_bit(VALVE1, VALVEOFF);
; Line 1101
	*** 001296	6a 01 			push	1
	*** 001298	6a 0a 			push	10	;000aH
	*** 00129a	9a 00 00 00 00 		call	FAR PTR ?write_bit@@ZAXHH@Z	; write_bit
	*** 00129f	83 c4 04 		add	sp,4
;|***   write_bit(VALVE2, VALVEOFF);
; Line 1102
	*** 0012a2	6a 01 			push	1
	*** 0012a4	6a 0b 			push	11	;000bH
	*** 0012a6	9a 00 00 00 00 		call	FAR PTR ?write_bit@@ZAXHH@Z	; write_bit
	*** 0012ab	83 c4 04 		add	sp,4
;|***   write_bit(VALVE3, VALVEOFF);
; Line 1103
	*** 0012ae	6a 01 			push	1
	*** 0012b0	6a 0c 			push	12	;000cH
	*** 0012b2	9a 00 00 00 00 		call	FAR PTR ?write_bit@@ZAXHH@Z	; write_bit
	*** 0012b7	83 c4 04 		add	sp,4
;|***   write_bit(VALVE4, VALVEOFF);
; Line 1104
	*** 0012ba	6a 01 			push	1
	*** 0012bc	6a 0d 			push	13	;000dH
	*** 0012be	9a 00 00 00 00 		call	FAR PTR ?write_bit@@ZAXHH@Z	; write_bit
	*** 0012c3	83 c4 04 		add	sp,4
;|***   write_bit(VALVE5, VALVEOFF);
; Line 1105
	*** 0012c6	6a 01 			push	1
	*** 0012c8	6a 0e 			push	14	;000eH
	*** 0012ca	9a 00 00 00 00 		call	FAR PTR ?write_bit@@ZAXHH@Z	; write_bit
	*** 0012cf	83 c4 04 		add	sp,4
;|***   write_bit(VALVE6, VALVEOFF);
; Line 1106
	*** 0012d2	6a 01 			push	1
	*** 0012d4	6a 0f 			push	15	;000fH
	*** 0012d6	9a 00 00 00 00 		call	FAR PTR ?write_bit@@ZAXHH@Z	; write_bit
	*** 0012db	83 c4 04 		add	sp,4
;|***   write_bit(ERS, ERSNOBLOW);
; Line 1107
	*** 0012de	6a 01 			push	1
	*** 0012e0	6a 12 			push	18	;0012H
	*** 0012e2	9a 00 00 00 00 		call	FAR PTR ?write_bit@@ZAXHH@Z	; write_bit
	*** 0012e7	83 c4 04 		add	sp,4
;|***   write_bit(PFSVENTBLOW, PFSBLOW);
; Line 1108
	*** 0012ea	6a 00 			push	0
	*** 0012ec	6a 09 			push	9
	*** 0012ee	9a 00 00 00 00 		call	FAR PTR ?write_bit@@ZAXHH@Z	; write_bit
	*** 0012f3	83 c4 04 		add	sp,4
;|*** 
;|***   configure_escc();
; Line 1110
	*** 0012f6	9a 00 00 00 00 		call	FAR PTR ?configure_escc@@ZAXXZ	; configure_escc
;|***   init_tech80();
; Line 1111
	*** 0012fb	9a 00 00 00 00 		call	FAR PTR ?init_tech80@@ZAXXZ	; init_tech80
;|***   init_sys_timer();
; Line 1112
	*** 001300	9a 00 00 00 00 		call	FAR PTR ?init_sys_timer@@ZAXXZ	; init_sys_timer
;|***   init_com1();
; Line 1113
	*** 001305	9a 00 00 00 00 		call	FAR PTR ?init_com1@@ZAXXZ	; init_com1
;|***   init_com2();
; Line 1114
	*** 00130a	9a 00 00 00 00 		call	FAR PTR ?init_com2@@ZAXXZ	; init_com2
;|***   init_com4();
; Line 1115
	*** 00130f	9a 00 00 00 00 		call	FAR PTR ?init_com4@@ZAXXZ	; init_com4
;|***   configure_enet();
; Line 1116
	*** 001314	9a 00 00 00 00 		call	FAR PTR ?configure_enet@@ZAXXZ	; configure_enet
;|***   configure_dmm32a(); // onboard sensor adc
; Line 1117
	*** 001319	9a 00 00 00 00 		call	FAR PTR ?configure_dmm32a@@ZAXXZ	; configure_dmm32a
;|***   configure_dmm32b(); // dyno adc
; Line 1118
	*** 00131e	9a 00 00 00 00 		call	FAR PTR ?configure_dmm32b@@ZAXXZ	; configure_dmm32b
;|***   init_screen();
; Line 1119
	*** 001323	9a 00 00 00 00 		call	FAR PTR ?init_screen@@ZAXXZ	; init_screen
;|***   
;|***   }
; Line 1121
	*** 001328	e9 00 00 		jmp	$EX3792
					$EX3792:
	*** 00132b	5e 			pop	si
	*** 00132c	5f 			pop	di
	*** 00132d	c9 			leave	
	*** 00132e	cb 			ret	

?configure_obc@@ZAXXZ	ENDP
	PUBLIC	?init_tech80@@ZAXXZ	; init_tech80
?init_tech80@@ZAXXZ	PROC FAR	; init_tech80
;|*** 
;|*** 
;|*** void init_tech80(void)
;|***   {
; Line 1125
	*** 00132f	c8 00 00 00 		enter	0,0
	*** 001333	57 			push	di
	*** 001334	56 			push	si
;|***   cout << "te5650InitSw:    " << hex << te5650InitSw() << dec << endl;
; Line 1126
	*** 001335	68 00 00 		push	SEG ?endl@@ZAAEVostream@@AEV1@@Z	;endl
	*** 001338	68 00 00 		push	OFFSET ?endl@@ZAAEVostream@@AEV1@@Z	;endl
	*** 00133b	68 00 00 		push	SEG ?dec@@ZAAEVios@@AEV1@@Z	;dec
	*** 00133e	68 00 00 		push	OFFSET ?dec@@ZAAEVios@@AEV1@@Z	;dec
	*** 001341	9a 00 00 00 00 		call	FAR PTR _te5650InitSw
	*** 001346	50 			push	ax
	*** 001347	68 00 00 		push	SEG ?hex@@ZAAEVios@@AEV1@@Z	;hex
	*** 00134a	68 00 00 		push	OFFSET ?hex@@ZAAEVios@@AEV1@@Z	;hex
	*** 00134d	1e 			push	ds
	*** 00134e	68 00 00 		push	OFFSET DGROUP:$SG3800
	*** 001351	68 00 00 		push	SEG ?cout@@3Vostream_withassign@@E	;cout
	*** 001354	68 00 00 		push	OFFSET ?cout@@3Vostream_withassign@@E	;cout
	*** 001357	9a 00 00 00 00 		call	FAR PTR ??6ostream@@RECAEV0@PFD@Z	; ostream::operator<<
	*** 00135c	52 			push	dx
	*** 00135d	50 			push	ax
	*** 00135e	9a 00 00 00 00 		call	FAR PTR ??6ostream@@RECAEV0@P7AAEVios@@AEV1@@Z@Z	; ostream::operator<<
	*** 001363	52 			push	dx
	*** 001364	50 			push	ax
	*** 001365	9a 00 00 00 00 		call	FAR PTR ??6ostream@@RECAEV0@F@Z	; ostream::operator<<
	*** 00136a	52 			push	dx
	*** 00136b	50 			push	ax
	*** 00136c	9a 00 00 00 00 		call	FAR PTR ??6ostream@@RECAEV0@P7AAEVios@@AEV1@@Z@Z	; ostream::operator<<
	*** 001371	52 			push	dx
	*** 001372	50 			push	ax
	*** 001373	9a 00 00 00 00 		call	FAR PTR ??6ostream@@RECAEV0@P7AAEV0@AEV0@@Z@Z	; ostream::operator<<
;|***   cout << "te5650InitServo: " << te5650InitServo(0x400, TE5650TYPE_DAC16) << endl;
; Line 1127
	*** 001378	68 00 00 		push	SEG ?endl@@ZAAEVostream@@AEV1@@Z	;endl
	*** 00137b	68 00 00 		push	OFFSET ?endl@@ZAAEVostream@@AEV1@@Z	;endl
	*** 00137e	6a 00 			push	0
	*** 001380	68 00 04 		push	1024	;0400H
	*** 001383	9a 00 00 00 00 		call	FAR PTR _te5650InitServo
	*** 001388	83 c4 04 		add	sp,4
	*** 00138b	50 			push	ax
	*** 00138c	1e 			push	ds
	*** 00138d	68 00 00 		push	OFFSET DGROUP:$SG3801
	*** 001390	68 00 00 		push	SEG ?cout@@3Vostream_withassign@@E	;cout
	*** 001393	68 00 00 		push	OFFSET ?cout@@3Vostream_withassign@@E	;cout
	*** 001396	9a 00 00 00 00 		call	FAR PTR ??6ostream@@RECAEV0@PFD@Z	; ostream::operator<<
	*** 00139b	52 			push	dx
	*** 00139c	50 			push	ax
	*** 00139d	9a 00 00 00 00 		call	FAR PTR ??6ostream@@RECAEV0@F@Z	; ostream::operator<<
	*** 0013a2	52 			push	dx
	*** 0013a3	50 			push	ax
	*** 0013a4	9a 00 00 00 00 		call	FAR PTR ??6ostream@@RECAEV0@P7AAEV0@AEV0@@Z@Z	; ostream::operator<<
;|***   cout << "te5650SetAxis:   " << te5650SetAxis(1,STBD_PROP) << endl;
; Line 1128
	*** 0013a9	68 00 00 		push	SEG ?endl@@ZAAEVostream@@AEV1@@Z	;endl
	*** 0013ac	68 00 00 		push	OFFSET ?endl@@ZAAEVostream@@AEV1@@Z	;endl
	*** 0013af	6a 01 			push	1
	*** 0013b1	6a 01 			push	1
	*** 0013b3	9a 00 00 00 00 		call	FAR PTR _te5650SetAxis
	*** 0013b8	83 c4 04 		add	sp,4
	*** 0013bb	50 			push	ax
	*** 0013bc	1e 			push	ds
	*** 0013bd	68 00 00 		push	OFFSET DGROUP:$SG3802
	*** 0013c0	68 00 00 		push	SEG ?cout@@3Vostream_withassign@@E	;cout
	*** 0013c3	68 00 00 		push	OFFSET ?cout@@3Vostream_withassign@@E	;cout
	*** 0013c6	9a 00 00 00 00 		call	FAR PTR ??6ostream@@RECAEV0@PFD@Z	; ostream::operator<<
	*** 0013cb	52 			push	dx
	*** 0013cc	50 			push	ax
	*** 0013cd	9a 00 00 00 00 		call	FAR PTR ??6ostream@@RECAEV0@F@Z	; ostream::operator<<
	*** 0013d2	52 			push	dx
	*** 0013d3	50 			push	ax
	*** 0013d4	9a 00 00 00 00 		call	FAR PTR ??6ostream@@RECAEV0@P7AAEV0@AEV0@@Z@Z	; ostream::operator<<
;|***   //te5650PhasesPolarity(1,1,1);  // invert A,B,I phases  old encoder
;|***   te5650PhasesPolarity(1,1,1);  // no invert A,B, invert I phases  new encoder
; Line 1130
	*** 0013d9	6a 01 			push	1
	*** 0013db	6a 01 			push	1
	*** 0013dd	6a 01 			push	1
	*** 0013df	9a 00 00 00 00 		call	FAR PTR _te5650PhasesPolarity
	*** 0013e4	83 c4 06 		add	sp,6
;|***   te5650Update();
; Line 1131
	*** 0013e7	9a 00 00 00 00 		call	FAR PTR _te5650Update
;|***   te5650CaptureIndex();  
; Line 1132
	*** 0013ec	9a 00 00 00 00 		call	FAR PTR _te5650CaptureIndex
;|***   te5650Update();
; Line 1133
	*** 0013f1	9a 00 00 00 00 		call	FAR PTR _te5650Update
;|***   te5650ResetCapture();
; Line 1134
	*** 0013f6	9a 00 00 00 00 		call	FAR PTR _te5650ResetCapture
;|***   te5650Update();
; Line 1135
	*** 0013fb	9a 00 00 00 00 		call	FAR PTR _te5650Update
;|***   te5650MotorOff();
; Line 1136
	*** 001400	9a 00 00 00 00 		call	FAR PTR _te5650MotorOff
;|***   te5650Update();
; Line 1137
	*** 001405	9a 00 00 00 00 		call	FAR PTR _te5650Update
;|***   te5650SetMotor(0);
; Line 1138
	*** 00140a	6a 00 			push	0
	*** 00140c	9a 00 00 00 00 		call	FAR PTR _te5650SetMotor
	*** 001411	83 c4 02 		add	sp,2
;|***   te5650Update();
; Line 1139
	*** 001414	9a 00 00 00 00 		call	FAR PTR _te5650Update
;|*** 
;|***   cout << "te5650SetAxis:   " << te5650SetAxis(1,PORT_PROP) << endl;
; Line 1141
	*** 001419	68 00 00 		push	SEG ?endl@@ZAAEVostream@@AEV1@@Z	;endl
	*** 00141c	68 00 00 		push	OFFSET ?endl@@ZAAEVostream@@AEV1@@Z	;endl
	*** 00141f	6a 02 			push	2
	*** 001421	6a 01 			push	1
	*** 001423	9a 00 00 00 00 		call	FAR PTR _te5650SetAxis
	*** 001428	83 c4 04 		add	sp,4
	*** 00142b	50 			push	ax
	*** 00142c	1e 			push	ds
	*** 00142d	68 00 00 		push	OFFSET DGROUP:$SG3803
	*** 001430	68 00 00 		push	SEG ?cout@@3Vostream_withassign@@E	;cout
	*** 001433	68 00 00 		push	OFFSET ?cout@@3Vostream_withassign@@E	;cout
	*** 001436	9a 00 00 00 00 		call	FAR PTR ??6ostream@@RECAEV0@PFD@Z	; ostream::operator<<
	*** 00143b	52 			push	dx
	*** 00143c	50 			push	ax
	*** 00143d	9a 00 00 00 00 		call	FAR PTR ??6ostream@@RECAEV0@F@Z	; ostream::operator<<
	*** 001442	52 			push	dx
	*** 001443	50 			push	ax
	*** 001444	9a 00 00 00 00 		call	FAR PTR ??6ostream@@RECAEV0@P7AAEV0@AEV0@@Z@Z	; ostream::operator<<
;|***   //te5650PhasesPolarity(1,1,1);  // invert A,B,I phases  old encoder
;|***   te5650PhasesPolarity(1,1,1);  // no invert A,B, invert I phases  new encoder
; Line 1143
	*** 001449	6a 01 			push	1
	*** 00144b	6a 01 			push	1
	*** 00144d	6a 01 			push	1
	*** 00144f	9a 00 00 00 00 		call	FAR PTR _te5650PhasesPolarity
	*** 001454	83 c4 06 		add	sp,6
;|***   te5650Update();
; Line 1144
	*** 001457	9a 00 00 00 00 		call	FAR PTR _te5650Update
;|***   te5650CaptureIndex();  
; Line 1145
	*** 00145c	9a 00 00 00 00 		call	FAR PTR _te5650CaptureIndex
;|***   te5650Update();
; Line 1146
	*** 001461	9a 00 00 00 00 		call	FAR PTR _te5650Update
;|***   te5650ResetCapture();
; Line 1147
	*** 001466	9a 00 00 00 00 		call	FAR PTR _te5650ResetCapture
;|***   te5650Update();
; Line 1148
	*** 00146b	9a 00 00 00 00 		call	FAR PTR _te5650Update
;|***   te5650MotorOff();
; Line 1149
	*** 001470	9a 00 00 00 00 		call	FAR PTR _te5650MotorOff
;|***   te5650Update();
; Line 1150
	*** 001475	9a 00 00 00 00 		call	FAR PTR _te5650Update
;|***   te5650SetMotor(0);
; Line 1151
	*** 00147a	6a 00 			push	0
	*** 00147c	9a 00 00 00 00 		call	FAR PTR _te5650SetMotor
	*** 001481	83 c4 02 		add	sp,2
;|***   te5650Update();
; Line 1152
	*** 001484	9a 00 00 00 00 		call	FAR PTR _te5650Update
;|*** 
;|***   }
; Line 1154
	*** 001489	e9 00 00 		jmp	$EX3799
					$EX3799:
	*** 00148c	5e 			pop	si
	*** 00148d	5f 			pop	di
	*** 00148e	c9 			leave	
	*** 00148f	cb 			ret	

?init_tech80@@ZAXXZ	ENDP
	PUBLIC	?init_sys_timer@@ZAXXZ	; init_sys_timer
?init_sys_timer@@ZAXXZ	PROC FAR	; init_sys_timer
;|***   
;|***   
;|*** void init_sys_timer(void)
;|***   {
; Line 1158
	*** 001490	c8 00 00 00 		enter	0,0
	*** 001494	57 			push	di
	*** 001495	56 			push	si
;|***   rtc_vect = _dos_getvect(0x08);               // save the pc's default rtc isr vector
; Line 1159
	*** 001496	6a 08 			push	8
	*** 001498	9a 00 00 00 00 		call	FAR PTR __dos_getvect
	*** 00149d	83 c4 02 		add	sp,2
	*** 0014a0	a3 00 00 		mov	WORD PTR ?rtc_vect@@3P7AXXZE,ax	;rtc_vect
	*** 0014a3	89 16 02 00 		mov	WORD PTR ?rtc_vect@@3P7AXXZE+2,dx	;rtc_vect
;|***   _disable();                                  // so we can chain into it later
; Line 1160
	*** 0014a7	9a 00 00 00 00 		call	FAR PTR __disable
;|***   _dos_setvect(0x08, sys_timer_isr);           // hook our system timer isr
; Line 1161
	*** 0014ac	68 00 00 		push	SEG ?sys_timer_isr@@ZAXXZ	;sys_timer_isr
	*** 0014af	68 00 00 		push	OFFSET ?sys_timer_isr@@ZAXXZ	;sys_timer_isr
	*** 0014b2	6a 08 			push	8
	*** 0014b4	9a 00 00 00 00 		call	FAR PTR __dos_setvect
	*** 0014b9	83 c4 06 		add	sp,6
;|***   _outp(0x43, CTC0 | LSBMSB | MODE2 | BINARY); // change the pc's 8254 to mode2 operation
; Line 1162
	*** 0014bc	6a 34 			push	52	;0034H
	*** 0014be	6a 43 			push	67	;0043H
	*** 0014c0	9a 00 00 00 00 		call	FAR PTR __outp
	*** 0014c5	83 c4 04 		add	sp,4
;|***   _outp(0x40, 0xff);                           // load timer divisor LSB, then MSB
; Line 1163
	*** 0014c8	68 ff 00 		push	255	;00ffH
	*** 0014cb	6a 40 			push	64	;0040H
	*** 0014cd	9a 00 00 00 00 		call	FAR PTR __outp
	*** 0014d2	83 c4 04 		add	sp,4
;|***   _outp(0x40, 0xff);
; Line 1164
	*** 0014d5	68 ff 00 		push	255	;00ffH
	*** 0014d8	6a 40 			push	64	;0040H
	*** 0014da	9a 00 00 00 00 		call	FAR PTR __outp
	*** 0014df	83 c4 04 		add	sp,4
;|***   _enable();
; Line 1165
	*** 0014e2	9a 00 00 00 00 		call	FAR PTR __enable
;|***   }
; Line 1166
	*** 0014e7	e9 00 00 		jmp	$EX3805
					$EX3805:
	*** 0014ea	5e 			pop	si
	*** 0014eb	5f 			pop	di
	*** 0014ec	c9 			leave	
	*** 0014ed	cb 			ret	

?init_sys_timer@@ZAXXZ	ENDP
	PUBLIC	?configure_enet@@ZAXXZ	; configure_enet
?configure_enet@@ZAXXZ	PROC FAR	; configure_enet
;|*** 
;|*** 
;|*** void configure_enet(void)
;|***   {
; Line 1170
	*** 0014ee	c8 06 00 00 		enter	6,0
	*** 0014f2	57 			push	di
	*** 0014f3	56 			push	si
;	packet_type = -2
;	ptype = -6
;|***   char packet_type[2] = {0x08, 0x00};
; Line 1171
	*** 0014f4	c6 46 fe 08 		mov	BYTE PTR [bp-2],8	;packet_type
	*** 0014f8	c6 46 ff 00 		mov	BYTE PTR [bp-1],0
;|***   char far *ptype = packet_type;
; Line 1172
	*** 0014fc	8d 46 fe 		lea	ax,WORD PTR [bp-2]	;packet_type
	*** 0014ff	89 46 fa 		mov	WORD PTR [bp-6],ax	;ptype
	*** 001502	8c 56 fc 		mov	WORD PTR [bp-4],ss
;|*** 
;|*** /*
;|***   // use at/lantic packet driver
;|***   system("c:\\ne2000\\pktdrv\\atdrive -i 0x7e -b 0x300 -q 10");
;|***   cout << "Access_type() error: " << access_type(1, 52, 0, ptype, 2, receiver) << endl;
;|***   cout << "Handle: " << handle << endl;
;|***   cout << "Set_rcv_mode() error: " << set_rcv_mode(handle, 6) << endl;
;|*** */  
;|***   
;|***   // use ne2000 packet driver
;|***   system("c:\\packet\\pktdrv\\ne2000 0x7e 10 0x300");
; Line 1183
	*** 001505	1e 			push	ds
	*** 001506	68 00 00 		push	OFFSET DGROUP:$SG3810
	*** 001509	9a 00 00 00 00 		call	FAR PTR _system
	*** 00150e	83 c4 04 		add	sp,4
;|***   cout << "Access_type() error: " << access_type(1, 52, 0, NULL, 0, receiver) << endl;
; Line 1184
	*** 001511	68 00 00 		push	SEG ?endl@@ZAAEVostream@@AEV1@@Z	;endl
	*** 001514	68 00 00 		push	OFFSET ?endl@@ZAAEVostream@@AEV1@@Z	;endl
	*** 001517	68 00 00 		push	SEG ?receiver@@ZAXIIIIIIIIIIIII@Z	;receiver
	*** 00151a	68 00 00 		push	OFFSET ?receiver@@ZAXIIIIIIIIIIIII@Z	;receiver
	*** 00151d	6a 00 			push	0
	*** 00151f	6a 00 			push	0
	*** 001521	6a 00 			push	0
	*** 001523	6a 00 			push	0
	*** 001525	6a 34 			push	52	;0034H
	*** 001527	6a 01 			push	1
	*** 001529	9a 00 00 00 00 		call	FAR PTR ?access_type@@ZAHHHHPEDIP7AXIIIIIIIIIIIII@Z@Z	; access_type
	*** 00152e	83 c4 10 		add	sp,16	;0010H
	*** 001531	50 			push	ax
	*** 001532	1e 			push	ds
	*** 001533	68 00 00 		push	OFFSET DGROUP:$SG3811
	*** 001536	68 00 00 		push	SEG ?cout@@3Vostream_withassign@@E	;cout
	*** 001539	68 00 00 		push	OFFSET ?cout@@3Vostream_withassign@@E	;cout
	*** 00153c	9a 00 00 00 00 		call	FAR PTR ??6ostream@@RECAEV0@PFD@Z	; ostream::operator<<
	*** 001541	52 			push	dx
	*** 001542	50 			push	ax
	*** 001543	9a 00 00 00 00 		call	FAR PTR ??6ostream@@RECAEV0@H@Z	; ostream::operator<<
	*** 001548	52 			push	dx
	*** 001549	50 			push	ax
	*** 00154a	9a 00 00 00 00 		call	FAR PTR ??6ostream@@RECAEV0@P7AAEV0@AEV0@@Z@Z	; ostream::operator<<
;|***   cout << "Handle: " << handle << endl;
; Line 1185
	*** 00154f	68 00 00 		push	SEG ?endl@@ZAAEVostream@@AEV1@@Z	;endl
	*** 001552	68 00 00 		push	OFFSET ?endl@@ZAAEVostream@@AEV1@@Z	;endl
	*** 001555	ff 36 00 00 		push	WORD PTR ?handle@@3HE	;handle
	*** 001559	1e 			push	ds
	*** 00155a	68 00 00 		push	OFFSET DGROUP:$SG3812
	*** 00155d	68 00 00 		push	SEG ?cout@@3Vostream_withassign@@E	;cout
	*** 001560	68 00 00 		push	OFFSET ?cout@@3Vostream_withassign@@E	;cout
	*** 001563	9a 00 00 00 00 		call	FAR PTR ??6ostream@@RECAEV0@PFD@Z	; ostream::operator<<
	*** 001568	52 			push	dx
	*** 001569	50 			push	ax
	*** 00156a	9a 00 00 00 00 		call	FAR PTR ??6ostream@@RECAEV0@H@Z	; ostream::operator<<
	*** 00156f	52 			push	dx
	*** 001570	50 			push	ax
	*** 001571	9a 00 00 00 00 		call	FAR PTR ??6ostream@@RECAEV0@P7AAEV0@AEV0@@Z@Z	; ostream::operator<<
;|***   cout << "Driver_info() error: " << driver_info(handle) << endl;
; Line 1186
	*** 001576	68 00 00 		push	SEG ?endl@@ZAAEVostream@@AEV1@@Z	;endl
	*** 001579	68 00 00 		push	OFFSET ?endl@@ZAAEVostream@@AEV1@@Z	;endl
	*** 00157c	ff 36 00 00 		push	WORD PTR ?handle@@3HE	;handle
	*** 001580	9a 00 00 00 00 		call	FAR PTR ?driver_info@@ZAHI@Z	; driver_info
	*** 001585	83 c4 02 		add	sp,2
	*** 001588	50 			push	ax
	*** 001589	1e 			push	ds
	*** 00158a	68 00 00 		push	OFFSET DGROUP:$SG3813
	*** 00158d	68 00 00 		push	SEG ?cout@@3Vostream_withassign@@E	;cout
	*** 001590	68 00 00 		push	OFFSET ?cout@@3Vostream_withassign@@E	;cout
	*** 001593	9a 00 00 00 00 		call	FAR PTR ??6ostream@@RECAEV0@PFD@Z	; ostream::operator<<
	*** 001598	52 			push	dx
	*** 001599	50 			push	ax
	*** 00159a	9a 00 00 00 00 		call	FAR PTR ??6ostream@@RECAEV0@H@Z	; ostream::operator<<
	*** 00159f	52 			push	dx
	*** 0015a0	50 			push	ax
	*** 0015a1	9a 00 00 00 00 		call	FAR PTR ??6ostream@@RECAEV0@P7AAEV0@AEV0@@Z@Z	; ostream::operator<<
;|***   cout << "Rpm_sf: " << rpm_sf << endl;
; Line 1187
	*** 0015a6	68 00 00 		push	SEG ?endl@@ZAAEVostream@@AEV1@@Z	;endl
	*** 0015a9	68 00 00 		push	OFFSET ?endl@@ZAAEVostream@@AEV1@@Z	;endl
	*** 0015ac	ff 36 02 00 		push	WORD PTR ?rpm_sf@@3ME+2	;rpm_sf
	*** 0015b0	ff 36 00 00 		push	WORD PTR ?rpm_sf@@3ME	;rpm_sf
	*** 0015b4	1e 			push	ds
	*** 0015b5	68 00 00 		push	OFFSET DGROUP:$SG3814
	*** 0015b8	68 00 00 		push	SEG ?cout@@3Vostream_withassign@@E	;cout
	*** 0015bb	68 00 00 		push	OFFSET ?cout@@3Vostream_withassign@@E	;cout
	*** 0015be	9a 00 00 00 00 		call	FAR PTR ??6ostream@@RECAEV0@PFD@Z	; ostream::operator<<
	*** 0015c3	52 			push	dx
	*** 0015c4	50 			push	ax
	*** 0015c5	9a 00 00 00 00 		call	FAR PTR ??6ostream@@RECAEV0@M@Z	; ostream::operator<<
	*** 0015ca	52 			push	dx
	*** 0015cb	50 			push	ax
	*** 0015cc	9a 00 00 00 00 		call	FAR PTR ??6ostream@@RECAEV0@P7AAEV0@AEV0@@Z@Z	; ostream::operator<<
;|*** /*
;|***   cout << "..... press <spacebar> to continue....." << endl;
;|***   while(!kbhit());
;|***   _getch();
;|*** */  
;|***   }
; Line 1193
	*** 0015d1	e9 00 00 		jmp	$EX3807
					$EX3807:
	*** 0015d4	5e 			pop	si
	*** 0015d5	5f 			pop	di
	*** 0015d6	c9 			leave	
	*** 0015d7	cb 			ret	

?configure_enet@@ZAXXZ	ENDP
	PUBLIC	?configure_escc@@ZAXXZ	; configure_escc
?configure_escc@@ZAXXZ	PROC FAR	; configure_escc
;|*** 
;|***   
;|*** void configure_escc(void)
;|***   {
; Line 1197
	*** 0015d8	c8 00 00 00 		enter	0,0
	*** 0015dc	57 			push	di
	*** 0015dd	56 			push	si
;|***   
;|***   // open the two escc communications ports using add_port() function
;|***   // parameters: (base address of escc board,
;|***   //              escc channel 0 or 1,
;|***   //              IRQ setting,   
;|***   //              dma channel for receive,  
;|***   //              dma channel for transmit)
;|*** 
;|***   // channel A to communicate with the LN200                  
;|***   channela = escc1.add_port(0x240,0,5,0,0);  //1st channel, IRQ 5, no dma
; Line 1207
	*** 0015de	68 40 02 		push	576	;0240H
	*** 0015e1	6a 00 			push	0
	*** 0015e3	6a 05 			push	5
	*** 0015e5	6a 00 			push	0
	*** 0015e7	6a 00 			push	0
	*** 0015e9	68 00 00 		push	SEG ?escc1@@3VCescc@@E	;escc1
	*** 0015ec	68 00 00 		push	OFFSET ?escc1@@3VCescc@@E	;escc1
	*** 0015ef	9a 00 00 00 00 		call	FAR PTR ?add_port@Cescc@@RECIIIIII@Z	; Cescc::add_port
	*** 0015f4	a3 00 00 		mov	WORD PTR ?channela@@3IE,ax	;channela
;|***   cout << "Channel A = " << channela << endl;
; Line 1208
	*** 0015f7	68 00 00 		push	SEG ?endl@@ZAAEVostream@@AEV1@@Z	;endl
	*** 0015fa	68 00 00 		push	OFFSET ?endl@@ZAAEVostream@@AEV1@@Z	;endl
	*** 0015fd	ff 36 00 00 		push	WORD PTR ?channela@@3IE	;channela
	*** 001601	1e 			push	ds
	*** 001602	68 00 00 		push	OFFSET DGROUP:$SG3817
	*** 001605	68 00 00 		push	SEG ?cout@@3Vostream_withassign@@E	;cout
	*** 001608	68 00 00 		push	OFFSET ?cout@@3Vostream_withassign@@E	;cout
	*** 00160b	9a 00 00 00 00 		call	FAR PTR ??6ostream@@RECAEV0@PFD@Z	; ostream::operator<<
	*** 001610	52 			push	dx
	*** 001611	50 			push	ax
	*** 001612	9a 00 00 00 00 		call	FAR PTR ??6ostream@@RECAEV0@I@Z	; ostream::operator<<
	*** 001617	52 			push	dx
	*** 001618	50 			push	ax
	*** 001619	9a 00 00 00 00 		call	FAR PTR ??6ostream@@RECAEV0@P7AAEV0@AEV0@@Z@Z	; ostream::operator<<
;|***   
;|***   // channel B to transmit the pcm telemetry
;|***   channelb = escc1.add_port(0x240,1,5,1,5);  //2nd channel IRQ 5, Rx=DMA Ch1, Tx=DMA Ch5
; Line 1211
	*** 00161e	68 40 02 		push	576	;0240H
	*** 001621	6a 01 			push	1
	*** 001623	6a 05 			push	5
	*** 001625	6a 01 			push	1
	*** 001627	6a 05 			push	5
	*** 001629	68 00 00 		push	SEG ?escc1@@3VCescc@@E	;escc1
	*** 00162c	68 00 00 		push	OFFSET ?escc1@@3VCescc@@E	;escc1
	*** 00162f	9a 00 00 00 00 		call	FAR PTR ?add_port@Cescc@@RECIIIIII@Z	; Cescc::add_port
	*** 001634	a3 00 00 		mov	WORD PTR ?channelb@@3IE,ax	;channelb
;|***   cout << "Channel B = " << channelb  << endl;
; Line 1212
	*** 001637	68 00 00 		push	SEG ?endl@@ZAAEVostream@@AEV1@@Z	;endl
	*** 00163a	68 00 00 		push	OFFSET ?endl@@ZAAEVostream@@AEV1@@Z	;endl
	*** 00163d	ff 36 00 00 		push	WORD PTR ?channelb@@3IE	;channelb
	*** 001641	1e 			push	ds
	*** 001642	68 00 00 		push	OFFSET DGROUP:$SG3818
	*** 001645	68 00 00 		push	SEG ?cout@@3Vostream_withassign@@E	;cout
	*** 001648	68 00 00 		push	OFFSET ?cout@@3Vostream_withassign@@E	;cout
	*** 00164b	9a 00 00 00 00 		call	FAR PTR ??6ostream@@RECAEV0@PFD@Z	; ostream::operator<<
	*** 001650	52 			push	dx
	*** 001651	50 			push	ax
	*** 001652	9a 00 00 00 00 		call	FAR PTR ??6ostream@@RECAEV0@I@Z	; ostream::operator<<
	*** 001657	52 			push	dx
	*** 001658	50 			push	ax
	*** 001659	9a 00 00 00 00 		call	FAR PTR ??6ostream@@RECAEV0@P7AAEV0@AEV0@@Z@Z	; ostream::operator<<
;|***   
;|***   // assemble configuration data for channel_a for LN200 SDLC operation.
;|***   // see Siemens SAB 82532 ESCC User's Manual page 110.
;|***   settings.mode = 0x88;   // transparent 0 frames, receiver active
; Line 1216
	*** 00165e	8e 06 00 00 		mov	es,WORD PTR $T4111
	*** 001662	26 c7 06 02 00 88 00 	mov	WORD PTR es:?settings@@3Uescc_regs@@E+2,136	;0088H	;settings
;|***   settings.timr = 0x1f;   // for cb98
; Line 1217
	*** 001669	26 c7 06 04 00 1f 00 	mov	WORD PTR es:?settings@@3Uescc_regs@@E+4,31	;001fH	;settings
;|***   settings.xbcl = 0x00;   // n/a for interrupt mode
; Line 1218
	*** 001670	26 c7 06 06 00 00 00 	mov	WORD PTR es:?settings@@3Uescc_regs@@E+6,0	;settings
;|***   settings.xbch = 0x00;   // interrupt mode (no dma)
; Line 1219
	*** 001677	26 c7 06 08 00 00 00 	mov	WORD PTR es:?settings@@3Uescc_regs@@E+8,0	;settings
;|***   settings.ccr0 = 0xc0;   // power up, master clock enabled
; Line 1220
	*** 00167e	26 c7 06 0a 00 c0 00 	mov	WORD PTR es:?settings@@3Uescc_regs@@E+10,192	;00c0H	;settings
;|***   settings.ccr1 = 0x10;   // txd push-pull, one's insertion, clk mode 0 (use LN200 clock)
; Line 1221
	*** 001685	26 c7 06 0c 00 10 00 	mov	WORD PTR es:?settings@@3Uescc_regs@@E+12,16	;0010H	;settings
;|***   settings.ccr2 = 0x00;   // normal txd/rxd, ssel=0 (clk mode 0a), crc-ccitt, no inversion 
; Line 1222
	*** 00168c	26 c7 06 0e 00 00 00 	mov	WORD PTR es:?settings@@3Uescc_regs@@E+14,0	;settings
;|***   settings.ccr3 = 0x00;   // no preamble, rx crc off, tx crc generated internally
; Line 1223
	*** 001693	26 c7 06 10 00 00 00 	mov	WORD PTR es:?settings@@3Uescc_regs@@E+16,0	;settings
;|***   settings.ccr4 = 0x00;   // 
; Line 1224
	*** 00169a	26 c7 06 12 00 00 00 	mov	WORD PTR es:?settings@@3Uescc_regs@@E+18,0	;settings
;|***   settings.bgr  = 0x00;   // 
; Line 1225
	*** 0016a1	26 c7 06 14 00 00 00 	mov	WORD PTR es:?settings@@3Uescc_regs@@E+20,0	;settings
;|***   settings.iva  = 0x00;   // 
; Line 1226
	*** 0016a8	26 c7 06 16 00 00 00 	mov	WORD PTR es:?settings@@3Uescc_regs@@E+22,0	;settings
;|***   settings.ipc  = 0x03;   // masked interrupts NOT visible, pin INT = push/pull active high
; Line 1227
	*** 0016af	26 c7 06 18 00 03 00 	mov	WORD PTR es:?settings@@3Uescc_regs@@E+24,3	;settings
;|***   settings.imr0 = 0x04;   // cdsc disabled
; Line 1228
	*** 0016b6	26 c7 06 1a 00 04 00 	mov	WORD PTR es:?settings@@3Uescc_regs@@E+26,4	;settings
;|***   settings.imr1 = 0x00;   // all interrupts enabled 
; Line 1229
	*** 0016bd	26 c7 06 1c 00 00 00 	mov	WORD PTR es:?settings@@3Uescc_regs@@E+28,0	;settings
;|***   settings.pvr  = 0x00;   //
; Line 1230
	*** 0016c4	26 c7 06 1e 00 00 00 	mov	WORD PTR es:?settings@@3Uescc_regs@@E+30,0	;settings
;|***   settings.pim  = 0xff;
; Line 1231
	*** 0016cb	26 c7 06 20 00 ff 00 	mov	WORD PTR es:?settings@@3Uescc_regs@@E+32,255	;00ffH	;settings
;|***   settings.pcr  = 0xe0;
; Line 1232
	*** 0016d2	26 c7 06 22 00 e0 00 	mov	WORD PTR es:?settings@@3Uescc_regs@@E+34,224	;00e0H	;settings
;|***   settings.xad1 = 0xff;
; Line 1233
	*** 0016d9	26 c7 06 24 00 ff 00 	mov	WORD PTR es:?settings@@3Uescc_regs@@E+36,255	;00ffH	;settings
;|***   settings.xad2 = 0xff;
; Line 1234
	*** 0016e0	26 c7 06 26 00 ff 00 	mov	WORD PTR es:?settings@@3Uescc_regs@@E+38,255	;00ffH	;settings
;|***   settings.rah1 = 0xff;
; Line 1235
	*** 0016e7	26 c7 06 28 00 ff 00 	mov	WORD PTR es:?settings@@3Uescc_regs@@E+40,255	;00ffH	;settings
;|***   settings.rah2 = 0xff;
; Line 1236
	*** 0016ee	26 c7 06 2a 00 ff 00 	mov	WORD PTR es:?settings@@3Uescc_regs@@E+42,255	;00ffH	;settings
;|***   settings.ral1 = 0xff;
; Line 1237
	*** 0016f5	26 c7 06 2c 00 ff 00 	mov	WORD PTR es:?settings@@3Uescc_regs@@E+44,255	;00ffH	;settings
;|***   settings.ral2 = 0xff;
; Line 1238
	*** 0016fc	26 c7 06 2e 00 ff 00 	mov	WORD PTR es:?settings@@3Uescc_regs@@E+46,255	;00ffH	;settings
;|***   settings.rlcr = 0x00;
; Line 1239
	*** 001703	26 c7 06 30 00 00 00 	mov	WORD PTR es:?settings@@3Uescc_regs@@E+48,0	;settings
;|***   settings.pre  = 0x00;
; Line 1240
	*** 00170a	26 c7 06 32 00 00 00 	mov	WORD PTR es:?settings@@3Uescc_regs@@E+50,0	;settings
;|***     
;|***   // write configuration data to escc channel a registers
;|***   // parameters:(port to intialize,
;|***   //             operating mode,
;|***   //             settings defined above,
;|***   //             number of receive buffers,
;|***   //             number of transmit buffers)
;|***   cout << "initializing channel a" << endl;
; Line 1248
	*** 001711	68 00 00 		push	SEG ?endl@@ZAAEVostream@@AEV1@@Z	;endl
	*** 001714	68 00 00 		push	OFFSET ?endl@@ZAAEVostream@@AEV1@@Z	;endl
	*** 001717	1e 			push	ds
	*** 001718	68 00 00 		push	OFFSET DGROUP:$SG3819
	*** 00171b	68 00 00 		push	SEG ?cout@@3Vostream_withassign@@E	;cout
	*** 00171e	68 00 00 		push	OFFSET ?cout@@3Vostream_withassign@@E	;cout
	*** 001721	9a 00 00 00 00 		call	FAR PTR ??6ostream@@RECAEV0@PFD@Z	; ostream::operator<<
	*** 001726	52 			push	dx
	*** 001727	50 			push	ax
	*** 001728	9a 00 00 00 00 		call	FAR PTR ??6ostream@@RECAEV0@P7AAEV0@AEV0@@Z@Z	; ostream::operator<<
;|***   if(escc1.init_port(channela,OPMODE_HDLC,&settings,2,2)==TRUE)
; Line 1249
	*** 00172d	ff 36 00 00 		push	WORD PTR ?channela@@3IE	;channela
	*** 001731	6a 00 			push	0
	*** 001733	68 00 00 		push	SEG ?settings@@3Uescc_regs@@E	;settings
	*** 001736	68 00 00 		push	OFFSET ?settings@@3Uescc_regs@@E	;settings
	*** 001739	6a 02 			push	2
	*** 00173b	6a 02 			push	2
	*** 00173d	68 00 00 		push	SEG ?escc1@@3VCescc@@E	;escc1
	*** 001740	68 00 00 		push	OFFSET ?escc1@@3VCescc@@E	;escc1
	*** 001743	9a 00 00 00 00 		call	FAR PTR ?init_port@Cescc@@RECIIIPEUescc_regs@@II@Z	; Cescc::init_port
	*** 001748	3d 00 00 		cmp	ax,0
	*** 00174b	74 03 			je	$JCC5963
	*** 00174d	e9 1f 00 		jmp	$I3820
					$JCC5963:
;|***     cout << "Intialize Channel A OK." << endl;
; Line 1250
	*** 001750	68 00 00 		push	SEG ?endl@@ZAAEVostream@@AEV1@@Z	;endl
	*** 001753	68 00 00 		push	OFFSET ?endl@@ZAAEVostream@@AEV1@@Z	;endl
	*** 001756	1e 			push	ds
	*** 001757	68 00 00 		push	OFFSET DGROUP:$SG3821
	*** 00175a	68 00 00 		push	SEG ?cout@@3Vostream_withassign@@E	;cout
	*** 00175d	68 00 00 		push	OFFSET ?cout@@3Vostream_withassign@@E	;cout
	*** 001760	9a 00 00 00 00 		call	FAR PTR ??6ostream@@RECAEV0@PFD@Z	; ostream::operator<<
	*** 001765	52 			push	dx
	*** 001766	50 			push	ax
	*** 001767	9a 00 00 00 00 		call	FAR PTR ??6ostream@@RECAEV0@P7AAEV0@AEV0@@Z@Z	; ostream::operator<<
;|***   else
; Line 1251
	*** 00176c	e9 26 00 		jmp	$I3822
					$I3820:
;|***     {
; Line 1252
;|***     cout << "Initialize Channel A FAILED!" << endl;
; Line 1253
	*** 00176f	68 00 00 		push	SEG ?endl@@ZAAEVostream@@AEV1@@Z	;endl
	*** 001772	68 00 00 		push	OFFSET ?endl@@ZAAEVostream@@AEV1@@Z	;endl
	*** 001775	1e 			push	ds
	*** 001776	68 00 00 		push	OFFSET DGROUP:$SG3823
	*** 001779	68 00 00 		push	SEG ?cout@@3Vostream_withassign@@E	;cout
	*** 00177c	68 00 00 		push	OFFSET ?cout@@3Vostream_withassign@@E	;cout
	*** 00177f	9a 00 00 00 00 		call	FAR PTR ??6ostream@@RECAEV0@PFD@Z	; ostream::operator<<
	*** 001784	52 			push	dx
	*** 001785	50 			push	ax
	*** 001786	9a 00 00 00 00 		call	FAR PTR ??6ostream@@RECAEV0@P7AAEV0@AEV0@@Z@Z	; ostream::operator<<
;|***     //terminate();
;|***     exit(0);
; Line 1255
	*** 00178b	6a 00 			push	0
	*** 00178d	9a 00 00 00 00 		call	FAR PTR _exit
	*** 001792	83 c4 02 		add	sp,2
;|***     }
; Line 1256
					$I3822:
;|***   
;|***   // test channel a to make sure it opened
;|***   if(escc1.clear_rx_buffer(channela)==TRUE)
; Line 1259
	*** 001795	ff 36 00 00 		push	WORD PTR ?channela@@3IE	;channela
	*** 001799	68 00 00 		push	SEG ?escc1@@3VCescc@@E	;escc1
	*** 00179c	68 00 00 		push	OFFSET ?escc1@@3VCescc@@E	;escc1
	*** 00179f	9a 00 00 00 00 		call	FAR PTR ?clear_rx_buffer@Cescc@@RECII@Z	; Cescc::clear_rx_buffer
	*** 0017a4	3d 00 00 		cmp	ax,0
	*** 0017a7	74 03 			je	$JCC6055
	*** 0017a9	e9 1f 00 		jmp	$I3824
					$JCC6055:
;|***     cout << "Channel A rx buffer cleared OK.  " << endl;
; Line 1260
	*** 0017ac	68 00 00 		push	SEG ?endl@@ZAAEVostream@@AEV1@@Z	;endl
	*** 0017af	68 00 00 		push	OFFSET ?endl@@ZAAEVostream@@AEV1@@Z	;endl
	*** 0017b2	1e 			push	ds
	*** 0017b3	68 00 00 		push	OFFSET DGROUP:$SG3825
	*** 0017b6	68 00 00 		push	SEG ?cout@@3Vostream_withassign@@E	;cout
	*** 0017b9	68 00 00 		push	OFFSET ?cout@@3Vostream_withassign@@E	;cout
	*** 0017bc	9a 00 00 00 00 		call	FAR PTR ??6ostream@@RECAEV0@PFD@Z	; ostream::operator<<
	*** 0017c1	52 			push	dx
	*** 0017c2	50 			push	ax
	*** 0017c3	9a 00 00 00 00 		call	FAR PTR ??6ostream@@RECAEV0@P7AAEV0@AEV0@@Z@Z	; ostream::operator<<
;|***   else
; Line 1261
	*** 0017c8	e9 26 00 		jmp	$I3826
					$I3824:
;|***     {
; Line 1262
;|***     cout << "Channel A rx buffer clear FAILED!" << endl;
; Line 1263
	*** 0017cb	68 00 00 		push	SEG ?endl@@ZAAEVostream@@AEV1@@Z	;endl
	*** 0017ce	68 00 00 		push	OFFSET ?endl@@ZAAEVostream@@AEV1@@Z	;endl
	*** 0017d1	1e 			push	ds
	*** 0017d2	68 00 00 		push	OFFSET DGROUP:$SG3827
	*** 0017d5	68 00 00 		push	SEG ?cout@@3Vostream_withassign@@E	;cout
	*** 0017d8	68 00 00 		push	OFFSET ?cout@@3Vostream_withassign@@E	;cout
	*** 0017db	9a 00 00 00 00 		call	FAR PTR ??6ostream@@RECAEV0@PFD@Z	; ostream::operator<<
	*** 0017e0	52 			push	dx
	*** 0017e1	50 			push	ax
	*** 0017e2	9a 00 00 00 00 		call	FAR PTR ??6ostream@@RECAEV0@P7AAEV0@AEV0@@Z@Z	; ostream::operator<<
;|***     //terminate();
;|***     exit(0);
; Line 1265
	*** 0017e7	6a 00 			push	0
	*** 0017e9	9a 00 00 00 00 		call	FAR PTR _exit
	*** 0017ee	83 c4 02 		add	sp,2
;|***     }
; Line 1266
					$I3826:
;|*** 
;|***   if(escc1.clear_tx_buffer(channela)==TRUE)
; Line 1268
	*** 0017f1	ff 36 00 00 		push	WORD PTR ?channela@@3IE	;channela
	*** 0017f5	68 00 00 		push	SEG ?escc1@@3VCescc@@E	;escc1
	*** 0017f8	68 00 00 		push	OFFSET ?escc1@@3VCescc@@E	;escc1
	*** 0017fb	9a 00 00 00 00 		call	FAR PTR ?clear_tx_buffer@Cescc@@RECII@Z	; Cescc::clear_tx_buffer
	*** 001800	3d 00 00 		cmp	ax,0
	*** 001803	74 03 			je	$JCC6147
	*** 001805	e9 1f 00 		jmp	$I3828
					$JCC6147:
;|***     cout << "Channel A tx buffer cleared OK." << endl;
; Line 1269
	*** 001808	68 00 00 		push	SEG ?endl@@ZAAEVostream@@AEV1@@Z	;endl
	*** 00180b	68 00 00 		push	OFFSET ?endl@@ZAAEVostream@@AEV1@@Z	;endl
	*** 00180e	1e 			push	ds
	*** 00180f	68 00 00 		push	OFFSET DGROUP:$SG3829
	*** 001812	68 00 00 		push	SEG ?cout@@3Vostream_withassign@@E	;cout
	*** 001815	68 00 00 		push	OFFSET ?cout@@3Vostream_withassign@@E	;cout
	*** 001818	9a 00 00 00 00 		call	FAR PTR ??6ostream@@RECAEV0@PFD@Z	; ostream::operator<<
	*** 00181d	52 			push	dx
	*** 00181e	50 			push	ax
	*** 00181f	9a 00 00 00 00 		call	FAR PTR ??6ostream@@RECAEV0@P7AAEV0@AEV0@@Z@Z	; ostream::operator<<
;|***   else
; Line 1270
	*** 001824	e9 21 00 		jmp	$I3830
					$I3828:
;|***     {
; Line 1271
;|***     cout << "Channel A tx buffer clear FAILED!" << endl;
; Line 1272
	*** 001827	68 00 00 		push	SEG ?endl@@ZAAEVostream@@AEV1@@Z	;endl
	*** 00182a	68 00 00 		push	OFFSET ?endl@@ZAAEVostream@@AEV1@@Z	;endl
	*** 00182d	1e 			push	ds
	*** 00182e	68 00 00 		push	OFFSET DGROUP:$SG3831
	*** 001831	68 00 00 		push	SEG ?cout@@3Vostream_withassign@@E	;cout
	*** 001834	68 00 00 		push	OFFSET ?cout@@3Vostream_withassign@@E	;cout
	*** 001837	9a 00 00 00 00 		call	FAR PTR ??6ostream@@RECAEV0@PFD@Z	; ostream::operator<<
	*** 00183c	52 			push	dx
	*** 00183d	50 			push	ax
	*** 00183e	9a 00 00 00 00 		call	FAR PTR ??6ostream@@RECAEV0@P7AAEV0@AEV0@@Z@Z	; ostream::operator<<
;|***     terminate();
; Line 1273
	*** 001843	9a 00 00 00 00 		call	FAR PTR ?terminate@@ZAXXZ	; terminate
;|***     }
; Line 1274
					$I3830:
;|***   
;|***   // set channel a frame transmission type
;|***   if(escc1.set_tx_type(channela, TRANSPARENT_MODE)==TRUE)
; Line 1277
	*** 001848	ff 36 00 00 		push	WORD PTR ?channela@@3IE	;channela
	*** 00184c	6a 01 			push	1
	*** 00184e	68 00 00 		push	SEG ?escc1@@3VCescc@@E	;escc1
	*** 001851	68 00 00 		push	OFFSET ?escc1@@3VCescc@@E	;escc1
	*** 001854	9a 00 00 00 00 		call	FAR PTR ?set_tx_type@Cescc@@RECIII@Z	; Cescc::set_tx_type
	*** 001859	3d 00 00 		cmp	ax,0
	*** 00185c	74 03 			je	$JCC6236
	*** 00185e	e9 1f 00 		jmp	$I3832
					$JCC6236:
;|***     cout << "Channel A set to Transparent Mode.  " << endl;
; Line 1278
	*** 001861	68 00 00 		push	SEG ?endl@@ZAAEVostream@@AEV1@@Z	;endl
	*** 001864	68 00 00 		push	OFFSET ?endl@@ZAAEVostream@@AEV1@@Z	;endl
	*** 001867	1e 			push	ds
	*** 001868	68 00 00 		push	OFFSET DGROUP:$SG3833
	*** 00186b	68 00 00 		push	SEG ?cout@@3Vostream_withassign@@E	;cout
	*** 00186e	68 00 00 		push	OFFSET ?cout@@3Vostream_withassign@@E	;cout
	*** 001871	9a 00 00 00 00 		call	FAR PTR ??6ostream@@RECAEV0@PFD@Z	; ostream::operator<<
	*** 001876	52 			push	dx
	*** 001877	50 			push	ax
	*** 001878	9a 00 00 00 00 		call	FAR PTR ??6ostream@@RECAEV0@P7AAEV0@AEV0@@Z@Z	; ostream::operator<<
;|***   else
; Line 1279
	*** 00187d	e9 21 00 		jmp	$I3834
					$I3832:
;|***     {
; Line 1280
;|***     cout << "Channel A Transparent Mode not set!  Channel not open!" << endl;
; Line 1281
	*** 001880	68 00 00 		push	SEG ?endl@@ZAAEVostream@@AEV1@@Z	;endl
	*** 001883	68 00 00 		push	OFFSET ?endl@@ZAAEVostream@@AEV1@@Z	;endl
	*** 001886	1e 			push	ds
	*** 001887	68 00 00 		push	OFFSET DGROUP:$SG3835
	*** 00188a	68 00 00 		push	SEG ?cout@@3Vostream_withassign@@E	;cout
	*** 00188d	68 00 00 		push	OFFSET ?cout@@3Vostream_withassign@@E	;cout
	*** 001890	9a 00 00 00 00 		call	FAR PTR ??6ostream@@RECAEV0@PFD@Z	; ostream::operator<<
	*** 001895	52 			push	dx
	*** 001896	50 			push	ax
	*** 001897	9a 00 00 00 00 		call	FAR PTR ??6ostream@@RECAEV0@P7AAEV0@AEV0@@Z@Z	; ostream::operator<<
;|***     terminate();
; Line 1282
	*** 00189c	9a 00 00 00 00 		call	FAR PTR ?terminate@@ZAXXZ	; terminate
;|***     }
; Line 1283
					$I3834:
;|*** 
;|***   // Channel b will run off the escc internal oscillator, so must first
;|***   // configure the escc frequency generator to produce a 9.8304 MHz clock signal
;|***   // from the onboard 18.432 MHz TTL oscillator.  The 9.8304 MHz clock is 
;|***   // then divided by 128 to be used as the master clock for the 76.8 KHz pcm data stream
;|***   //
;|***   // See escc.cpp, Cypress ICD2053B datasheet and BitCalc software
;|***   // available at the Cypress Web site to calculate the clock scaling factor
;|***   // to be loaded into the clock generator.
;|***   //
;|***   // void Cescc::set_clock_generator(unsigned port,     //either channel A or B will work
;|***   //                                 unsigned long hval,//stuffed hex value from BitCalc
;|***   //                                 unsigned nmbits)   //number of bits in stuffed value
;|***   //escc1.set_clock_generator(channela, 0x5d31c0L, 0x18);  // old decom
;|***   
;|***   // new 2.4576 MHz clock for 19.2 KHz PCM bit rate 12/19/2007 jtm
;|***   escc1.set_clock_generator(channela, 0x5d51c0L, 24);      // new decom
; Line 1300
	*** 0018a1	ff 36 00 00 		push	WORD PTR ?channela@@3IE	;channela
	*** 0018a5	6a 5d 			push	93	;005dH
	*** 0018a7	68 c0 51 		push	20928	;51c0H
	*** 0018aa	6a 18 			push	24	;0018H
	*** 0018ac	68 00 00 		push	SEG ?escc1@@3VCescc@@E	;escc1
	*** 0018af	68 00 00 		push	OFFSET ?escc1@@3VCescc@@E	;escc1
	*** 0018b2	9a 00 00 00 00 		call	FAR PTR ?set_clock_generator@Cescc@@RECXIKI@Z	; Cescc::set_clock_generator
;|***   
;|***   
;|***   // Configure channel_b for biphase-m operation for pcm telemetry.
;|***   // see Siemens SAB 82532 ESCC User's Manual page 110 for register descriptions.
;|***   settings.mode = 0xC8;  // extended transparent mode 0, rcvr active, extern timer k=32768
; Line 1305
	*** 0018b7	8e 06 00 00 		mov	es,WORD PTR $T4111
	*** 0018bb	26 c7 06 02 00 c8 00 	mov	WORD PTR es:?settings@@3Uescc_regs@@E+2,200	;00c8H	;settings
;|***   settings.timr = 0xe2;  // cnt=7, value=2, continuous 100 Hz interrupts when tcp=1/9.8304MHz
; Line 1306
	*** 0018c2	26 c7 06 04 00 e2 00 	mov	WORD PTR es:?settings@@3Uescc_regs@@E+4,226	;00e2H	;settings
;|***   settings.xbcl = 0x00;  // set up by setupdmat() when transmission is started
; Line 1307
	*** 0018c9	26 c7 06 06 00 00 00 	mov	WORD PTR es:?settings@@3Uescc_regs@@E+6,0	;settings
;|***   settings.xbch = 0x80;  // dma data transfer mode
; Line 1308
	*** 0018d0	26 c7 06 08 00 80 00 	mov	WORD PTR es:?settings@@3Uescc_regs@@E+8,128	;0080H	;settings
;|***   
;|***   // Note:  ESCC User's manual p 92/129 has switched FM0 & FM1?  Actually FM0=101, FM1=100 ?
;|***   settings.ccr0 = 0xD0;  // power-up, master clk=xtal, FM1(biphase-m), hdlc/sdlc
; Line 1311
	*** 0018d7	26 c7 06 0a 00 d0 00 	mov	WORD PTR es:?settings@@3Uescc_regs@@E+10,208	;00d0H	;settings
;|***   settings.ccr1 = 0x17;  // set txd push-pull, set clk mode 7b
; Line 1312
	*** 0018de	26 c7 06 0c 00 17 00 	mov	WORD PTR es:?settings@@3Uescc_regs@@E+12,23	;0017H	;settings
;|***   settings.ccr2 = 0x38;  // br9&8=0, bdf=1, ssel=1, toe=1, rwx=0, crc-ccitt, no inversion
; Line 1313
	*** 0018e5	26 c7 06 0e 00 38 00 	mov	WORD PTR es:?settings@@3Uescc_regs@@E+14,56	;0038H	;settings
;|***   settings.ccr3 = 0x02;  // no preamble, radd=0, crl=0, rcrc=off, xcrc=off, psd=na
; Line 1314
	*** 0018ec	26 c7 06 10 00 02 00 	mov	WORD PTR es:?settings@@3Uescc_regs@@E+16,2	;settings
;|***   settings.ccr4 = 0x00;  // added to implement MCK4 and EBRG, but not used
; Line 1315
	*** 0018f3	26 c7 06 12 00 00 00 	mov	WORD PTR es:?settings@@3Uescc_regs@@E+18,0	;settings
;|***   settings.bgr  = 0x3f;  // brg divisor=63 (0x3F), 76.8 KHz = 9.8304 MHz /((63+1)*2)
; Line 1316
	*** 0018fa	26 c7 06 14 00 3f 00 	mov	WORD PTR es:?settings@@3Uescc_regs@@E+20,63	;003fH	;settings
;|***   settings.iva  = 0x00;  // not set here
; Line 1317
	*** 001901	26 c7 06 16 00 00 00 	mov	WORD PTR es:?settings@@3Uescc_regs@@E+22,0	;settings
;|***   settings.ipc  = 0x03;  // masked interrupts not visible, pin INT = push/pull active high
; Line 1318
	*** 001908	26 c7 06 18 00 03 00 	mov	WORD PTR es:?settings@@3Uescc_regs@@E+24,3	;settings
;|***   settings.imr0 = 0x00;  // all interrupts enabled
; Line 1319
	*** 00190f	26 c7 06 1a 00 00 00 	mov	WORD PTR es:?settings@@3Uescc_regs@@E+26,0	;settings
;|***   settings.imr1 = 0x00;  // all interrupts enabled
; Line 1320
	*** 001916	26 c7 06 1c 00 00 00 	mov	WORD PTR es:?settings@@3Uescc_regs@@E+28,0	;settings
;|***   settings.pvr  = 0x00;  
; Line 1321
	*** 00191d	26 c7 06 1e 00 00 00 	mov	WORD PTR es:?settings@@3Uescc_regs@@E+30,0	;settings
;|***   settings.pim  = 0xff;
; Line 1322
	*** 001924	26 c7 06 20 00 ff 00 	mov	WORD PTR es:?settings@@3Uescc_regs@@E+32,255	;00ffH	;settings
;|***   settings.pcr  = 0xe0;
; Line 1323
	*** 00192b	26 c7 06 22 00 e0 00 	mov	WORD PTR es:?settings@@3Uescc_regs@@E+34,224	;00e0H	;settings
;|***   settings.xad1 = 0xff;
; Line 1324
	*** 001932	26 c7 06 24 00 ff 00 	mov	WORD PTR es:?settings@@3Uescc_regs@@E+36,255	;00ffH	;settings
;|***   settings.xad2 = 0xff;
; Line 1325
	*** 001939	26 c7 06 26 00 ff 00 	mov	WORD PTR es:?settings@@3Uescc_regs@@E+38,255	;00ffH	;settings
;|***   settings.rah1 = 0xff;
; Line 1326
	*** 001940	26 c7 06 28 00 ff 00 	mov	WORD PTR es:?settings@@3Uescc_regs@@E+40,255	;00ffH	;settings
;|***   settings.rah2 = 0xff;
; Line 1327
	*** 001947	26 c7 06 2a 00 ff 00 	mov	WORD PTR es:?settings@@3Uescc_regs@@E+42,255	;00ffH	;settings
;|***   settings.ral1 = 0xff;
; Line 1328
	*** 00194e	26 c7 06 2c 00 ff 00 	mov	WORD PTR es:?settings@@3Uescc_regs@@E+44,255	;00ffH	;settings
;|***   settings.ral2 = 0xff;
; Line 1329
	*** 001955	26 c7 06 2e 00 ff 00 	mov	WORD PTR es:?settings@@3Uescc_regs@@E+46,255	;00ffH	;settings
;|***   settings.rlcr = 0x00;
; Line 1330
	*** 00195c	26 c7 06 30 00 00 00 	mov	WORD PTR es:?settings@@3Uescc_regs@@E+48,0	;settings
;|***   settings.pre  = 0x00;
; Line 1331
	*** 001963	26 c7 06 32 00 00 00 	mov	WORD PTR es:?settings@@3Uescc_regs@@E+50,0	;settings
;|***   
;|***   //Write configuration to channelb registers
;|***   //Parameters: (port to intialize,
;|***   //             operating mode,
;|***   //             settings defined above,
;|***   //             number of receive buffers,
;|***   //             number of transmit buffers)
;|***   if(escc1.init_port(channelb,OPMODE_HDLC,&settings,MAX_RBUFS,MAX_TBUFS)==TRUE)
; Line 1339
	*** 00196a	ff 36 00 00 		push	WORD PTR ?channelb@@3IE	;channelb
	*** 00196e	6a 00 			push	0
	*** 001970	06 			push	es
	*** 001971	68 00 00 		push	OFFSET ?settings@@3Uescc_regs@@E	;settings
	*** 001974	6a 10 			push	16	;0010H
	*** 001976	6a 10 			push	16	;0010H
	*** 001978	68 00 00 		push	SEG ?escc1@@3VCescc@@E	;escc1
	*** 00197b	68 00 00 		push	OFFSET ?escc1@@3VCescc@@E	;escc1
	*** 00197e	9a 00 00 00 00 		call	FAR PTR ?init_port@Cescc@@RECIIIPEUescc_regs@@II@Z	; Cescc::init_port
	*** 001983	3d 00 00 		cmp	ax,0
	*** 001986	74 03 			je	$JCC6534
	*** 001988	e9 1f 00 		jmp	$I3836
					$JCC6534:
;|***     cout << "Intialize Channel B OK." << endl;
; Line 1340
	*** 00198b	68 00 00 		push	SEG ?endl@@ZAAEVostream@@AEV1@@Z	;endl
	*** 00198e	68 00 00 		push	OFFSET ?endl@@ZAAEVostream@@AEV1@@Z	;endl
	*** 001991	1e 			push	ds
	*** 001992	68 00 00 		push	OFFSET DGROUP:$SG3837
	*** 001995	68 00 00 		push	SEG ?cout@@3Vostream_withassign@@E	;cout
	*** 001998	68 00 00 		push	OFFSET ?cout@@3Vostream_withassign@@E	;cout
	*** 00199b	9a 00 00 00 00 		call	FAR PTR ??6ostream@@RECAEV0@PFD@Z	; ostream::operator<<
	*** 0019a0	52 			push	dx
	*** 0019a1	50 			push	ax
	*** 0019a2	9a 00 00 00 00 		call	FAR PTR ??6ostream@@RECAEV0@P7AAEV0@AEV0@@Z@Z	; ostream::operator<<
;|***   else
; Line 1341
	*** 0019a7	e9 21 00 		jmp	$I3838
					$I3836:
;|***     {
; Line 1342
;|***     cout << "Initialize Channel B FAILED!" << endl;
; Line 1343
	*** 0019aa	68 00 00 		push	SEG ?endl@@ZAAEVostream@@AEV1@@Z	;endl
	*** 0019ad	68 00 00 		push	OFFSET ?endl@@ZAAEVostream@@AEV1@@Z	;endl
	*** 0019b0	1e 			push	ds
	*** 0019b1	68 00 00 		push	OFFSET DGROUP:$SG3839
	*** 0019b4	68 00 00 		push	SEG ?cout@@3Vostream_withassign@@E	;cout
	*** 0019b7	68 00 00 		push	OFFSET ?cout@@3Vostream_withassign@@E	;cout
	*** 0019ba	9a 00 00 00 00 		call	FAR PTR ??6ostream@@RECAEV0@PFD@Z	; ostream::operator<<
	*** 0019bf	52 			push	dx
	*** 0019c0	50 			push	ax
	*** 0019c1	9a 00 00 00 00 		call	FAR PTR ??6ostream@@RECAEV0@P7AAEV0@AEV0@@Z@Z	; ostream::operator<<
;|***     terminate();
; Line 1344
	*** 0019c6	9a 00 00 00 00 		call	FAR PTR ?terminate@@ZAXXZ	; terminate
;|***     }
; Line 1345
					$I3838:
;|***   
;|***   // test channelb to make sure it opened
;|***   if(escc1.clear_rx_buffer(channelb)==TRUE)
; Line 1348
	*** 0019cb	ff 36 00 00 		push	WORD PTR ?channelb@@3IE	;channelb
	*** 0019cf	68 00 00 		push	SEG ?escc1@@3VCescc@@E	;escc1
	*** 0019d2	68 00 00 		push	OFFSET ?escc1@@3VCescc@@E	;escc1
	*** 0019d5	9a 00 00 00 00 		call	FAR PTR ?clear_rx_buffer@Cescc@@RECII@Z	; Cescc::clear_rx_buffer
	*** 0019da	3d 00 00 		cmp	ax,0
	*** 0019dd	74 03 			je	$JCC6621
	*** 0019df	e9 1f 00 		jmp	$I3840
					$JCC6621:
;|***     cout << "Channel B rx buffer cleared OK.  " << endl;
; Line 1349
	*** 0019e2	68 00 00 		push	SEG ?endl@@ZAAEVostream@@AEV1@@Z	;endl
	*** 0019e5	68 00 00 		push	OFFSET ?endl@@ZAAEVostream@@AEV1@@Z	;endl
	*** 0019e8	1e 			push	ds
	*** 0019e9	68 00 00 		push	OFFSET DGROUP:$SG3841
	*** 0019ec	68 00 00 		push	SEG ?cout@@3Vostream_withassign@@E	;cout
	*** 0019ef	68 00 00 		push	OFFSET ?cout@@3Vostream_withassign@@E	;cout
	*** 0019f2	9a 00 00 00 00 		call	FAR PTR ??6ostream@@RECAEV0@PFD@Z	; ostream::operator<<
	*** 0019f7	52 			push	dx
	*** 0019f8	50 			push	ax
	*** 0019f9	9a 00 00 00 00 		call	FAR PTR ??6ostream@@RECAEV0@P7AAEV0@AEV0@@Z@Z	; ostream::operator<<
;|***   else
; Line 1350
	*** 0019fe	e9 21 00 		jmp	$I3842
					$I3840:
;|***     {
; Line 1351
;|***     cout << "Channel B rx buffer clear FAILED!" << endl;
; Line 1352
	*** 001a01	68 00 00 		push	SEG ?endl@@ZAAEVostream@@AEV1@@Z	;endl
	*** 001a04	68 00 00 		push	OFFSET ?endl@@ZAAEVostream@@AEV1@@Z	;endl
	*** 001a07	1e 			push	ds
	*** 001a08	68 00 00 		push	OFFSET DGROUP:$SG3843
	*** 001a0b	68 00 00 		push	SEG ?cout@@3Vostream_withassign@@E	;cout
	*** 001a0e	68 00 00 		push	OFFSET ?cout@@3Vostream_withassign@@E	;cout
	*** 001a11	9a 00 00 00 00 		call	FAR PTR ??6ostream@@RECAEV0@PFD@Z	; ostream::operator<<
	*** 001a16	52 			push	dx
	*** 001a17	50 			push	ax
	*** 001a18	9a 00 00 00 00 		call	FAR PTR ??6ostream@@RECAEV0@P7AAEV0@AEV0@@Z@Z	; ostream::operator<<
;|***     terminate();
; Line 1353
	*** 001a1d	9a 00 00 00 00 		call	FAR PTR ?terminate@@ZAXXZ	; terminate
;|***     }
; Line 1354
					$I3842:
;|***   
;|***   if(escc1.clear_tx_buffer(channelb)==TRUE)
; Line 1356
	*** 001a22	ff 36 00 00 		push	WORD PTR ?channelb@@3IE	;channelb
	*** 001a26	68 00 00 		push	SEG ?escc1@@3VCescc@@E	;escc1
	*** 001a29	68 00 00 		push	OFFSET ?escc1@@3VCescc@@E	;escc1
	*** 001a2c	9a 00 00 00 00 		call	FAR PTR ?clear_tx_buffer@Cescc@@RECII@Z	; Cescc::clear_tx_buffer
	*** 001a31	3d 00 00 		cmp	ax,0
	*** 001a34	74 03 			je	$JCC6708
	*** 001a36	e9 1f 00 		jmp	$I3844
					$JCC6708:
;|***     cout << "Channel B tx buffer cleared OK." << endl;
; Line 1357
	*** 001a39	68 00 00 		push	SEG ?endl@@ZAAEVostream@@AEV1@@Z	;endl
	*** 001a3c	68 00 00 		push	OFFSET ?endl@@ZAAEVostream@@AEV1@@Z	;endl
	*** 001a3f	1e 			push	ds
	*** 001a40	68 00 00 		push	OFFSET DGROUP:$SG3845
	*** 001a43	68 00 00 		push	SEG ?cout@@3Vostream_withassign@@E	;cout
	*** 001a46	68 00 00 		push	OFFSET ?cout@@3Vostream_withassign@@E	;cout
	*** 001a49	9a 00 00 00 00 		call	FAR PTR ??6ostream@@RECAEV0@PFD@Z	; ostream::operator<<
	*** 001a4e	52 			push	dx
	*** 001a4f	50 			push	ax
	*** 001a50	9a 00 00 00 00 		call	FAR PTR ??6ostream@@RECAEV0@P7AAEV0@AEV0@@Z@Z	; ostream::operator<<
;|***   else
; Line 1358
	*** 001a55	e9 21 00 		jmp	$I3846
					$I3844:
;|***     {
; Line 1359
;|***     cout << "Channel B tx buffer clear FAILED!" << endl;
; Line 1360
	*** 001a58	68 00 00 		push	SEG ?endl@@ZAAEVostream@@AEV1@@Z	;endl
	*** 001a5b	68 00 00 		push	OFFSET ?endl@@ZAAEVostream@@AEV1@@Z	;endl
	*** 001a5e	1e 			push	ds
	*** 001a5f	68 00 00 		push	OFFSET DGROUP:$SG3847
	*** 001a62	68 00 00 		push	SEG ?cout@@3Vostream_withassign@@E	;cout
	*** 001a65	68 00 00 		push	OFFSET ?cout@@3Vostream_withassign@@E	;cout
	*** 001a68	9a 00 00 00 00 		call	FAR PTR ??6ostream@@RECAEV0@PFD@Z	; ostream::operator<<
	*** 001a6d	52 			push	dx
	*** 001a6e	50 			push	ax
	*** 001a6f	9a 00 00 00 00 		call	FAR PTR ??6ostream@@RECAEV0@P7AAEV0@AEV0@@Z@Z	; ostream::operator<<
;|***     terminate();
; Line 1361
	*** 001a74	9a 00 00 00 00 		call	FAR PTR ?terminate@@ZAXXZ	; terminate
;|***     }
; Line 1362
					$I3846:
;|***   
;|***   //set channelb frame transmission type
;|***   if(escc1.set_tx_type(channelb, TRANSPARENT_MODE)==TRUE)
; Line 1365
	*** 001a79	ff 36 00 00 		push	WORD PTR ?channelb@@3IE	;channelb
	*** 001a7d	6a 01 			push	1
	*** 001a7f	68 00 00 		push	SEG ?escc1@@3VCescc@@E	;escc1
	*** 001a82	68 00 00 		push	OFFSET ?escc1@@3VCescc@@E	;escc1
	*** 001a85	9a 00 00 00 00 		call	FAR PTR ?set_tx_type@Cescc@@RECIII@Z	; Cescc::set_tx_type
	*** 001a8a	3d 00 00 		cmp	ax,0
	*** 001a8d	74 03 			je	$JCC6797
	*** 001a8f	e9 1f 00 		jmp	$I3848
					$JCC6797:
;|***     cout << "Channel B set to Transparent Mode.  " << endl;
; Line 1366
	*** 001a92	68 00 00 		push	SEG ?endl@@ZAAEVostream@@AEV1@@Z	;endl
	*** 001a95	68 00 00 		push	OFFSET ?endl@@ZAAEVostream@@AEV1@@Z	;endl
	*** 001a98	1e 			push	ds
	*** 001a99	68 00 00 		push	OFFSET DGROUP:$SG3849
	*** 001a9c	68 00 00 		push	SEG ?cout@@3Vostream_withassign@@E	;cout
	*** 001a9f	68 00 00 		push	OFFSET ?cout@@3Vostream_withassign@@E	;cout
	*** 001aa2	9a 00 00 00 00 		call	FAR PTR ??6ostream@@RECAEV0@PFD@Z	; ostream::operator<<
	*** 001aa7	52 			push	dx
	*** 001aa8	50 			push	ax
	*** 001aa9	9a 00 00 00 00 		call	FAR PTR ??6ostream@@RECAEV0@P7AAEV0@AEV0@@Z@Z	; ostream::operator<<
;|***   else
; Line 1367
	*** 001aae	e9 21 00 		jmp	$I3850
					$I3848:
;|***     {
; Line 1368
;|***     cout << "Channel B Transparent Mode not set!  Channel not open!" << endl;
; Line 1369
	*** 001ab1	68 00 00 		push	SEG ?endl@@ZAAEVostream@@AEV1@@Z	;endl
	*** 001ab4	68 00 00 		push	OFFSET ?endl@@ZAAEVostream@@AEV1@@Z	;endl
	*** 001ab7	1e 			push	ds
	*** 001ab8	68 00 00 		push	OFFSET DGROUP:$SG3851
	*** 001abb	68 00 00 		push	SEG ?cout@@3Vostream_withassign@@E	;cout
	*** 001abe	68 00 00 		push	OFFSET ?cout@@3Vostream_withassign@@E	;cout
	*** 001ac1	9a 00 00 00 00 		call	FAR PTR ??6ostream@@RECAEV0@PFD@Z	; ostream::operator<<
	*** 001ac6	52 			push	dx
	*** 001ac7	50 			push	ax
	*** 001ac8	9a 00 00 00 00 		call	FAR PTR ??6ostream@@RECAEV0@P7AAEV0@AEV0@@Z@Z	; ostream::operator<<
;|***     terminate();
; Line 1370
	*** 001acd	9a 00 00 00 00 		call	FAR PTR ?terminate@@ZAXXZ	; terminate
;|***     }
; Line 1371
					$I3850:
;|***   }
; Line 1372
	*** 001ad2	e9 00 00 		jmp	$EX3816
					$EX3816:
	*** 001ad5	5e 			pop	si
	*** 001ad6	5f 			pop	di
	*** 001ad7	c9 			leave	
	*** 001ad8	cb 			ret	

?configure_escc@@ZAXXZ	ENDP
	PUBLIC	?wait_for_time_tick@@ZAXXZ	; wait_for_time_tick
?wait_for_time_tick@@ZAXXZ	PROC FAR	; wait_for_time_tick
;|*** 
;|*** 
;|*** 
;|***   
;|*** void wait_for_time_tick(void)
;|***   {
; Line 1378
	*** 001ad9	c8 02 00 00 		enter	2,0
	*** 001add	57 			push	di
	*** 001ade	56 			push	si
;	pcm_lockup = -2
;|***   static unsigned toggle = 0;
;|***   unsigned pcm_lockup = 1;
; Line 1380
	*** 001adf	c7 46 fe 01 00 		mov	WORD PTR [bp-2],1	;pcm_lockup
;|***   
;|***   pcm_sent = 0;                          // residual crap, does nothing
; Line 1382
	*** 001ae4	c7 06 00 00 00 00 	mov	WORD PTR ?pcm_sent@@3IE,0	;pcm_sent
;|***     
;|***   while(frame < next_frame)              // idle loop waits until beginning of next frame
; Line 1384
					$FC3858:
	*** 001aea	a1 00 00 		mov	ax,WORD PTR ?frame@@3KE	;frame
	*** 001aed	8b 16 02 00 		mov	dx,WORD PTR ?frame@@3KE+2	;frame
	*** 001af1	39 16 02 00 		cmp	WORD PTR ?next_frame@@3KE+2,dx	;next_frame
	*** 001af5	73 03 			jae	$JCC6901
	*** 001af7	e9 4b 00 		jmp	$FB3859
					$JCC6901:
	*** 001afa	76 03 			jbe	$JCC6906
	*** 001afc	e9 09 00 		jmp	$L4114
					$JCC6906:
	*** 001aff	39 06 00 00 		cmp	WORD PTR ?next_frame@@3KE,ax	;next_frame
	*** 001b03	77 03 			ja	$JCC6915
	*** 001b05	e9 3d 00 		jmp	$FB3859
					$JCC6915:
					$L4114:
;|***     {                                    // frame is incremented in dmm32a isr by 100 Hz timer
; Line 1385
;|***     if(data_ready)
; Line 1386
	*** 001b08	83 3e 00 00 00 		cmp	WORD PTR ?data_ready@@3IE,0	;data_ready
	*** 001b0d	75 03 			jne	$JCC6925
	*** 001b0f	e9 0b 00 		jmp	$I3860
					$JCC6925:
;|***       {                                  // wait until adc's are done before querying the ln200
; Line 1387
;|***       data_ready = 0;
; Line 1388
	*** 001b12	c7 06 00 00 00 00 	mov	WORD PTR ?data_ready@@3IE,0	;data_ready
;|***       query_ln200();
; Line 1389
	*** 001b18	9a 00 00 00 00 		call	FAR PTR ?query_ln200@@ZAXXZ	; query_ln200
;|***       }
; Line 1390
;|***     if(escc1.istxing[channelb]==0)
; Line 1391
					$I3860:
	*** 001b1d	8e 06 00 00 		mov	es,WORD PTR $T4111
	*** 001b21	8b 1e 00 00 		mov	bx,WORD PTR ?channelb@@3IE	;channelb
	*** 001b25	d1 e3 			shl	bx,1
	*** 001b27	26 83 bf 92 01 00 	cmp	WORD PTR es:?escc1@@3VCescc@@E[bx+402],0	;escc1
	*** 001b2d	74 03 			je	$JCC6957
	*** 001b2f	e9 10 00 		jmp	$I3861
					$JCC6957:
;|***       {
; Line 1392
;|***       pcm_sent = 0;
; Line 1393
	*** 001b32	c7 06 00 00 00 00 	mov	WORD PTR ?pcm_sent@@3IE,0	;pcm_sent
;|***       send_pcm();
; Line 1394
	*** 001b38	9a 00 00 00 00 		call	FAR PTR ?send_pcm@@ZAXXZ	; send_pcm
;|***       pcm_lockup = 0;
; Line 1395
	*** 001b3d	c7 46 fe 00 00 		mov	WORD PTR [bp-2],0	;pcm_lockup
;|***       }  
; Line 1396
;|***     }
; Line 1397
					$I3861:
	*** 001b42	e9 a5 ff 		jmp	$FC3858
DMMTEST_TEXT      ENDS
CONST      SEGMENT
$T4115	DQ	03f768003999a2d0er    ;	5.493177473577816E-03
CONST      ENDS
DMMTEST_TEXT      SEGMENT
	ASSUME	CS: DMMTEST_TEXT
					$FB3859:
;|***   
;|***   //if(pcm_lockup) escc1.clear_tx_buffer(channelb);
;|***     
;|*** /*  // new decom    
;|***     if(frame%10 == 0)                    // send pcm message every tenth frame for new decom
;|***       {
;|***       if(escc1.istxing[channelb]==0)     // make sure last pcm message went out 
;|***         {
;|***         pcm_sent = 0;
;|***         send_pcm();
;|***         pcm_lockup = 0;
;|***         }  
;|***       if(pcm_lockup)
;|***         {
;|***         escc1.clear_tx_buffer(channelb);  
;|***         pcm_sent = 0;
;|***         send_pcm();
;|***         }
;|***       }
;|***     }
;|***   
;|*** */  
;|***     
;|***   sprintf(s, "Pitch:   %04x  %10.2f deg", ln200.data[9], (ln200.data[9] / 182.044));   // Pitch
; Line 1421
	*** 001b45	8e 06 00 00 		mov	es,WORD PTR $T4111
	*** 001b49	bb 1e 00 		mov	bx,OFFSET ?ln200@@3ULN200@@E+30	;ln200
	*** 001b4c	9a 00 00 00 00 		call	FAR PTR __aFeldw
	*** 001b51	9a 00 00 00 00 		call	FAR PTR __aFdcvt
	*** 001b56	bb 00 00 		mov	bx,OFFSET DGROUP:$T4115
	*** 001b59	9a 00 00 00 00 		call	FAR PTR __aFfmuld
	*** 001b5e	83 ec 08 		sub	sp,8
	*** 001b61	8b dc 			mov	bx,sp
	*** 001b63	9a 00 00 00 00 		call	FAR PTR __aFfstdp
	*** 001b68	8e 06 00 00 		mov	es,WORD PTR $T4111
	*** 001b6c	26 ff 36 1e 00 		push	WORD PTR es:?ln200@@3ULN200@@E+30	;ln200
	*** 001b71	1e 			push	ds
	*** 001b72	68 00 00 		push	OFFSET DGROUP:$SG3862
	*** 001b75	1e 			push	ds
	*** 001b76	68 00 00 		push	OFFSET DGROUP:?s@@3QIDI	;s
	*** 001b79	9a 00 00 00 00 		call	FAR PTR _sprintf
	*** 001b7e	83 c4 12 		add	sp,18	;0012H
;|***   PC_DispStr(0,6, (unsigned char *)s, DISP_FGND_BLACK + DISP_BGND_RED);
; Line 1422
	*** 001b81	6a 40 			push	64	;0040H
	*** 001b83	1e 			push	ds
	*** 001b84	68 00 00 		push	OFFSET DGROUP:?s@@3QIDI	;s
	*** 001b87	6a 06 			push	6
	*** 001b89	6a 00 			push	0
	*** 001b8b	9a 00 00 00 00 		call	FAR PTR ?PC_DispStr@@ZAXEEPIEE@Z	; PC_DispStr
	*** 001b90	83 c4 0a 		add	sp,10	;000aH
;|***   sprintf(s, "Roll:    %04x  %10.2f deg", ln200.data[10], (ln200.data[10] / 182.044));  // Roll
; Line 1423
	*** 001b93	8e 06 00 00 		mov	es,WORD PTR $T4111
	*** 001b97	bb 20 00 		mov	bx,OFFSET ?ln200@@3ULN200@@E+32	;ln200
	*** 001b9a	9a 00 00 00 00 		call	FAR PTR __aFeldw
	*** 001b9f	9a 00 00 00 00 		call	FAR PTR __aFdcvt
	*** 001ba4	bb 00 00 		mov	bx,OFFSET DGROUP:$T4115
	*** 001ba7	9a 00 00 00 00 		call	FAR PTR __aFfmuld
	*** 001bac	83 ec 08 		sub	sp,8
	*** 001baf	8b dc 			mov	bx,sp
	*** 001bb1	9a 00 00 00 00 		call	FAR PTR __aFfstdp
	*** 001bb6	8e 06 00 00 		mov	es,WORD PTR $T4111
	*** 001bba	26 ff 36 20 00 		push	WORD PTR es:?ln200@@3ULN200@@E+32	;ln200
	*** 001bbf	1e 			push	ds
	*** 001bc0	68 00 00 		push	OFFSET DGROUP:$SG3864
	*** 001bc3	1e 			push	ds
	*** 001bc4	68 00 00 		push	OFFSET DGROUP:?s@@3QIDI	;s
	*** 001bc7	9a 00 00 00 00 		call	FAR PTR _sprintf
	*** 001bcc	83 c4 12 		add	sp,18	;0012H
;|***   PC_DispStr(0,7, (unsigned char *)s, DISP_FGND_BLACK + DISP_BGND_RED);
; Line 1424
	*** 001bcf	6a 40 			push	64	;0040H
	*** 001bd1	1e 			push	ds
	*** 001bd2	68 00 00 		push	OFFSET DGROUP:?s@@3QIDI	;s
	*** 001bd5	6a 07 			push	7
	*** 001bd7	6a 00 			push	0
	*** 001bd9	9a 00 00 00 00 		call	FAR PTR ?PC_DispStr@@ZAXEEPIEE@Z	; PC_DispStr
	*** 001bde	83 c4 0a 		add	sp,10	;000aH
;|***   sprintf(s, "Heading: %04x  %10.2f deg", ln200.data[11], (ln200.data[11] / 182.044));  // Heading
; Line 1425
	*** 001be1	8e 06 00 00 		mov	es,WORD PTR $T4111
	*** 001be5	bb 22 00 		mov	bx,OFFSET ?ln200@@3ULN200@@E+34	;ln200
	*** 001be8	9a 00 00 00 00 		call	FAR PTR __aFeldw
	*** 001bed	9a 00 00 00 00 		call	FAR PTR __aFdcvt
	*** 001bf2	bb 00 00 		mov	bx,OFFSET DGROUP:$T4115
	*** 001bf5	9a 00 00 00 00 		call	FAR PTR __aFfmuld
	*** 001bfa	83 ec 08 		sub	sp,8
	*** 001bfd	8b dc 			mov	bx,sp
	*** 001bff	9a 00 00 00 00 		call	FAR PTR __aFfstdp
	*** 001c04	8e 06 00 00 		mov	es,WORD PTR $T4111
	*** 001c08	26 ff 36 22 00 		push	WORD PTR es:?ln200@@3ULN200@@E+34	;ln200
	*** 001c0d	1e 			push	ds
	*** 001c0e	68 00 00 		push	OFFSET DGROUP:$SG3866
	*** 001c11	1e 			push	ds
	*** 001c12	68 00 00 		push	OFFSET DGROUP:?s@@3QIDI	;s
	*** 001c15	9a 00 00 00 00 		call	FAR PTR _sprintf
	*** 001c1a	83 c4 12 		add	sp,18	;0012H
;|***   PC_DispStr(0,8, (unsigned char *)s, DISP_FGND_BLACK + DISP_BGND_RED);
; Line 1426
	*** 001c1d	6a 40 			push	64	;0040H
	*** 001c1f	1e 			push	ds
	*** 001c20	68 00 00 		push	OFFSET DGROUP:?s@@3QIDI	;s
	*** 001c23	6a 08 			push	8
	*** 001c25	6a 00 			push	0
	*** 001c27	9a 00 00 00 00 		call	FAR PTR ?PC_DispStr@@ZAXEEPIEE@Z	; PC_DispStr
	*** 001c2c	83 c4 0a 		add	sp,10	;000aH
;|***   
;|***   sprintf(s, "Stern 1: %04x", echo.data[4]);
; Line 1428
	*** 001c2f	8e 06 00 00 		mov	es,WORD PTR $T4111
	*** 001c33	26 a0 10 00 		mov	al,BYTE PTR es:?echo@@3UECHO@@E+16	;echo
	*** 001c37	2a e4 			sub	ah,ah
	*** 001c39	50 			push	ax
	*** 001c3a	1e 			push	ds
	*** 001c3b	68 00 00 		push	OFFSET DGROUP:$SG3868
	*** 001c3e	1e 			push	ds
	*** 001c3f	68 00 00 		push	OFFSET DGROUP:?s@@3QIDI	;s
	*** 001c42	9a 00 00 00 00 		call	FAR PTR _sprintf
	*** 001c47	83 c4 0a 		add	sp,10	;000aH
;|***   PC_DispStr(0,9, (unsigned char *)s, DISP_FGND_BLACK + DISP_BGND_RED);     // Stern 1
; Line 1429
	*** 001c4a	6a 40 			push	64	;0040H
	*** 001c4c	1e 			push	ds
	*** 001c4d	68 00 00 		push	OFFSET DGROUP:?s@@3QIDI	;s
	*** 001c50	6a 09 			push	9
	*** 001c52	6a 00 			push	0
	*** 001c54	9a 00 00 00 00 		call	FAR PTR ?PC_DispStr@@ZAXEEPIEE@Z	; PC_DispStr
	*** 001c59	83 c4 0a 		add	sp,10	;000aH
;|***   sprintf(s, "Stern 2: %04x", echo.data[5]);
; Line 1430
	*** 001c5c	8e 06 00 00 		mov	es,WORD PTR $T4111
	*** 001c60	26 a0 11 00 		mov	al,BYTE PTR es:?echo@@3UECHO@@E+17	;echo
	*** 001c64	2a e4 			sub	ah,ah
	*** 001c66	50 			push	ax
	*** 001c67	1e 			push	ds
	*** 001c68	68 00 00 		push	OFFSET DGROUP:$SG3870
	*** 001c6b	1e 			push	ds
	*** 001c6c	68 00 00 		push	OFFSET DGROUP:?s@@3QIDI	;s
	*** 001c6f	9a 00 00 00 00 		call	FAR PTR _sprintf
	*** 001c74	83 c4 0a 		add	sp,10	;000aH
;|***   PC_DispStr(0,10, (unsigned char *)s, DISP_FGND_BLACK + DISP_BGND_RED);     // Stern 2
; Line 1431
	*** 001c77	6a 40 			push	64	;0040H
	*** 001c79	1e 			push	ds
	*** 001c7a	68 00 00 		push	OFFSET DGROUP:?s@@3QIDI	;s
	*** 001c7d	6a 0a 			push	10	;000aH
	*** 001c7f	6a 00 			push	0
	*** 001c81	9a 00 00 00 00 		call	FAR PTR ?PC_DispStr@@ZAXEEPIEE@Z	; PC_DispStr
	*** 001c86	83 c4 0a 		add	sp,10	;000aH
;|***   sprintf(s, "Rudder:  %04x", echo.data[3]);
; Line 1432
	*** 001c89	8e 06 00 00 		mov	es,WORD PTR $T4111
	*** 001c8d	26 a0 0f 00 		mov	al,BYTE PTR es:?echo@@3UECHO@@E+15	;echo
	*** 001c91	2a e4 			sub	ah,ah
	*** 001c93	50 			push	ax
	*** 001c94	1e 			push	ds
	*** 001c95	68 00 00 		push	OFFSET DGROUP:$SG3872
	*** 001c98	1e 			push	ds
	*** 001c99	68 00 00 		push	OFFSET DGROUP:?s@@3QIDI	;s
	*** 001c9c	9a 00 00 00 00 		call	FAR PTR _sprintf
	*** 001ca1	83 c4 0a 		add	sp,10	;000aH
;|***   PC_DispStr(0,11, (unsigned char *)s, DISP_FGND_BLACK + DISP_BGND_RED);     // Rudder
; Line 1433
	*** 001ca4	6a 40 			push	64	;0040H
	*** 001ca6	1e 			push	ds
	*** 001ca7	68 00 00 		push	OFFSET DGROUP:?s@@3QIDI	;s
	*** 001caa	6a 0b 			push	11	;000bH
	*** 001cac	6a 00 			push	0
	*** 001cae	9a 00 00 00 00 		call	FAR PTR ?PC_DispStr@@ZAXEEPIEE@Z	; PC_DispStr
	*** 001cb3	83 c4 0a 		add	sp,10	;000aH
;|***   sprintf(s, "Fore:    %04x", echo.data[6]);
; Line 1434
	*** 001cb6	8e 06 00 00 		mov	es,WORD PTR $T4111
	*** 001cba	26 a0 12 00 		mov	al,BYTE PTR es:?echo@@3UECHO@@E+18	;echo
	*** 001cbe	2a e4 			sub	ah,ah
	*** 001cc0	50 			push	ax
	*** 001cc1	1e 			push	ds
	*** 001cc2	68 00 00 		push	OFFSET DGROUP:$SG3874
	*** 001cc5	1e 			push	ds
	*** 001cc6	68 00 00 		push	OFFSET DGROUP:?s@@3QIDI	;s
	*** 001cc9	9a 00 00 00 00 		call	FAR PTR _sprintf
	*** 001cce	83 c4 0a 		add	sp,10	;000aH
;|***   PC_DispStr(0,12, (unsigned char *)s, DISP_FGND_BLACK + DISP_BGND_RED);     // Fore
; Line 1435
	*** 001cd1	6a 40 			push	64	;0040H
	*** 001cd3	1e 			push	ds
	*** 001cd4	68 00 00 		push	OFFSET DGROUP:?s@@3QIDI	;s
	*** 001cd7	6a 0c 			push	12	;000cH
	*** 001cd9	6a 00 			push	0
	*** 001cdb	9a 00 00 00 00 		call	FAR PTR ?PC_DispStr@@ZAXEEPIEE@Z	; PC_DispStr
	*** 001ce0	83 c4 0a 		add	sp,10	;000aH
;|***   
;|***   sprintf(s, "RawPos:    %08ld", prop_report);
; Line 1437
	*** 001ce3	ff 36 02 00 		push	WORD PTR ?prop_report@@3JE+2	;prop_report
	*** 001ce7	ff 36 00 00 		push	WORD PTR ?prop_report@@3JE	;prop_report
	*** 001ceb	1e 			push	ds
	*** 001cec	68 00 00 		push	OFFSET DGROUP:$SG3876
	*** 001cef	1e 			push	ds
	*** 001cf0	68 00 00 		push	OFFSET DGROUP:?s@@3QIDI	;s
	*** 001cf3	9a 00 00 00 00 		call	FAR PTR _sprintf
	*** 001cf8	83 c4 0c 		add	sp,12	;000cH
;|***   PC_DispStr(0,13, (unsigned char *)s, DISP_FGND_BLACK + DISP_BGND_RED);     // Prop position
; Line 1438
	*** 001cfb	6a 40 			push	64	;0040H
	*** 001cfd	1e 			push	ds
	*** 001cfe	68 00 00 		push	OFFSET DGROUP:?s@@3QIDI	;s
	*** 001d01	6a 0d 			push	13	;000dH
	*** 001d03	6a 00 			push	0
	*** 001d05	9a 00 00 00 00 		call	FAR PTR ?PC_DispStr@@ZAXEEPIEE@Z	; PC_DispStr
	*** 001d0a	83 c4 0a 		add	sp,10	;000aH
;|***   
;|***   sprintf(s, "RawIndex:    %08ld", index_report);
; Line 1440
	*** 001d0d	ff 36 02 00 		push	WORD PTR ?index_report@@3JE+2	;index_report
	*** 001d11	ff 36 00 00 		push	WORD PTR ?index_report@@3JE	;index_report
	*** 001d15	1e 			push	ds
	*** 001d16	68 00 00 		push	OFFSET DGROUP:$SG3878
	*** 001d19	1e 			push	ds
	*** 001d1a	68 00 00 		push	OFFSET DGROUP:?s@@3QIDI	;s
	*** 001d1d	9a 00 00 00 00 		call	FAR PTR _sprintf
	*** 001d22	83 c4 0c 		add	sp,12	;000cH
;|***   PC_DispStr(0,14, (unsigned char *)s, DISP_FGND_BLACK + DISP_BGND_RED);     // Prop position
; Line 1441
	*** 001d25	6a 40 			push	64	;0040H
	*** 001d27	1e 			push	ds
	*** 001d28	68 00 00 		push	OFFSET DGROUP:?s@@3QIDI	;s
	*** 001d2b	6a 0e 			push	14	;000eH
	*** 001d2d	6a 00 			push	0
	*** 001d2f	9a 00 00 00 00 		call	FAR PTR ?PC_DispStr@@ZAXEEPIEE@Z	; PC_DispStr
	*** 001d34	83 c4 0a 		add	sp,10	;000aH
;|***   
;|***   sprintf(s, "PPos:    %08d", prop.position);
; Line 1443
	*** 001d37	8e 06 00 00 		mov	es,WORD PTR $T4111
	*** 001d3b	26 ff 36 1c 00 		push	WORD PTR es:?prop@@3UPROP@@E+28	;prop
	*** 001d40	26 ff 36 1a 00 		push	WORD PTR es:?prop@@3UPROP@@E+26	;prop
	*** 001d45	1e 			push	ds
	*** 001d46	68 00 00 		push	OFFSET DGROUP:$SG3880
	*** 001d49	1e 			push	ds
	*** 001d4a	68 00 00 		push	OFFSET DGROUP:?s@@3QIDI	;s
	*** 001d4d	9a 00 00 00 00 		call	FAR PTR _sprintf
	*** 001d52	83 c4 0c 		add	sp,12	;000cH
;|***   PC_DispStr(0,15, (unsigned char *)s, DISP_FGND_BLACK + DISP_BGND_RED);     // Prop position
; Line 1444
	*** 001d55	6a 40 			push	64	;0040H
	*** 001d57	1e 			push	ds
	*** 001d58	68 00 00 		push	OFFSET DGROUP:?s@@3QIDI	;s
	*** 001d5b	6a 0f 			push	15	;000fH
	*** 001d5d	6a 00 			push	0
	*** 001d5f	9a 00 00 00 00 		call	FAR PTR ?PC_DispStr@@ZAXEEPIEE@Z	; PC_DispStr
	*** 001d64	83 c4 0a 		add	sp,10	;000aH
;|***     
;|***   next_frame = frame + 1;                
; Line 1446
	*** 001d67	a1 00 00 		mov	ax,WORD PTR ?frame@@3KE	;frame
	*** 001d6a	8b 16 02 00 		mov	dx,WORD PTR ?frame@@3KE+2	;frame
	*** 001d6e	05 01 00 		add	ax,1
	*** 001d71	83 d2 00 		adc	dx,0
	*** 001d74	a3 00 00 		mov	WORD PTR ?next_frame@@3KE,ax	;next_frame
	*** 001d77	89 16 02 00 		mov	WORD PTR ?next_frame@@3KE+2,dx	;next_frame
;|***   
;|***   //clr_bit(48);
;|***   }
; Line 1449
	*** 001d7b	e9 00 00 		jmp	$EX3853
					$EX3853:
	*** 001d7e	5e 			pop	si
	*** 001d7f	5f 			pop	di
	*** 001d80	c9 			leave	
	*** 001d81	cb 			ret	

?wait_for_time_tick@@ZAXXZ	ENDP
	PUBLIC	?start_data_collection@@ZAXXZ	; start_data_collection
?start_data_collection@@ZAXXZ	PROC FAR	; start_data_collection
;|*** 
;|*** 
;|***   
;|*** void start_data_collection(void)  
;|***   {
; Line 1454
	*** 001d82	c8 00 00 00 		enter	0,0
	*** 001d86	57 			push	di
	*** 001d87	56 			push	si
;|***   trigger_dmm32a();
; Line 1455
	*** 001d88	9a 00 00 00 00 		call	FAR PTR ?trigger_dmm32a@@ZAXXZ	; trigger_dmm32a
;|***   trigger_dmm32b();
; Line 1456
	*** 001d8d	9a 00 00 00 00 		call	FAR PTR ?trigger_dmm32b@@ZAXXZ	; trigger_dmm32b
;|***   }
; Line 1457
	*** 001d92	e9 00 00 		jmp	$EX3883
					$EX3883:
	*** 001d95	5e 			pop	si
	*** 001d96	5f 			pop	di
	*** 001d97	c9 			leave	
	*** 001d98	cb 			ret	

?start_data_collection@@ZAXXZ	ENDP
	PUBLIC	?query_ln200@@ZAXXZ	; query_ln200
?query_ln200@@ZAXXZ	PROC FAR	; query_ln200
;|*** 
;|*** 
;|*** void query_ln200(void)
;|***   {
; Line 1461
	*** 001d99	c8 00 00 00 		enter	0,0
	*** 001d9d	57 			push	di
	*** 001d9e	56 			push	si
;|***   prep_ln200_command();                        // build the ln200 initialization command
; Line 1462
	*** 001d9f	9a 00 00 00 00 		call	FAR PTR ?prep_ln200_command@@ZAXXZ	; prep_ln200_command
;|***   escc1.tx_port(channela, ln200_command, 14);  // and send it to the ln200
; Line 1463
	*** 001da4	ff 36 00 00 		push	WORD PTR ?channela@@3IE	;channela
	*** 001da8	1e 			push	ds
	*** 001da9	68 00 00 		push	OFFSET DGROUP:?ln200_command@@3QIDI	;ln200_command
	*** 001dac	6a 0e 			push	14	;000eH
	*** 001dae	68 00 00 		push	SEG ?escc1@@3VCescc@@E	;escc1
	*** 001db1	68 00 00 		push	OFFSET ?escc1@@3VCescc@@E	;escc1
	*** 001db4	9a 00 00 00 00 		call	FAR PTR ?tx_port@Cescc@@RECIIPEDI@Z	; Cescc::tx_port
;|***   }
; Line 1464
	*** 001db9	e9 00 00 		jmp	$EX3885
					$EX3885:
	*** 001dbc	5e 			pop	si
	*** 001dbd	5f 			pop	di
	*** 001dbe	c9 			leave	
	*** 001dbf	cb 			ret	

?query_ln200@@ZAXXZ	ENDP
	PUBLIC	?configure_dmm32a@@ZAXXZ	; configure_dmm32a
?configure_dmm32a@@ZAXXZ	PROC FAR	; configure_dmm32a
;|***   
;|*** 
;|*** void configure_dmm32a(void)
;|***   { //io = 0x340, irq=11, top board, reads the two banks of 5B modules
; Line 1468
	*** 001dc0	c8 00 00 00 		enter	0,0
	*** 001dc4	57 			push	di
	*** 001dc5	56 			push	si
;|***   _disable();
; Line 1469
	*** 001dc6	9a 00 00 00 00 		call	FAR PTR __disable
;|***   _outp(OBS_BASE+FCR, FIFORST);                   // reset the fifo
; Line 1470
	*** 001dcb	6a 02 			push	2
	*** 001dcd	68 47 03 		push	839	;0347H
	*** 001dd0	9a 00 00 00 00 		call	FAR PTR __outp
	*** 001dd5	83 c4 04 		add	sp,4
;|*** 
;|***   _outp(OBS_BASE+MCR, PAGE1);                     // set dio ports for outputs, mode0
; Line 1472
	*** 001dd8	6a 01 			push	1
	*** 001dda	68 48 03 		push	840	;0348H
	*** 001ddd	9a 00 00 00 00 		call	FAR PTR __outp
	*** 001de2	83 c4 04 		add	sp,4
;|***   _outp(OBS_BASE+15,  0x80);
; Line 1473
	*** 001de5	68 80 00 		push	128	;0080H
	*** 001de8	68 4f 03 		push	847	;034fH
	*** 001deb	9a 00 00 00 00 		call	FAR PTR __outp
	*** 001df0	83 c4 04 		add	sp,4
;|***   _outp(OBS_BASE+MCR, PAGE0);
; Line 1474
	*** 001df3	6a 00 			push	0
	*** 001df5	68 48 03 		push	840	;0348H
	*** 001df8	9a 00 00 00 00 		call	FAR PTR __outp
	*** 001dfd	83 c4 04 		add	sp,4
;|*** 
;|***   _outp(OBS_BASE+LCR,  0);                         // set the range of channels to scan
; Line 1476
	*** 001e00	6a 00 			push	0
	*** 001e02	68 42 03 		push	834	;0342H
	*** 001e05	9a 00 00 00 00 		call	FAR PTR __outp
	*** 001e0a	83 c4 04 		add	sp,4
;|***   _outp(OBS_BASE+HCR,  31);                        // all channels for the 2 5B module backplanes
; Line 1477
	*** 001e0d	6a 1f 			push	31	;001fH
	*** 001e0f	68 43 03 		push	835	;0343H
	*** 001e12	9a 00 00 00 00 		call	FAR PTR __outp
	*** 001e17	83 c4 04 		add	sp,4
;|***   _outp(OBS_BASE+FCR, SCANEN);                     // enable scan interrupts
; Line 1478
	*** 001e1a	6a 04 			push	4
	*** 001e1c	68 47 03 		push	839	;0347H
	*** 001e1f	9a 00 00 00 00 		call	FAR PTR __outp
	*** 001e24	83 c4 04 		add	sp,4
;|***   _outp(OBS_BASE+ACR, KHZ200 | BIPOLAR5 | GAIN1);  // 200KHz scans, +-5Volt inputs
; Line 1479
	*** 001e27	6a 30 			push	48	;0030H
	*** 001e29	68 4b 03 		push	843	;034bH
	*** 001e2c	9a 00 00 00 00 		call	FAR PTR __outp
	*** 001e31	83 c4 04 		add	sp,4
;|***   while(_inp(OBS_BASE+ARR) & WAIT);                // wait for the adc circuits to settle
; Line 1480
					$FC3889:
	*** 001e34	68 4b 03 		push	843	;034bH
	*** 001e37	9a 00 00 00 00 		call	FAR PTR __inp
	*** 001e3c	83 c4 02 		add	sp,2
	*** 001e3f	a8 80 			test	al,128	;0080H
	*** 001e41	75 03 			jne	$JCC7745
	*** 001e43	e9 03 00 		jmp	$FB3890
					$JCC7745:
	*** 001e46	e9 eb ff 		jmp	$FC3889
					$FB3890:
;|*** 
;|***   _outp(OBS_BASE+MCR, PAGE2);                      // configure ctc0 for falling edge trigger
; Line 1482
	*** 001e49	6a 02 			push	2
	*** 001e4b	68 48 03 		push	840	;0348H
	*** 001e4e	9a 00 00 00 00 		call	FAR PTR __outp
	*** 001e53	83 c4 04 		add	sp,4
;|***   _outp(OBS_BASE+15 , 1);
; Line 1483
	*** 001e56	6a 01 			push	1
	*** 001e58	68 4f 03 		push	847	;034fH
	*** 001e5b	9a 00 00 00 00 		call	FAR PTR __outp
	*** 001e60	83 c4 04 		add	sp,4
;|***   _outp(OBS_BASE+MCR, PAGE0);
; Line 1484
	*** 001e63	6a 00 			push	0
	*** 001e65	68 48 03 		push	840	;0348H
	*** 001e68	9a 00 00 00 00 		call	FAR PTR __outp
	*** 001e6d	83 c4 04 		add	sp,4
;|***   _outp(OBS_BASE+CTCCR, 0x42);                     // set CTC0 to 10 KHz input
; Line 1485
	*** 001e70	6a 42 			push	66	;0042H
	*** 001e72	68 4a 03 		push	842	;034aH
	*** 001e75	9a 00 00 00 00 		call	FAR PTR __outp
	*** 001e7a	83 c4 04 		add	sp,4
;|***   _outp(OBS_BASE+MCR, PAGE0);                      // access the 82C54's registers
; Line 1486
	*** 001e7d	6a 00 			push	0
	*** 001e7f	68 48 03 		push	840	;0348H
	*** 001e82	9a 00 00 00 00 		call	FAR PTR __outp
	*** 001e87	83 c4 04 		add	sp,4
;|***   _outp(OBS_BASE+15, CTC0 | LSBMSB | MODE2 | BINARY);// program the 82C54's mode
; Line 1487
	*** 001e8a	6a 34 			push	52	;0034H
	*** 001e8c	68 4f 03 		push	847	;034fH
	*** 001e8f	9a 00 00 00 00 		call	FAR PTR __outp
	*** 001e94	83 c4 04 		add	sp,4
;|***   _outp(OBS_BASE+12, 0x64);                        // load divisor LSB (100 or 0x0064)
; Line 1488
	*** 001e97	6a 64 			push	100	;0064H
	*** 001e99	68 4c 03 		push	844	;034cH
	*** 001e9c	9a 00 00 00 00 		call	FAR PTR __outp
	*** 001ea1	83 c4 04 		add	sp,4
;|***   _outp(OBS_BASE+12, 0x00);                        // load divisor MSB
; Line 1489
	*** 001ea4	6a 00 			push	0
	*** 001ea6	68 4c 03 		push	844	;034cH
	*** 001ea9	9a 00 00 00 00 		call	FAR PTR __outp
	*** 001eae	83 c4 04 		add	sp,4
;|***                                                    // 10 KHz / 100 = 100 Hz frame rate
;|***   old_dmm32a_vect = _dos_getvect(11-8+0x70);       // save old irq11 vector
; Line 1491
	*** 001eb1	6a 73 			push	115	;0073H
	*** 001eb3	9a 00 00 00 00 		call	FAR PTR __dos_getvect
	*** 001eb8	83 c4 02 		add	sp,2
	*** 001ebb	a3 00 00 		mov	WORD PTR ?old_dmm32a_vect@@3P7AXXZE,ax	;old_dmm32a_vect
	*** 001ebe	89 16 02 00 		mov	WORD PTR ?old_dmm32a_vect@@3P7AXXZE+2,dx	;old_dmm32a_vect
;|***   _dos_setvect(11-8+0x70, isr_dmm32a);             // install dmm32a isr vector
; Line 1492
	*** 001ec2	68 00 00 		push	SEG ?isr_dmm32a@@ZAXXZ	;isr_dmm32a
	*** 001ec5	68 00 00 		push	OFFSET ?isr_dmm32a@@ZAXXZ	;isr_dmm32a
	*** 001ec8	6a 73 			push	115	;0073H
	*** 001eca	9a 00 00 00 00 		call	FAR PTR __dos_setvect
	*** 001ecf	83 c4 06 		add	sp,6
;|***   _outp(0xa1, _inp(0xa1) & 0xf7);                  // unmask irq11 at pic
; Line 1493
	*** 001ed2	68 a1 00 		push	161	;00a1H
	*** 001ed5	9a 00 00 00 00 		call	FAR PTR __inp
	*** 001eda	83 c4 02 		add	sp,2
	*** 001edd	25 f7 00 		and	ax,247	;00f7H
	*** 001ee0	50 			push	ax
	*** 001ee1	68 a1 00 		push	161	;00a1H
	*** 001ee4	9a 00 00 00 00 		call	FAR PTR __outp
	*** 001ee9	83 c4 04 		add	sp,4
;|*** 
;|***   _outp(OBS_BASE+ICR, ADINTE | TINTE);             // enable adc and timer interrupts
; Line 1495
	*** 001eec	68 a0 00 		push	160	;00a0H
	*** 001eef	68 49 03 		push	841	;0349H
	*** 001ef2	9a 00 00 00 00 		call	FAR PTR __outp
	*** 001ef7	83 c4 04 		add	sp,4
;|***   _enable();
; Line 1496
	*** 001efa	9a 00 00 00 00 		call	FAR PTR __enable
;|***   }
; Line 1497
	*** 001eff	e9 00 00 		jmp	$EX3887
					$EX3887:
	*** 001f02	5e 			pop	si
	*** 001f03	5f 			pop	di
	*** 001f04	c9 			leave	
	*** 001f05	cb 			ret	

?configure_dmm32a@@ZAXXZ	ENDP
	PUBLIC	?trigger_dmm32a@@ZAXXZ	; trigger_dmm32a
?trigger_dmm32a@@ZAXXZ	PROC FAR	; trigger_dmm32a
;|***   
;|*** 
;|*** void trigger_dmm32a(void)  
;|***   {
; Line 1501
	*** 001f06	c8 00 00 00 		enter	0,0
	*** 001f0a	57 			push	di
	*** 001f0b	56 			push	si
;|***   while(_inp(OBS_BASE+ARR) & WAIT);        // wait for the adc inputs to settle
; Line 1502
					$FC3894:
	*** 001f0c	68 4b 03 		push	843	;034bH
	*** 001f0f	9a 00 00 00 00 		call	FAR PTR __inp
	*** 001f14	83 c4 02 		add	sp,2
	*** 001f17	a8 80 			test	al,128	;0080H
	*** 001f19	75 03 			jne	$JCC7961
	*** 001f1b	e9 03 00 		jmp	$FB3895
					$JCC7961:
	*** 001f1e	e9 eb ff 		jmp	$FC3894
					$FB3895:
;|***   _outp(OBS_BASE, 0);                      // start the scan of the onboard sensors
; Line 1503
	*** 001f21	6a 00 			push	0
	*** 001f23	68 40 03 		push	832	;0340H
	*** 001f26	9a 00 00 00 00 		call	FAR PTR __outp
	*** 001f2b	83 c4 04 		add	sp,4
;|***   }
; Line 1504
	*** 001f2e	e9 00 00 		jmp	$EX3892
					$EX3892:
	*** 001f31	5e 			pop	si
	*** 001f32	5f 			pop	di
	*** 001f33	c9 			leave	
	*** 001f34	cb 			ret	

?trigger_dmm32a@@ZAXXZ	ENDP
	PUBLIC	?isr_dmm32a@@ZAXXZ	; isr_dmm32a
?isr_dmm32a@@ZAXXZ	PROC FAR	; isr_dmm32a
;|***   
;|***   
;|*** void interrupt isr_dmm32a(void)
;|***   {
; Line 1508
	*** 001f35	60 			pusha
	*** 001f36	1e 			push	ds
	*** 001f37	06 			push	es
	*** 001f38	8b ec 			mov	bp,sp
	*** 001f3a	81 ec 06 00 		sub	sp,6
	*** 001f3e	1e 			push	ds
	*** 001f3f	b8 00 00 		mov	ax,DGROUP
	*** 001f42	8e d8 			mov	ds,ax
	ASSUME DS: DGROUP
	*** 001f44	fc 			cld	
;	i = -2
;	lsb = -4
;	msb = -6
;|***   // the dmm32 A board will generate two types of interrupts:
;|***   // 1) 82C54 ctc0 timeouts, TINT, the 100 Hz frame timer
;|***   // 2) adc scan complete, ADINT, when onboard sensor data is ready
;|***   
;|***   unsigned i;
;|***   unsigned lsb = 0;
; Line 1514
	*** 001f45	c7 46 fc 00 00 		mov	WORD PTR [bp-4],0	;lsb
;|***   unsigned msb = 0;
; Line 1515
	*** 001f4a	c7 46 fa 00 00 		mov	WORD PTR [bp-6],0	;msb
;|*** 
;|***   // section 1, a TINT has occurred, the 100 Hz ctc0 signals the beginning of a new frame
;|***   if(_inp(OBS_BASE+ISR) & TINT)
; Line 1518
	*** 001f4f	68 49 03 		push	841	;0349H
	*** 001f52	9a 00 00 00 00 		call	FAR PTR __inp
	*** 001f57	83 c4 02 		add	sp,2
	*** 001f5a	a8 20 			test	al,32	;0020H
	*** 001f5c	75 03 			jne	$JCC8028
	*** 001f5e	e9 0a 00 		jmp	$I3901
					$JCC8028:
;|***     {
; Line 1519
;|***     frame++;                                             // update the frame counter
; Line 1520
	*** 001f61	83 06 00 00 01 		add	WORD PTR ?frame@@3KE,1	;frame
	*** 001f66	83 16 02 00 00 		adc	WORD PTR ?frame@@3KE+2,0	;frame
;|***     }
; Line 1521
;|***   
;|***   // section 2, an ADINT has occurred, the onboard sensor data is ready
;|***   if(_inp(OBS_BASE+ISR) & ADINT)
; Line 1524
					$I3901:
	*** 001f6b	68 49 03 		push	841	;0349H
	*** 001f6e	9a 00 00 00 00 		call	FAR PTR __inp
	*** 001f73	83 c4 02 		add	sp,2
	*** 001f76	a8 80 			test	al,128	;0080H
	*** 001f78	75 03 			jne	$JCC8056
	*** 001f7a	e9 5f 00 		jmp	$I3902
					$JCC8056:
;|***     {
; Line 1525
;|***     time_stamp(&obs_time);
; Line 1526
	*** 001f7d	68 00 00 		push	SEG ?obs_time@@3UTIMER@@E	;obs_time
	*** 001f80	68 00 00 		push	OFFSET ?obs_time@@3UTIMER@@E	;obs_time
	*** 001f83	9a 00 00 00 00 		call	FAR PTR ?time_stamp@@ZAXPEUTIMER@@@Z	; time_stamp
	*** 001f88	83 c4 04 		add	sp,4
;|***     for(i=0; i<32; i++) obs_array[i] = _inpw(OBS_BASE);  // read the data from the dmm32a fifo
; Line 1527
	*** 001f8b	c7 46 fe 00 00 		mov	WORD PTR [bp-2],0	;i
	*** 001f90	e9 03 00 		jmp	$F3903
					$FC3904:
	*** 001f93	ff 46 fe 		inc	WORD PTR [bp-2]	;i
					$F3903:
	*** 001f96	83 7e fe 20 		cmp	WORD PTR [bp-2],32	;0020H	;i
	*** 001f9a	72 03 			jb	$JCC8090
	*** 001f9c	e9 17 00 		jmp	$FB3905
					$JCC8090:
	*** 001f9f	68 40 03 		push	832	;0340H
	*** 001fa2	9a 00 00 00 00 		call	FAR PTR __inpw
	*** 001fa7	83 c4 02 		add	sp,2
	*** 001faa	8b 5e fe 		mov	bx,WORD PTR [bp-2]	;i
	*** 001fad	d1 e3 			shl	bx,1
	*** 001faf	89 87 00 00 		mov	WORD PTR ?obs_array@@3QIII[bx],ax	;obs_array
	*** 001fb3	e9 dd ff 		jmp	$FC3904
					$FB3905:
;|***     _fmemcpy(obs_buffer, obs_array, sizeof(obs_array));  // buffer the data
; Line 1528
	*** 001fb6	6a 40 			push	64	;0040H
	*** 001fb8	1e 			push	ds
	*** 001fb9	68 00 00 		push	OFFSET DGROUP:?obs_array@@3QIII	;obs_array
	*** 001fbc	1e 			push	ds
	*** 001fbd	68 00 00 		push	OFFSET DGROUP:?obs_buffer@@3QIEI	;obs_buffer
	*** 001fc0	9a 00 00 00 00 		call	FAR PTR __fmemcpy
	*** 001fc5	83 c4 0a 		add	sp,10	;000aH
;|***     obs_new_data = 1;                                    // flag the system new data available
; Line 1529
	*** 001fc8	c7 06 00 00 01 00 	mov	WORD PTR ?obs_new_data@@3IE,1	;obs_new_data
;|***     obs_data_frame = frame;                              // record the frame number
; Line 1530
	*** 001fce	a1 00 00 		mov	ax,WORD PTR ?frame@@3KE	;frame
	*** 001fd1	8b 16 02 00 		mov	dx,WORD PTR ?frame@@3KE+2	;frame
	*** 001fd5	a3 00 00 		mov	WORD PTR ?obs_data_frame@@3KE,ax	;obs_data_frame
	*** 001fd8	89 16 02 00 		mov	WORD PTR ?obs_data_frame@@3KE+2,dx	;obs_data_frame
;|***     }
; Line 1531
;|***   _outp(OBS_BASE+MCR, INTRST);                           // reset the dmm32's interrupt circuit    
; Line 1532
					$I3902:
	*** 001fdc	6a 08 			push	8
	*** 001fde	68 48 03 		push	840	;0348H
	*** 001fe1	9a 00 00 00 00 		call	FAR PTR __outp
	*** 001fe6	83 c4 04 		add	sp,4
;|***   _outp(OBS_BASE+FCR, FIFORST);                          // reset the fifo
; Line 1533
	*** 001fe9	6a 02 			push	2
	*** 001feb	68 47 03 		push	839	;0347H
	*** 001fee	9a 00 00 00 00 		call	FAR PTR __outp
	*** 001ff3	83 c4 04 		add	sp,4
;|***   _outp(OBS_BASE+LCR,  0);                               // reset the range of channels to scan
; Line 1534
	*** 001ff6	6a 00 			push	0
	*** 001ff8	68 42 03 		push	834	;0342H
	*** 001ffb	9a 00 00 00 00 		call	FAR PTR __outp
	*** 002000	83 c4 04 		add	sp,4
;|***   _outp(OBS_BASE+HCR,  31);
; Line 1535
	*** 002003	6a 1f 			push	31	;001fH
	*** 002005	68 43 03 		push	835	;0343H
	*** 002008	9a 00 00 00 00 		call	FAR PTR __outp
	*** 00200d	83 c4 04 		add	sp,4
;|***   _outp(OBS_BASE+FCR, SCANEN);                           // enable scan interrupts
; Line 1536
	*** 002010	6a 04 			push	4
	*** 002012	68 47 03 		push	839	;0347H
	*** 002015	9a 00 00 00 00 		call	FAR PTR __outp
	*** 00201a	83 c4 04 		add	sp,4
;|*** 
;|***   _outp(0xa0, 0x20);                                     // slave EOI
; Line 1538
	*** 00201d	6a 20 			push	32	;0020H
	*** 00201f	68 a0 00 		push	160	;00a0H
	*** 002022	9a 00 00 00 00 		call	FAR PTR __outp
	*** 002027	83 c4 04 		add	sp,4
;|***   _outp(0x20, 0x20);                                     // master EOI  
; Line 1539
	*** 00202a	6a 20 			push	32	;0020H
	*** 00202c	6a 20 			push	32	;0020H
	*** 00202e	9a 00 00 00 00 		call	FAR PTR __outp
	*** 002033	83 c4 04 		add	sp,4
;|***   }
; Line 1540
	*** 002036	e9 00 00 		jmp	$EX3897
					$EX3897:
	*** 002039	8b e5 			mov	sp,bp
	*** 00203b	07 			pop	es
	*** 00203c	1f 			pop	ds
	ASSUME DS: DGROUP
	*** 00203d	61 			popa
	*** 00203e	cf 			iret	

?isr_dmm32a@@ZAXXZ	ENDP
	PUBLIC	?configure_dmm32b@@ZAXXZ	; configure_dmm32b
?configure_dmm32b@@ZAXXZ	PROC FAR	; configure_dmm32b
;|***   
;|*** 
;|*** void configure_dmm32b(void)
;|***   {//io = 0x380, irq=12, bottom board, reads the mux boxes and the prop slip ring/dynos
; Line 1544
	*** 00203f	c8 00 00 00 		enter	0,0
	*** 002043	57 			push	di
	*** 002044	56 			push	si
;|***   _disable();
; Line 1545
	*** 002045	9a 00 00 00 00 		call	FAR PTR __disable
;|*** 
;|***   _outp(DYNO_BASE+FCR, FIFORST);                         // reset the adc fifo
; Line 1547
	*** 00204a	6a 02 			push	2
	*** 00204c	68 87 03 		push	903	;0387H
	*** 00204f	9a 00 00 00 00 		call	FAR PTR __outp
	*** 002054	83 c4 04 		add	sp,4
;|***   _outp(DYNO_BASE+LCR,  0);                              // set the range of channels to scan
; Line 1548
	*** 002057	6a 00 			push	0
	*** 002059	68 82 03 		push	898	;0382H
	*** 00205c	9a 00 00 00 00 		call	FAR PTR __outp
	*** 002061	83 c4 04 		add	sp,4
;|***   _outp(DYNO_BASE+HCR,  7);                              // initially set for 8 channels for mux boxes
; Line 1549
	*** 002064	6a 07 			push	7
	*** 002066	68 83 03 		push	899	;0383H
	*** 002069	9a 00 00 00 00 		call	FAR PTR __outp
	*** 00206e	83 c4 04 		add	sp,4
;|***   _outp(DYNO_BASE+FCR, SCANEN);                          // enable adc scan interrupts
; Line 1550
	*** 002071	6a 04 			push	4
	*** 002073	68 87 03 		push	903	;0387H
	*** 002076	9a 00 00 00 00 		call	FAR PTR __outp
	*** 00207b	83 c4 04 		add	sp,4
;|***   _outp(DYNO_BASE+ACR, KHZ200 | BIPOLAR5 | GAIN1);       // 200KHz scans, +-5Volt inputs
; Line 1551
	*** 00207e	6a 30 			push	48	;0030H
	*** 002080	68 8b 03 		push	907	;038bH
	*** 002083	9a 00 00 00 00 		call	FAR PTR __outp
	*** 002088	83 c4 04 		add	sp,4
;|***   while(_inp(DYNO_BASE+ARR) & WAIT);                     // wait for adc inputs to settle
; Line 1552
					$FC3909:
	*** 00208b	68 8b 03 		push	907	;038bH
	*** 00208e	9a 00 00 00 00 		call	FAR PTR __inp
	*** 002093	83 c4 02 		add	sp,2
	*** 002096	a8 80 			test	al,128	;0080H
	*** 002098	75 03 			jne	$JCC8344
	*** 00209a	e9 03 00 		jmp	$FB3910
					$JCC8344:
	*** 00209d	e9 eb ff 		jmp	$FC3909
					$FB3910:
;|*** 
;|***   _outp(DYNO_BASE+MCR, PAGE1);                           // set the 8255 dio ports for outputs, mode0
; Line 1554
	*** 0020a0	6a 01 			push	1
	*** 0020a2	68 88 03 		push	904	;0388H
	*** 0020a5	9a 00 00 00 00 		call	FAR PTR __outp
	*** 0020aa	83 c4 04 		add	sp,4
;|***   _outp(DYNO_BASE+15,  0x80);
; Line 1555
	*** 0020ad	68 80 00 		push	128	;0080H
	*** 0020b0	68 8f 03 		push	911	;038fH
	*** 0020b3	9a 00 00 00 00 		call	FAR PTR __outp
	*** 0020b8	83 c4 04 		add	sp,4
;|***   _outp(DYNO_BASE+MCR, PAGE0);
; Line 1556
	*** 0020bb	6a 00 			push	0
	*** 0020bd	68 88 03 		push	904	;0388H
	*** 0020c0	9a 00 00 00 00 		call	FAR PTR __outp
	*** 0020c5	83 c4 04 		add	sp,4
;|*** 
;|***   old_dmm32b_vect = _dos_getvect(12-8+0x70);             // save old irq12 isr vector
; Line 1558
	*** 0020c8	6a 74 			push	116	;0074H
	*** 0020ca	9a 00 00 00 00 		call	FAR PTR __dos_getvect
	*** 0020cf	83 c4 02 		add	sp,2
	*** 0020d2	a3 00 00 		mov	WORD PTR ?old_dmm32b_vect@@3P7AXXZE,ax	;old_dmm32b_vect
	*** 0020d5	89 16 02 00 		mov	WORD PTR ?old_dmm32b_vect@@3P7AXXZE+2,dx	;old_dmm32b_vect
;|***   _dos_setvect(12-8+0x70, isr_dmm32b);                   // install new isr_dmm32b vector
; Line 1559
	*** 0020d9	68 00 00 		push	SEG ?isr_dmm32b@@ZAXXZ	;isr_dmm32b
	*** 0020dc	68 00 00 		push	OFFSET ?isr_dmm32b@@ZAXXZ	;isr_dmm32b
	*** 0020df	6a 74 			push	116	;0074H
	*** 0020e1	9a 00 00 00 00 		call	FAR PTR __dos_setvect
	*** 0020e6	83 c4 06 		add	sp,6
;|***   _outp(0xa1, _inp(0xa1) & 0xef);                        // unmask irq12 at pic
; Line 1560
	*** 0020e9	68 a1 00 		push	161	;00a1H
	*** 0020ec	9a 00 00 00 00 		call	FAR PTR __inp
	*** 0020f1	83 c4 02 		add	sp,2
	*** 0020f4	25 ef 00 		and	ax,239	;00efH
	*** 0020f7	50 			push	ax
	*** 0020f8	68 a1 00 		push	161	;00a1H
	*** 0020fb	9a 00 00 00 00 		call	FAR PTR __outp
	*** 002100	83 c4 04 		add	sp,4
;|*** 
;|***   _outp(DYNO_BASE+CTCCR, _inp(DYNO_BASE+CTCCR) | 0x02);  // set 8254 ctc0 for 10 MHz input
; Line 1562
	*** 002103	68 8a 03 		push	906	;038aH
	*** 002106	9a 00 00 00 00 		call	FAR PTR __inp
	*** 00210b	83 c4 02 		add	sp,2
	*** 00210e	0d 02 00 		or	ax,2
	*** 002111	50 			push	ax
	*** 002112	68 8a 03 		push	906	;038aH
	*** 002115	9a 00 00 00 00 		call	FAR PTR __outp
	*** 00211a	83 c4 04 		add	sp,4
;|***   _outp(DYNO_BASE+MCR, PAGE2);                           // set ctc0 for falling edge trigger
; Line 1563
	*** 00211d	6a 02 			push	2
	*** 00211f	68 88 03 		push	904	;0388H
	*** 002122	9a 00 00 00 00 		call	FAR PTR __outp
	*** 002127	83 c4 04 		add	sp,4
;|***   _outp(DYNO_BASE+15 , 1);
; Line 1564
	*** 00212a	6a 01 			push	1
	*** 00212c	68 8f 03 		push	911	;038fH
	*** 00212f	9a 00 00 00 00 		call	FAR PTR __outp
	*** 002134	83 c4 04 		add	sp,4
;|***   _outp(DYNO_BASE+MCR, PAGE0);
; Line 1565
	*** 002137	6a 00 			push	0
	*** 002139	68 88 03 		push	904	;0388H
	*** 00213c	9a 00 00 00 00 		call	FAR PTR __outp
	*** 002141	83 c4 04 		add	sp,4
;|***   _outp(DYNO_BASE+ICR, ADINTE | TINTE);                  // enable adc & ctc0 timer interrupts
; Line 1566
	*** 002144	68 a0 00 		push	160	;00a0H
	*** 002147	68 89 03 		push	905	;0389H
	*** 00214a	9a 00 00 00 00 		call	FAR PTR __outp
	*** 00214f	83 c4 04 		add	sp,4
;|*** 
;|***   _enable();
; Line 1568
	*** 002152	9a 00 00 00 00 		call	FAR PTR __enable
;|***   }
; Line 1569
	*** 002157	e9 00 00 		jmp	$EX3907
					$EX3907:
	*** 00215a	5e 			pop	si
	*** 00215b	5f 			pop	di
	*** 00215c	c9 			leave	
	*** 00215d	cb 			ret	

?configure_dmm32b@@ZAXXZ	ENDP
	PUBLIC	?trigger_dmm32b@@ZAXXZ	; trigger_dmm32b
?trigger_dmm32b@@ZAXXZ	PROC FAR	; trigger_dmm32b
;|*** 
;|*** 
;|*** void trigger_dmm32b(void)  
;|***   {                                  // start dmm32b for the entire mux/scan/read routine
; Line 1573
	*** 00215e	c8 00 00 00 		enter	0,0
	*** 002162	57 			push	di
	*** 002163	56 			push	si
;|***   reading_prop = 0;                  // start with mux box scans, not prop scans
; Line 1574
	*** 002164	c7 06 00 00 00 00 	mov	WORD PTR ?reading_prop@@3IE,0	;reading_prop
;|***   mux_addr = 0;
; Line 1575
	*** 00216a	c7 06 00 00 00 00 	mov	WORD PTR ?mux_addr@@3IE,0	;mux_addr
;|*** 
;|***   _disable();                        // initialize the mux address and put it on the wires
; Line 1577
	*** 002170	9a 00 00 00 00 		call	FAR PTR __disable
;|***   _outp(DYNO_BASE+MCR, PAGE1);
; Line 1578
	*** 002175	6a 01 			push	1
	*** 002177	68 88 03 		push	904	;0388H
	*** 00217a	9a 00 00 00 00 		call	FAR PTR __outp
	*** 00217f	83 c4 04 		add	sp,4
;|***   _outp(DYNO_BASE+PORTA , mux_addr);
; Line 1579
	*** 002182	ff 36 00 00 		push	WORD PTR ?mux_addr@@3IE	;mux_addr
	*** 002186	68 8c 03 		push	908	;038cH
	*** 002189	9a 00 00 00 00 		call	FAR PTR __outp
	*** 00218e	83 c4 04 		add	sp,4
;|***   _outp(DYNO_BASE+MCR, PAGE0);
; Line 1580
	*** 002191	6a 00 			push	0
	*** 002193	68 88 03 		push	904	;0388H
	*** 002196	9a 00 00 00 00 		call	FAR PTR __outp
	*** 00219b	83 c4 04 		add	sp,4
;|*** 
;|***   // start a 200 usec settling period for the mux box data 
;|***   // with a 10MHz input to ctc0 and desired delay of 200 usec the divisor = 2000 = 0x07d0
;|***   _outp(DYNO_BASE+15, CTC0 | LSBMSB | MODE0 | BINARY);   // program ctc0
; Line 1584
	*** 00219e	6a 30 			push	48	;0030H
	*** 0021a0	68 8f 03 		push	911	;038fH
	*** 0021a3	9a 00 00 00 00 		call	FAR PTR __outp
	*** 0021a8	83 c4 04 		add	sp,4
;|***   _outp(DYNO_BASE+12, 0xd0);                             // load divisor LSB
; Line 1585
	*** 0021ab	68 d0 00 		push	208	;00d0H
	*** 0021ae	68 8c 03 		push	908	;038cH
	*** 0021b1	9a 00 00 00 00 		call	FAR PTR __outp
	*** 0021b6	83 c4 04 		add	sp,4
;|***   _outp(DYNO_BASE+12, 0x07);                             // load divisor MSB
; Line 1586
	*** 0021b9	6a 07 			push	7
	*** 0021bb	68 8c 03 		push	908	;038cH
	*** 0021be	9a 00 00 00 00 		call	FAR PTR __outp
	*** 0021c3	83 c4 04 		add	sp,4
;|***   _outp(DYNO_BASE+ICR, ADINTE | TINTE);                  // enable adc and timer interrupts
; Line 1587
	*** 0021c6	68 a0 00 		push	160	;00a0H
	*** 0021c9	68 89 03 		push	905	;0389H
	*** 0021cc	9a 00 00 00 00 		call	FAR PTR __outp
	*** 0021d1	83 c4 04 		add	sp,4
;|***   _enable();
; Line 1588
	*** 0021d4	9a 00 00 00 00 		call	FAR PTR __enable
;|***   // ctc0 will generate a TINT interrupt 200usec from now
;|***   // we will trigger a scan of the mux boards in the dmm32b isr when the TINT interrupt occurs
;|***   }
; Line 1591
	*** 0021d9	e9 00 00 		jmp	$EX3912
					$EX3912:
	*** 0021dc	5e 			pop	si
	*** 0021dd	5f 			pop	di
	*** 0021de	c9 			leave	
	*** 0021df	cb 			ret	

?trigger_dmm32b@@ZAXXZ	ENDP
	PUBLIC	?isr_dmm32b@@ZAXXZ	; isr_dmm32b
?isr_dmm32b@@ZAXXZ	PROC FAR	; isr_dmm32b
;|***     
;|*** 
;|*** void interrupt isr_dmm32b(void)
;|***   {
; Line 1595
	*** 0021e0	60 			pusha
	*** 0021e1	1e 			push	ds
	*** 0021e2	06 			push	es
	*** 0021e3	8b ec 			mov	bp,sp
	*** 0021e5	81 ec 0a 00 		sub	sp,10	;000aH
	*** 0021e9	1e 			push	ds
	*** 0021ea	b8 00 00 		mov	ax,DGROUP
	*** 0021ed	8e d8 			mov	ds,ax
	ASSUME DS: DGROUP
	*** 0021ef	fc 			cld	
;	i = -2
;	lsb = -4
;	msb = -6
;	prop_pos = -10
;|***   // two modes of operation
;|***   // 1) reading the prop dynos      (no multiplexing)
;|***   // 2) reading the mux boxes dynos (with multiplexing)
;|***   //
;|***   // for each mode there are two types of interrupts
;|***   // a) settling time complete (TINT, 82C54 ctc0 timeouts)
;|***   // b) adc scan complete (ADINT)
;|***   
;|***   unsigned int i;
;|***   unsigned int lsb = 0;
; Line 1605
	*** 0021f0	c7 46 fc 00 00 		mov	WORD PTR [bp-4],0	;lsb
;|***   unsigned int msb = 0;
; Line 1606
	*** 0021f5	c7 46 fa 00 00 		mov	WORD PTR [bp-6],0	;msb
;|***   long int     prop_pos = 0;
; Line 1607
	*** 0021fa	2b c0 			sub	ax,ax
	*** 0021fc	89 46 f8 		mov	WORD PTR [bp-8],ax
	*** 0021ff	89 46 f6 		mov	WORD PTR [bp-10],ax	;prop_pos
;|***   
;|***   // mode 1, reading prop dynos
;|***   if(reading_prop)
; Line 1610
	*** 002202	83 3e 00 00 00 		cmp	WORD PTR ?reading_prop@@3IE,0	;reading_prop
	*** 002207	75 03 			jne	$JCC8711
	*** 002209	e9 96 01 		jmp	$I3919
					$JCC8711:
;|***     {
; Line 1611
;|***     if(_inp(DYNO_BASE+ISR) & TINT)                        // settling time is complete so 
; Line 1612
	*** 00220c	68 89 03 		push	905	;0389H
	*** 00220f	9a 00 00 00 00 		call	FAR PTR __inp
	*** 002214	83 c4 02 		add	sp,2
	*** 002217	a8 20 			test	al,32	;0020H
	*** 002219	75 03 			jne	$JCC8729
	*** 00221b	e9 4d 00 		jmp	$I3920
					$JCC8729:
;|***       {                                                   // trigger a scan the prop dynos
; Line 1613
;|***       _outp(DYNO_BASE+ICR, ADINTE & ~TINTE);              // disable further timer interrupts
; Line 1614
	*** 00221e	68 80 00 		push	128	;0080H
	*** 002221	68 89 03 		push	905	;0389H
	*** 002224	9a 00 00 00 00 		call	FAR PTR __outp
	*** 002229	83 c4 04 		add	sp,4
;|***       _outp(DYNO_BASE+FCR, _inp(DYNO_BASE+FCR) | FIFORST);// reset the fifo
; Line 1615
	*** 00222c	68 87 03 		push	903	;0387H
	*** 00222f	9a 00 00 00 00 		call	FAR PTR __inp
	*** 002234	83 c4 02 		add	sp,2
	*** 002237	0d 02 00 		or	ax,2
	*** 00223a	50 			push	ax
	*** 00223b	68 87 03 		push	903	;0387H
	*** 00223e	9a 00 00 00 00 		call	FAR PTR __outp
	*** 002243	83 c4 04 		add	sp,4
;|***       while(_inp(DYNO_BASE+ARR) & WAIT);                  // ensure the adc is ready      
; Line 1616
					$FC3922:
	*** 002246	68 8b 03 		push	907	;038bH
	*** 002249	9a 00 00 00 00 		call	FAR PTR __inp
	*** 00224e	83 c4 02 		add	sp,2
	*** 002251	a8 80 			test	al,128	;0080H
	*** 002253	75 03 			jne	$JCC8787
	*** 002255	e9 03 00 		jmp	$FB3923
					$JCC8787:
	*** 002258	e9 eb ff 		jmp	$FC3922
					$FB3923:
;|***       _outp(DYNO_BASE, 0);                                // trigger the scan
; Line 1617
	*** 00225b	6a 00 			push	0
	*** 00225d	68 80 03 		push	896	;0380H
	*** 002260	9a 00 00 00 00 		call	FAR PTR __outp
	*** 002265	83 c4 04 		add	sp,4
;|***       // we will read the prop dyno adc's when an ADINT interrupt occurs about 30 usec from now
;|***       }
; Line 1619
;|***     else                                                  // not a TINT, must be an ADINT
; Line 1620
	*** 002268	e9 34 01 		jmp	$I3924
					$I3920:
;|***       {                                                   
; Line 1621
;|***       if(_inp(DYNO_BASE+ISR) & ADINT)                     // time to read the prop data
; Line 1622
	*** 00226b	68 89 03 		push	905	;0389H
	*** 00226e	9a 00 00 00 00 		call	FAR PTR __inp
	*** 002273	83 c4 02 		add	sp,2
	*** 002276	a8 80 			test	al,128	;0080H
	*** 002278	75 03 			jne	$JCC8824
	*** 00227a	e9 22 01 		jmp	$I3925
					$JCC8824:
;|***         {
; Line 1623
;|***         time_stamp(&prop_adc_time);
; Line 1624
	*** 00227d	68 00 00 		push	SEG ?prop_adc_time@@3UTIMER@@E	;prop_adc_time
	*** 002280	68 00 00 		push	OFFSET ?prop_adc_time@@3UTIMER@@E	;prop_adc_time
	*** 002283	9a 00 00 00 00 		call	FAR PTR ?time_stamp@@ZAXPEUTIMER@@@Z	; time_stamp
	*** 002288	83 c4 04 		add	sp,4
;|***         if(te5650IsCapture()==1)
; Line 1625
	*** 00228b	9a 00 00 00 00 		call	FAR PTR _te5650IsCapture
	*** 002290	48 			dec	ax
	*** 002291	74 03 			je	$JCC8849
	*** 002293	e9 0c 00 		jmp	$I3926
					$JCC8849:
;|***           {
; Line 1626
;|***           te5650CapturePos(&prop_index); // get prop index
; Line 1627
	*** 002296	1e 			push	ds
	*** 002297	68 00 00 		push	OFFSET DGROUP:?prop_index@@3JE	;prop_index
	*** 00229a	9a 00 00 00 00 		call	FAR PTR _te5650CapturePos
	*** 00229f	83 c4 04 		add	sp,4
;|***           }
; Line 1628
;|***         te5650ActPos(&prop_pos);                             // get prop position
; Line 1629
					$I3926:
	*** 0022a2	8d 46 f6 		lea	ax,WORD PTR [bp-10]	;prop_pos
	*** 0022a5	16 			push	ss
	*** 0022a6	50 			push	ax
	*** 0022a7	9a 00 00 00 00 		call	FAR PTR _te5650ActPos
	*** 0022ac	83 c4 04 		add	sp,4
;|***         prop_report = prop_pos;
; Line 1630
	*** 0022af	8b 46 f6 		mov	ax,WORD PTR [bp-10]	;prop_pos
	*** 0022b2	8b 56 f8 		mov	dx,WORD PTR [bp-8]
	*** 0022b5	a3 00 00 		mov	WORD PTR ?prop_report@@3JE,ax	;prop_report
	*** 0022b8	89 16 02 00 		mov	WORD PTR ?prop_report@@3JE+2,dx	;prop_report
;|***         index_report = prop_index;
; Line 1631
	*** 0022bc	a1 00 00 		mov	ax,WORD PTR ?prop_index@@3JE	;prop_index
	*** 0022bf	8b 16 02 00 		mov	dx,WORD PTR ?prop_index@@3JE+2	;prop_index
	*** 0022c3	a3 00 00 		mov	WORD PTR ?index_report@@3JE,ax	;index_report
	*** 0022c6	89 16 02 00 		mov	WORD PTR ?index_report@@3JE+2,dx	;index_report
;|***         time_stamp(&prop_position_time);
; Line 1632
	*** 0022ca	68 00 00 		push	SEG ?prop_position_time@@3UTIMER@@E	;prop_position_time
	*** 0022cd	68 00 00 		push	OFFSET ?prop_position_time@@3UTIMER@@E	;prop_position_time
	*** 0022d0	9a 00 00 00 00 		call	FAR PTR ?time_stamp@@ZAXPEUTIMER@@@Z	; time_stamp
	*** 0022d5	83 c4 04 		add	sp,4
;|***         time_stamp(&prop_rpm_time);
; Line 1633
	*** 0022d8	68 00 00 		push	SEG ?prop_rpm_time@@3UTIMER@@E	;prop_rpm_time
	*** 0022db	68 00 00 		push	OFFSET ?prop_rpm_time@@3UTIMER@@E	;prop_rpm_time
	*** 0022de	9a 00 00 00 00 		call	FAR PTR ?time_stamp@@ZAXPEUTIMER@@@Z	; time_stamp
	*** 0022e3	83 c4 04 		add	sp,4
;|***         prop_position_absolute_current = prop_pos;
; Line 1634
	*** 0022e6	8b 46 f6 		mov	ax,WORD PTR [bp-10]	;prop_pos
	*** 0022e9	8b 56 f8 		mov	dx,WORD PTR [bp-8]
	*** 0022ec	a3 00 00 		mov	WORD PTR ?prop_position_absolute_current@@3JE,ax	;prop_position_absolute_current
	*** 0022ef	89 16 02 00 		mov	WORD PTR ?prop_position_absolute_current@@3JE+2,dx	;prop_position_absolute_current
;|***         prop_position = (prop_pos - prop_index) - 17609;  // jtm 5/8/2007
; Line 1635
	*** 0022f3	8b 46 f6 		mov	ax,WORD PTR [bp-10]	;prop_pos
	*** 0022f6	8b 56 f8 		mov	dx,WORD PTR [bp-8]
	*** 0022f9	2b 06 00 00 		sub	ax,WORD PTR ?prop_index@@3JE	;prop_index
	*** 0022fd	1b 16 02 00 		sbb	dx,WORD PTR ?prop_index@@3JE+2	;prop_index
	*** 002301	2d c9 44 		sub	ax,17609	;44c9H
	*** 002304	83 da 00 		sbb	dx,0
	*** 002307	a3 00 00 		mov	WORD PTR ?prop_position@@3JE,ax	;prop_position
	*** 00230a	89 16 02 00 		mov	WORD PTR ?prop_position@@3JE+2,dx	;prop_position
;|***         
;|***         for(i=0; i<6; i++)                                // read and buffer the dyno data  
; Line 1637
	*** 00230e	c7 46 fe 00 00 		mov	WORD PTR [bp-2],0	;i
	*** 002313	e9 03 00 		jmp	$F3927
					$FC3928:
	*** 002316	ff 46 fe 		inc	WORD PTR [bp-2]	;i
					$F3927:
	*** 002319	83 7e fe 06 		cmp	WORD PTR [bp-2],6	;i
	*** 00231d	72 03 			jb	$JCC8989
	*** 00231f	e9 17 00 		jmp	$FB3929
					$JCC8989:
;|***           {
; Line 1638
;|***           prop_array[i] = _inpw(DYNO_BASE);
; Line 1639
	*** 002322	68 80 03 		push	896	;0380H
	*** 002325	9a 00 00 00 00 		call	FAR PTR __inpw
	*** 00232a	83 c4 02 		add	sp,2
	*** 00232d	8b 5e fe 		mov	bx,WORD PTR [bp-2]	;i
	*** 002330	d1 e3 			shl	bx,1
	*** 002332	89 87 00 00 		mov	WORD PTR ?prop_array@@3QIII[bx],ax	;prop_array
;|***           }
; Line 1640
	*** 002336	e9 dd ff 		jmp	$FC3928
					$FB3929:
;|***         _fmemcpy(prop_buffer, prop_array, sizeof(prop_array));
; Line 1641
	*** 002339	6a 0c 			push	12	;000cH
	*** 00233b	1e 			push	ds
	*** 00233c	68 00 00 		push	OFFSET DGROUP:?prop_array@@3QIII	;prop_array
	*** 00233f	1e 			push	ds
	*** 002340	68 00 00 		push	OFFSET DGROUP:?prop_buffer@@3QIEI	;prop_buffer
	*** 002343	9a 00 00 00 00 		call	FAR PTR __fmemcpy
	*** 002348	83 c4 0a 		add	sp,10	;000aH
;|***                                                                                                 
;|***         prop_new_data = 1;                                // flag new data is available
; Line 1643
	*** 00234b	c7 06 00 00 01 00 	mov	WORD PTR ?prop_new_data@@3IE,1	;prop_new_data
;|***         prop_data_frame = frame;                          // record the frame number      
; Line 1644
	*** 002351	a1 00 00 		mov	ax,WORD PTR ?frame@@3KE	;frame
	*** 002354	8b 16 02 00 		mov	dx,WORD PTR ?frame@@3KE+2	;frame
	*** 002358	a3 00 00 		mov	WORD PTR ?prop_data_frame@@3KE,ax	;prop_data_frame
	*** 00235b	89 16 02 00 		mov	WORD PTR ?prop_data_frame@@3KE+2,dx	;prop_data_frame
;|***         
;|***         reading_prop = 0;                                 // set to scan mux boxes next
; Line 1646
	*** 00235f	c7 06 00 00 00 00 	mov	WORD PTR ?reading_prop@@3IE,0	;reading_prop
;|***         _outp(DYNO_BASE+FCR, _inp(DYNO_BASE+FCR) | FIFORST); // reset the fifo
; Line 1647
	*** 002365	68 87 03 		push	903	;0387H
	*** 002368	9a 00 00 00 00 		call	FAR PTR __inp
	*** 00236d	83 c4 02 		add	sp,2
	*** 002370	0d 02 00 		or	ax,2
	*** 002373	50 			push	ax
	*** 002374	68 87 03 		push	903	;0387H
	*** 002377	9a 00 00 00 00 		call	FAR PTR __outp
	*** 00237c	83 c4 04 		add	sp,4
;|***         _outp(DYNO_BASE+LCR,  0);                         // set the range of channels to scan
; Line 1648
	*** 00237f	6a 00 			push	0
	*** 002381	68 82 03 		push	898	;0382H
	*** 002384	9a 00 00 00 00 		call	FAR PTR __outp
	*** 002389	83 c4 04 		add	sp,4
;|***         _outp(DYNO_BASE+HCR,  7);
; Line 1649
	*** 00238c	6a 07 			push	7
	*** 00238e	68 83 03 		push	899	;0383H
	*** 002391	9a 00 00 00 00 		call	FAR PTR __outp
	*** 002396	83 c4 04 		add	sp,4
;|***         
;|***         data_ready = 1;
; Line 1651
	*** 002399	c7 06 00 00 01 00 	mov	WORD PTR ?data_ready@@3IE,1	;data_ready
;|***         }
; Line 1652
;|***       }
; Line 1653
					$I3925:
					$I3924:
;|***     } // end of the prop section
; Line 1654
;|***   
;|***   
;|***   // mode 2, reading mux boxes 
;|***   else
; Line 1658
	*** 00239f	e9 da 01 		jmp	$I3930
					$I3919:
;|***     {
; Line 1659
;|***     if(_inp(DYNO_BASE+ISR) & TINT)                        // the settling time is complete
; Line 1660
	*** 0023a2	68 89 03 		push	905	;0389H
	*** 0023a5	9a 00 00 00 00 		call	FAR PTR __inp
	*** 0023aa	83 c4 02 		add	sp,2
	*** 0023ad	a8 20 			test	al,32	;0020H
	*** 0023af	75 03 			jne	$JCC9135
	*** 0023b1	e9 33 00 		jmp	$I3931
					$JCC9135:
;|***       {                                                   // so start a mux box scan
; Line 1661
;|***       _outp(DYNO_BASE+ICR, ADINTE & ~TINTE);              // disable further TINT interrupts
; Line 1662
	*** 0023b4	68 80 00 		push	128	;0080H
	*** 0023b7	68 89 03 		push	905	;0389H
	*** 0023ba	9a 00 00 00 00 		call	FAR PTR __outp
	*** 0023bf	83 c4 04 		add	sp,4
;|***       while(_inp(DYNO_BASE+ARR) & WAIT);                  // wait for adc ready
; Line 1663
					$FC3933:
	*** 0023c2	68 8b 03 		push	907	;038bH
	*** 0023c5	9a 00 00 00 00 		call	FAR PTR __inp
	*** 0023ca	83 c4 02 		add	sp,2
	*** 0023cd	a8 80 			test	al,128	;0080H
	*** 0023cf	75 03 			jne	$JCC9167
	*** 0023d1	e9 03 00 		jmp	$FB3934
					$JCC9167:
	*** 0023d4	e9 eb ff 		jmp	$FC3933
					$FB3934:
;|***       _outp(DYNO_BASE, 0);                                // trigger the scan
; Line 1664
	*** 0023d7	6a 00 			push	0
	*** 0023d9	68 80 03 		push	896	;0380H
	*** 0023dc	9a 00 00 00 00 		call	FAR PTR __outp
	*** 0023e1	83 c4 04 		add	sp,4
;|***       // we will read the mux box scan about 40 usec from now when an ADINT irq occurs
;|***       }
; Line 1666
;|***       
;|***     else                                                  
; Line 1668
	*** 0023e4	e9 95 01 		jmp	$I3935
					$I3931:
;|***       {
; Line 1669
;|***       if(_inp(DYNO_BASE+ISR) & ADINT)                     // the adc data is ready
; Line 1670
	*** 0023e7	68 89 03 		push	905	;0389H
	*** 0023ea	9a 00 00 00 00 		call	FAR PTR __inp
	*** 0023ef	83 c4 02 		add	sp,2
	*** 0023f2	a8 80 			test	al,128	;0080H
	*** 0023f4	75 03 			jne	$JCC9204
	*** 0023f6	e9 83 01 		jmp	$I3936
					$JCC9204:
;|***         {
; Line 1671
;|***         for(i=0; i<8; i++)                                // read the data  
; Line 1672
	*** 0023f9	c7 46 fe 00 00 		mov	WORD PTR [bp-2],0	;i
	*** 0023fe	e9 03 00 		jmp	$F3937
					$FC3938:
	*** 002401	ff 46 fe 		inc	WORD PTR [bp-2]	;i
					$F3937:
	*** 002404	83 7e fe 08 		cmp	WORD PTR [bp-2],8	;i
	*** 002408	72 03 			jb	$JCC9224
	*** 00240a	e9 1e 00 		jmp	$FB3939
					$JCC9224:
;|***           {
; Line 1673
;|***           dyno_array[i + (mux_addr*8)] = _inpw(DYNO_BASE);
; Line 1674
	*** 00240d	68 80 03 		push	896	;0380H
	*** 002410	9a 00 00 00 00 		call	FAR PTR __inpw
	*** 002415	83 c4 02 		add	sp,2
	*** 002418	8b 1e 00 00 		mov	bx,WORD PTR ?mux_addr@@3IE	;mux_addr
	*** 00241c	c1 e3 03 		shl	bx,3
	*** 00241f	03 5e fe 		add	bx,WORD PTR [bp-2]	;i
	*** 002422	d1 e3 			shl	bx,1
	*** 002424	89 87 00 00 		mov	WORD PTR ?dyno_array@@3QIII[bx],ax	;dyno_array
;|***           }
; Line 1675
	*** 002428	e9 d6 ff 		jmp	$FC3938
					$FB3939:
;|***         
;|***         mux_addr++;                                       // set mux address for the next scan
; Line 1677
	*** 00242b	ff 06 00 00 		inc	WORD PTR ?mux_addr@@3IE	;mux_addr
;|***         
;|***         if(mux_addr < 16)                                 // not done scanning all addresses
; Line 1679
	*** 00242f	83 3e 00 00 10 		cmp	WORD PTR ?mux_addr@@3IE,16	;0010H	;mux_addr
	*** 002434	72 03 			jb	$JCC9268
	*** 002436	e9 62 00 		jmp	$I3940
					$JCC9268:
;|***           {
; Line 1680
;|***           _outp(DYNO_BASE+MCR, PAGE1);                    // put address on the dio port
; Line 1681
	*** 002439	6a 01 			push	1
	*** 00243b	68 88 03 		push	904	;0388H
	*** 00243e	9a 00 00 00 00 		call	FAR PTR __outp
	*** 002443	83 c4 04 		add	sp,4
;|***           _outp(DYNO_BASE+PORTA , mux_addr);
; Line 1682
	*** 002446	ff 36 00 00 		push	WORD PTR ?mux_addr@@3IE	;mux_addr
	*** 00244a	68 8c 03 		push	908	;038cH
	*** 00244d	9a 00 00 00 00 		call	FAR PTR __outp
	*** 002452	83 c4 04 		add	sp,4
;|***           
;|***           // start another 200 usec settling period
;|***           _outp(DYNO_BASE+MCR, PAGE0);                         // access the 82C54 timer
; Line 1685
	*** 002455	6a 00 			push	0
	*** 002457	68 88 03 		push	904	;0388H
	*** 00245a	9a 00 00 00 00 		call	FAR PTR __outp
	*** 00245f	83 c4 04 		add	sp,4
;|***           _outp(DYNO_BASE+15, CTC0 | LSBMSB | MODE0 | BINARY); // set up ctc0
; Line 1686
	*** 002462	6a 30 			push	48	;0030H
	*** 002464	68 8f 03 		push	911	;038fH
	*** 002467	9a 00 00 00 00 		call	FAR PTR __outp
	*** 00246c	83 c4 04 		add	sp,4
;|***           _outp(DYNO_BASE+12, 0xd0);                           // divisor LSB (2000 or 0x07d0)
; Line 1687
	*** 00246f	68 d0 00 		push	208	;00d0H
	*** 002472	68 8c 03 		push	908	;038cH
	*** 002475	9a 00 00 00 00 		call	FAR PTR __outp
	*** 00247a	83 c4 04 		add	sp,4
;|***           _outp(DYNO_BASE+12, 0x07);                           // divisor MSB 
; Line 1688
	*** 00247d	6a 07 			push	7
	*** 00247f	68 8c 03 		push	908	;038cH
	*** 002482	9a 00 00 00 00 		call	FAR PTR __outp
	*** 002487	83 c4 04 		add	sp,4
;|***           _outp(DYNO_BASE+ICR, ADINTE | TINTE);                // enable adc & timer interrupts
; Line 1689
	*** 00248a	68 a0 00 		push	160	;00a0H
	*** 00248d	68 89 03 		push	905	;0389H
	*** 002490	9a 00 00 00 00 		call	FAR PTR __outp
	*** 002495	83 c4 04 		add	sp,4
;|***           // we will scan the mux data again when ctc0 generates a TINT irq 200 usec from now
;|***           }
; Line 1691
;|***           
;|***         else                                            // all mux addresses have been scanned
; Line 1693
	*** 002498	e9 e1 00 		jmp	$I3941
					$I3940:
;|***           {
; Line 1694
;|***           time_stamp(&dyno_time);
; Line 1695
	*** 00249b	68 00 00 		push	SEG ?dyno_time@@3UTIMER@@E	;dyno_time
	*** 00249e	68 00 00 		push	OFFSET ?dyno_time@@3UTIMER@@E	;dyno_time
	*** 0024a1	9a 00 00 00 00 		call	FAR PTR ?time_stamp@@ZAXPEUTIMER@@@Z	; time_stamp
	*** 0024a6	83 c4 04 		add	sp,4
;|***           
;|***           _fmemcpy(dyno_buffer, dyno_array, sizeof(dyno_array));      // buffer the data
; Line 1697
	*** 0024a9	68 00 01 		push	256	;0100H
	*** 0024ac	1e 			push	ds
	*** 0024ad	68 00 00 		push	OFFSET DGROUP:?dyno_array@@3QIII	;dyno_array
	*** 0024b0	1e 			push	ds
	*** 0024b1	68 00 00 		push	OFFSET DGROUP:?dyno_buffer@@3QIEI	;dyno_buffer
	*** 0024b4	9a 00 00 00 00 		call	FAR PTR __fmemcpy
	*** 0024b9	83 c4 0a 		add	sp,10	;000aH
;|***           dyno_data_frame = frame;                                    // set system flags
; Line 1698
	*** 0024bc	a1 00 00 		mov	ax,WORD PTR ?frame@@3KE	;frame
	*** 0024bf	8b 16 02 00 		mov	dx,WORD PTR ?frame@@3KE+2	;frame
	*** 0024c3	a3 00 00 		mov	WORD PTR ?dyno_data_frame@@3KE,ax	;dyno_data_frame
	*** 0024c6	89 16 02 00 		mov	WORD PTR ?dyno_data_frame@@3KE+2,dx	;dyno_data_frame
;|***           dyno_new_data = 1;
; Line 1699
	*** 0024ca	c7 06 00 00 01 00 	mov	WORD PTR ?dyno_new_data@@3IE,1	;dyno_new_data
;|***           
;|***           mux_addr = 0;                                   // reset the mux addess for next frame 
; Line 1701
	*** 0024d0	c7 06 00 00 00 00 	mov	WORD PTR ?mux_addr@@3IE,0	;mux_addr
;|***           _outp(DYNO_BASE+MCR, PAGE1);
; Line 1702
	*** 0024d6	6a 01 			push	1
	*** 0024d8	68 88 03 		push	904	;0388H
	*** 0024db	9a 00 00 00 00 		call	FAR PTR __outp
	*** 0024e0	83 c4 04 		add	sp,4
;|***           _outp(DYNO_BASE+PORTA, mux_addr);
; Line 1703
	*** 0024e3	ff 36 00 00 		push	WORD PTR ?mux_addr@@3IE	;mux_addr
	*** 0024e7	68 8c 03 		push	908	;038cH
	*** 0024ea	9a 00 00 00 00 		call	FAR PTR __outp
	*** 0024ef	83 c4 04 		add	sp,4
;|***           _outp(DYNO_BASE+MCR, PAGE0);
; Line 1704
	*** 0024f2	6a 00 			push	0
	*** 0024f4	68 88 03 		push	904	;0388H
	*** 0024f7	9a 00 00 00 00 		call	FAR PTR __outp
	*** 0024fc	83 c4 04 		add	sp,4
;|***           
;|***           reading_prop = 1;                                   // do a prop scan next
; Line 1706
	*** 0024ff	c7 06 00 00 01 00 	mov	WORD PTR ?reading_prop@@3IE,1	;reading_prop
;|***           _outp(DYNO_BASE+FCR, _inp(DYNO_BASE+FCR) | FIFORST);// reset the fifo
; Line 1707
	*** 002505	68 87 03 		push	903	;0387H
	*** 002508	9a 00 00 00 00 		call	FAR PTR __inp
	*** 00250d	83 c4 02 		add	sp,2
	*** 002510	0d 02 00 		or	ax,2
	*** 002513	50 			push	ax
	*** 002514	68 87 03 		push	903	;0387H
	*** 002517	9a 00 00 00 00 		call	FAR PTR __outp
	*** 00251c	83 c4 04 		add	sp,4
;|***           _outp(DYNO_BASE+LCR, 16);                           // set range of prop channels
; Line 1708
	*** 00251f	6a 10 			push	16	;0010H
	*** 002521	68 82 03 		push	898	;0382H
	*** 002524	9a 00 00 00 00 		call	FAR PTR __outp
	*** 002529	83 c4 04 		add	sp,4
;|***           _outp(DYNO_BASE+HCR, 21);
; Line 1709
	*** 00252c	6a 15 			push	21	;0015H
	*** 00252e	68 83 03 		push	899	;0383H
	*** 002531	9a 00 00 00 00 		call	FAR PTR __outp
	*** 002536	83 c4 04 		add	sp,4
;|*** 
;|***           // start another 200 usec settling period
;|***           _outp(DYNO_BASE+MCR, PAGE0);                        // access the 82C54's registers
; Line 1712
	*** 002539	6a 00 			push	0
	*** 00253b	68 88 03 		push	904	;0388H
	*** 00253e	9a 00 00 00 00 		call	FAR PTR __outp
	*** 002543	83 c4 04 		add	sp,4
;|***           _outp(DYNO_BASE+15, CTC0 | LSBMSB | MODE0 | BINARY);// set up ctc0
; Line 1713
	*** 002546	6a 30 			push	48	;0030H
	*** 002548	68 8f 03 		push	911	;038fH
	*** 00254b	9a 00 00 00 00 		call	FAR PTR __outp
	*** 002550	83 c4 04 		add	sp,4
;|***           _outp(DYNO_BASE+12, 0xd0);                          // load divisor LSB (2000 or 0x07d0)
; Line 1714
	*** 002553	68 d0 00 		push	208	;00d0H
	*** 002556	68 8c 03 		push	908	;038cH
	*** 002559	9a 00 00 00 00 		call	FAR PTR __outp
	*** 00255e	83 c4 04 		add	sp,4
;|***           _outp(DYNO_BASE+12, 0x07);                          // load divisor MSB
; Line 1715
	*** 002561	6a 07 			push	7
	*** 002563	68 8c 03 		push	908	;038cH
	*** 002566	9a 00 00 00 00 		call	FAR PTR __outp
	*** 00256b	83 c4 04 		add	sp,4
;|***           _outp(DYNO_BASE+ICR, ADINTE | TINTE);               // enable adc & timer interrupts
; Line 1716
	*** 00256e	68 a0 00 		push	160	;00a0H
	*** 002571	68 89 03 		push	905	;0389H
	*** 002574	9a 00 00 00 00 		call	FAR PTR __outp
	*** 002579	83 c4 04 		add	sp,4
;|***           // we will scan the prop dynos when ctc0 generates a TINT irq 200 usec from now
;|***           }
; Line 1718
					$I3941:
;|***         }
; Line 1719
;|***       }
; Line 1720
					$I3936:
					$I3935:
;|***     } // end mux box section
; Line 1721
					$I3930:
;|*** 
;|***   _outp(DYNO_BASE+MCR, INTRST); // reset the dmm32's interrupt circuit    
; Line 1723
	*** 00257c	6a 08 			push	8
	*** 00257e	68 88 03 		push	904	;0388H
	*** 002581	9a 00 00 00 00 		call	FAR PTR __outp
	*** 002586	83 c4 04 		add	sp,4
;|***   _outp(0xa0, 0x20);            // slave  EOI
; Line 1724
	*** 002589	6a 20 			push	32	;0020H
	*** 00258b	68 a0 00 		push	160	;00a0H
	*** 00258e	9a 00 00 00 00 		call	FAR PTR __outp
	*** 002593	83 c4 04 		add	sp,4
;|***   _outp(0x20, 0x20);            // master EOI  
; Line 1725
	*** 002596	6a 20 			push	32	;0020H
	*** 002598	6a 20 			push	32	;0020H
	*** 00259a	9a 00 00 00 00 		call	FAR PTR __outp
	*** 00259f	83 c4 04 		add	sp,4
;|***   // end dmm32b isr
;|***   }
; Line 1727
	*** 0025a2	e9 00 00 		jmp	$EX3914
					$EX3914:
	*** 0025a5	8b e5 			mov	sp,bp
	*** 0025a7	07 			pop	es
	*** 0025a8	1f 			pop	ds
	ASSUME DS: DGROUP
	*** 0025a9	61 			popa
	*** 0025aa	cf 			iret	

?isr_dmm32b@@ZAXXZ	ENDP
	PUBLIC	?sys_timer_isr@@ZAXXZ	; sys_timer_isr
?sys_timer_isr@@ZAXXZ	PROC FAR	; sys_timer_isr
;|***   
;|*** 
;|*** void interrupt sys_timer_isr(void) 
;|***   {                                // every pc timer tick (approx 55 msec)
; Line 1731
	*** 0025ab	60 			pusha
	*** 0025ac	1e 			push	ds
	*** 0025ad	06 			push	es
	*** 0025ae	8b ec 			mov	bp,sp
	*** 0025b0	81 ec 00 00 		sub	sp,0
	*** 0025b4	1e 			push	ds
	*** 0025b5	b8 00 00 		mov	ax,DGROUP
	*** 0025b8	8e d8 			mov	ds,ax
	ASSUME DS: DGROUP
	*** 0025ba	fc 			cld	
;|***   sys_timer.high++;                // increment the high long word of the obc system timer
; Line 1732
	*** 0025bb	8e 06 00 00 		mov	es,WORD PTR $T4111
	*** 0025bf	26 83 06 00 00 01 	add	WORD PTR es:?sys_timer@@3UTIMER@@E,1	;sys_timer
	*** 0025c5	26 83 16 02 00 00 	adc	WORD PTR es:?sys_timer@@3UTIMER@@E+2,0	;sys_timer
;|***   _chain_intr(rtc_vect);           // chain back into the pc's original rtc isr
; Line 1733
	*** 0025cb	ff 36 02 00 		push	WORD PTR ?rtc_vect@@3P7AXXZE+2	;rtc_vect
	*** 0025cf	ff 36 00 00 		push	WORD PTR ?rtc_vect@@3P7AXXZE	;rtc_vect
	*** 0025d3	9a 00 00 00 00 		call	FAR PTR __chain_intr
	*** 0025d8	83 c4 04 		add	sp,4
;|***   }
; Line 1734
	*** 0025db	e9 00 00 		jmp	$EX3943
					$EX3943:
	*** 0025de	8b e5 			mov	sp,bp
	*** 0025e0	07 			pop	es
	*** 0025e1	1f 			pop	ds
	ASSUME DS: DGROUP
	*** 0025e2	61 			popa
	*** 0025e3	cf 			iret	

?sys_timer_isr@@ZAXXZ	ENDP
	PUBLIC	?terminate@@ZAXXZ	; terminate
?terminate@@ZAXXZ	PROC FAR	; terminate
;|***   
;|*** 
;|*** void terminate(void)
;|***   {
; Line 1738
	*** 0025e4	c8 52 00 00 		enter	82,0
	*** 0025e8	57 			push	di
	*** 0025e9	56 			push	si
;	s = -82
;|***   char s[81];
;|***   
;|***   _getch();
; Line 1741
	*** 0025ea	9a 00 00 00 00 		call	FAR PTR __getch
;|***   _disable();
; Line 1742
	*** 0025ef	9a 00 00 00 00 		call	FAR PTR __disable
;|***   shutdown_tech80();
; Line 1743
	*** 0025f4	9a 00 00 00 00 		call	FAR PTR ?shutdown_tech80@@ZAXXZ	; shutdown_tech80
;|***   shutdown_enet();
; Line 1744
	*** 0025f9	9a 00 00 00 00 		call	FAR PTR ?shutdown_enet@@ZAXXZ	; shutdown_enet
;|***   shutdown_com1();
; Line 1745
	*** 0025fe	9a 00 00 00 00 		call	FAR PTR ?shutdown_com1@@ZAXXZ	; shutdown_com1
;|***   shutdown_com2();
; Line 1746
	*** 002603	9a 00 00 00 00 		call	FAR PTR ?shutdown_com2@@ZAXXZ	; shutdown_com2
;|***   shutdown_com4();
; Line 1747
	*** 002608	9a 00 00 00 00 		call	FAR PTR ?shutdown_com4@@ZAXXZ	; shutdown_com4
;|***   shutdown_dmm32a();
; Line 1748
	*** 00260d	9a 00 00 00 00 		call	FAR PTR ?shutdown_dmm32a@@ZAXXZ	; shutdown_dmm32a
;|***   shutdown_dmm32b();
; Line 1749
	*** 002612	9a 00 00 00 00 		call	FAR PTR ?shutdown_dmm32b@@ZAXXZ	; shutdown_dmm32b
;|***   shutdown_escc();
; Line 1750
	*** 002617	9a 00 00 00 00 		call	FAR PTR ?shutdown_escc@@ZAXXZ	; shutdown_escc
;|***   shutdown_sys_timer();
; Line 1751
	*** 00261c	9a 00 00 00 00 		call	FAR PTR ?shutdown_sys_timer@@ZAXXZ	; shutdown_sys_timer
;|***   _enable();
; Line 1752
	*** 002621	9a 00 00 00 00 		call	FAR PTR __enable
;|***   
;|***   // put the times on screen
;|***         sprintf(s, "%s%8lu %5u%s%8lu", "Frame start:   ",
;|***           frame_time.high, frame_time.low, "    Frame # ", frame);
; Line 1756
	*** 002626	ff 36 02 00 		push	WORD PTR ?frame@@3KE+2	;frame
	*** 00262a	ff 36 00 00 		push	WORD PTR ?frame@@3KE	;frame
	*** 00262e	1e 			push	ds
	*** 00262f	68 00 00 		push	OFFSET DGROUP:$SG3947
	*** 002632	8e 06 00 00 		mov	es,WORD PTR $T4111
	*** 002636	26 ff 36 04 00 		push	WORD PTR es:?frame_time@@3UTIMER@@E+4	;frame_time
	*** 00263b	26 ff 36 02 00 		push	WORD PTR es:?frame_time@@3UTIMER@@E+2	;frame_time
	*** 002640	26 ff 36 00 00 		push	WORD PTR es:?frame_time@@3UTIMER@@E	;frame_time
	*** 002645	1e 			push	ds
	*** 002646	68 00 00 		push	OFFSET DGROUP:$SG3948
	*** 002649	1e 			push	ds
	*** 00264a	68 00 00 		push	OFFSET DGROUP:$SG3949
	*** 00264d	8d 46 ae 		lea	ax,WORD PTR [bp-82]	;s
	*** 002650	16 			push	ss
	*** 002651	50 			push	ax
	*** 002652	9a 00 00 00 00 		call	FAR PTR _sprintf
	*** 002657	83 c4 1a 		add	sp,26	;001aH
;|***         PC_DispStr(0,6, (unsigned char *)s, DISP_FGND_BLACK + DISP_BGND_LIGHT_GRAY);  
; Line 1757
	*** 00265a	6a 70 			push	112	;0070H
	*** 00265c	8d 46 ae 		lea	ax,WORD PTR [bp-82]	;s
	*** 00265f	16 			push	ss
	*** 002660	50 			push	ax
	*** 002661	6a 06 			push	6
	*** 002663	6a 00 			push	0
	*** 002665	9a 00 00 00 00 		call	FAR PTR ?PC_DispStr@@ZAXEEPIEE@Z	; PC_DispStr
	*** 00266a	83 c4 0a 		add	sp,10	;000aH
;|*** 
;|***         sprintf(s, "%s%8lu %5u", "OBS data:      ",
;|***           obs_time.high, obs_time.low);
; Line 1760
	*** 00266d	8e 06 00 00 		mov	es,WORD PTR $T4111
	*** 002671	26 ff 36 04 00 		push	WORD PTR es:?obs_time@@3UTIMER@@E+4	;obs_time
	*** 002676	26 ff 36 02 00 		push	WORD PTR es:?obs_time@@3UTIMER@@E+2	;obs_time
	*** 00267b	26 ff 36 00 00 		push	WORD PTR es:?obs_time@@3UTIMER@@E	;obs_time
	*** 002680	1e 			push	ds
	*** 002681	68 00 00 		push	OFFSET DGROUP:$SG3951
	*** 002684	1e 			push	ds
	*** 002685	68 00 00 		push	OFFSET DGROUP:$SG3952
	*** 002688	8d 46 ae 		lea	ax,WORD PTR [bp-82]	;s
	*** 00268b	16 			push	ss
	*** 00268c	50 			push	ax
	*** 00268d	9a 00 00 00 00 		call	FAR PTR _sprintf
	*** 002692	83 c4 12 		add	sp,18	;0012H
;|***         PC_DispStr(0,7, (unsigned char *)s, DISP_FGND_BLACK + DISP_BGND_LIGHT_GRAY);
; Line 1761
	*** 002695	6a 70 			push	112	;0070H
	*** 002697	8d 46 ae 		lea	ax,WORD PTR [bp-82]	;s
	*** 00269a	16 			push	ss
	*** 00269b	50 			push	ax
	*** 00269c	6a 07 			push	7
	*** 00269e	6a 00 			push	0
	*** 0026a0	9a 00 00 00 00 		call	FAR PTR ?PC_DispStr@@ZAXEEPIEE@Z	; PC_DispStr
	*** 0026a5	83 c4 0a 		add	sp,10	;000aH
;|*** 
;|***         sprintf(s, "%s%8lu %5u", "Dyno data:     ",
;|***           dyno_time.high, dyno_time.low);
; Line 1764
	*** 0026a8	8e 06 00 00 		mov	es,WORD PTR $T4111
	*** 0026ac	26 ff 36 04 00 		push	WORD PTR es:?dyno_time@@3UTIMER@@E+4	;dyno_time
	*** 0026b1	26 ff 36 02 00 		push	WORD PTR es:?dyno_time@@3UTIMER@@E+2	;dyno_time
	*** 0026b6	26 ff 36 00 00 		push	WORD PTR es:?dyno_time@@3UTIMER@@E	;dyno_time
	*** 0026bb	1e 			push	ds
	*** 0026bc	68 00 00 		push	OFFSET DGROUP:$SG3954
	*** 0026bf	1e 			push	ds
	*** 0026c0	68 00 00 		push	OFFSET DGROUP:$SG3955
	*** 0026c3	8d 46 ae 		lea	ax,WORD PTR [bp-82]	;s
	*** 0026c6	16 			push	ss
	*** 0026c7	50 			push	ax
	*** 0026c8	9a 00 00 00 00 		call	FAR PTR _sprintf
	*** 0026cd	83 c4 12 		add	sp,18	;0012H
;|***         PC_DispStr(0,8, (unsigned char *)s, DISP_FGND_BLACK + DISP_BGND_LIGHT_GRAY);
; Line 1765
	*** 0026d0	6a 70 			push	112	;0070H
	*** 0026d2	8d 46 ae 		lea	ax,WORD PTR [bp-82]	;s
	*** 0026d5	16 			push	ss
	*** 0026d6	50 			push	ax
	*** 0026d7	6a 08 			push	8
	*** 0026d9	6a 00 			push	0
	*** 0026db	9a 00 00 00 00 		call	FAR PTR ?PC_DispStr@@ZAXEEPIEE@Z	; PC_DispStr
	*** 0026e0	83 c4 0a 		add	sp,10	;000aH
;|*** 
;|***         sprintf(s, "%s%8lu %5u", "Prop adc:      ",
;|***           prop_adc_time.high, prop_adc_time.low);
; Line 1768
	*** 0026e3	8e 06 00 00 		mov	es,WORD PTR $T4111
	*** 0026e7	26 ff 36 04 00 		push	WORD PTR es:?prop_adc_time@@3UTIMER@@E+4	;prop_adc_time
	*** 0026ec	26 ff 36 02 00 		push	WORD PTR es:?prop_adc_time@@3UTIMER@@E+2	;prop_adc_time
	*** 0026f1	26 ff 36 00 00 		push	WORD PTR es:?prop_adc_time@@3UTIMER@@E	;prop_adc_time
	*** 0026f6	1e 			push	ds
	*** 0026f7	68 00 00 		push	OFFSET DGROUP:$SG3957
	*** 0026fa	1e 			push	ds
	*** 0026fb	68 00 00 		push	OFFSET DGROUP:$SG3958
	*** 0026fe	8d 46 ae 		lea	ax,WORD PTR [bp-82]	;s
	*** 002701	16 			push	ss
	*** 002702	50 			push	ax
	*** 002703	9a 00 00 00 00 		call	FAR PTR _sprintf
	*** 002708	83 c4 12 		add	sp,18	;0012H
;|***         PC_DispStr(0,9, (unsigned char *)s, DISP_FGND_BLACK + DISP_BGND_LIGHT_GRAY);
; Line 1769
	*** 00270b	6a 70 			push	112	;0070H
	*** 00270d	8d 46 ae 		lea	ax,WORD PTR [bp-82]	;s
	*** 002710	16 			push	ss
	*** 002711	50 			push	ax
	*** 002712	6a 09 			push	9
	*** 002714	6a 00 			push	0
	*** 002716	9a 00 00 00 00 		call	FAR PTR ?PC_DispStr@@ZAXEEPIEE@Z	; PC_DispStr
	*** 00271b	83 c4 0a 		add	sp,10	;000aH
;|*** 
;|***         sprintf(s, "%s%8lu %5u", "Prop position: ",
;|***           prop_position_time.high, prop_position_time.low);
; Line 1772
	*** 00271e	8e 06 00 00 		mov	es,WORD PTR $T4111
	*** 002722	26 ff 36 04 00 		push	WORD PTR es:?prop_position_time@@3UTIMER@@E+4	;prop_position_time
	*** 002727	26 ff 36 02 00 		push	WORD PTR es:?prop_position_time@@3UTIMER@@E+2	;prop_position_time
	*** 00272c	26 ff 36 00 00 		push	WORD PTR es:?prop_position_time@@3UTIMER@@E	;prop_position_time
	*** 002731	1e 			push	ds
	*** 002732	68 00 00 		push	OFFSET DGROUP:$SG3960
	*** 002735	1e 			push	ds
	*** 002736	68 00 00 		push	OFFSET DGROUP:$SG3961
	*** 002739	8d 46 ae 		lea	ax,WORD PTR [bp-82]	;s
	*** 00273c	16 			push	ss
	*** 00273d	50 			push	ax
	*** 00273e	9a 00 00 00 00 		call	FAR PTR _sprintf
	*** 002743	83 c4 12 		add	sp,18	;0012H
;|***         PC_DispStr(0,10, (unsigned char *)s, DISP_FGND_BLACK + DISP_BGND_LIGHT_GRAY);
; Line 1773
	*** 002746	6a 70 			push	112	;0070H
	*** 002748	8d 46 ae 		lea	ax,WORD PTR [bp-82]	;s
	*** 00274b	16 			push	ss
	*** 00274c	50 			push	ax
	*** 00274d	6a 0a 			push	10	;000aH
	*** 00274f	6a 00 			push	0
	*** 002751	9a 00 00 00 00 		call	FAR PTR ?PC_DispStr@@ZAXEEPIEE@Z	; PC_DispStr
	*** 002756	83 c4 0a 		add	sp,10	;000aH
;|*** 
;|***         sprintf(s, "%s%8lu %5u", "Commands rcvd: ",
;|***           cmds_time.high, cmds_time.low);
; Line 1776
	*** 002759	8e 06 00 00 		mov	es,WORD PTR $T4111
	*** 00275d	26 ff 36 04 00 		push	WORD PTR es:?cmds_time@@3UTIMER@@E+4	;cmds_time
	*** 002762	26 ff 36 02 00 		push	WORD PTR es:?cmds_time@@3UTIMER@@E+2	;cmds_time
	*** 002767	26 ff 36 00 00 		push	WORD PTR es:?cmds_time@@3UTIMER@@E	;cmds_time
	*** 00276c	1e 			push	ds
	*** 00276d	68 00 00 		push	OFFSET DGROUP:$SG3963
	*** 002770	1e 			push	ds
	*** 002771	68 00 00 		push	OFFSET DGROUP:$SG3964
	*** 002774	8d 46 ae 		lea	ax,WORD PTR [bp-82]	;s
	*** 002777	16 			push	ss
	*** 002778	50 			push	ax
	*** 002779	9a 00 00 00 00 		call	FAR PTR _sprintf
	*** 00277e	83 c4 12 		add	sp,18	;0012H
;|***         PC_DispStr(0,11, (unsigned char *)s, DISP_FGND_BLACK + DISP_BGND_LIGHT_GRAY);
; Line 1777
	*** 002781	6a 70 			push	112	;0070H
	*** 002783	8d 46 ae 		lea	ax,WORD PTR [bp-82]	;s
	*** 002786	16 			push	ss
	*** 002787	50 			push	ax
	*** 002788	6a 0b 			push	11	;000bH
	*** 00278a	6a 00 			push	0
	*** 00278c	9a 00 00 00 00 		call	FAR PTR ?PC_DispStr@@ZAXEEPIEE@Z	; PC_DispStr
	*** 002791	83 c4 0a 		add	sp,10	;000aH
;|*** 
;|***         sprintf(s, "%s%8lu %5u", "ADCP rcvd:     ",
;|***           adcp_time.high, adcp_time.low);
; Line 1780
	*** 002794	8e 06 00 00 		mov	es,WORD PTR $T4111
	*** 002798	26 ff 36 04 00 		push	WORD PTR es:?adcp_time@@3UTIMER@@E+4	;adcp_time
	*** 00279d	26 ff 36 02 00 		push	WORD PTR es:?adcp_time@@3UTIMER@@E+2	;adcp_time
	*** 0027a2	26 ff 36 00 00 		push	WORD PTR es:?adcp_time@@3UTIMER@@E	;adcp_time
	*** 0027a7	1e 			push	ds
	*** 0027a8	68 00 00 		push	OFFSET DGROUP:$SG3966
	*** 0027ab	1e 			push	ds
	*** 0027ac	68 00 00 		push	OFFSET DGROUP:$SG3967
	*** 0027af	8d 46 ae 		lea	ax,WORD PTR [bp-82]	;s
	*** 0027b2	16 			push	ss
	*** 0027b3	50 			push	ax
	*** 0027b4	9a 00 00 00 00 		call	FAR PTR _sprintf
	*** 0027b9	83 c4 12 		add	sp,18	;0012H
;|***         PC_DispStr(0,12, (unsigned char *)s, DISP_FGND_BLACK + DISP_BGND_LIGHT_GRAY);
; Line 1781
	*** 0027bc	6a 70 			push	112	;0070H
	*** 0027be	8d 46 ae 		lea	ax,WORD PTR [bp-82]	;s
	*** 0027c1	16 			push	ss
	*** 0027c2	50 			push	ax
	*** 0027c3	6a 0c 			push	12	;000cH
	*** 0027c5	6a 00 			push	0
	*** 0027c7	9a 00 00 00 00 		call	FAR PTR ?PC_DispStr@@ZAXEEPIEE@Z	; PC_DispStr
	*** 0027cc	83 c4 0a 		add	sp,10	;000aH
;|*** 
;|***         sprintf(s, "%s%8lu %5u", "DS rcvd:       ",
;|***           ds_time.high, ds_time.low);
; Line 1784
	*** 0027cf	8e 06 00 00 		mov	es,WORD PTR $T4111
	*** 0027d3	26 ff 36 04 00 		push	WORD PTR es:?ds_time@@3UTIMER@@E+4	;ds_time
	*** 0027d8	26 ff 36 02 00 		push	WORD PTR es:?ds_time@@3UTIMER@@E+2	;ds_time
	*** 0027dd	26 ff 36 00 00 		push	WORD PTR es:?ds_time@@3UTIMER@@E	;ds_time
	*** 0027e2	1e 			push	ds
	*** 0027e3	68 00 00 		push	OFFSET DGROUP:$SG3969
	*** 0027e6	1e 			push	ds
	*** 0027e7	68 00 00 		push	OFFSET DGROUP:$SG3970
	*** 0027ea	8d 46 ae 		lea	ax,WORD PTR [bp-82]	;s
	*** 0027ed	16 			push	ss
	*** 0027ee	50 			push	ax
	*** 0027ef	9a 00 00 00 00 		call	FAR PTR _sprintf
	*** 0027f4	83 c4 12 		add	sp,18	;0012H
;|***         PC_DispStr(0,13, (unsigned char *)s, DISP_FGND_BLACK + DISP_BGND_LIGHT_GRAY);
; Line 1785
	*** 0027f7	6a 70 			push	112	;0070H
	*** 0027f9	8d 46 ae 		lea	ax,WORD PTR [bp-82]	;s
	*** 0027fc	16 			push	ss
	*** 0027fd	50 			push	ax
	*** 0027fe	6a 0d 			push	13	;000dH
	*** 002800	6a 00 			push	0
	*** 002802	9a 00 00 00 00 		call	FAR PTR ?PC_DispStr@@ZAXEEPIEE@Z	; PC_DispStr
	*** 002807	83 c4 0a 		add	sp,10	;000aH
;|***         
;|***         sprintf(s, "%s%8lu %5u%s%8lu ", "LN200 rcvd:    ",
;|***           ln200_time.high, ln200_time.low, "    LN200 # ", ln200_rx_num);
; Line 1788
	*** 00280a	ff 36 02 00 		push	WORD PTR ?ln200_rx_num@@3KE+2	;ln200_rx_num
	*** 00280e	ff 36 00 00 		push	WORD PTR ?ln200_rx_num@@3KE	;ln200_rx_num
	*** 002812	1e 			push	ds
	*** 002813	68 00 00 		push	OFFSET DGROUP:$SG3972
	*** 002816	8e 06 00 00 		mov	es,WORD PTR $T4111
	*** 00281a	26 ff 36 04 00 		push	WORD PTR es:?ln200_time@@3UTIMER@@E+4	;ln200_time
	*** 00281f	26 ff 36 02 00 		push	WORD PTR es:?ln200_time@@3UTIMER@@E+2	;ln200_time
	*** 002824	26 ff 36 00 00 		push	WORD PTR es:?ln200_time@@3UTIMER@@E	;ln200_time
	*** 002829	1e 			push	ds
	*** 00282a	68 00 00 		push	OFFSET DGROUP:$SG3973
	*** 00282d	1e 			push	ds
	*** 00282e	68 00 00 		push	OFFSET DGROUP:$SG3974
	*** 002831	8d 46 ae 		lea	ax,WORD PTR [bp-82]	;s
	*** 002834	16 			push	ss
	*** 002835	50 			push	ax
	*** 002836	9a 00 00 00 00 		call	FAR PTR _sprintf
	*** 00283b	83 c4 1a 		add	sp,26	;001aH
;|***         PC_DispStr(0,14, (unsigned char *)s, DISP_FGND_BLACK + DISP_BGND_LIGHT_GRAY);
; Line 1789
	*** 00283e	6a 70 			push	112	;0070H
	*** 002840	8d 46 ae 		lea	ax,WORD PTR [bp-82]	;s
	*** 002843	16 			push	ss
	*** 002844	50 			push	ax
	*** 002845	6a 0e 			push	14	;000eH
	*** 002847	6a 00 			push	0
	*** 002849	9a 00 00 00 00 		call	FAR PTR ?PC_DispStr@@ZAXEEPIEE@Z	; PC_DispStr
	*** 00284e	83 c4 0a 		add	sp,10	;000aH
;|***         
;|***         sprintf(s, "%s%lu", "Received packets: ", packets_rcvd);          
; Line 1791
	*** 002851	ff 36 02 00 		push	WORD PTR ?packets_rcvd@@3KE+2	;packets_rcvd
	*** 002855	ff 36 00 00 		push	WORD PTR ?packets_rcvd@@3KE	;packets_rcvd
	*** 002859	1e 			push	ds
	*** 00285a	68 00 00 		push	OFFSET DGROUP:$SG3976
	*** 00285d	1e 			push	ds
	*** 00285e	68 00 00 		push	OFFSET DGROUP:$SG3977
	*** 002861	8d 46 ae 		lea	ax,WORD PTR [bp-82]	;s
	*** 002864	16 			push	ss
	*** 002865	50 			push	ax
	*** 002866	9a 00 00 00 00 		call	FAR PTR _sprintf
	*** 00286b	83 c4 10 		add	sp,16	;0010H
;|***         PC_DispStr(0,15, (unsigned char *)s, DISP_FGND_BLACK + DISP_BGND_LIGHT_GRAY);
; Line 1792
	*** 00286e	6a 70 			push	112	;0070H
	*** 002870	8d 46 ae 		lea	ax,WORD PTR [bp-82]	;s
	*** 002873	16 			push	ss
	*** 002874	50 			push	ax
	*** 002875	6a 0f 			push	15	;000fH
	*** 002877	6a 00 			push	0
	*** 002879	9a 00 00 00 00 		call	FAR PTR ?PC_DispStr@@ZAXEEPIEE@Z	; PC_DispStr
	*** 00287e	83 c4 0a 		add	sp,10	;000aH
;|*** 
;|***         sprintf(s, "%s%lu", "Ax0 count:        ", ax0_counter);          
; Line 1794
	*** 002881	ff 36 02 00 		push	WORD PTR ?ax0_counter@@3KE+2	;ax0_counter
	*** 002885	ff 36 00 00 		push	WORD PTR ?ax0_counter@@3KE	;ax0_counter
	*** 002889	1e 			push	ds
	*** 00288a	68 00 00 		push	OFFSET DGROUP:$SG3979
	*** 00288d	1e 			push	ds
	*** 00288e	68 00 00 		push	OFFSET DGROUP:$SG3980
	*** 002891	8d 46 ae 		lea	ax,WORD PTR [bp-82]	;s
	*** 002894	16 			push	ss
	*** 002895	50 			push	ax
	*** 002896	9a 00 00 00 00 		call	FAR PTR _sprintf
	*** 00289b	83 c4 10 		add	sp,16	;0010H
;|***         PC_DispStr(0,16, (unsigned char *)s, DISP_FGND_BLACK + DISP_BGND_LIGHT_GRAY);
; Line 1795
	*** 00289e	6a 70 			push	112	;0070H
	*** 0028a0	8d 46 ae 		lea	ax,WORD PTR [bp-82]	;s
	*** 0028a3	16 			push	ss
	*** 0028a4	50 			push	ax
	*** 0028a5	6a 10 			push	16	;0010H
	*** 0028a7	6a 00 			push	0
	*** 0028a9	9a 00 00 00 00 		call	FAR PTR ?PC_DispStr@@ZAXEEPIEE@Z	; PC_DispStr
	*** 0028ae	83 c4 0a 		add	sp,10	;000aH
;|***         
;|***         sprintf(s, "%s%lu", "Ax1 count:        ", ax1_counter);          
; Line 1797
	*** 0028b1	ff 36 02 00 		push	WORD PTR ?ax1_counter@@3KE+2	;ax1_counter
	*** 0028b5	ff 36 00 00 		push	WORD PTR ?ax1_counter@@3KE	;ax1_counter
	*** 0028b9	1e 			push	ds
	*** 0028ba	68 00 00 		push	OFFSET DGROUP:$SG3982
	*** 0028bd	1e 			push	ds
	*** 0028be	68 00 00 		push	OFFSET DGROUP:$SG3983
	*** 0028c1	8d 46 ae 		lea	ax,WORD PTR [bp-82]	;s
	*** 0028c4	16 			push	ss
	*** 0028c5	50 			push	ax
	*** 0028c6	9a 00 00 00 00 		call	FAR PTR _sprintf
	*** 0028cb	83 c4 10 		add	sp,16	;0010H
;|***         PC_DispStr(0,17, (unsigned char *)s, DISP_FGND_BLACK + DISP_BGND_LIGHT_GRAY);
; Line 1798
	*** 0028ce	6a 70 			push	112	;0070H
	*** 0028d0	8d 46 ae 		lea	ax,WORD PTR [bp-82]	;s
	*** 0028d3	16 			push	ss
	*** 0028d4	50 			push	ax
	*** 0028d5	6a 11 			push	17	;0011H
	*** 0028d7	6a 00 			push	0
	*** 0028d9	9a 00 00 00 00 		call	FAR PTR ?PC_DispStr@@ZAXEEPIEE@Z	; PC_DispStr
	*** 0028de	83 c4 0a 		add	sp,10	;000aH
;|***         
;|***         sprintf(s, "%s%lu", "Discards:         ", discards);          
; Line 1800
	*** 0028e1	ff 36 02 00 		push	WORD PTR ?discards@@3KE+2	;discards
	*** 0028e5	ff 36 00 00 		push	WORD PTR ?discards@@3KE	;discards
	*** 0028e9	1e 			push	ds
	*** 0028ea	68 00 00 		push	OFFSET DGROUP:$SG3985
	*** 0028ed	1e 			push	ds
	*** 0028ee	68 00 00 		push	OFFSET DGROUP:$SG3986
	*** 0028f1	8d 46 ae 		lea	ax,WORD PTR [bp-82]	;s
	*** 0028f4	16 			push	ss
	*** 0028f5	50 			push	ax
	*** 0028f6	9a 00 00 00 00 		call	FAR PTR _sprintf
	*** 0028fb	83 c4 10 		add	sp,16	;0010H
;|***         PC_DispStr(0,18, (unsigned char *)s, DISP_FGND_BLACK + DISP_BGND_LIGHT_GRAY);
; Line 1801
	*** 0028fe	6a 70 			push	112	;0070H
	*** 002900	8d 46 ae 		lea	ax,WORD PTR [bp-82]	;s
	*** 002903	16 			push	ss
	*** 002904	50 			push	ax
	*** 002905	6a 12 			push	18	;0012H
	*** 002907	6a 00 			push	0
	*** 002909	9a 00 00 00 00 		call	FAR PTR ?PC_DispStr@@ZAXEEPIEE@Z	; PC_DispStr
	*** 00290e	83 c4 0a 		add	sp,10	;000aH
;|*** 
;|***         sprintf(s, "%s%lu", "Receiver calls:   ", receiver_calls);          
; Line 1803
	*** 002911	ff 36 02 00 		push	WORD PTR ?receiver_calls@@3KE+2	;receiver_calls
	*** 002915	ff 36 00 00 		push	WORD PTR ?receiver_calls@@3KE	;receiver_calls
	*** 002919	1e 			push	ds
	*** 00291a	68 00 00 		push	OFFSET DGROUP:$SG3988
	*** 00291d	1e 			push	ds
	*** 00291e	68 00 00 		push	OFFSET DGROUP:$SG3989
	*** 002921	8d 46 ae 		lea	ax,WORD PTR [bp-82]	;s
	*** 002924	16 			push	ss
	*** 002925	50 			push	ax
	*** 002926	9a 00 00 00 00 		call	FAR PTR _sprintf
	*** 00292b	83 c4 10 		add	sp,16	;0010H
;|***         PC_DispStr(0,19, (unsigned char *)s, DISP_FGND_BLACK + DISP_BGND_LIGHT_GRAY);
; Line 1804
	*** 00292e	6a 70 			push	112	;0070H
	*** 002930	8d 46 ae 		lea	ax,WORD PTR [bp-82]	;s
	*** 002933	16 			push	ss
	*** 002934	50 			push	ax
	*** 002935	6a 13 			push	19	;0013H
	*** 002937	6a 00 			push	0
	*** 002939	9a 00 00 00 00 		call	FAR PTR ?PC_DispStr@@ZAXEEPIEE@Z	; PC_DispStr
	*** 00293e	83 c4 0a 		add	sp,10	;000aH
;|*** 
;|***   }
; Line 1806
	*** 002941	e9 00 00 		jmp	$EX3945
					$EX3945:
	*** 002944	5e 			pop	si
	*** 002945	5f 			pop	di
	*** 002946	c9 			leave	
	*** 002947	cb 			ret	

?terminate@@ZAXXZ	ENDP
	PUBLIC	?shutdown_sys_timer@@ZAXXZ	; shutdown_sys_timer
?shutdown_sys_timer@@ZAXXZ	PROC FAR	; shutdown_sys_timer
;|*** 
;|*** void shutdown_sys_timer(void)
;|***   {  // restore pc's default system timer isr
; Line 1809
	*** 002948	c8 00 00 00 		enter	0,0
	*** 00294c	57 			push	di
	*** 00294d	56 			push	si
;|***   _disable();
; Line 1810
	*** 00294e	9a 00 00 00 00 		call	FAR PTR __disable
;|***   _dos_setvect(0x08, rtc_vect);
; Line 1811
	*** 002953	ff 36 02 00 		push	WORD PTR ?rtc_vect@@3P7AXXZE+2	;rtc_vect
	*** 002957	ff 36 00 00 		push	WORD PTR ?rtc_vect@@3P7AXXZE	;rtc_vect
	*** 00295b	6a 08 			push	8
	*** 00295d	9a 00 00 00 00 		call	FAR PTR __dos_setvect
	*** 002962	83 c4 06 		add	sp,6
;|***   _enable();
; Line 1812
	*** 002965	9a 00 00 00 00 		call	FAR PTR __enable
;|***   }
; Line 1813
	*** 00296a	e9 00 00 		jmp	$EX3992
					$EX3992:
	*** 00296d	5e 			pop	si
	*** 00296e	5f 			pop	di
	*** 00296f	c9 			leave	
	*** 002970	cb 			ret	

?shutdown_sys_timer@@ZAXXZ	ENDP
	PUBLIC	?shutdown_enet@@ZAXXZ	; shutdown_enet
?shutdown_enet@@ZAXXZ	PROC FAR	; shutdown_enet
;|*** 
;|*** void shutdown_enet(void)
;|***   {
; Line 1816
	*** 002971	c8 00 00 00 		enter	0,0
	*** 002975	57 			push	di
	*** 002976	56 			push	si
;|*** /*  while(handle > 0)  // use with at/lantic pkt driver
;|***     {
;|***     release_type(handle);
;|***     handle--;
;|***     }
;|***     
;|*** */    
;|***   terminate(handle);  // use with the ne2000 driver
; Line 1824
	*** 002977	ff 36 00 00 		push	WORD PTR ?handle@@3HE	;handle
	*** 00297b	9a 00 00 00 00 		call	FAR PTR ?terminate@@ZAHH@Z	; terminate
	*** 002980	83 c4 02 		add	sp,2
;|***   }    
; Line 1825
	*** 002983	e9 00 00 		jmp	$EX3994
					$EX3994:
	*** 002986	5e 			pop	si
	*** 002987	5f 			pop	di
	*** 002988	c9 			leave	
	*** 002989	cb 			ret	

?shutdown_enet@@ZAXXZ	ENDP
	PUBLIC	?shutdown_tech80@@ZAXXZ	; shutdown_tech80
?shutdown_tech80@@ZAXXZ	PROC FAR	; shutdown_tech80
;|***   
;|***   
;|*** void shutdown_tech80(void)
;|***   {
; Line 1829
	*** 00298a	c8 00 00 00 		enter	0,0
	*** 00298e	57 			push	di
	*** 00298f	56 			push	si
;|***   te5650SetAxis(1,STBD_PROP);
; Line 1830
	*** 002990	6a 01 			push	1
	*** 002992	6a 01 			push	1
	*** 002994	9a 00 00 00 00 		call	FAR PTR _te5650SetAxis
	*** 002999	83 c4 04 		add	sp,4
;|***   te5650SetMotor(0);
; Line 1831
	*** 00299c	6a 00 			push	0
	*** 00299e	9a 00 00 00 00 		call	FAR PTR _te5650SetMotor
	*** 0029a3	83 c4 02 		add	sp,2
;|***   te5650Update();
; Line 1832
	*** 0029a6	9a 00 00 00 00 		call	FAR PTR _te5650Update
;|***   te5650SetAxis(1,PORT_PROP);
; Line 1833
	*** 0029ab	6a 02 			push	2
	*** 0029ad	6a 01 			push	1
	*** 0029af	9a 00 00 00 00 		call	FAR PTR _te5650SetAxis
	*** 0029b4	83 c4 04 		add	sp,4
;|***   te5650SetMotor(0);
; Line 1834
	*** 0029b7	6a 00 			push	0
	*** 0029b9	9a 00 00 00 00 		call	FAR PTR _te5650SetMotor
	*** 0029be	83 c4 02 		add	sp,2
;|***   te5650Update();  
; Line 1835
	*** 0029c1	9a 00 00 00 00 		call	FAR PTR _te5650Update
;|***   }
; Line 1836
	*** 0029c6	e9 00 00 		jmp	$EX3996
					$EX3996:
	*** 0029c9	5e 			pop	si
	*** 0029ca	5f 			pop	di
	*** 0029cb	c9 			leave	
	*** 0029cc	cb 			ret	

?shutdown_tech80@@ZAXXZ	ENDP
	PUBLIC	?shutdown_dmm32a@@ZAXXZ	; shutdown_dmm32a
?shutdown_dmm32a@@ZAXXZ	PROC FAR	; shutdown_dmm32a
;|***   
;|*** 
;|*** void shutdown_dmm32a(void)
;|***   {                                           // onboard sensors, irq 11
; Line 1840
	*** 0029cd	c8 00 00 00 		enter	0,0
	*** 0029d1	57 			push	di
	*** 0029d2	56 			push	si
;|***   _outp(OBS_BASE+ICR, 0x00);                  // disable interrupts on the dmm32
; Line 1841
	*** 0029d3	6a 00 			push	0
	*** 0029d5	68 49 03 		push	841	;0349H
	*** 0029d8	9a 00 00 00 00 		call	FAR PTR __outp
	*** 0029dd	83 c4 04 		add	sp,4
;|***   _disable();
; Line 1842
	*** 0029e0	9a 00 00 00 00 		call	FAR PTR __disable
;|***   _outp(OBS_BASE+MCR, 0x20);                  // apply dmm32 master reset
; Line 1843
	*** 0029e5	6a 20 			push	32	;0020H
	*** 0029e7	68 48 03 		push	840	;0348H
	*** 0029ea	9a 00 00 00 00 		call	FAR PTR __outp
	*** 0029ef	83 c4 04 		add	sp,4
;|***   _outp(0xa1, _inp(0xa1) | ~0xf7);            // mask off irq 11 at the pic
; Line 1844
	*** 0029f2	68 a1 00 		push	161	;00a1H
	*** 0029f5	9a 00 00 00 00 		call	FAR PTR __inp
	*** 0029fa	83 c4 02 		add	sp,2
	*** 0029fd	0d 08 ff 		or	ax,-248	;ff08H
	*** 002a00	50 			push	ax
	*** 002a01	68 a1 00 		push	161	;00a1H
	*** 002a04	9a 00 00 00 00 		call	FAR PTR __outp
	*** 002a09	83 c4 04 		add	sp,4
;|***   _dos_setvect(11-8+0x70, old_dmm32a_vect);   // rehook previous irq handler
; Line 1845
	*** 002a0c	ff 36 02 00 		push	WORD PTR ?old_dmm32a_vect@@3P7AXXZE+2	;old_dmm32a_vect
	*** 002a10	ff 36 00 00 		push	WORD PTR ?old_dmm32a_vect@@3P7AXXZE	;old_dmm32a_vect
	*** 002a14	6a 73 			push	115	;0073H
	*** 002a16	9a 00 00 00 00 		call	FAR PTR __dos_setvect
	*** 002a1b	83 c4 06 		add	sp,6
;|***   _enable();
; Line 1846
	*** 002a1e	9a 00 00 00 00 		call	FAR PTR __enable
;|***   }
; Line 1847
	*** 002a23	e9 00 00 		jmp	$EX3998
					$EX3998:
	*** 002a26	5e 			pop	si
	*** 002a27	5f 			pop	di
	*** 002a28	c9 			leave	
	*** 002a29	cb 			ret	

?shutdown_dmm32a@@ZAXXZ	ENDP
	PUBLIC	?shutdown_dmm32b@@ZAXXZ	; shutdown_dmm32b
?shutdown_dmm32b@@ZAXXZ	PROC FAR	; shutdown_dmm32b
;|*** 
;|*** 
;|*** void shutdown_dmm32b(void)
;|***   {                                           // dyno, irq 12
; Line 1851
	*** 002a2a	c8 00 00 00 		enter	0,0
	*** 002a2e	57 			push	di
	*** 002a2f	56 			push	si
;|***   _outp(DYNO_BASE+ICR, 0x00);                 // disable interrupts on the dmm32
; Line 1852
	*** 002a30	6a 00 			push	0
	*** 002a32	68 89 03 		push	905	;0389H
	*** 002a35	9a 00 00 00 00 		call	FAR PTR __outp
	*** 002a3a	83 c4 04 		add	sp,4
;|***   _disable();
; Line 1853
	*** 002a3d	9a 00 00 00 00 		call	FAR PTR __disable
;|***   _outp(DYNO_BASE+MCR, 0x20);                 // apply dmm32 master reset
; Line 1854
	*** 002a42	6a 20 			push	32	;0020H
	*** 002a44	68 88 03 		push	904	;0388H
	*** 002a47	9a 00 00 00 00 		call	FAR PTR __outp
	*** 002a4c	83 c4 04 		add	sp,4
;|***   _outp(0xa1, _inp(0xa1) | ~0xef);            // mask off irq 12 at the pic
; Line 1855
	*** 002a4f	68 a1 00 		push	161	;00a1H
	*** 002a52	9a 00 00 00 00 		call	FAR PTR __inp
	*** 002a57	83 c4 02 		add	sp,2
	*** 002a5a	0d 10 ff 		or	ax,-240	;ff10H
	*** 002a5d	50 			push	ax
	*** 002a5e	68 a1 00 		push	161	;00a1H
	*** 002a61	9a 00 00 00 00 		call	FAR PTR __outp
	*** 002a66	83 c4 04 		add	sp,4
;|***   _dos_setvect(12-8+0x70, old_dmm32b_vect);   // rehook previous irq handler
; Line 1856
	*** 002a69	ff 36 02 00 		push	WORD PTR ?old_dmm32b_vect@@3P7AXXZE+2	;old_dmm32b_vect
	*** 002a6d	ff 36 00 00 		push	WORD PTR ?old_dmm32b_vect@@3P7AXXZE	;old_dmm32b_vect
	*** 002a71	6a 74 			push	116	;0074H
	*** 002a73	9a 00 00 00 00 		call	FAR PTR __dos_setvect
	*** 002a78	83 c4 06 		add	sp,6
;|***   _enable();
; Line 1857
	*** 002a7b	9a 00 00 00 00 		call	FAR PTR __enable
;|***   }
; Line 1858
	*** 002a80	e9 00 00 		jmp	$EX4000
					$EX4000:
	*** 002a83	5e 			pop	si
	*** 002a84	5f 			pop	di
	*** 002a85	c9 			leave	
	*** 002a86	cb 			ret	

?shutdown_dmm32b@@ZAXXZ	ENDP
	PUBLIC	?shutdown_escc@@ZAXXZ	; shutdown_escc
?shutdown_escc@@ZAXXZ	PROC FAR	; shutdown_escc
;|*** 
;|*** 
;|*** 
;|***   
;|*** void shutdown_escc(void)
;|***   {
; Line 1864
	*** 002a87	c8 00 00 00 		enter	0,0
	*** 002a8b	57 			push	di
	*** 002a8c	56 			push	si
;|***   escc1.kill_port(channela);
; Line 1865
	*** 002a8d	ff 36 00 00 		push	WORD PTR ?channela@@3IE	;channela
	*** 002a91	68 00 00 		push	SEG ?escc1@@3VCescc@@E	;escc1
	*** 002a94	68 00 00 		push	OFFSET ?escc1@@3VCescc@@E	;escc1
	*** 002a97	9a 00 00 00 00 		call	FAR PTR ?kill_port@Cescc@@RECII@Z	; Cescc::kill_port
;|***   escc1.kill_port(channelb);
; Line 1866
	*** 002a9c	ff 36 00 00 		push	WORD PTR ?channelb@@3IE	;channelb
	*** 002aa0	68 00 00 		push	SEG ?escc1@@3VCescc@@E	;escc1
	*** 002aa3	68 00 00 		push	OFFSET ?escc1@@3VCescc@@E	;escc1
	*** 002aa6	9a 00 00 00 00 		call	FAR PTR ?kill_port@Cescc@@RECII@Z	; Cescc::kill_port
;|***   // nothing yet
;|***   }
; Line 1868
	*** 002aab	e9 00 00 		jmp	$EX4002
					$EX4002:
	*** 002aae	5e 			pop	si
	*** 002aaf	5f 			pop	di
	*** 002ab0	c9 			leave	
	*** 002ab1	cb 			ret	

?shutdown_escc@@ZAXXZ	ENDP
	PUBLIC	?build_packet@@ZAXXZ	; build_packet
?build_packet@@ZAXXZ	PROC FAR	; build_packet
;|***   
;|*** 
;|*** 
;|*** void build_packet(void)
;|***   {
; Line 1873
	*** 002ab2	c8 30 00 00 		enter	48,0
	*** 002ab6	57 			push	di
	*** 002ab7	56 			push	si
;	i = -2
;	j = -4
;	value = -6
;	checksum16 = -8
;	checksum32 = -12
;	udp_pseudo = -32
;	prop_delta_position = -36
;	prop_delta_time_high = -40
;	prop_delta_time_low = -44
;	prop_delta_time = -48
;|***   unsigned i,j,value;
;|***   unsigned checksum16 = 0;
; Line 1875
	*** 002ab8	c7 46 f8 00 00 		mov	WORD PTR [bp-8],0	;checksum16
;|***   unsigned long checksum32 = 0;
; Line 1876
	*** 002abd	2b c0 			sub	ax,ax
	*** 002abf	89 46 f6 		mov	WORD PTR [bp-10],ax
	*** 002ac2	89 46 f4 		mov	WORD PTR [bp-12],ax	;checksum32
;|***   unsigned char udp_pseudo[20];
;|***   long prop_delta_position = 0;
; Line 1878
	*** 002ac5	2b c0 			sub	ax,ax
	*** 002ac7	89 46 de 		mov	WORD PTR [bp-34],ax
	*** 002aca	89 46 dc 		mov	WORD PTR [bp-36],ax	;prop_delta_position
;|***   //unsigned long prop_delta_time_high = 0;
;|***   long prop_delta_time_high = 0;
; Line 1880
	*** 002acd	2b c0 			sub	ax,ax
	*** 002acf	89 46 da 		mov	WORD PTR [bp-38],ax
	*** 002ad2	89 46 d8 		mov	WORD PTR [bp-40],ax	;prop_delta_time_high
;|***   //unsigned long prop_delta_time_low = 0;
;|***   long prop_delta_time_low = 0;
; Line 1882
	*** 002ad5	2b c0 			sub	ax,ax
	*** 002ad7	89 46 d6 		mov	WORD PTR [bp-42],ax
	*** 002ada	89 46 d4 		mov	WORD PTR [bp-44],ax	;prop_delta_time_low
;|***   unsigned long prop_delta_time = 0;
; Line 1883
	*** 002add	2b c0 			sub	ax,ax
	*** 002adf	89 46 d2 		mov	WORD PTR [bp-46],ax
	*** 002ae2	89 46 d0 		mov	WORD PTR [bp-48],ax	;prop_delta_time
;|*** 
;|*** /*
;|***   for(j=0;j<1514;j++)
;|***     {
;|***     data_pkt[j]=0;
;|***     }
;|*** */    
;|***     
;|***   _fmemset(data_pkt, 0, sizeof(data_pkt));
; Line 1892
	*** 002ae5	68 ea 05 		push	1514	;05eaH
	*** 002ae8	6a 00 			push	0
	*** 002aea	1e 			push	ds
	*** 002aeb	68 00 00 		push	OFFSET DGROUP:?data_pkt@@3QIEI	;data_pkt
	*** 002aee	9a 00 00 00 00 		call	FAR PTR __fmemset
	*** 002af3	83 c4 08 		add	sp,8
;|***   
;|***   _disable();             // turn off other services while we copy data
; Line 1894
	*** 002af6	9a 00 00 00 00 		call	FAR PTR __disable
;|***   
;|***   sys.packet_number++;
; Line 1896
	*** 002afb	8e 06 00 00 		mov	es,WORD PTR $T4111
	*** 002aff	26 ff 06 02 00 		inc	WORD PTR es:?sys@@3USYS@@E+2	;sys
;|***   sys.frame = frame - 1;  // previous frame number, not this one
; Line 1897
	*** 002b04	a1 00 00 		mov	ax,WORD PTR ?frame@@3KE	;frame
	*** 002b07	8b 16 02 00 		mov	dx,WORD PTR ?frame@@3KE+2	;frame
	*** 002b0b	2d 01 00 		sub	ax,1
	*** 002b0e	83 da 00 		sbb	dx,0
	*** 002b11	26 a3 04 00 		mov	WORD PTR es:?sys@@3USYS@@E+4,ax	;sys
	*** 002b15	26 89 16 06 00 		mov	WORD PTR es:?sys@@3USYS@@E+6,dx	;sys
;|***   sys.fs_status = 0;
; Line 1898
	*** 002b1a	26 c7 06 08 00 00 00 	mov	WORD PTR es:?sys@@3USYS@@E+8,0	;sys
;|***   sys.fs_status = (read_port(FSHIGH) << 8) | read_port(FSLOW);
; Line 1899
	*** 002b21	6a 03 			push	3
	*** 002b23	9a 00 00 00 00 		call	FAR PTR ?read_port@@ZAIH@Z	; read_port
	*** 002b28	83 c4 02 		add	sp,2
	*** 002b2b	6a 00 			push	0
	*** 002b2d	8b f0 			mov	si,ax
	*** 002b2f	9a 00 00 00 00 		call	FAR PTR ?read_port@@ZAIH@Z	; read_port
	*** 002b34	83 c4 02 		add	sp,2
	*** 002b37	8b ce 			mov	cx,si
	*** 002b39	8a e9 			mov	ch,cl
	*** 002b3b	2a c9 			sub	cl,cl
	*** 002b3d	0b c1 			or	ax,cx
	*** 002b3f	8e 06 00 00 		mov	es,WORD PTR $T4111
	*** 002b43	26 a3 08 00 		mov	WORD PTR es:?sys@@3USYS@@E+8,ax	;sys
;|***   sys.op_status = read_port(FSHIGH2);
; Line 1900
	*** 002b47	6a 04 			push	4
	*** 002b49	9a 00 00 00 00 		call	FAR PTR ?read_port@@ZAIH@Z	; read_port
	*** 002b4e	83 c4 02 		add	sp,2
	*** 002b51	8e 06 00 00 		mov	es,WORD PTR $T4111
	*** 002b55	26 a3 0a 00 		mov	WORD PTR es:?sys@@3USYS@@E+10,ax	;sys
;|***   sys.time_high = frame_time.high;
; Line 1901
	*** 002b59	8e 06 00 00 		mov	es,WORD PTR $T4111
	*** 002b5d	26 a1 00 00 		mov	ax,WORD PTR es:?frame_time@@3UTIMER@@E	;frame_time
	*** 002b61	26 8b 16 02 00 		mov	dx,WORD PTR es:?frame_time@@3UTIMER@@E+2	;frame_time
	*** 002b66	8e 06 00 00 		mov	es,WORD PTR $T4111
	*** 002b6a	26 a3 0c 00 		mov	WORD PTR es:?sys@@3USYS@@E+12,ax	;sys
	*** 002b6e	26 89 16 0e 00 		mov	WORD PTR es:?sys@@3USYS@@E+14,dx	;sys
;|***   sys.time_low  = frame_time.low;
; Line 1902
	*** 002b73	8e 06 00 00 		mov	es,WORD PTR $T4111
	*** 002b77	26 a1 04 00 		mov	ax,WORD PTR es:?frame_time@@3UTIMER@@E+4	;frame_time
	*** 002b7b	8e 06 00 00 		mov	es,WORD PTR $T4111
	*** 002b7f	26 a3 10 00 		mov	WORD PTR es:?sys@@3USYS@@E+16,ax	;sys
;|***   
;|***   obs.new_data = obs_new_data;
; Line 1904
	*** 002b83	a1 00 00 		mov	ax,WORD PTR ?obs_new_data@@3IE	;obs_new_data
	*** 002b86	8e 06 00 00 		mov	es,WORD PTR $T4111
	*** 002b8a	26 a3 00 00 		mov	WORD PTR es:?obs@@3UOBS@@E,ax	;obs
;|***   obs_new_data = 0;
; Line 1905
	*** 002b8e	c7 06 00 00 00 00 	mov	WORD PTR ?obs_new_data@@3IE,0	;obs_new_data
;|***   obs.frame = obs_data_frame;
; Line 1906
	*** 002b94	a1 00 00 		mov	ax,WORD PTR ?obs_data_frame@@3KE	;obs_data_frame
	*** 002b97	8b 16 02 00 		mov	dx,WORD PTR ?obs_data_frame@@3KE+2	;obs_data_frame
	*** 002b9b	26 a3 02 00 		mov	WORD PTR es:?obs@@3UOBS@@E+2,ax	;obs
	*** 002b9f	26 89 16 04 00 		mov	WORD PTR es:?obs@@3UOBS@@E+4,dx	;obs
;|***   obs.time_high = obs_time.high;
; Line 1907
	*** 002ba4	8e 06 00 00 		mov	es,WORD PTR $T4111
	*** 002ba8	26 a1 00 00 		mov	ax,WORD PTR es:?obs_time@@3UTIMER@@E	;obs_time
	*** 002bac	26 8b 16 02 00 		mov	dx,WORD PTR es:?obs_time@@3UTIMER@@E+2	;obs_time
	*** 002bb1	8e 06 00 00 		mov	es,WORD PTR $T4111
	*** 002bb5	26 a3 06 00 		mov	WORD PTR es:?obs@@3UOBS@@E+6,ax	;obs
	*** 002bb9	26 89 16 08 00 		mov	WORD PTR es:?obs@@3UOBS@@E+8,dx	;obs
;|***   obs.time_low  = obs_time.low;
; Line 1908
	*** 002bbe	8e 06 00 00 		mov	es,WORD PTR $T4111
	*** 002bc2	26 a1 04 00 		mov	ax,WORD PTR es:?obs_time@@3UTIMER@@E+4	;obs_time
	*** 002bc6	8e 06 00 00 		mov	es,WORD PTR $T4111
	*** 002bca	26 a3 0a 00 		mov	WORD PTR es:?obs@@3UOBS@@E+10,ax	;obs
;|***   _fmemcpy(&obs.data, &obs_buffer, sizeof(obs.data));  
; Line 1909
	*** 002bce	6a 40 			push	64	;0040H
	*** 002bd0	1e 			push	ds
	*** 002bd1	68 00 00 		push	OFFSET DGROUP:?obs_buffer@@3QIEI	;obs_buffer
	*** 002bd4	06 			push	es
	*** 002bd5	68 0c 00 		push	OFFSET ?obs@@3UOBS@@E+12	;obs
	*** 002bd8	9a 00 00 00 00 		call	FAR PTR __fmemcpy
	*** 002bdd	83 c4 0a 		add	sp,10	;000aH
;|***   
;|***   dyno.new_data = dyno_new_data;
; Line 1911
	*** 002be0	a1 00 00 		mov	ax,WORD PTR ?dyno_new_data@@3IE	;dyno_new_data
	*** 002be3	8e 06 00 00 		mov	es,WORD PTR $T4111
	*** 002be7	26 a3 00 00 		mov	WORD PTR es:?dyno@@3UDYNO@@E,ax	;dyno
;|***   dyno_new_data = 0;
; Line 1912
	*** 002beb	c7 06 00 00 00 00 	mov	WORD PTR ?dyno_new_data@@3IE,0	;dyno_new_data
;|***   dyno.frame = dyno_data_frame;
; Line 1913
	*** 002bf1	a1 00 00 		mov	ax,WORD PTR ?dyno_data_frame@@3KE	;dyno_data_frame
	*** 002bf4	8b 16 02 00 		mov	dx,WORD PTR ?dyno_data_frame@@3KE+2	;dyno_data_frame
	*** 002bf8	26 a3 02 00 		mov	WORD PTR es:?dyno@@3UDYNO@@E+2,ax	;dyno
	*** 002bfc	26 89 16 04 00 		mov	WORD PTR es:?dyno@@3UDYNO@@E+4,dx	;dyno
;|***   dyno.time_high = dyno_time.high;
; Line 1914
	*** 002c01	8e 06 00 00 		mov	es,WORD PTR $T4111
	*** 002c05	26 a1 00 00 		mov	ax,WORD PTR es:?dyno_time@@3UTIMER@@E	;dyno_time
	*** 002c09	26 8b 16 02 00 		mov	dx,WORD PTR es:?dyno_time@@3UTIMER@@E+2	;dyno_time
	*** 002c0e	8e 06 00 00 		mov	es,WORD PTR $T4111
	*** 002c12	26 a3 06 00 		mov	WORD PTR es:?dyno@@3UDYNO@@E+6,ax	;dyno
	*** 002c16	26 89 16 08 00 		mov	WORD PTR es:?dyno@@3UDYNO@@E+8,dx	;dyno
;|***   dyno.time_low  = dyno_time.low;
; Line 1915
	*** 002c1b	8e 06 00 00 		mov	es,WORD PTR $T4111
	*** 002c1f	26 a1 04 00 		mov	ax,WORD PTR es:?dyno_time@@3UTIMER@@E+4	;dyno_time
	*** 002c23	8e 06 00 00 		mov	es,WORD PTR $T4111
	*** 002c27	26 a3 0a 00 		mov	WORD PTR es:?dyno@@3UDYNO@@E+10,ax	;dyno
;|***   _fmemcpy(&dyno.data, &dyno_buffer, sizeof(dyno.data));  
; Line 1916
	*** 002c2b	68 00 01 		push	256	;0100H
	*** 002c2e	1e 			push	ds
	*** 002c2f	68 00 00 		push	OFFSET DGROUP:?dyno_buffer@@3QIEI	;dyno_buffer
	*** 002c32	06 			push	es
	*** 002c33	68 0c 00 		push	OFFSET ?dyno@@3UDYNO@@E+12	;dyno
	*** 002c36	9a 00 00 00 00 		call	FAR PTR __fmemcpy
	*** 002c3b	83 c4 0a 		add	sp,10	;000aH
;|***   
;|***   prop.new_data = prop_new_data;
; Line 1918
	*** 002c3e	a1 00 00 		mov	ax,WORD PTR ?prop_new_data@@3IE	;prop_new_data
	*** 002c41	8e 06 00 00 		mov	es,WORD PTR $T4111
	*** 002c45	26 a3 00 00 		mov	WORD PTR es:?prop@@3UPROP@@E,ax	;prop
;|***   prop_new_data = 0;
; Line 1919
	*** 002c49	c7 06 00 00 00 00 	mov	WORD PTR ?prop_new_data@@3IE,0	;prop_new_data
;|***   prop.frame = prop_data_frame;
; Line 1920
	*** 002c4f	a1 00 00 		mov	ax,WORD PTR ?prop_data_frame@@3KE	;prop_data_frame
	*** 002c52	8b 16 02 00 		mov	dx,WORD PTR ?prop_data_frame@@3KE+2	;prop_data_frame
	*** 002c56	26 a3 02 00 		mov	WORD PTR es:?prop@@3UPROP@@E+2,ax	;prop
	*** 002c5a	26 89 16 04 00 		mov	WORD PTR es:?prop@@3UPROP@@E+4,dx	;prop
;|***   prop.rpm_time_high = prop_rpm_time.high;
; Line 1921
	*** 002c5f	8e 06 00 00 		mov	es,WORD PTR $T4111
	*** 002c63	26 a1 00 00 		mov	ax,WORD PTR es:?prop_rpm_time@@3UTIMER@@E	;prop_rpm_time
	*** 002c67	26 8b 16 02 00 		mov	dx,WORD PTR es:?prop_rpm_time@@3UTIMER@@E+2	;prop_rpm_time
	*** 002c6c	8e 06 00 00 		mov	es,WORD PTR $T4111
	*** 002c70	26 a3 06 00 		mov	WORD PTR es:?prop@@3UPROP@@E+6,ax	;prop
	*** 002c74	26 89 16 08 00 		mov	WORD PTR es:?prop@@3UPROP@@E+8,dx	;prop
;|***   prop.rpm_time_low  = prop_rpm_time.low;
; Line 1922
	*** 002c79	8e 06 00 00 		mov	es,WORD PTR $T4111
	*** 002c7d	26 a1 04 00 		mov	ax,WORD PTR es:?prop_rpm_time@@3UTIMER@@E+4	;prop_rpm_time
	*** 002c81	8e 06 00 00 		mov	es,WORD PTR $T4111
	*** 002c85	26 a3 0a 00 		mov	WORD PTR es:?prop@@3UPROP@@E+10,ax	;prop
;|***   prop.position_time_high = prop_position_time.high;
; Line 1923
	*** 002c89	8e 06 00 00 		mov	es,WORD PTR $T4111
	*** 002c8d	26 a1 00 00 		mov	ax,WORD PTR es:?prop_position_time@@3UTIMER@@E	;prop_position_time
	*** 002c91	26 8b 16 02 00 		mov	dx,WORD PTR es:?prop_position_time@@3UTIMER@@E+2	;prop_position_time
	*** 002c96	8e 06 00 00 		mov	es,WORD PTR $T4111
	*** 002c9a	26 a3 0c 00 		mov	WORD PTR es:?prop@@3UPROP@@E+12,ax	;prop
	*** 002c9e	26 89 16 0e 00 		mov	WORD PTR es:?prop@@3UPROP@@E+14,dx	;prop
;|***   prop.position_time_low  = prop_position_time.low;
; Line 1924
	*** 002ca3	8e 06 00 00 		mov	es,WORD PTR $T4111
	*** 002ca7	26 a1 04 00 		mov	ax,WORD PTR es:?prop_position_time@@3UTIMER@@E+4	;prop_position_time
	*** 002cab	8e 06 00 00 		mov	es,WORD PTR $T4111
	*** 002caf	26 a3 10 00 		mov	WORD PTR es:?prop@@3UPROP@@E+16,ax	;prop
;|*** //  while(prop_position < 0) prop_position += 10160;  // old encoder normalize the prop position
;|***   while(prop_position < 0) prop_position += 20000;    // new encoder normalize the prop position
; Line 1926
					$FC4016:
	*** 002cb3	83 3e 02 00 00 		cmp	WORD PTR ?prop_position@@3JE+2,0	;prop_position
	*** 002cb8	7c 03 			jl	$JCC11448
	*** 002cba	e9 0e 00 		jmp	$FB4017
					$JCC11448:
	*** 002cbd	81 06 00 00 20 4e 	add	WORD PTR ?prop_position@@3JE,20000	;4e20H	;prop_position
	*** 002cc3	83 16 02 00 00 		adc	WORD PTR ?prop_position@@3JE+2,0	;prop_position
	*** 002cc8	e9 e8 ff 		jmp	$FC4016
					$FB4017:
;|*** //  while(prop_position > 10159) prop_position -= 10160; // old encoder
;|***   while(prop_position > 19999) prop_position -= 20000;   // new encoder
; Line 1928
					$FC4019:
	*** 002ccb	83 3e 02 00 00 		cmp	WORD PTR ?prop_position@@3JE+2,0	;prop_position
	*** 002cd0	7d 03 			jge	$JCC11472
	*** 002cd2	e9 1e 00 		jmp	$FB4020
					$JCC11472:
	*** 002cd5	7e 03 			jle	$JCC11477
	*** 002cd7	e9 0b 00 		jmp	$L4120
					$JCC11477:
	*** 002cda	81 3e 00 00 1f 4e 	cmp	WORD PTR ?prop_position@@3JE,19999	;4e1fH	;prop_position
	*** 002ce0	77 03 			ja	$JCC11488
	*** 002ce2	e9 0e 00 		jmp	$FB4020
					$JCC11488:
					$L4120:
	*** 002ce5	81 2e 00 00 20 4e 	sub	WORD PTR ?prop_position@@3JE,20000	;4e20H	;prop_position
	*** 002ceb	83 1e 02 00 00 		sbb	WORD PTR ?prop_position@@3JE+2,0	;prop_position
	*** 002cf0	e9 d8 ff 		jmp	$FC4019
DMMTEST_TEXT      ENDS
CONST      SEGMENT
$T4121	DD	03e99999ar   ;	.30000001
CONST      ENDS
DMMTEST_TEXT      SEGMENT
	ASSUME	CS: DMMTEST_TEXT
					$FB4020:
;|***   prop.position = prop_position;
; Line 1929
	*** 002cf3	a1 00 00 		mov	ax,WORD PTR ?prop_position@@3JE	;prop_position
	*** 002cf6	8b 16 02 00 		mov	dx,WORD PTR ?prop_position@@3JE+2	;prop_position
	*** 002cfa	8e 06 00 00 		mov	es,WORD PTR $T4111
	*** 002cfe	26 a3 1a 00 		mov	WORD PTR es:?prop@@3UPROP@@E+26,ax	;prop
	*** 002d02	26 89 16 1c 00 		mov	WORD PTR es:?prop@@3UPROP@@E+28,dx	;prop
;|***   
;|***   prop_delta_position = prop_position_absolute_current - prop_position_absolute_previous;
; Line 1931
	*** 002d07	a1 00 00 		mov	ax,WORD PTR ?prop_position_absolute_current@@3JE	;prop_position_absolute_current
	*** 002d0a	8b 16 02 00 		mov	dx,WORD PTR ?prop_position_absolute_current@@3JE+2	;prop_position_absolute_current
	*** 002d0e	2b 06 00 00 		sub	ax,WORD PTR ?prop_position_absolute_previous@@3JE	;prop_position_absolute_previous
	*** 002d12	1b 16 02 00 		sbb	dx,WORD PTR ?prop_position_absolute_previous@@3JE+2	;prop_position_absolute_previous
	*** 002d16	89 46 dc 		mov	WORD PTR [bp-36],ax	;prop_delta_position
	*** 002d19	89 56 de 		mov	WORD PTR [bp-34],dx
;|*** 
;|*** /*
;|***   prop_delta_time_high = prop_position_time.high - prop_position_time_previous.high;
;|***   prop_delta_time_low = prop_position_time.low - prop_position_time_previous.low;
;|***   if(prop_delta_time_low < 0)
;|***     {
;|***     prop_delta_time_high--;
;|***     prop_delta_time_low += 65536;
;|***     }
;|***   prop_delta_time = (65535 * prop_delta_time_high) + prop_delta_time_low;
;|***   
;|***   if(prop_delta_time != 0)
;|***      prop.rpm = (int) (rpm_sf * ((float)prop_delta_position / (float)prop_delta_time));
;|*** */
;|***   // rpm scale factor = 60 sec/min  x  rev/numcounts  x  1/.01 sec
;|*** //  prop.rpm = (int) ((float)prop_delta_position * 0.590551f);  // old encoder
;|***   prop.rpm = (int) ((float)prop_delta_position * 0.3f);  // new encoder
; Line 1948
	*** 002d1c	bb 00 00 		mov	bx,OFFSET DGROUP:$T4121
	*** 002d1f	9a 00 00 00 00 		call	FAR PTR __aFflds
	*** 002d24	8d 5e dc 		lea	bx,WORD PTR [bp-36]	;prop_delta_position
	*** 002d27	9a 00 00 00 00 		call	FAR PTR __aFfldl
	*** 002d2c	9a 00 00 00 00 		call	FAR PTR __aFfmul
	*** 002d31	9a 00 00 00 00 		call	FAR PTR __aFdcvt
	*** 002d36	9a 00 00 00 00 		call	FAR PTR __aFftol
	*** 002d3b	8e 06 00 00 		mov	es,WORD PTR $T4111
	*** 002d3f	26 a3 18 00 		mov	WORD PTR es:?prop@@3UPROP@@E+24,ax	;prop
;|***   
;|***   prop_position_absolute_previous = prop_position_absolute_current;
; Line 1950
	*** 002d43	a1 00 00 		mov	ax,WORD PTR ?prop_position_absolute_current@@3JE	;prop_position_absolute_current
	*** 002d46	8b 16 02 00 		mov	dx,WORD PTR ?prop_position_absolute_current@@3JE+2	;prop_position_absolute_current
	*** 002d4a	a3 00 00 		mov	WORD PTR ?prop_position_absolute_previous@@3JE,ax	;prop_position_absolute_previous
	*** 002d4d	89 16 02 00 		mov	WORD PTR ?prop_position_absolute_previous@@3JE+2,dx	;prop_position_absolute_previous
;|***   prop_position_time_previous.high = prop_position_time.high;
; Line 1951
	*** 002d51	8e 06 00 00 		mov	es,WORD PTR $T4111
	*** 002d55	26 a1 00 00 		mov	ax,WORD PTR es:?prop_position_time@@3UTIMER@@E	;prop_position_time
	*** 002d59	26 8b 16 02 00 		mov	dx,WORD PTR es:?prop_position_time@@3UTIMER@@E+2	;prop_position_time
	*** 002d5e	8e 06 00 00 		mov	es,WORD PTR $T4111
	*** 002d62	26 a3 00 00 		mov	WORD PTR es:?prop_position_time_previous@@3UTIMER@@E,ax	;prop_position_time_previous
	*** 002d66	26 89 16 02 00 		mov	WORD PTR es:?prop_position_time_previous@@3UTIMER@@E+2,dx	;prop_position_time_previous
;|***   prop_position_time_previous.low  = prop_position_time.low;
; Line 1952
	*** 002d6b	8e 06 00 00 		mov	es,WORD PTR $T4111
	*** 002d6f	26 a1 04 00 		mov	ax,WORD PTR es:?prop_position_time@@3UTIMER@@E+4	;prop_position_time
	*** 002d73	8e 06 00 00 		mov	es,WORD PTR $T4111
	*** 002d77	26 a3 04 00 		mov	WORD PTR es:?prop_position_time_previous@@3UTIMER@@E+4,ax	;prop_position_time_previous
;|*** 
;|***   prop.adc_time_high = prop_adc_time.high;
; Line 1954
	*** 002d7b	8e 06 00 00 		mov	es,WORD PTR $T4111
	*** 002d7f	26 a1 00 00 		mov	ax,WORD PTR es:?prop_adc_time@@3UTIMER@@E	;prop_adc_time
	*** 002d83	26 8b 16 02 00 		mov	dx,WORD PTR es:?prop_adc_time@@3UTIMER@@E+2	;prop_adc_time
	*** 002d88	8e 06 00 00 		mov	es,WORD PTR $T4111
	*** 002d8c	26 a3 12 00 		mov	WORD PTR es:?prop@@3UPROP@@E+18,ax	;prop
	*** 002d90	26 89 16 14 00 		mov	WORD PTR es:?prop@@3UPROP@@E+20,dx	;prop
;|***   prop.adc_time_low  = prop_adc_time.low;
; Line 1955
	*** 002d95	8e 06 00 00 		mov	es,WORD PTR $T4111
	*** 002d99	26 a1 04 00 		mov	ax,WORD PTR es:?prop_adc_time@@3UTIMER@@E+4	;prop_adc_time
	*** 002d9d	8e 06 00 00 		mov	es,WORD PTR $T4111
	*** 002da1	26 a3 16 00 		mov	WORD PTR es:?prop@@3UPROP@@E+22,ax	;prop
;|***   _fmemcpy(&prop.data, &prop_buffer, sizeof(prop.data));  
; Line 1956
	*** 002da5	6a 0c 			push	12	;000cH
	*** 002da7	1e 			push	ds
	*** 002da8	68 00 00 		push	OFFSET DGROUP:?prop_buffer@@3QIEI	;prop_buffer
	*** 002dab	06 			push	es
	*** 002dac	68 1e 00 		push	OFFSET ?prop@@3UPROP@@E+30	;prop
	*** 002daf	9a 00 00 00 00 		call	FAR PTR __fmemcpy
	*** 002db4	83 c4 0a 		add	sp,10	;000aH
;|***   
;|***   ln200.new_data = ln200_new_data;
; Line 1958
	*** 002db7	a1 00 00 		mov	ax,WORD PTR ?ln200_new_data@@3IE	;ln200_new_data
	*** 002dba	8e 06 00 00 		mov	es,WORD PTR $T4111
	*** 002dbe	26 a3 00 00 		mov	WORD PTR es:?ln200@@3ULN200@@E,ax	;ln200
;|***   ln200_new_data = 0;
; Line 1959
	*** 002dc2	c7 06 00 00 00 00 	mov	WORD PTR ?ln200_new_data@@3IE,0	;ln200_new_data
;|***   ln200.frame = ln200_data_frame;
; Line 1960
	*** 002dc8	a1 00 00 		mov	ax,WORD PTR ?ln200_data_frame@@3KE	;ln200_data_frame
	*** 002dcb	8b 16 02 00 		mov	dx,WORD PTR ?ln200_data_frame@@3KE+2	;ln200_data_frame
	*** 002dcf	26 a3 02 00 		mov	WORD PTR es:?ln200@@3ULN200@@E+2,ax	;ln200
	*** 002dd3	26 89 16 04 00 		mov	WORD PTR es:?ln200@@3ULN200@@E+4,dx	;ln200
;|***   ln200.time_high = ln200_time.high;
; Line 1961
	*** 002dd8	8e 06 00 00 		mov	es,WORD PTR $T4111
	*** 002ddc	26 a1 00 00 		mov	ax,WORD PTR es:?ln200_time@@3UTIMER@@E	;ln200_time
	*** 002de0	26 8b 16 02 00 		mov	dx,WORD PTR es:?ln200_time@@3UTIMER@@E+2	;ln200_time
	*** 002de5	8e 06 00 00 		mov	es,WORD PTR $T4111
	*** 002de9	26 a3 06 00 		mov	WORD PTR es:?ln200@@3ULN200@@E+6,ax	;ln200
	*** 002ded	26 89 16 08 00 		mov	WORD PTR es:?ln200@@3ULN200@@E+8,dx	;ln200
;|***   ln200.time_low  = ln200_time.low;
; Line 1962
	*** 002df2	8e 06 00 00 		mov	es,WORD PTR $T4111
	*** 002df6	26 a1 04 00 		mov	ax,WORD PTR es:?ln200_time@@3UTIMER@@E+4	;ln200_time
	*** 002dfa	8e 06 00 00 		mov	es,WORD PTR $T4111
	*** 002dfe	26 a3 0a 00 		mov	WORD PTR es:?ln200@@3ULN200@@E+10,ax	;ln200
;|***   _fmemcpy(&ln200.data, &ln200_buffer, sizeof(ln200.data));  
; Line 1963
	*** 002e02	6a 20 			push	32	;0020H
	*** 002e04	1e 			push	ds
	*** 002e05	68 00 00 		push	OFFSET DGROUP:?ln200_buffer@@3QIEI	;ln200_buffer
	*** 002e08	06 			push	es
	*** 002e09	68 0c 00 		push	OFFSET ?ln200@@3ULN200@@E+12	;ln200
	*** 002e0c	9a 00 00 00 00 		call	FAR PTR __fmemcpy
	*** 002e11	83 c4 0a 		add	sp,10	;000aH
;|***                                       
;|***   echo.new_data = echo_new_data;
; Line 1965
	*** 002e14	a1 00 00 		mov	ax,WORD PTR ?echo_new_data@@3IE	;echo_new_data
	*** 002e17	8e 06 00 00 		mov	es,WORD PTR $T4111
	*** 002e1b	26 a3 00 00 		mov	WORD PTR es:?echo@@3UECHO@@E,ax	;echo
;|***   echo_new_data = 0;
; Line 1966
	*** 002e1f	c7 06 00 00 00 00 	mov	WORD PTR ?echo_new_data@@3IE,0	;echo_new_data
;|***   echo.frame = echo_data_frame;
; Line 1967
	*** 002e25	a1 00 00 		mov	ax,WORD PTR ?echo_data_frame@@3KE	;echo_data_frame
	*** 002e28	8b 16 02 00 		mov	dx,WORD PTR ?echo_data_frame@@3KE+2	;echo_data_frame
	*** 002e2c	26 a3 02 00 		mov	WORD PTR es:?echo@@3UECHO@@E+2,ax	;echo
	*** 002e30	26 89 16 04 00 		mov	WORD PTR es:?echo@@3UECHO@@E+4,dx	;echo
;|***   echo.time_high = cmds_time.high;
; Line 1968
	*** 002e35	8e 06 00 00 		mov	es,WORD PTR $T4111
	*** 002e39	26 a1 00 00 		mov	ax,WORD PTR es:?cmds_time@@3UTIMER@@E	;cmds_time
	*** 002e3d	26 8b 16 02 00 		mov	dx,WORD PTR es:?cmds_time@@3UTIMER@@E+2	;cmds_time
	*** 002e42	8e 06 00 00 		mov	es,WORD PTR $T4111
	*** 002e46	26 a3 06 00 		mov	WORD PTR es:?echo@@3UECHO@@E+6,ax	;echo
	*** 002e4a	26 89 16 08 00 		mov	WORD PTR es:?echo@@3UECHO@@E+8,dx	;echo
;|***   echo.time_low  = cmds_time.low;
; Line 1969
	*** 002e4f	8e 06 00 00 		mov	es,WORD PTR $T4111
	*** 002e53	26 a1 04 00 		mov	ax,WORD PTR es:?cmds_time@@3UTIMER@@E+4	;cmds_time
	*** 002e57	8e 06 00 00 		mov	es,WORD PTR $T4111
	*** 002e5b	26 a3 0a 00 		mov	WORD PTR es:?echo@@3UECHO@@E+10,ax	;echo
;|***   _fmemcpy(&echo.data, &commands, sizeof(echo.data));  
; Line 1970
	*** 002e5f	6a 24 			push	36	;0024H
	*** 002e61	68 00 00 		push	SEG ?commands@@3UCOMMANDS@@E	;commands
	*** 002e64	68 00 00 		push	OFFSET ?commands@@3UCOMMANDS@@E	;commands
	*** 002e67	06 			push	es
	*** 002e68	68 0c 00 		push	OFFSET ?echo@@3UECHO@@E+12	;echo
	*** 002e6b	9a 00 00 00 00 		call	FAR PTR __fmemcpy
	*** 002e70	83 c4 0a 		add	sp,10	;000aH
;|***   
;|***   ds.new_data = ds_new_data;
; Line 1972
	*** 002e73	a1 00 00 		mov	ax,WORD PTR ?ds_new_data@@3IE	;ds_new_data
	*** 002e76	8e 06 00 00 		mov	es,WORD PTR $T4111
	*** 002e7a	26 a3 00 00 		mov	WORD PTR es:?ds@@3UDS@@E,ax	;ds
;|***   ds_new_data = 0;
; Line 1973
	*** 002e7e	c7 06 00 00 00 00 	mov	WORD PTR ?ds_new_data@@3IE,0	;ds_new_data
;|***   ds.frame = ds_data_frame;
; Line 1974
	*** 002e84	a1 00 00 		mov	ax,WORD PTR ?ds_data_frame@@3KE	;ds_data_frame
	*** 002e87	8b 16 02 00 		mov	dx,WORD PTR ?ds_data_frame@@3KE+2	;ds_data_frame
	*** 002e8b	26 a3 02 00 		mov	WORD PTR es:?ds@@3UDS@@E+2,ax	;ds
	*** 002e8f	26 89 16 04 00 		mov	WORD PTR es:?ds@@3UDS@@E+4,dx	;ds
;|***   ds.time_high = ds_time.high;
; Line 1975
	*** 002e94	8e 06 00 00 		mov	es,WORD PTR $T4111
	*** 002e98	26 a1 00 00 		mov	ax,WORD PTR es:?ds_time@@3UTIMER@@E	;ds_time
	*** 002e9c	26 8b 16 02 00 		mov	dx,WORD PTR es:?ds_time@@3UTIMER@@E+2	;ds_time
	*** 002ea1	8e 06 00 00 		mov	es,WORD PTR $T4111
	*** 002ea5	26 a3 06 00 		mov	WORD PTR es:?ds@@3UDS@@E+6,ax	;ds
	*** 002ea9	26 89 16 08 00 		mov	WORD PTR es:?ds@@3UDS@@E+8,dx	;ds
;|***   ds.time_low  = ds_time.low;
; Line 1976
	*** 002eae	8e 06 00 00 		mov	es,WORD PTR $T4111
	*** 002eb2	26 a1 04 00 		mov	ax,WORD PTR es:?ds_time@@3UTIMER@@E+4	;ds_time
	*** 002eb6	8e 06 00 00 		mov	es,WORD PTR $T4111
	*** 002eba	26 a3 0a 00 		mov	WORD PTR es:?ds@@3UDS@@E+10,ax	;ds
;|***   _fmemcpy(&ds.data, &ds_buffer, sizeof(ds.data));  
; Line 1977
	*** 002ebe	6a 50 			push	80	;0050H
	*** 002ec0	1e 			push	ds
	*** 002ec1	68 00 00 		push	OFFSET DGROUP:?ds_buffer@@3QIEI	;ds_buffer
	*** 002ec4	06 			push	es
	*** 002ec5	68 0c 00 		push	OFFSET ?ds@@3UDS@@E+12	;ds
	*** 002ec8	9a 00 00 00 00 		call	FAR PTR __fmemcpy
	*** 002ecd	83 c4 0a 		add	sp,10	;000aH
;|***   
;|***   adcp.new_data = adcp_new_data;
; Line 1979
	*** 002ed0	a1 00 00 		mov	ax,WORD PTR ?adcp_new_data@@3IE	;adcp_new_data
	*** 002ed3	8e 06 00 00 		mov	es,WORD PTR $T4111
	*** 002ed7	26 a3 00 00 		mov	WORD PTR es:?adcp@@3UADCP@@E,ax	;adcp
;|***   adcp_new_data = 0;
; Line 1980
	*** 002edb	c7 06 00 00 00 00 	mov	WORD PTR ?adcp_new_data@@3IE,0	;adcp_new_data
;|***   adcp.frame = adcp_data_frame;
; Line 1981
	*** 002ee1	a1 00 00 		mov	ax,WORD PTR ?adcp_data_frame@@3KE	;adcp_data_frame
	*** 002ee4	8b 16 02 00 		mov	dx,WORD PTR ?adcp_data_frame@@3KE+2	;adcp_data_frame
	*** 002ee8	26 a3 02 00 		mov	WORD PTR es:?adcp@@3UADCP@@E+2,ax	;adcp
	*** 002eec	26 89 16 04 00 		mov	WORD PTR es:?adcp@@3UADCP@@E+4,dx	;adcp
;|***   adcp.time_high = adcp_time.high;
; Line 1982
	*** 002ef1	8e 06 00 00 		mov	es,WORD PTR $T4111
	*** 002ef5	26 a1 00 00 		mov	ax,WORD PTR es:?adcp_time@@3UTIMER@@E	;adcp_time
	*** 002ef9	26 8b 16 02 00 		mov	dx,WORD PTR es:?adcp_time@@3UTIMER@@E+2	;adcp_time
	*** 002efe	8e 06 00 00 		mov	es,WORD PTR $T4111
	*** 002f02	26 a3 06 00 		mov	WORD PTR es:?adcp@@3UADCP@@E+6,ax	;adcp
	*** 002f06	26 89 16 08 00 		mov	WORD PTR es:?adcp@@3UADCP@@E+8,dx	;adcp
;|***   adcp.time_low  = adcp_time.low;
; Line 1983
	*** 002f0b	8e 06 00 00 		mov	es,WORD PTR $T4111
	*** 002f0f	26 a1 04 00 		mov	ax,WORD PTR es:?adcp_time@@3UTIMER@@E+4	;adcp_time
	*** 002f13	8e 06 00 00 		mov	es,WORD PTR $T4111
	*** 002f17	26 a3 0a 00 		mov	WORD PTR es:?adcp@@3UADCP@@E+10,ax	;adcp
;|***   _fmemcpy(&adcp.data, &adcp_buffer, sizeof(adcp.data));  
; Line 1984
	*** 002f1b	68 d5 00 		push	213	;00d5H
	*** 002f1e	1e 			push	ds
	*** 002f1f	68 00 00 		push	OFFSET DGROUP:?adcp_buffer@@3QIEI	;adcp_buffer
	*** 002f22	06 			push	es
	*** 002f23	68 0c 00 		push	OFFSET ?adcp@@3UADCP@@E+12	;adcp
	*** 002f26	9a 00 00 00 00 		call	FAR PTR __fmemcpy
	*** 002f2b	83 c4 0a 		add	sp,10	;000aH
;|***   
;|***   gps.new_data = gps_new_data;
; Line 1986
	*** 002f2e	a1 00 00 		mov	ax,WORD PTR ?gps_new_data@@3IE	;gps_new_data
	*** 002f31	8e 06 00 00 		mov	es,WORD PTR $T4111
	*** 002f35	26 a3 00 00 		mov	WORD PTR es:?gps@@3UGPS@@E,ax	;gps
;|***   gps_new_data = 0;
; Line 1987
	*** 002f39	c7 06 00 00 00 00 	mov	WORD PTR ?gps_new_data@@3IE,0	;gps_new_data
;|***   gps.frame = gps_data_frame;
; Line 1988
	*** 002f3f	a1 00 00 		mov	ax,WORD PTR ?gps_data_frame@@3KE	;gps_data_frame
	*** 002f42	8b 16 02 00 		mov	dx,WORD PTR ?gps_data_frame@@3KE+2	;gps_data_frame
	*** 002f46	26 a3 02 00 		mov	WORD PTR es:?gps@@3UGPS@@E+2,ax	;gps
	*** 002f4a	26 89 16 04 00 		mov	WORD PTR es:?gps@@3UGPS@@E+4,dx	;gps
;|***   gps.time_high = gps_time.high;
; Line 1989
	*** 002f4f	8e 06 00 00 		mov	es,WORD PTR $T4111
	*** 002f53	26 a1 00 00 		mov	ax,WORD PTR es:?gps_time@@3UTIMER@@E	;gps_time
	*** 002f57	26 8b 16 02 00 		mov	dx,WORD PTR es:?gps_time@@3UTIMER@@E+2	;gps_time
	*** 002f5c	8e 06 00 00 		mov	es,WORD PTR $T4111
	*** 002f60	26 a3 06 00 		mov	WORD PTR es:?gps@@3UGPS@@E+6,ax	;gps
	*** 002f64	26 89 16 08 00 		mov	WORD PTR es:?gps@@3UGPS@@E+8,dx	;gps
;|***   gps.time_low  = gps_time.low;
; Line 1990
	*** 002f69	8e 06 00 00 		mov	es,WORD PTR $T4111
	*** 002f6d	26 a1 04 00 		mov	ax,WORD PTR es:?gps_time@@3UTIMER@@E+4	;gps_time
	*** 002f71	8e 06 00 00 		mov	es,WORD PTR $T4111
	*** 002f75	26 a3 0a 00 		mov	WORD PTR es:?gps@@3UGPS@@E+10,ax	;gps
;|***   _fmemcpy(&gps.data, &gps_buffer, sizeof(gps.data));  
; Line 1991
	*** 002f79	6a 50 			push	80	;0050H
	*** 002f7b	1e 			push	ds
	*** 002f7c	68 00 00 		push	OFFSET DGROUP:?gps_buffer@@3QIEI	;gps_buffer
	*** 002f7f	06 			push	es
	*** 002f80	68 0c 00 		push	OFFSET ?gps@@3UGPS@@E+12	;gps
	*** 002f83	9a 00 00 00 00 		call	FAR PTR __fmemcpy
	*** 002f88	83 c4 0a 		add	sp,10	;000aH
;|*** 
;|***   _enable();
; Line 1993
	*** 002f8b	9a 00 00 00 00 		call	FAR PTR __enable
;|***   
;|***   //_fmemcpy(data_pkt, micron_mac, 6);    // insert destination mac addr;
;|***   //_fmemcpy(data_pkt, control_mac, 6);    // insert destination mac addr;
;|***   _fmemcpy(data_pkt, broadcast_mac, 6);    // insert destination mac addr;
; Line 1997
	*** 002f90	6a 06 			push	6
	*** 002f92	1e 			push	ds
	*** 002f93	68 00 00 		push	OFFSET DGROUP:?broadcast_mac@@3QIEI	;broadcast_mac
	*** 002f96	1e 			push	ds
	*** 002f97	68 00 00 		push	OFFSET DGROUP:?data_pkt@@3QIEI	;data_pkt
	*** 002f9a	9a 00 00 00 00 		call	FAR PTR __fmemcpy
	*** 002f9f	83 c4 0a 		add	sp,10	;000aH
;|***   //_fmemcpy(data_pkt, shore_mac, 6);    // insert destination mac addr;
;|***   _fmemcpy(data_pkt+6, obc_mac, 6);     // insert source mac addr
; Line 1999
	*** 002fa2	6a 06 			push	6
	*** 002fa4	1e 			push	ds
	*** 002fa5	68 00 00 		push	OFFSET DGROUP:?obc_mac@@3QIEI	;obc_mac
	*** 002fa8	1e 			push	ds
	*** 002fa9	68 06 00 		push	OFFSET DGROUP:?data_pkt@@3QIEI+6	;data_pkt
	*** 002fac	9a 00 00 00 00 		call	FAR PTR __fmemcpy
	*** 002fb1	83 c4 0a 		add	sp,10	;000aH
;|*** 
;|***   // for DIX insert packet type = 0x0800 (ip packet)
;|***   data_pkt[12] = 0x08;
; Line 2002
	*** 002fb4	c6 06 0c 00 08 		mov	BYTE PTR ?data_pkt@@3QIEI+12,8	;data_pkt
;|***   data_pkt[13] = 0x00;
; Line 2003
	*** 002fb9	c6 06 0d 00 00 		mov	BYTE PTR ?data_pkt@@3QIEI+13,0	;data_pkt
;|*** 
;|***   // insert ip header
;|***   // insert version (4 bit) and header length (4 bit)
;|***   data_pkt[14] = 0x45; // version = 0, hdr len = 5 (ie: 5 x 32-bit words) 69
; Line 2007
	*** 002fbe	c6 06 0e 00 45 		mov	BYTE PTR ?data_pkt@@3QIEI+14,69	;0045H	;data_pkt
;|*** 
;|***   // insert type of service (TOS) (8 bit)
;|***   data_pkt[15] = 0;
; Line 2010
	*** 002fc3	c6 06 0f 00 00 		mov	BYTE PTR ?data_pkt@@3QIEI+15,0	;data_pkt
;|*** 
;|***   // insert total length (16 bit)
;|***   data_pkt[16] = 0x05;  // high byte 1500 bytes to fit in Ethernet data field
; Line 2013
	*** 002fc8	c6 06 10 00 05 		mov	BYTE PTR ?data_pkt@@3QIEI+16,5	;data_pkt
;|***   data_pkt[17] = 0xdc;  // low byte  
; Line 2014
	*** 002fcd	c6 06 11 00 dc 		mov	BYTE PTR ?data_pkt@@3QIEI+17,220	;00dcH	;data_pkt
;|*** 
;|***   // insert id (16 bit)
;|***   data_pkt[18] = high_byte(ip_id); // high byte
; Line 2017
	*** 002fd2	ff 36 00 00 		push	WORD PTR ?ip_id@@3IE	;ip_id
	*** 002fd6	9a 00 00 00 00 		call	FAR PTR ?high_byte@@ZAEI@Z	; high_byte
	*** 002fdb	83 c4 02 		add	sp,2
	*** 002fde	a2 12 00 		mov	BYTE PTR ?data_pkt@@3QIEI+18,al	;data_pkt
;|***   data_pkt[19] = low_byte(ip_id);      // low byte
; Line 2018
	*** 002fe1	ff 36 00 00 		push	WORD PTR ?ip_id@@3IE	;ip_id
	*** 002fe5	9a 00 00 00 00 		call	FAR PTR ?low_byte@@ZAEI@Z	; low_byte
	*** 002fea	83 c4 02 		add	sp,2
	*** 002fed	a2 13 00 		mov	BYTE PTR ?data_pkt@@3QIEI+19,al	;data_pkt
;|***   ip_id++;
; Line 2019
	*** 002ff0	ff 06 00 00 		inc	WORD PTR ?ip_id@@3IE	;ip_id
;|*** 
;|***   // insert flags (3 bit) and fragment offset (13 bit)
;|***   data_pkt[20] = 0;
; Line 2022
	*** 002ff4	c6 06 14 00 00 		mov	BYTE PTR ?data_pkt@@3QIEI+20,0	;data_pkt
;|***   data_pkt[21] = 0;
; Line 2023
	*** 002ff9	c6 06 15 00 00 		mov	BYTE PTR ?data_pkt@@3QIEI+21,0	;data_pkt
;|*** 
;|***   // insert time to live (TTL) (8 bit)
;|***   data_pkt[22] = 64;
; Line 2026
	*** 002ffe	c6 06 16 00 40 		mov	BYTE PTR ?data_pkt@@3QIEI+22,64	;0040H	;data_pkt
;|*** 
;|***   // insert protocol (8 bit)
;|***   data_pkt[23] = 17;  // UDP = 17
; Line 2029
	*** 003003	c6 06 17 00 11 		mov	BYTE PTR ?data_pkt@@3QIEI+23,17	;0011H	;data_pkt
;|*** 
;|***   // insert dummy ip checksum
;|***   data_pkt[24] = 0;
; Line 2032
	*** 003008	c6 06 18 00 00 		mov	BYTE PTR ?data_pkt@@3QIEI+24,0	;data_pkt
;|***   data_pkt[25] = 0;
; Line 2033
	*** 00300d	c6 06 19 00 00 		mov	BYTE PTR ?data_pkt@@3QIEI+25,0	;data_pkt
;|*** 
;|***   // insert source ip address (32 bit)
;|***   data_pkt[26] = 192;
; Line 2036
	*** 003012	c6 06 1a 00 c0 		mov	BYTE PTR ?data_pkt@@3QIEI+26,192	;00c0H	;data_pkt
;|***   data_pkt[27] = 168;
; Line 2037
	*** 003017	c6 06 1b 00 a8 		mov	BYTE PTR ?data_pkt@@3QIEI+27,168	;00a8H	;data_pkt
;|***   data_pkt[28] = 1;
; Line 2038
	*** 00301c	c6 06 1c 00 01 		mov	BYTE PTR ?data_pkt@@3QIEI+28,1	;data_pkt
;|***   data_pkt[29] = 4;
; Line 2039
	*** 003021	c6 06 1d 00 04 		mov	BYTE PTR ?data_pkt@@3QIEI+29,4	;data_pkt
;|*** /*
;|***   // insert destination ip address (32 bit) sam
;|***   data_pkt[30] = 192;
;|***   data_pkt[31] = 168;
;|***   data_pkt[32] = 1;
;|***   data_pkt[33] = 8;
;|*** */
;|*** /*
;|***   // insert destination ip address (32 bit) jim
;|***   data_pkt[30] = 192;
;|***   data_pkt[31] = 168;
;|***   data_pkt[32] = 1;
;|***   data_pkt[33] = 5;
;|*** */
;|*** /*  // insert destination ip address (32 bit) shore
;|***   data_pkt[30] = 192;
;|***   data_pkt[31] = 168;
;|***   data_pkt[32] = 1;
;|***   data_pkt[33] = 30;
;|*** */
;|*** /*
;|***   // insert destination ip address (32 bit) control
;|***   data_pkt[30] = 192;
;|***   data_pkt[31] = 168;
;|***   data_pkt[32] = 1;
;|***   data_pkt[33] = 8;
;|*** */  
;|***   // insert destination ip address (32 bit) broadcast ip
;|***   data_pkt[30] = 192;
; Line 2068
	*** 003026	c6 06 1e 00 c0 		mov	BYTE PTR ?data_pkt@@3QIEI+30,192	;00c0H	;data_pkt
;|***   data_pkt[31] = 168;
; Line 2069
	*** 00302b	c6 06 1f 00 a8 		mov	BYTE PTR ?data_pkt@@3QIEI+31,168	;00a8H	;data_pkt
;|***   data_pkt[32] = 1;
; Line 2070
	*** 003030	c6 06 20 00 01 		mov	BYTE PTR ?data_pkt@@3QIEI+32,1	;data_pkt
;|***   data_pkt[33] = 255;
; Line 2071
	*** 003035	c6 06 21 00 ff 		mov	BYTE PTR ?data_pkt@@3QIEI+33,255	;00ffH	;data_pkt
;|*** 
;|***   // insert true ip header checksum
;|***   // checksum is the 1's complement of the 16-bit 1's complement sum
;|***   // each pair of 8-bit bytes is first converted to a 16-bit word which
;|***   // must be converted from 2's complement to 1's complememt representation
;|***   checksum32=0;        // use 32-bit to capture the 1's complement carry bit
; Line 2077
	*** 00303a	2b c0 			sub	ax,ax
	*** 00303c	89 46 f6 		mov	WORD PTR [bp-10],ax
	*** 00303f	89 46 f4 		mov	WORD PTR [bp-12],ax	;checksum32
;|***   for(j=14;j<34;)
; Line 2078
	*** 003042	c7 46 fc 0e 00 		mov	WORD PTR [bp-4],14	;000eH	;j
					$FC4024:
	*** 003047	83 7e fc 22 		cmp	WORD PTR [bp-4],34	;0022H	;j
	*** 00304b	72 03 			jb	$JCC12363
	*** 00304d	e9 4c 00 		jmp	$FB4025
					$JCC12363:
;|***     {
; Line 2079
;|***     value = (data_pkt[j] << 8) + data_pkt[j+1];  // form next 16-bit word
; Line 2080
	*** 003050	8b 5e fc 		mov	bx,WORD PTR [bp-4]	;j
	*** 003053	8a a7 00 00 		mov	ah,BYTE PTR ?data_pkt@@3QIEI[bx]	;data_pkt
	*** 003057	2a c0 			sub	al,al
	*** 003059	8b 5e fc 		mov	bx,WORD PTR [bp-4]	;j
	*** 00305c	8a 8f 01 00 		mov	cl,BYTE PTR ?data_pkt@@3QIEI[bx+1]	;data_pkt
	*** 003060	2a ed 			sub	ch,ch
	*** 003062	03 c1 			add	ax,cx
	*** 003064	89 46 fa 		mov	WORD PTR [bp-6],ax	;value
;|***     //if(value < 0) value -= 1;                    // convert to 1's complement
;|***     checksum32 += value;                         // add it to the checksum and
; Line 2082
	*** 003067	8b 46 fa 		mov	ax,WORD PTR [bp-6]	;value
	*** 00306a	2b d2 			sub	dx,dx
	*** 00306c	01 46 f4 		add	WORD PTR [bp-12],ax	;checksum32
	*** 00306f	11 56 f6 		adc	WORD PTR [bp-10],dx
;|***     if(checksum32 > 0x0000ffff)                  // perform end-around carry
; Line 2083
	*** 003072	83 7e f6 00 		cmp	WORD PTR [bp-10],0
	*** 003076	76 03 			jbe	$JCC12406
	*** 003078	e9 09 00 		jmp	$L4126
					$JCC12406:
	*** 00307b	83 7e f4 ff 		cmp	WORD PTR [bp-12],-1	;ffffH	;checksum32
	*** 00307f	77 03 			ja	$JCC12415
	*** 003081	e9 11 00 		jmp	$I4026
					$JCC12415:
					$L4126:
;|***       {                                          // if required
; Line 2084
;|***       checksum32 = (checksum32 & 0x0000ffff) + 1;
; Line 2085
	*** 003084	8b 46 f4 		mov	ax,WORD PTR [bp-12]	;checksum32
	*** 003087	2b d2 			sub	dx,dx
	*** 003089	05 01 00 		add	ax,1
	*** 00308c	83 d2 00 		adc	dx,0
	*** 00308f	89 46 f4 		mov	WORD PTR [bp-12],ax	;checksum32
	*** 003092	89 56 f6 		mov	WORD PTR [bp-10],dx
;|***       }
; Line 2086
;|***     j = j+2;
; Line 2087
					$I4026:
	*** 003095	83 46 fc 02 		add	WORD PTR [bp-4],2	;j
;|***     }
; Line 2088
	*** 003099	e9 ab ff 		jmp	$FC4024
					$FB4025:
;|***   checksum16 = (unsigned)(checksum32 & 0x0000ffff);          // convert back to 16-bit
; Line 2089
	*** 00309c	8b 46 f4 		mov	ax,WORD PTR [bp-12]	;checksum32
	*** 00309f	89 46 f8 		mov	WORD PTR [bp-8],ax	;checksum16
;|***   checksum16 = ~checksum16;                      // take the 1's complement
; Line 2090
	*** 0030a2	f7 56 f8 		not	WORD PTR [bp-8]	;checksum16
;|***   data_pkt[24] = high_byte(checksum16);          // and insert into header
; Line 2091
	*** 0030a5	ff 76 f8 		push	WORD PTR [bp-8]	;checksum16
	*** 0030a8	9a 00 00 00 00 		call	FAR PTR ?high_byte@@ZAEI@Z	; high_byte
	*** 0030ad	83 c4 02 		add	sp,2
	*** 0030b0	a2 18 00 		mov	BYTE PTR ?data_pkt@@3QIEI+24,al	;data_pkt
;|***   data_pkt[25] = low_byte(checksum16);
; Line 2092
	*** 0030b3	ff 76 f8 		push	WORD PTR [bp-8]	;checksum16
	*** 0030b6	9a 00 00 00 00 		call	FAR PTR ?low_byte@@ZAEI@Z	; low_byte
	*** 0030bb	83 c4 02 		add	sp,2
	*** 0030be	a2 19 00 		mov	BYTE PTR ?data_pkt@@3QIEI+25,al	;data_pkt
;|*** 
;|***   // insert udp packet into ip data field (up to 1480 bytes)
;|***   // start with the udp header
;|***   // insert udp source port
;|***   data_pkt[34] = high_byte(UDP_SOURCE_PORT);
; Line 2097
	*** 0030c1	68 57 13 		push	4951	;1357H
	*** 0030c4	9a 00 00 00 00 		call	FAR PTR ?high_byte@@ZAEI@Z	; high_byte
	*** 0030c9	83 c4 02 		add	sp,2
	*** 0030cc	a2 22 00 		mov	BYTE PTR ?data_pkt@@3QIEI+34,al	;data_pkt
;|***   data_pkt[35] = low_byte(UDP_SOURCE_PORT);
; Line 2098
	*** 0030cf	68 57 13 		push	4951	;1357H
	*** 0030d2	9a 00 00 00 00 		call	FAR PTR ?low_byte@@ZAEI@Z	; low_byte
	*** 0030d7	83 c4 02 		add	sp,2
	*** 0030da	a2 23 00 		mov	BYTE PTR ?data_pkt@@3QIEI+35,al	;data_pkt
;|*** 
;|***   // insert udp destination port
;|***   data_pkt[36] = high_byte(UDP_DEST_PORT);
; Line 2101
	*** 0030dd	68 56 13 		push	4950	;1356H
	*** 0030e0	9a 00 00 00 00 		call	FAR PTR ?high_byte@@ZAEI@Z	; high_byte
	*** 0030e5	83 c4 02 		add	sp,2
	*** 0030e8	a2 24 00 		mov	BYTE PTR ?data_pkt@@3QIEI+36,al	;data_pkt
;|***   data_pkt[37] = low_byte(UDP_DEST_PORT);
; Line 2102
	*** 0030eb	68 56 13 		push	4950	;1356H
	*** 0030ee	9a 00 00 00 00 		call	FAR PTR ?low_byte@@ZAEI@Z	; low_byte
	*** 0030f3	83 c4 02 		add	sp,2
	*** 0030f6	a2 25 00 		mov	BYTE PTR ?data_pkt@@3QIEI+37,al	;data_pkt
;|*** 
;|***   // insert udp length
;|***   data_pkt[38] = high_byte(UDP_LENGTH);
; Line 2105
	*** 0030f9	68 c8 05 		push	1480	;05c8H
	*** 0030fc	9a 00 00 00 00 		call	FAR PTR ?high_byte@@ZAEI@Z	; high_byte
	*** 003101	83 c4 02 		add	sp,2
	*** 003104	a2 26 00 		mov	BYTE PTR ?data_pkt@@3QIEI+38,al	;data_pkt
;|***   data_pkt[39] = low_byte(UDP_LENGTH);
; Line 2106
	*** 003107	68 c8 05 		push	1480	;05c8H
	*** 00310a	9a 00 00 00 00 		call	FAR PTR ?low_byte@@ZAEI@Z	; low_byte
	*** 00310f	83 c4 02 		add	sp,2
	*** 003112	a2 27 00 		mov	BYTE PTR ?data_pkt@@3QIEI+39,al	;data_pkt
;|*** 
;|***   // insert dummy udp checksum
;|***   // must wait until after udp data is loaded
;|***   // to calculate the real udp checksum
;|***   data_pkt[40] = 0;
; Line 2111
	*** 003115	c6 06 28 00 00 		mov	BYTE PTR ?data_pkt@@3QIEI+40,0	;data_pkt
;|***   data_pkt[41] = 0;
; Line 2112
	*** 00311a	c6 06 29 00 00 		mov	BYTE PTR ?data_pkt@@3QIEI+41,0	;data_pkt
;|***   
;|***   /*
;|***   // insert dummy udp data
;|***   for(i=42; i<1514; i++) // insert packet data
;|***     {
;|***     data_pkt[i] = (unsigned char) i & 0xf;
;|***     }
;|***   */
;|***   
;|***   // insert real obc data
;|***   i = 42;
; Line 2123
	*** 00311f	c7 46 fe 2a 00 		mov	WORD PTR [bp-2],42	;002aH	;i
;|***   
;|***   _fmemcpy(&data_pkt[i], &sys,  sizeof(sys));
; Line 2125
	*** 003124	6a 12 			push	18	;0012H
	*** 003126	68 00 00 		push	SEG ?sys@@3USYS@@E	;sys
	*** 003129	68 00 00 		push	OFFSET ?sys@@3USYS@@E	;sys
	*** 00312c	8b 46 fe 		mov	ax,WORD PTR [bp-2]	;i
	*** 00312f	05 00 00 		add	ax,OFFSET DGROUP:?data_pkt@@3QIEI	;data_pkt
	*** 003132	1e 			push	ds
	*** 003133	50 			push	ax
	*** 003134	9a 00 00 00 00 		call	FAR PTR __fmemcpy
	*** 003139	83 c4 0a 		add	sp,10	;000aH
;|***   i += sizeof(sys);
; Line 2126
	*** 00313c	83 46 fe 12 		add	WORD PTR [bp-2],18	;0012H	;i
;|*** 
;|***   _fmemcpy(&data_pkt[i], &obs, sizeof(obs));
; Line 2128
	*** 003140	6a 4c 			push	76	;004cH
	*** 003142	68 00 00 		push	SEG ?obs@@3UOBS@@E	;obs
	*** 003145	68 00 00 		push	OFFSET ?obs@@3UOBS@@E	;obs
	*** 003148	8b 46 fe 		mov	ax,WORD PTR [bp-2]	;i
	*** 00314b	05 00 00 		add	ax,OFFSET DGROUP:?data_pkt@@3QIEI	;data_pkt
	*** 00314e	1e 			push	ds
	*** 00314f	50 			push	ax
	*** 003150	9a 00 00 00 00 		call	FAR PTR __fmemcpy
	*** 003155	83 c4 0a 		add	sp,10	;000aH
;|***   i += sizeof(obs);
; Line 2129
	*** 003158	83 46 fe 4c 		add	WORD PTR [bp-2],76	;004cH	;i
;|***   
;|***   _fmemcpy(&data_pkt[i], &dyno, sizeof(dyno));
; Line 2131
	*** 00315c	68 0c 01 		push	268	;010cH
	*** 00315f	68 00 00 		push	SEG ?dyno@@3UDYNO@@E	;dyno
	*** 003162	68 00 00 		push	OFFSET ?dyno@@3UDYNO@@E	;dyno
	*** 003165	8b 46 fe 		mov	ax,WORD PTR [bp-2]	;i
	*** 003168	05 00 00 		add	ax,OFFSET DGROUP:?data_pkt@@3QIEI	;data_pkt
	*** 00316b	1e 			push	ds
	*** 00316c	50 			push	ax
	*** 00316d	9a 00 00 00 00 		call	FAR PTR __fmemcpy
	*** 003172	83 c4 0a 		add	sp,10	;000aH
;|***   i += sizeof(dyno);
; Line 2132
	*** 003175	81 46 fe 0c 01 		add	WORD PTR [bp-2],268	;010cH	;i
;|***   
;|***   _fmemcpy(&data_pkt[i], &prop, sizeof(prop));
; Line 2134
	*** 00317a	6a 2a 			push	42	;002aH
	*** 00317c	68 00 00 		push	SEG ?prop@@3UPROP@@E	;prop
	*** 00317f	68 00 00 		push	OFFSET ?prop@@3UPROP@@E	;prop
	*** 003182	8b 46 fe 		mov	ax,WORD PTR [bp-2]	;i
	*** 003185	05 00 00 		add	ax,OFFSET DGROUP:?data_pkt@@3QIEI	;data_pkt
	*** 003188	1e 			push	ds
	*** 003189	50 			push	ax
	*** 00318a	9a 00 00 00 00 		call	FAR PTR __fmemcpy
	*** 00318f	83 c4 0a 		add	sp,10	;000aH
;|***   i += sizeof(prop);
; Line 2135
	*** 003192	83 46 fe 2a 		add	WORD PTR [bp-2],42	;002aH	;i
;|***   
;|***   _fmemcpy(&data_pkt[i], &ln200, sizeof(ln200));
; Line 2137
	*** 003196	6a 2c 			push	44	;002cH
	*** 003198	68 00 00 		push	SEG ?ln200@@3ULN200@@E	;ln200
	*** 00319b	68 00 00 		push	OFFSET ?ln200@@3ULN200@@E	;ln200
	*** 00319e	8b 46 fe 		mov	ax,WORD PTR [bp-2]	;i
	*** 0031a1	05 00 00 		add	ax,OFFSET DGROUP:?data_pkt@@3QIEI	;data_pkt
	*** 0031a4	1e 			push	ds
	*** 0031a5	50 			push	ax
	*** 0031a6	9a 00 00 00 00 		call	FAR PTR __fmemcpy
	*** 0031ab	83 c4 0a 		add	sp,10	;000aH
;|***   i += sizeof(ln200);
; Line 2138
	*** 0031ae	83 46 fe 2c 		add	WORD PTR [bp-2],44	;002cH	;i
;|***   
;|***   _fmemcpy(&data_pkt[i], &echo, sizeof(echo));
; Line 2140
	*** 0031b2	6a 30 			push	48	;0030H
	*** 0031b4	68 00 00 		push	SEG ?echo@@3UECHO@@E	;echo
	*** 0031b7	68 00 00 		push	OFFSET ?echo@@3UECHO@@E	;echo
	*** 0031ba	8b 46 fe 		mov	ax,WORD PTR [bp-2]	;i
	*** 0031bd	05 00 00 		add	ax,OFFSET DGROUP:?data_pkt@@3QIEI	;data_pkt
	*** 0031c0	1e 			push	ds
	*** 0031c1	50 			push	ax
	*** 0031c2	9a 00 00 00 00 		call	FAR PTR __fmemcpy
	*** 0031c7	83 c4 0a 		add	sp,10	;000aH
;|***   i += sizeof(echo);
; Line 2141
	*** 0031ca	83 46 fe 30 		add	WORD PTR [bp-2],48	;0030H	;i
;|***   
;|***   _fmemcpy(&data_pkt[i], &ds, sizeof(ds));
; Line 2143
	*** 0031ce	6a 5c 			push	92	;005cH
	*** 0031d0	68 00 00 		push	SEG ?ds@@3UDS@@E	;ds
	*** 0031d3	68 00 00 		push	OFFSET ?ds@@3UDS@@E	;ds
	*** 0031d6	8b 46 fe 		mov	ax,WORD PTR [bp-2]	;i
	*** 0031d9	05 00 00 		add	ax,OFFSET DGROUP:?data_pkt@@3QIEI	;data_pkt
	*** 0031dc	1e 			push	ds
	*** 0031dd	50 			push	ax
	*** 0031de	9a 00 00 00 00 		call	FAR PTR __fmemcpy
	*** 0031e3	83 c4 0a 		add	sp,10	;000aH
;|***   i += sizeof(ds);
; Line 2144
	*** 0031e6	83 46 fe 5c 		add	WORD PTR [bp-2],92	;005cH	;i
;|***   
;|***   _fmemcpy(&data_pkt[i], &adcp, sizeof(adcp));
; Line 2146
	*** 0031ea	68 e1 00 		push	225	;00e1H
	*** 0031ed	68 00 00 		push	SEG ?adcp@@3UADCP@@E	;adcp
	*** 0031f0	68 00 00 		push	OFFSET ?adcp@@3UADCP@@E	;adcp
	*** 0031f3	8b 46 fe 		mov	ax,WORD PTR [bp-2]	;i
	*** 0031f6	05 00 00 		add	ax,OFFSET DGROUP:?data_pkt@@3QIEI	;data_pkt
	*** 0031f9	1e 			push	ds
	*** 0031fa	50 			push	ax
	*** 0031fb	9a 00 00 00 00 		call	FAR PTR __fmemcpy
	*** 003200	83 c4 0a 		add	sp,10	;000aH
;|***   i += sizeof(adcp);
; Line 2147
	*** 003203	81 46 fe e1 00 		add	WORD PTR [bp-2],225	;00e1H	;i
;|***   
;|***   _fmemcpy(&data_pkt[i], &gps, sizeof(gps));
; Line 2149
	*** 003208	6a 5c 			push	92	;005cH
	*** 00320a	68 00 00 		push	SEG ?gps@@3UGPS@@E	;gps
	*** 00320d	68 00 00 		push	OFFSET ?gps@@3UGPS@@E	;gps
	*** 003210	8b 46 fe 		mov	ax,WORD PTR [bp-2]	;i
	*** 003213	05 00 00 		add	ax,OFFSET DGROUP:?data_pkt@@3QIEI	;data_pkt
	*** 003216	1e 			push	ds
	*** 003217	50 			push	ax
	*** 003218	9a 00 00 00 00 		call	FAR PTR __fmemcpy
	*** 00321d	83 c4 0a 		add	sp,10	;000aH
;|***   i += sizeof(gps);
; Line 2150
	*** 003220	83 46 fe 5c 		add	WORD PTR [bp-2],92	;005cH	;i
;|*** 
;|***   // now calculate and insert the real udp checksum
;|***   // from the udp pseudo-header and true header
;|***   for(j=0;j<8;j++) udp_pseudo[j] = data_pkt[j+26];  // source & dest ip addr
; Line 2154
	*** 003224	c7 46 fc 00 00 		mov	WORD PTR [bp-4],0	;j
	*** 003229	e9 03 00 		jmp	$F4028
					$FC4029:
	*** 00322c	ff 46 fc 		inc	WORD PTR [bp-4]	;j
					$F4028:
	*** 00322f	83 7e fc 08 		cmp	WORD PTR [bp-4],8	;j
	*** 003233	72 03 			jb	$JCC12851
	*** 003235	e9 10 00 		jmp	$FB4030
					$JCC12851:
	*** 003238	8b 5e fc 		mov	bx,WORD PTR [bp-4]	;j
	*** 00323b	8a 87 1a 00 		mov	al,BYTE PTR ?data_pkt@@3QIEI[bx+26]	;data_pkt
	*** 00323f	8b 76 fc 		mov	si,WORD PTR [bp-4]	;j
	*** 003242	88 42 e0 		mov	BYTE PTR [bp-32][si],al
	*** 003245	e9 e4 ff 		jmp	$FC4029
					$FB4030:
;|***   udp_pseudo[8] = 0;
; Line 2155
	*** 003248	c6 46 e8 00 		mov	BYTE PTR [bp-24],0
;|***   udp_pseudo[9] = data_pkt[23];  // protocol id
; Line 2156
	*** 00324c	a0 17 00 		mov	al,BYTE PTR ?data_pkt@@3QIEI+23	;data_pkt
	*** 00324f	88 46 e9 		mov	BYTE PTR [bp-23],al
;|***   udp_pseudo[10] = data_pkt[38];  // udp len high
; Line 2157
	*** 003252	a0 26 00 		mov	al,BYTE PTR ?data_pkt@@3QIEI+38	;data_pkt
	*** 003255	88 46 ea 		mov	BYTE PTR [bp-22],al
;|***   udp_pseudo[11] = data_pkt[39];  // udp len low
; Line 2158
	*** 003258	a0 27 00 		mov	al,BYTE PTR ?data_pkt@@3QIEI+39	;data_pkt
	*** 00325b	88 46 eb 		mov	BYTE PTR [bp-21],al
;|*** 
;|***   // calculate the 1's complement checksum
;|***   checksum32 = 0;
; Line 2161
	*** 00325e	2b c0 			sub	ax,ax
	*** 003260	89 46 f6 		mov	WORD PTR [bp-10],ax
	*** 003263	89 46 f4 		mov	WORD PTR [bp-12],ax	;checksum32
;|***   for(j=0;j<12;)
; Line 2162
	*** 003266	c7 46 fc 00 00 		mov	WORD PTR [bp-4],0	;j
					$FC4032:
	*** 00326b	83 7e fc 0c 		cmp	WORD PTR [bp-4],12	;000cH	;j
	*** 00326f	72 03 			jb	$JCC12911
	*** 003271	e9 4a 00 		jmp	$FB4033
					$JCC12911:
;|***     {
; Line 2163
;|***     value = (udp_pseudo[j] << 8) + udp_pseudo[j+1];
; Line 2164
	*** 003274	8b 76 fc 		mov	si,WORD PTR [bp-4]	;j
	*** 003277	8a 62 e0 		mov	ah,BYTE PTR [bp-32][si]
	*** 00327a	2a c0 			sub	al,al
	*** 00327c	8b 76 fc 		mov	si,WORD PTR [bp-4]	;j
	*** 00327f	8a 4a e1 		mov	cl,BYTE PTR [bp-31][si]
	*** 003282	2a ed 			sub	ch,ch
	*** 003284	03 c1 			add	ax,cx
	*** 003286	89 46 fa 		mov	WORD PTR [bp-6],ax	;value
;|***     //if(value < 0) value -= 1;                    // convert to 1's complement
;|***     checksum32 += value;                         // add them up
; Line 2166
	*** 003289	8b 46 fa 		mov	ax,WORD PTR [bp-6]	;value
	*** 00328c	2b d2 			sub	dx,dx
	*** 00328e	01 46 f4 		add	WORD PTR [bp-12],ax	;checksum32
	*** 003291	11 56 f6 		adc	WORD PTR [bp-10],dx
;|***     if(checksum32 > 0x0000ffff)                  // perform end-around carry
; Line 2167
	*** 003294	83 7e f6 00 		cmp	WORD PTR [bp-10],0
	*** 003298	76 03 			jbe	$JCC12952
	*** 00329a	e9 09 00 		jmp	$L4127
					$JCC12952:
	*** 00329d	83 7e f4 ff 		cmp	WORD PTR [bp-12],-1	;ffffH	;checksum32
	*** 0032a1	77 03 			ja	$JCC12961
	*** 0032a3	e9 11 00 		jmp	$I4034
					$JCC12961:
					$L4127:
;|***       {
; Line 2168
;|***       checksum32 = (checksum32 & 0x0000ffff) + 1;
; Line 2169
	*** 0032a6	8b 46 f4 		mov	ax,WORD PTR [bp-12]	;checksum32
	*** 0032a9	2b d2 			sub	dx,dx
	*** 0032ab	05 01 00 		add	ax,1
	*** 0032ae	83 d2 00 		adc	dx,0
	*** 0032b1	89 46 f4 		mov	WORD PTR [bp-12],ax	;checksum32
	*** 0032b4	89 56 f6 		mov	WORD PTR [bp-10],dx
;|***       }
; Line 2170
;|***     j = j+2;
; Line 2171
					$I4034:
	*** 0032b7	83 46 fc 02 		add	WORD PTR [bp-4],2	;j
;|***     }
; Line 2172
	*** 0032bb	e9 ad ff 		jmp	$FC4032
					$FB4033:
;|*** 
;|***   // true udp header and data next
;|***   for(j=34;j<1514;)  // true udp header and data
; Line 2175
	*** 0032be	c7 46 fc 22 00 		mov	WORD PTR [bp-4],34	;0022H	;j
					$FC4036:
	*** 0032c3	81 7e fc ea 05 		cmp	WORD PTR [bp-4],1514	;05eaH	;j
	*** 0032c8	72 03 			jb	$JCC13000
	*** 0032ca	e9 4c 00 		jmp	$FB4037
					$JCC13000:
;|***     {
; Line 2176
;|***     value = (data_pkt[j] << 8) + data_pkt[j+1];
; Line 2177
	*** 0032cd	8b 5e fc 		mov	bx,WORD PTR [bp-4]	;j
	*** 0032d0	8a a7 00 00 		mov	ah,BYTE PTR ?data_pkt@@3QIEI[bx]	;data_pkt
	*** 0032d4	2a c0 			sub	al,al
	*** 0032d6	8b 5e fc 		mov	bx,WORD PTR [bp-4]	;j
	*** 0032d9	8a 8f 01 00 		mov	cl,BYTE PTR ?data_pkt@@3QIEI[bx+1]	;data_pkt
	*** 0032dd	2a ed 			sub	ch,ch
	*** 0032df	03 c1 			add	ax,cx
	*** 0032e1	89 46 fa 		mov	WORD PTR [bp-6],ax	;value
;|***     //if(value < 0) value -= 1;                    // convert it to 1's complement
;|***     checksum32 += value;                         // add them up
; Line 2179
	*** 0032e4	8b 46 fa 		mov	ax,WORD PTR [bp-6]	;value
	*** 0032e7	2b d2 			sub	dx,dx
	*** 0032e9	01 46 f4 		add	WORD PTR [bp-12],ax	;checksum32
	*** 0032ec	11 56 f6 		adc	WORD PTR [bp-10],dx
;|***     if(checksum32 > 0x0000ffff)                  // perform end-around carry
; Line 2180
	*** 0032ef	83 7e f6 00 		cmp	WORD PTR [bp-10],0
	*** 0032f3	76 03 			jbe	$JCC13043
	*** 0032f5	e9 09 00 		jmp	$L4128
					$JCC13043:
	*** 0032f8	83 7e f4 ff 		cmp	WORD PTR [bp-12],-1	;ffffH	;checksum32
	*** 0032fc	77 03 			ja	$JCC13052
	*** 0032fe	e9 11 00 		jmp	$I4038
					$JCC13052:
					$L4128:
;|***       {
; Line 2181
;|***       checksum32 = (checksum32 & 0x0000ffff) + 1;
; Line 2182
	*** 003301	8b 46 f4 		mov	ax,WORD PTR [bp-12]	;checksum32
	*** 003304	2b d2 			sub	dx,dx
	*** 003306	05 01 00 		add	ax,1
	*** 003309	83 d2 00 		adc	dx,0
	*** 00330c	89 46 f4 		mov	WORD PTR [bp-12],ax	;checksum32
	*** 00330f	89 56 f6 		mov	WORD PTR [bp-10],dx
;|***       }
; Line 2183
;|***     j = j+2;
; Line 2184
					$I4038:
	*** 003312	83 46 fc 02 		add	WORD PTR [bp-4],2	;j
;|***     }
; Line 2185
	*** 003316	e9 aa ff 		jmp	$FC4036
					$FB4037:
;|***   checksum16 = (unsigned)(checksum32 & 0x0000ffff);          // convert back to 16-bit
; Line 2186
	*** 003319	8b 46 f4 		mov	ax,WORD PTR [bp-12]	;checksum32
	*** 00331c	89 46 f8 		mov	WORD PTR [bp-8],ax	;checksum16
;|***   checksum16 = ~checksum16;                      // take the 1's complement
; Line 2187
	*** 00331f	f7 56 f8 		not	WORD PTR [bp-8]	;checksum16
;|***   if(checksum16 == 0) checksum16 = 0xffff;       // only for udp/tcp
; Line 2188
	*** 003322	83 7e f8 00 		cmp	WORD PTR [bp-8],0	;checksum16
	*** 003326	74 03 			je	$JCC13094
	*** 003328	e9 05 00 		jmp	$I4040
					$JCC13094:
	*** 00332b	c7 46 f8 ff ff 		mov	WORD PTR [bp-8],-1	;ffffH	;checksum16
;|***   data_pkt[40] = high_byte(checksum16);
; Line 2189
					$I4040:
	*** 003330	ff 76 f8 		push	WORD PTR [bp-8]	;checksum16
	*** 003333	9a 00 00 00 00 		call	FAR PTR ?high_byte@@ZAEI@Z	; high_byte
	*** 003338	83 c4 02 		add	sp,2
	*** 00333b	a2 28 00 		mov	BYTE PTR ?data_pkt@@3QIEI+40,al	;data_pkt
;|***   data_pkt[41] = low_byte(checksum16);
; Line 2190
	*** 00333e	ff 76 f8 		push	WORD PTR [bp-8]	;checksum16
	*** 003341	9a 00 00 00 00 		call	FAR PTR ?low_byte@@ZAEI@Z	; low_byte
	*** 003346	83 c4 02 		add	sp,2
	*** 003349	a2 29 00 		mov	BYTE PTR ?data_pkt@@3QIEI+41,al	;data_pkt
;|*** 
;|***    // end build_packet()
;|***   }
; Line 2193
	*** 00334c	e9 00 00 		jmp	$EX4004
					$EX4004:
	*** 00334f	5e 			pop	si
	*** 003350	5f 			pop	di
	*** 003351	c9 			leave	
	*** 003352	cb 			ret	

?build_packet@@ZAXXZ	ENDP
	PUBLIC	?high_byte@@ZAEI@Z	; high_byte
?high_byte@@ZAEI@Z	PROC FAR	; high_byte
;|*** 
;|*** 
;|*** unsigned char high_byte(unsigned int word)
;|***   {
; Line 2197
	*** 003353	c8 00 00 00 		enter	0,0
	*** 003357	57 			push	di
	*** 003358	56 			push	si
;	word = 6
;|***   return (unsigned char) ((word>>8)&0xff);
; Line 2198
	*** 003359	8a 46 07 		mov	al,BYTE PTR [bp+7]
	*** 00335c	e9 00 00 		jmp	$EX4042
;|***   }
; Line 2199
					$EX4042:
	*** 00335f	5e 			pop	si
	*** 003360	5f 			pop	di
	*** 003361	c9 			leave	
	*** 003362	cb 			ret	

?high_byte@@ZAEI@Z	ENDP
	PUBLIC	?low_byte@@ZAEI@Z	; low_byte
?low_byte@@ZAEI@Z	PROC FAR	; low_byte
;|*** 
;|*** 
;|*** 
;|*** unsigned char low_byte(unsigned int word)
;|***   {
; Line 2204
	*** 003363	c8 00 00 00 		enter	0,0
	*** 003367	57 			push	di
	*** 003368	56 			push	si
;	word = 6
;|***   return (unsigned char) (word&0xff);
; Line 2205
	*** 003369	8a 46 06 		mov	al,BYTE PTR [bp+6]	;word
	*** 00336c	e9 00 00 		jmp	$EX4045
;|***   }
; Line 2206
					$EX4045:
	*** 00336f	5e 			pop	si
	*** 003370	5f 			pop	di
	*** 003371	c9 			leave	
	*** 003372	cb 			ret	

?low_byte@@ZAEI@Z	ENDP
	PUBLIC	?init_screen@@ZAXXZ	; init_screen
?init_screen@@ZAXXZ	PROC FAR	; init_screen
;|***     
;|*** 
;|*** void init_screen(void)
;|*** {
; Line 2210
	*** 003373	c8 52 00 00 		enter	82,0
	*** 003377	57 			push	di
	*** 003378	56 			push	si
;	s = -82
;|***   char s[81];
;|*** 
;|***   PC_DispClrScr(DISP_FGND_LIGHT_GRAY + DISP_BGND_RED);
; Line 2213
	*** 003379	6a 47 			push	71	;0047H
	*** 00337b	9a 00 00 00 00 		call	FAR PTR ?PC_DispClrScr@@ZAXE@Z	; PC_DispClrScr
	*** 003380	83 c4 02 		add	sp,2
;|*** //  PC_DispClrRow(0, DISP_BGND_LIGHT_GRAY);
;|*** //  PC_DispClrRow(1, DISP_BGND_LIGHT_GRAY);
;|***   
;|***   sprintf(s, "%s", 
;|*** "                       Autonomous Model Onboard Computer                        ");
; Line 2218
	*** 003383	1e 			push	ds
	*** 003384	68 00 00 		push	OFFSET DGROUP:$SG4050
	*** 003387	1e 			push	ds
	*** 003388	68 00 00 		push	OFFSET DGROUP:$SG4051
	*** 00338b	8d 46 ae 		lea	ax,WORD PTR [bp-82]	;s
	*** 00338e	16 			push	ss
	*** 00338f	50 			push	ax
	*** 003390	9a 00 00 00 00 		call	FAR PTR _sprintf
	*** 003395	83 c4 0c 		add	sp,12	;000cH
;|***   PC_DispStr(0,0, (unsigned char *)s, DISP_FGND_BLACK + DISP_BGND_LIGHT_GRAY);
; Line 2219
	*** 003398	6a 70 			push	112	;0070H
	*** 00339a	8d 46 ae 		lea	ax,WORD PTR [bp-82]	;s
	*** 00339d	16 			push	ss
	*** 00339e	50 			push	ax
	*** 00339f	6a 00 			push	0
	*** 0033a1	6a 00 			push	0
	*** 0033a3	9a 00 00 00 00 		call	FAR PTR ?PC_DispStr@@ZAXEEPIEE@Z	; PC_DispStr
	*** 0033a8	83 c4 0a 		add	sp,10	;000aH
;|*** 
;|***   sprintf(s, "%s", 
;|*** "                               NSWC-CD Code 5600                                ");
; Line 2222
	*** 0033ab	1e 			push	ds
	*** 0033ac	68 00 00 		push	OFFSET DGROUP:$SG4053
	*** 0033af	1e 			push	ds
	*** 0033b0	68 00 00 		push	OFFSET DGROUP:$SG4054
	*** 0033b3	8d 46 ae 		lea	ax,WORD PTR [bp-82]	;s
	*** 0033b6	16 			push	ss
	*** 0033b7	50 			push	ax
	*** 0033b8	9a 00 00 00 00 		call	FAR PTR _sprintf
	*** 0033bd	83 c4 0c 		add	sp,12	;000cH
;|***   PC_DispStr(0,1, (unsigned char *)s, DISP_FGND_BLACK + DISP_BGND_LIGHT_GRAY);  
; Line 2223
	*** 0033c0	6a 70 			push	112	;0070H
	*** 0033c2	8d 46 ae 		lea	ax,WORD PTR [bp-82]	;s
	*** 0033c5	16 			push	ss
	*** 0033c6	50 			push	ax
	*** 0033c7	6a 01 			push	1
	*** 0033c9	6a 00 			push	0
	*** 0033cb	9a 00 00 00 00 		call	FAR PTR ?PC_DispStr@@ZAXEEPIEE@Z	; PC_DispStr
	*** 0033d0	83 c4 0a 		add	sp,10	;000aH
;|***     
;|***   sprintf(s, "%s",
;|*** "                             March 8, 2004 Rev 0.8                              ");
; Line 2226
	*** 0033d3	1e 			push	ds
	*** 0033d4	68 00 00 		push	OFFSET DGROUP:$SG4056
	*** 0033d7	1e 			push	ds
	*** 0033d8	68 00 00 		push	OFFSET DGROUP:$SG4057
	*** 0033db	8d 46 ae 		lea	ax,WORD PTR [bp-82]	;s
	*** 0033de	16 			push	ss
	*** 0033df	50 			push	ax
	*** 0033e0	9a 00 00 00 00 		call	FAR PTR _sprintf
	*** 0033e5	83 c4 0c 		add	sp,12	;000cH
;|***   PC_DispStr(0,2, (unsigned char *)s, DISP_FGND_BLACK + DISP_BGND_LIGHT_GRAY);
; Line 2227
	*** 0033e8	6a 70 			push	112	;0070H
	*** 0033ea	8d 46 ae 		lea	ax,WORD PTR [bp-82]	;s
	*** 0033ed	16 			push	ss
	*** 0033ee	50 			push	ax
	*** 0033ef	6a 02 			push	2
	*** 0033f1	6a 00 			push	0
	*** 0033f3	9a 00 00 00 00 		call	FAR PTR ?PC_DispStr@@ZAXEEPIEE@Z	; PC_DispStr
	*** 0033f8	83 c4 0a 		add	sp,10	;000aH
;|***   
;|*** }
; Line 2229
	*** 0033fb	e9 00 00 		jmp	$EX4048
					$EX4048:
	*** 0033fe	5e 			pop	si
	*** 0033ff	5f 			pop	di
	*** 003400	c9 			leave	
	*** 003401	cb 			ret	

?init_screen@@ZAXXZ	ENDP
	PUBLIC	?prep_ln200_command@@ZAXXZ	; prep_ln200_command
?prep_ln200_command@@ZAXXZ	PROC FAR	; prep_ln200_command
;|*** 
;|*** 
;|*** void prep_ln200_command(void)
;|***   {
; Line 2233
	*** 003402	c8 24 00 00 		enter	36,0
	*** 003406	57 			push	di
	*** 003407	56 			push	si
;	i = -2
;	heading = -4
;	latitude_valid = -6
;	boresights_valid = -8
;	heading_valid = -10
;	bit = -12
;	mode = -14
;	latitude = -16
;	x_axis = -18
;	y_axis = -20
;	z_axis = -22
;	icmd = -36
;|***   #define YES 1
;|***   //#define X_AXIS 0.0f
;|***   #define X_AXIS -0.48f
;|***   #define Y_AXIS 0.0f
;|***   #define Z_AXIS 0.0f
;|***   #define LATITUDE 38.7f
;|*** 
;|***   int i;
;|***   int heading;
;|***   unsigned latitude_valid;
;|***   unsigned boresights_valid;
;|***   unsigned heading_valid;
;|***   unsigned bit = 0;
; Line 2246
	*** 003408	c7 46 f4 00 00 		mov	WORD PTR [bp-12],0	;bit
;|***   unsigned mode = 0;
; Line 2247
	*** 00340d	c7 46 f2 00 00 		mov	WORD PTR [bp-14],0	;mode
;|***   int      latitude;
;|***   int      x_axis;
;|***   int      y_axis;
;|***   int      z_axis;
;|***   
;|***   unsigned icmd[7];
;|***   
;|***   static unsigned do_once = 1;
;|***   
;|***   //heading = (int) (-52.0 * 182.044);   // along wavemaker
;|***   heading =  (int) (-53.5 * 182.044);    // Tighe says so.
; Line 2258
	*** 003412	c7 46 fc f5 d9 		mov	WORD PTR [bp-4],-9739	;d9f5H	;heading
;|*** //  heading =  (int) (26.5 * 182.044);    // Aberdeen Alignment - 8/28/06 sjc
;|***   latitude = (int) (LATITUDE * 182.044); // LN200 operating latitude,+-degrees, see ln200 ICD
; Line 2260
	*** 003417	c7 46 f0 85 1b 		mov	WORD PTR [bp-16],7045	;1b85H	;latitude
;|***   x_axis =   (int) (X_AXIS * 182.044);     // LN200 boresight rotations,+-degrees
; Line 2261
	*** 00341c	c7 46 ee a9 ff 		mov	WORD PTR [bp-18],-87	;ffa9H	;x_axis
;|***   y_axis =   (int) (Y_AXIS * 182.044);
; Line 2262
	*** 003421	c7 46 ec 00 00 		mov	WORD PTR [bp-20],0	;y_axis
;|***   z_axis =   (int) (Z_AXIS * 182.044);
; Line 2263
	*** 003426	c7 46 ea 00 00 		mov	WORD PTR [bp-22],0	;z_axis
;|***     
;|***   //mode = 0;      //LN200 modes are 0 (free inertial) and 1 (fast leveling)
;|***   //mode = 1;
;|***     
;|***   latitude_valid  = YES;               // latitude valid?
; Line 2268
	*** 00342b	c7 46 fa 01 00 		mov	WORD PTR [bp-6],1	;latitude_valid
;|***   heading_valid = YES;                 // heading valid?
; Line 2269
	*** 003430	c7 46 f6 01 00 		mov	WORD PTR [bp-10],1	;heading_valid
;|***   boresights_valid = YES;              // boresight rotations valid?
; Line 2270
	*** 003435	c7 46 f8 01 00 		mov	WORD PTR [bp-8],1	;boresights_valid
;|***   bit = NO;
; Line 2271
	*** 00343a	c7 46 f4 00 00 		mov	WORD PTR [bp-12],0	;bit
;|***   
;|***   //ln200_mode = 0;
;|***   //if (commands.ln200_mode & 0x0010) commands.ln200_mode=0;               
;|***   if (commands.ln200_mode & 0x0010) commands.ln200_mode = commands.ln200_mode | 0x0001;               
; Line 2275
	*** 00343f	8e 06 00 00 		mov	es,WORD PTR $T4111
	*** 003443	26 f6 06 10 00 10 	test	BYTE PTR es:?commands@@3UCOMMANDS@@E+16,16	;0010H	;commands
	*** 003449	75 03 			jne	$JCC13385
	*** 00344b	e9 06 00 		jmp	$I4080
					$JCC13385:
	*** 00344e	26 83 0e 10 00 01 	or	WORD PTR es:?commands@@3UCOMMANDS@@E+16,1	;commands
;|***   
;|***   if (do_once)   // set heading to presets at model startup
; Line 2277
					$I4080:
	*** 003454	83 3e 00 00 00 		cmp	WORD PTR $S4074_?do_once@?1??prep_ln200_command@@ZAXXZ@4IE,0
	*** 003459	75 03 			jne	$JCC13401
	*** 00345b	e9 11 00 		jmp	$I4081
					$JCC13401:
;|***     {
; Line 2278
;|***     do_once = 0;
; Line 2279
	*** 00345e	c7 06 00 00 00 00 	mov	WORD PTR $S4074_?do_once@?1??prep_ln200_command@@ZAXXZ@4IE,0
;|***     commands.ln200_mode = 0x0011;
; Line 2280
	*** 003464	8e 06 00 00 		mov	es,WORD PTR $T4111
	*** 003468	26 c7 06 10 00 11 00 	mov	WORD PTR es:?commands@@3UCOMMANDS@@E+16,17	;0011H	;commands
;|***     }
; Line 2281
;|***                  
;|***   icmd[0]=0x0000;                      // assemble the command word icmd[]
; Line 2283
					$I4081:
	*** 00346f	c7 46 dc 00 00 		mov	WORD PTR [bp-36],0	;icmd
;|***   //icmd[0]=icmd[0]|mode;
;|***   icmd[0]=icmd[0]|commands.ln200_mode & 0x0007;
; Line 2285
	*** 003474	8e 06 00 00 		mov	es,WORD PTR $T4111
	*** 003478	26 a0 10 00 		mov	al,BYTE PTR es:?commands@@3UCOMMANDS@@E+16	;commands
	*** 00347c	25 07 00 		and	ax,7
	*** 00347f	09 46 dc 		or	WORD PTR [bp-36],ax	;icmd
;|***   icmd[0]=icmd[0]|(boresights_valid<<3);
; Line 2286
	*** 003482	8b 46 f8 		mov	ax,WORD PTR [bp-8]	;boresights_valid
	*** 003485	c1 e0 03 		shl	ax,3
	*** 003488	09 46 dc 		or	WORD PTR [bp-36],ax	;icmd
;|***   icmd[0]=icmd[0]|(bit<<4);
; Line 2287
	*** 00348b	8b 46 f4 		mov	ax,WORD PTR [bp-12]	;bit
	*** 00348e	c1 e0 04 		shl	ax,4
	*** 003491	09 46 dc 		or	WORD PTR [bp-36],ax	;icmd
;|***   icmd[0]=icmd[0]|(latitude_valid<<8);
; Line 2288
	*** 003494	8a 66 fa 		mov	ah,BYTE PTR [bp-6]	;latitude_valid
	*** 003497	2a c0 			sub	al,al
	*** 003499	09 46 dc 		or	WORD PTR [bp-36],ax	;icmd
;|***   icmd[0]=icmd[0]|((commands.ln200_mode & 0x0010) << 5);
; Line 2289
	*** 00349c	26 a0 10 00 		mov	al,BYTE PTR es:?commands@@3UCOMMANDS@@E+16	;commands
	*** 0034a0	25 10 00 		and	ax,16	;0010H
	*** 0034a3	c1 e0 05 		shl	ax,5
	*** 0034a6	09 46 dc 		or	WORD PTR [bp-36],ax	;icmd
;|***   icmd[1]=latitude;
; Line 2290
	*** 0034a9	8b 46 f0 		mov	ax,WORD PTR [bp-16]	;latitude
	*** 0034ac	89 46 de 		mov	WORD PTR [bp-34],ax
;|***   icmd[2]=heading;
; Line 2291
	*** 0034af	8b 46 fc 		mov	ax,WORD PTR [bp-4]	;heading
	*** 0034b2	89 46 e0 		mov	WORD PTR [bp-32],ax
;|***   icmd[3]=x_axis;
; Line 2292
	*** 0034b5	8b 46 ee 		mov	ax,WORD PTR [bp-18]	;x_axis
	*** 0034b8	89 46 e2 		mov	WORD PTR [bp-30],ax
;|***   icmd[4]=y_axis;
; Line 2293
	*** 0034bb	8b 46 ec 		mov	ax,WORD PTR [bp-20]	;y_axis
	*** 0034be	89 46 e4 		mov	WORD PTR [bp-28],ax
;|***   icmd[5]=z_axis;
; Line 2294
	*** 0034c1	8b 46 ea 		mov	ax,WORD PTR [bp-22]	;z_axis
	*** 0034c4	89 46 e6 		mov	WORD PTR [bp-26],ax
;|***   icmd[6]=0x0;                      // calculate icmd[] checksum
; Line 2295
	*** 0034c7	c7 46 e8 00 00 		mov	WORD PTR [bp-24],0
;|***   for (i=0;i<6;i++)                 // sum icmd[0] to icmd[5]
; Line 2296
	*** 0034cc	c7 46 fe 00 00 		mov	WORD PTR [bp-2],0	;i
	*** 0034d1	e9 03 00 		jmp	$F4082
					$FC4083:
	*** 0034d4	ff 46 fe 		inc	WORD PTR [bp-2]	;i
					$F4082:
	*** 0034d7	83 7e fe 06 		cmp	WORD PTR [bp-2],6	;i
	*** 0034db	7c 03 			jl	$JCC13531
	*** 0034dd	e9 0e 00 		jmp	$FB4084
					$JCC13531:
;|***     icmd[6]=icmd[6]+icmd[i];
; Line 2297
	*** 0034e0	8b 76 fe 		mov	si,WORD PTR [bp-2]	;i
	*** 0034e3	d1 e6 			shl	si,1
	*** 0034e5	8b 42 dc 		mov	ax,WORD PTR [bp-36][si]
	*** 0034e8	01 46 e8 		add	WORD PTR [bp-24],ax
	*** 0034eb	e9 e6 ff 		jmp	$FC4083
					$FB4084:
;|***   icmd[6]=~icmd[6];                 // then take bit-wise 1's complement
; Line 2298
	*** 0034ee	f7 56 e8 		not	WORD PTR [bp-24]
;|*** 
;|***   _fmemcpy(ln200_command, icmd, 14);
; Line 2300
	*** 0034f1	6a 0e 			push	14	;000eH
	*** 0034f3	8d 46 dc 		lea	ax,WORD PTR [bp-36]	;icmd
	*** 0034f6	16 			push	ss
	*** 0034f7	50 			push	ax
	*** 0034f8	1e 			push	ds
	*** 0034f9	68 00 00 		push	OFFSET DGROUP:?ln200_command@@3QIDI	;ln200_command
	*** 0034fc	9a 00 00 00 00 		call	FAR PTR __fmemcpy
	*** 003501	83 c4 0a 		add	sp,10	;000aH
;|***   } // end prep_ln200_command()
; Line 2301
	*** 003504	e9 00 00 		jmp	$EX4060
					$EX4060:
	*** 003507	5e 			pop	si
	*** 003508	5f 			pop	di
	*** 003509	c9 			leave	
	*** 00350a	cb 			ret	

?prep_ln200_command@@ZAXXZ	ENDP
	PUBLIC	?time_stamp@@ZAXPEUTIMER@@@Z	; time_stamp
?time_stamp@@ZAXPEUTIMER@@@Z	PROC FAR	; time_stamp
;|***   
;|*** 
;|*** void time_stamp(struct TIMER * t_struct)
;|***   {  // uses the pc's internal timer, resolution ~880 nsec
; Line 2305
	*** 00350b	c8 04 00 00 		enter	4,0
	*** 00350f	57 			push	di
	*** 003510	56 			push	si
;	lsb = -2
;	msb = -4
;	t_struct = 6
;|***   unsigned int lsb;
;|***   unsigned int msb;
;|***   
;|***    _outp(0x43, 0xd2);
; Line 2309
	*** 003511	68 d2 00 		push	210	;00d2H
	*** 003514	6a 43 			push	67	;0043H
	*** 003516	9a 00 00 00 00 		call	FAR PTR __outp
	*** 00351b	83 c4 04 		add	sp,4
;|***    lsb = _inp(0x40);
; Line 2310
	*** 00351e	6a 40 			push	64	;0040H
	*** 003520	9a 00 00 00 00 		call	FAR PTR __inp
	*** 003525	83 c4 02 		add	sp,2
	*** 003528	89 46 fe 		mov	WORD PTR [bp-2],ax	;lsb
;|***    msb = _inp(0x40);
; Line 2311
	*** 00352b	6a 40 			push	64	;0040H
	*** 00352d	9a 00 00 00 00 		call	FAR PTR __inp
	*** 003532	83 c4 02 		add	sp,2
	*** 003535	89 46 fc 		mov	WORD PTR [bp-4],ax	;msb
;|***    t_struct->low = ~((msb << 8) | lsb);
; Line 2312
	*** 003538	8a 66 fc 		mov	ah,BYTE PTR [bp-4]	;msb
	*** 00353b	2a c0 			sub	al,al
	*** 00353d	0b 46 fe 		or	ax,WORD PTR [bp-2]	;lsb
	*** 003540	f7 d0 			not	ax
	*** 003542	c4 5e 06 		les	bx,DWORD PTR [bp+6]	;t_struct
	*** 003545	26 89 47 04 		mov	WORD PTR es:[bx+4],ax
;|***    t_struct->high = sys_timer.high;
; Line 2313
	*** 003549	8e 06 00 00 		mov	es,WORD PTR $T4111
	*** 00354d	26 a1 00 00 		mov	ax,WORD PTR es:?sys_timer@@3UTIMER@@E	;sys_timer
	*** 003551	26 8b 16 02 00 		mov	dx,WORD PTR es:?sys_timer@@3UTIMER@@E+2	;sys_timer
	*** 003556	c4 5e 06 		les	bx,DWORD PTR [bp+6]	;t_struct
	*** 003559	26 89 07 		mov	WORD PTR es:[bx],ax
	*** 00355c	26 89 57 02 		mov	WORD PTR es:[bx+2],dx
;|***    }
; Line 2314
	*** 003560	e9 00 00 		jmp	$EX4086
					$EX4086:
	*** 003563	5e 			pop	si
	*** 003564	5f 			pop	di
	*** 003565	c9 			leave	
	*** 003566	cb 			ret	

?time_stamp@@ZAXPEUTIMER@@@Z	ENDP
	PUBLIC	?heartbeat@@ZAXXZ	; heartbeat
?heartbeat@@ZAXXZ	PROC FAR	; heartbeat
;|*** 
;|*** void heartbeat(void)
;|***   {
; Line 2317
	*** 003567	c8 00 00 00 		enter	0,0
	*** 00356b	57 			push	di
	*** 00356c	56 			push	si
;|***   //if(time_since_last_command >= 100)
;|***     {
; Line 2319
;|***     write_bit(HEARTBEAT, (!read_bit(HEARTBEAT)));
; Line 2320
	*** 00356d	6a 13 			push	19	;0013H
	*** 00356f	9a 00 00 00 00 		call	FAR PTR ?read_bit@@ZAHH@Z	; read_bit
	*** 003574	83 c4 02 		add	sp,2
	*** 003577	3d 01 00 		cmp	ax,1
	*** 00357a	1b c0 			sbb	ax,ax
	*** 00357c	f7 d8 			neg	ax
	*** 00357e	50 			push	ax
	*** 00357f	6a 13 			push	19	;0013H
	*** 003581	9a 00 00 00 00 		call	FAR PTR ?write_bit@@ZAXHH@Z	; write_bit
	*** 003586	83 c4 04 		add	sp,4
;|***     }
; Line 2321
;|***   }
; Line 2322
	*** 003589	e9 00 00 		jmp	$EX4090
					$EX4090:
	*** 00358c	5e 			pop	si
	*** 00358d	5f 			pop	di
	*** 00358e	c9 			leave	
	*** 00358f	cb 			ret	

?heartbeat@@ZAXXZ	ENDP

_aak	PROC FAR
;|***   ; Line 2323
	*** 003590	c8 00 00 00 		enter	0,0
	*** 003594	57 			push	di
	*** 003595	56 			push	si
	*** 003596	68 00 00 		push	SEG ?escc1@@3VCescc@@E	;escc1
	*** 003599	68 00 00 		push	OFFSET ?escc1@@3VCescc@@E	;escc1
	*** 00359c	9a 00 00 00 00 		call	FAR PTR ??1Cescc@@REC@XZ	; Cescc::~Cescc
	*** 0035a1	e9 00 00 		jmp	$EX4092
					$EX4092:
	*** 0035a4	5e 			pop	si
	*** 0035a5	5f 			pop	di
	*** 0035a6	c9 			leave	
	*** 0035a7	cb 			ret	

_aak	ENDP

_aal	PROC FAR
	*** 0035a8	c8 00 00 00 		enter	0,0
	*** 0035ac	57 			push	di
	*** 0035ad	56 			push	si
	*** 0035ae	68 00 00 		push	SEG _aak
	*** 0035b1	68 00 00 		push	OFFSET _aak
	*** 0035b4	9a 00 00 00 00 		call	FAR PTR __fatexit
	*** 0035b9	83 c4 04 		add	sp,4
	*** 0035bc	e9 00 00 		jmp	$EX4094
					$EX4094:
	*** 0035bf	5e 			pop	si
	*** 0035c0	5f 			pop	di
	*** 0035c1	c9 			leave	
	*** 0035c2	cb 			ret	

_aal	ENDP

_aan	PROC FAR
	*** 0035c3	c8 00 00 00 		enter	0,0
	*** 0035c7	57 			push	di
	*** 0035c8	56 			push	si
	*** 0035c9	9a 00 00 00 00 		call	FAR PTR _aaj
	*** 0035ce	9a 00 00 00 00 		call	FAR PTR _aal
	*** 0035d3	e9 00 00 		jmp	$EX4101
					$EX4101:
	*** 0035d6	5e 			pop	si
	*** 0035d7	5f 			pop	di
	*** 0035d8	c9 			leave	
	*** 0035d9	cb 			ret	

_aan	ENDP
	PUBLIC	?dec@@ZAAEVios@@AEV1@@Z	; dec
?dec@@ZAAEVios@@AEV1@@Z	PROC FAR	; dec COMDAT
;|*** /***
;|*** *ios.h - definitions/declarations for the ios class.
;|*** *
;|*** *   Copyright (c) 1990-1992, Microsoft Corporation.  All rights reserved.
;|*** *
;|*** *Purpose:
;|*** *   This file defines the classes, values, macros, and functions
;|*** *   used by the ios class.
;|*** *   [AT&T C++]
;|*** *
;|*** ****/
;|*** 
;|*** #ifndef _INC_IOS
;|*** #define _INC_IOS
;|*** 
;|*** 
;|*** #ifdef M_I86HM
;|*** #define _HFAR_ __far
;|*** #else 
;|*** #define _HFAR_
;|*** #endif 
;|*** 
;|*** #ifndef NULL
;|*** #define NULL    0
;|*** #endif 
;|*** 
;|*** #ifndef EOF
;|*** #define EOF (-1)
;|*** #endif 
;|*** 
;|*** // Force word packing to avoid possible -Zp override
;|*** #pragma pack(2)
;|*** 
;|*** #pragma warning(disable:4505)       // disable unwanted /W4 warning
;|*** // #pragma warning(default:4505)    // use this to reenable, if necessary
;|*** 
;|*** class streambuf;
;|*** class ostream;
;|*** 
;|*** class ios {
;|*** 
;|*** public:
;|***     enum io_state {  goodbit = 0x00,
;|***              eofbit  = 0x01,
;|***              failbit = 0x02,
;|***              badbit  = 0x04 };
;|*** 
;|***     enum open_mode { in        = 0x01,
;|***              out       = 0x02,
;|***              ate       = 0x04,
;|***              app       = 0x08,
;|***              trunc     = 0x10,
;|***              nocreate  = 0x20,
;|***              noreplace = 0x40,
;|***              binary    = 0x80 };    // CONSIDER: not in latest spec.
;|*** 
;|***     enum seek_dir { beg=0, cur=1, end=2 };
;|*** 
;|***     enum {  skipws     = 0x0001,
;|***         left       = 0x0002,
;|***         right      = 0x0004,
;|***         internal   = 0x0008,
;|***         dec        = 0x0010,
;|***         oct        = 0x0020,
;|***         hex        = 0x0040,
;|***         showbase   = 0x0080,
;|***         showpoint  = 0x0100,
;|***         uppercase  = 0x0200,
;|***         showpos    = 0x0400,
;|***         scientific = 0x0800,
;|***         fixed      = 0x1000,
;|***         unitbuf    = 0x2000,
;|***         stdio      = 0x4000
;|***                  };
;|*** 
;|***     static const long basefield;    // dec | oct | hex
;|***     static const long adjustfield;  // left | right | internal
;|***     static const long floatfield;   // scientific | fixed
;|*** 
;|***     ios(streambuf*);            // differs from ANSI
;|***     virtual ~ios();
;|*** 
;|***     inline long flags() const;
;|***     inline long flags(long _l);
;|*** 
;|***     inline long setf(long _f,long _m);
;|***     inline long setf(long _l);
;|***     inline long unsetf(long _l);
;|*** 
;|***     inline int width() const;
;|***     inline int width(int _i);
;|*** 
;|***     inline ostream* tie(ostream* _os);
;|***     inline ostream* tie() const;
;|*** 
;|***     inline char fill() const;
;|***     inline char fill(char _c);
;|*** 
;|***     inline int precision(int _i);
;|***     inline int precision() const;
;|*** 
;|***     inline int rdstate() const;
;|***     inline void clear(int _i = 0);
;|*** 
;|*** //  inline operator void*() const;
;|***     operator void *() const { if(state&(badbit|failbit) ) return 0; return (void *)this; }
;|***     inline int operator!() const;
;|*** 
;|***     inline int  good() const;
;|***     inline int  eof() const;
;|***     inline int  fail() const;
;|***     inline int  bad() const;
;|*** 
;|***     inline streambuf* rdbuf() const;
;|*** 
;|***     inline long _HFAR_ & iword(int) const;
;|***     inline void _HFAR_ * _HFAR_ & pword(int) const;
;|*** 
;|***     static long bitalloc();
;|***     static int xalloc();
;|***     static void sync_with_stdio();
;|*** 
;|*** protected:
;|***     ios();
;|***     ios(const ios&);            // treat as private
;|***     ios& operator=(const ios&);
;|***     void init(streambuf*);
;|*** 
;|***     enum { skipping, tied };
;|***     streambuf*  bp;
;|*** 
;|***     int     state;
;|***     int     ispecial;           // not used
;|***     int     ospecial;           // not used
;|***     int     isfx_special;       // not used
;|***     int     osfx_special;       // not used
;|***     int     x_delbuf;           // if set, rdbuf() deleted by ~ios
;|*** 
;|***     ostream* x_tie;
;|***     long    x_flags;
;|***     int     x_precision;
;|***     int     x_width;
;|***     char    x_fill;
;|*** 
;|***     static void (*stdioflush)();    // not used
;|*** public:
;|***     int delbuf() const { return x_delbuf; }
;|***     void    delbuf(int _i) { x_delbuf = _i; }
;|*** 
;|*** private:
;|***     static long x_maxbit;
;|***     static long _HFAR_ * x_statebuf;  // used by xalloc()
;|***     static int x_curindex;
;|*** // consider: make interal static to ios::sync_with_stdio()
;|***     static int sunk_with_stdio;     // make sure sync_with done only once
;|*** };
;|*** 
;|*** inline ios& dec(ios& _strm) { _strm.setf(ios::dec,ios::basefield); return _strm; }
; Line 158
	*** 000000	c8 00 00 00 		enter	0,0
	*** 000004	57 			push	di
	*** 000005	56 			push	si
;	_strm = 6
	*** 000006	6a 00 			push	0
	*** 000008	6a 10 			push	16	;0010H
	*** 00000a	ff 36 02 00 		push	WORD PTR ?basefield@ios@@2JF+2	;ios::basefield
	*** 00000e	ff 36 00 00 		push	WORD PTR ?basefield@ios@@2JF	;ios::basefield
	*** 000012	ff 76 08 		push	WORD PTR [bp+8]
	*** 000015	ff 76 06 		push	WORD PTR [bp+6]	;_strm
	*** 000018	9a 00 00 00 00 		call	FAR PTR ?setf@ios@@RECJJJ@Z	; ios::setf
	*** 00001d	8b 46 06 		mov	ax,WORD PTR [bp+6]	;_strm
	*** 000020	8b 56 08 		mov	dx,WORD PTR [bp+8]
	*** 000023	e9 00 00 		jmp	$EX1971
					$EX1971:
	*** 000026	5e 			pop	si
	*** 000027	5f 			pop	di
	*** 000028	c9 			leave	
	*** 000029	cb 			ret	

?dec@@ZAAEVios@@AEV1@@Z	ENDP
	PUBLIC	?hex@@ZAAEVios@@AEV1@@Z	; hex
?hex@@ZAAEVios@@AEV1@@Z	PROC FAR	; hex COMDAT
;|*** inline ios& hex(ios& _strm) { _strm.setf(ios::hex,ios::basefield); return _strm; }
; Line 159
	*** 000000	c8 00 00 00 		enter	0,0
	*** 000004	57 			push	di
	*** 000005	56 			push	si
;	_strm = 6
	*** 000006	6a 00 			push	0
	*** 000008	6a 40 			push	64	;0040H
	*** 00000a	ff 36 02 00 		push	WORD PTR ?basefield@ios@@2JF+2	;ios::basefield
	*** 00000e	ff 36 00 00 		push	WORD PTR ?basefield@ios@@2JF	;ios::basefield
	*** 000012	ff 76 08 		push	WORD PTR [bp+8]
	*** 000015	ff 76 06 		push	WORD PTR [bp+6]	;_strm
	*** 000018	9a 00 00 00 00 		call	FAR PTR ?setf@ios@@RECJJJ@Z	; ios::setf
	*** 00001d	8b 46 06 		mov	ax,WORD PTR [bp+6]	;_strm
	*** 000020	8b 56 08 		mov	dx,WORD PTR [bp+8]
	*** 000023	e9 00 00 		jmp	$EX1974
					$EX1974:
	*** 000026	5e 			pop	si
	*** 000027	5f 			pop	di
	*** 000028	c9 			leave	
	*** 000029	cb 			ret	

?hex@@ZAAEVios@@AEV1@@Z	ENDP
	PUBLIC	?setf@ios@@RECJJJ@Z	; ios::setf
?setf@ios@@RECJJJ@Z	PROC FAR	; ios::setf COMDAT
;|*** inline ios& oct(ios& _strm) { _strm.setf(ios::oct,ios::basefield); return _strm; }
;|*** 
;|*** inline long ios::flags() const { return x_flags; }
;|*** inline long ios::flags(long _l){ long _lO; _lO = x_flags; x_flags = _l; return _lO; }
;|*** 
;|*** inline long ios::setf(long _l,long _m){ long _lO; _lO = x_flags; x_flags = (_l&_m) | (x_flags&(~_m)); return _lO; }
; Line 165
	*** 000000	c8 04 00 00 		enter	4,0
	*** 000004	57 			push	di
	*** 000005	56 			push	si
;	_lO = -4
;	this = 6
;	_l = 14
;	_m = 10
	*** 000006	c4 5e 06 		les	bx,DWORD PTR [bp+6]	;this
	*** 000009	26 8b 47 18 		mov	ax,WORD PTR es:[bx+24]
	*** 00000d	26 8b 57 1a 		mov	dx,WORD PTR es:[bx+26]
	*** 000011	89 46 fc 		mov	WORD PTR [bp-4],ax	;_lO
	*** 000014	89 56 fe 		mov	WORD PTR [bp-2],dx
	*** 000017	8b 4e 0a 		mov	cx,WORD PTR [bp+10]	;_m
	*** 00001a	8b 5e 0c 		mov	bx,WORD PTR [bp+12]
	*** 00001d	f7 d1 			not	cx
	*** 00001f	f7 d3 			not	bx
	*** 000021	23 c1 			and	ax,cx
	*** 000023	23 d3 			and	dx,bx
	*** 000025	8b 4e 0a 		mov	cx,WORD PTR [bp+10]	;_m
	*** 000028	8b 5e 0c 		mov	bx,WORD PTR [bp+12]
	*** 00002b	23 4e 0e 		and	cx,WORD PTR [bp+14]	;_l
	*** 00002e	23 5e 10 		and	bx,WORD PTR [bp+16]
	*** 000031	0b c1 			or	ax,cx
	*** 000033	0b d3 			or	dx,bx
	*** 000035	c4 5e 06 		les	bx,DWORD PTR [bp+6]	;this
	*** 000038	26 89 47 18 		mov	WORD PTR es:[bx+24],ax
	*** 00003c	26 89 57 1a 		mov	WORD PTR es:[bx+26],dx
	*** 000040	8b 46 fc 		mov	ax,WORD PTR [bp-4]	;_lO
	*** 000043	8b 56 fe 		mov	dx,WORD PTR [bp-2]
	*** 000046	e9 00 00 		jmp	$EX1988
					$EX1988:
	*** 000049	5e 			pop	si
	*** 00004a	5f 			pop	di
	*** 00004b	c9 			leave	
	*** 00004c	ca 0c 00 		ret	12	;0000000cH

?setf@ios@@RECJJJ@Z	ENDP
	PUBLIC	??6ostream@@RECAEV0@P7AAEV0@AEV0@@Z@Z	; ostream::operator<<
??6ostream@@RECAEV0@P7AAEV0@AEV0@@Z@Z	PROC FAR	; ostream::operator<< COMDAT
;|*** /***
;|*** *ostream.h - definitions/declarations for the ostream class
;|*** *
;|*** *   Copyright (c) 1991-1992, Microsoft Corporation.  All rights reserved.
;|*** *
;|*** *Purpose:
;|*** *   This file defines the classes, values, macros, and functions
;|*** *   used by the ostream class.
;|*** *   [AT&T C++]
;|*** *
;|*** ****/
;|*** 
;|*** #ifndef _INC_OSTREAM
;|*** #define _INC_OSTREAM
;|*** 
;|*** #include <ios.h>
;|*** 
;|*** // Force word packing to avoid possible -Zp override
;|*** #pragma pack(2)
;|*** 
;|*** #pragma warning(disable:4505)       // disable unwanted /W4 warning
;|*** // #pragma warning(default:4505)    // use this to reenable, if necessary
;|*** 
;|*** #ifdef M_I86HM
;|*** #define _HFAR_ __far
;|*** #else 
;|*** #define _HFAR_
;|*** #endif 
;|*** 
;|*** typedef long streamoff, streampos;
;|*** 
;|*** class ostream : virtual public ios {
;|*** 
;|*** public:
;|***     ostream(streambuf*);
;|***     virtual ~ostream();
;|*** 
;|***     ostream& flush();
;|***     int  opfx();
;|***     void osfx();
;|*** 
;|*** inline  ostream& operator<<(ostream& (*f)(ostream&));
;|*** inline  ostream& operator<<(ios& (*f)(ios&));
;|***     ostream& operator<<(const char _HFAR_ *);
;|*** inline  ostream& operator<<(const unsigned char _HFAR_ *);
;|*** inline  ostream& operator<<(const signed char _HFAR_ *);
;|*** inline  ostream& operator<<(char);
;|***     ostream& operator<<(unsigned char);
;|*** inline  ostream& operator<<(signed char);
;|***     ostream& operator<<(short);
;|***     ostream& operator<<(unsigned short);
;|***     ostream& operator<<(int);
;|***     ostream& operator<<(unsigned int);
;|***     ostream& operator<<(long);
;|***     ostream& operator<<(unsigned long);
;|*** inline  ostream& operator<<(float);
;|***     ostream& operator<<(double);
;|***     ostream& operator<<(long double);
;|***     ostream& operator<<(const void _HFAR_ *);
;|***     ostream& operator<<(streambuf*);
;|*** inline  ostream& put(char);
;|***     ostream& put(unsigned char);
;|*** inline  ostream& put(signed char);
;|***     ostream& write(const char _HFAR_ *,int);
;|*** inline  ostream& write(const unsigned char _HFAR_ *,int);
;|*** inline  ostream& write(const signed char _HFAR_ *,int);
;|***     ostream& seekp(streampos);
;|***     ostream& seekp(streamoff,ios::seek_dir);
;|***     streampos tellp();
;|*** 
;|*** protected:
;|***     ostream();
;|***     ostream(const ostream&);    // treat as private
;|***     ostream& operator=(streambuf*); // treat as private
;|***     ostream& operator=(const ostream& _os) {return operator=(_os.rdbuf()); }
;|***     int do_opfx(int);       // not used
;|***     void do_osfx();         // not used
;|*** 
;|*** private:
;|***     ostream(ios&);
;|***     ostream& writepad(const char _HFAR_ *, const char _HFAR_ *);
;|***     int x_floatused;
;|*** };
;|*** 
;|*** inline ostream& ostream::operator<<(ostream& (*f)(ostream&)) { (*f)(*this); return *this; }
; Line 85
	*** 000000	c8 00 00 00 		enter	0,0
	*** 000004	57 			push	di
	*** 000005	56 			push	si
;	this = 6
;	f = 10
	*** 000006	ff 76 08 		push	WORD PTR [bp+8]
	*** 000009	ff 76 06 		push	WORD PTR [bp+6]	;this
	*** 00000c	ff 5e 0a 		call	DWORD PTR [bp+10]	;f
	*** 00000f	83 c4 04 		add	sp,4
	*** 000012	8b 46 06 		mov	ax,WORD PTR [bp+6]	;this
	*** 000015	8b 56 08 		mov	dx,WORD PTR [bp+8]
	*** 000018	e9 00 00 		jmp	$EX2645
					$EX2645:
	*** 00001b	5e 			pop	si
	*** 00001c	5f 			pop	di
	*** 00001d	c9 			leave	
	*** 00001e	ca 08 00 		ret	8

??6ostream@@RECAEV0@P7AAEV0@AEV0@@Z@Z	ENDP
	PUBLIC	??6ostream@@RECAEV0@P7AAEVios@@AEV1@@Z@Z	; ostream::operator<<
??6ostream@@RECAEV0@P7AAEVios@@AEV1@@Z@Z	PROC FAR	; ostream::operator<< COMDAT
;|*** inline ostream& ostream::operator<<(ios& (*f)(ios& )) { (*f)(*this); return *this; }
; Line 86
	*** 000000	c8 04 00 00 		enter	4,0
	*** 000004	57 			push	di
	*** 000005	56 			push	si
;	this = 6
;	f = 10
	*** 000006	8b 46 08 		mov	ax,WORD PTR [bp+8]
	*** 000009	0b 46 06 		or	ax,WORD PTR [bp+6]	;this
	*** 00000c	74 03 			je	$JCC12
	*** 00000e	e9 09 00 		jmp	$L4131
					$JCC12:
	*** 000011	b8 00 00 		mov	ax,0
	*** 000014	ba 00 00 		mov	dx,0
	*** 000017	e9 10 00 		jmp	$L4132
					$L4131:
	*** 00001a	c4 5e 06 		les	bx,DWORD PTR [bp+6]	;this
	*** 00001d	26 c4 1f 		les	bx,DWORD PTR es:[bx]
	*** 000020	26 8b 47 02 		mov	ax,WORD PTR es:[bx+2]
	*** 000024	03 46 06 		add	ax,WORD PTR [bp+6]	;this
	*** 000027	8b 56 08 		mov	dx,WORD PTR [bp+8]
					$L4132:
	*** 00002a	89 46 fc 		mov	WORD PTR [bp-4],ax
	*** 00002d	89 56 fe 		mov	WORD PTR [bp-2],dx
	*** 000030	52 			push	dx
	*** 000031	50 			push	ax
	*** 000032	ff 5e 0a 		call	DWORD PTR [bp+10]	;f
	*** 000035	83 c4 04 		add	sp,4
	*** 000038	8b 46 06 		mov	ax,WORD PTR [bp+6]	;this
	*** 00003b	8b 56 08 		mov	dx,WORD PTR [bp+8]
	*** 00003e	e9 00 00 		jmp	$EX2649
					$EX2649:
	*** 000041	5e 			pop	si
	*** 000042	5f 			pop	di
	*** 000043	c9 			leave	
	*** 000044	ca 08 00 		ret	8

??6ostream@@RECAEV0@P7AAEVios@@AEV1@@Z@Z	ENDP
	PUBLIC	??6ostream@@RECAEV0@M@Z	; ostream::operator<<
??6ostream@@RECAEV0@M@Z	PROC FAR	; ostream::operator<< COMDAT
;|*** 
;|*** inline  ostream& ostream::operator<<(char c) { return operator<<((unsigned char) c); }
;|*** inline  ostream& ostream::operator<<(signed char c) { return operator<<((unsigned char) c); }
;|*** 
;|*** inline  ostream& ostream::operator<<(const unsigned char _HFAR_ * s) { return operator<<((const char _HFAR_ *) s); }
;|*** inline  ostream& ostream::operator<<(const signed char _HFAR_ * s) { return operator<<((const char _HFAR_ *) s); }
;|*** 
;|*** inline  ostream& ostream::operator<<(float f) { x_floatused = 1; return operator<<((double) f); }
; Line 94
	*** 000000	c8 00 00 00 		enter	0,0
	*** 000004	57 			push	di
	*** 000005	56 			push	si
;	this = 6
;	f = 10
	*** 000006	c4 5e 06 		les	bx,DWORD PTR [bp+6]	;this
	*** 000009	26 c7 47 04 01 00 	mov	WORD PTR es:[bx+4],1
	*** 00000f	8d 5e 0a 		lea	bx,WORD PTR [bp+10]	;f
	*** 000012	9a 00 00 00 00 		call	FAR PTR __aFflds
	*** 000017	9a 00 00 00 00 		call	FAR PTR __aFdcvt
	*** 00001c	83 ec 08 		sub	sp,8
	*** 00001f	8b dc 			mov	bx,sp
	*** 000021	9a 00 00 00 00 		call	FAR PTR __aFfstdp
	*** 000026	ff 76 08 		push	WORD PTR [bp+8]
	*** 000029	ff 76 06 		push	WORD PTR [bp+6]	;this
	*** 00002c	9a 00 00 00 00 		call	FAR PTR ??6ostream@@RECAEV0@N@Z	; ostream::operator<<
	*** 000031	e9 00 00 		jmp	$EX2668
					$EX2668:
	*** 000034	5e 			pop	si
	*** 000035	5f 			pop	di
	*** 000036	c9 			leave	
	*** 000037	ca 08 00 		ret	8

??6ostream@@RECAEV0@M@Z	ENDP
	PUBLIC	?endl@@ZAAEVostream@@AEV1@@Z	; endl
?endl@@ZAAEVostream@@AEV1@@Z	PROC FAR	; endl COMDAT
;|*** 
;|*** inline  ostream& ostream::put(char c) { return put((unsigned char) c); }
;|*** inline  ostream& ostream::put(signed char c) { return put((unsigned char) c); }
;|*** 
;|*** inline  ostream& ostream::write(const unsigned char _HFAR_ * s, int n) { return write((char _HFAR_ *) s, n); }
;|*** inline  ostream& ostream::write(const signed char _HFAR_ * s, int n) { return write((char _HFAR_ *) s, n); }
;|*** 
;|*** 
;|*** class ostream_withassign : public ostream {
;|***     public:
;|***         ostream_withassign();
;|***         ostream_withassign(streambuf* _is);
;|***         ~ostream_withassign();
;|***     ostream& operator=(const ostream& _os) { return ostream::operator=(_os.rdbuf()); }
;|***     ostream& operator=(streambuf* _sb) { return ostream::operator=(_sb); }
;|*** };
;|*** 
;|*** #ifndef _WINDLL
;|*** extern ostream_withassign cout;
;|*** extern ostream_withassign cerr;
;|*** extern ostream_withassign clog;
;|*** #endif 
;|*** 
;|*** inline ostream& flush(ostream& _outs) { return _outs.flush(); }
;|*** inline ostream& endl(ostream& _outs) { return _outs << '\n' << flush; }
; Line 119
	*** 000000	c8 00 00 00 		enter	0,0
	*** 000004	57 			push	di
	*** 000005	56 			push	si
;	_outs = 6
	*** 000006	68 00 00 		push	SEG ?flush@@ZAAEVostream@@AEV1@@Z	;flush
	*** 000009	68 00 00 		push	OFFSET ?flush@@ZAAEVostream@@AEV1@@Z	;flush
	*** 00000c	6a 0a 			push	10	;000aH
	*** 00000e	ff 76 08 		push	WORD PTR [bp+8]
	*** 000011	ff 76 06 		push	WORD PTR [bp+6]	;_outs
	*** 000014	9a 00 00 00 00 		call	FAR PTR ??6ostream@@RECAEV0@D@Z	; ostream::operator<<
	*** 000019	52 			push	dx
	*** 00001a	50 			push	ax
	*** 00001b	9a 00 00 00 00 		call	FAR PTR ??6ostream@@RECAEV0@P7AAEV0@AEV0@@Z@Z	; ostream::operator<<
	*** 000020	e9 00 00 		jmp	$EX2729
					$EX2729:
	*** 000023	5e 			pop	si
	*** 000024	5f 			pop	di
	*** 000025	c9 			leave	
	*** 000026	cb 			ret	

?endl@@ZAAEVostream@@AEV1@@Z	ENDP
	PUBLIC	??6ostream@@RECAEV0@D@Z	; ostream::operator<<
??6ostream@@RECAEV0@D@Z	PROC FAR	; ostream::operator<< COMDAT
;|*** inline  ostream& ostream::operator<<(char c) { return operator<<((unsigned char) c); }
; Line 88
	*** 000000	c8 00 00 00 		enter	0,0
	*** 000004	57 			push	di
	*** 000005	56 			push	si
;	this = 6
;	c = 10
	*** 000006	8a 46 0a 		mov	al,BYTE PTR [bp+10]	;c
	*** 000009	50 			push	ax
	*** 00000a	ff 76 08 		push	WORD PTR [bp+8]
	*** 00000d	ff 76 06 		push	WORD PTR [bp+6]	;this
	*** 000010	9a 00 00 00 00 		call	FAR PTR ??6ostream@@RECAEV0@E@Z	; ostream::operator<<
	*** 000015	e9 00 00 		jmp	$EX2652
					$EX2652:
	*** 000018	5e 			pop	si
	*** 000019	5f 			pop	di
	*** 00001a	c9 			leave	
	*** 00001b	ca 06 00 		ret	6

??6ostream@@RECAEV0@D@Z	ENDP
	PUBLIC	?flush@@ZAAEVostream@@AEV1@@Z	; flush
?flush@@ZAAEVostream@@AEV1@@Z	PROC FAR	; flush COMDAT
;|*** inline  ostream& ostream::operator<<(signed char c) { return operator<<((unsigned char) c); }
;|*** 
;|*** inline  ostream& ostream::operator<<(const unsigned char _HFAR_ * s) { return operator<<((const char _HFAR_ *) s); }
;|*** inline  ostream& ostream::operator<<(const signed char _HFAR_ * s) { return operator<<((const char _HFAR_ *) s); }
;|*** 
;|*** inline  ostream& ostream::operator<<(float f) { x_floatused = 1; return operator<<((double) f); }
;|*** 
;|*** inline  ostream& ostream::put(char c) { return put((unsigned char) c); }
;|*** inline  ostream& ostream::put(signed char c) { return put((unsigned char) c); }
;|*** 
;|*** inline  ostream& ostream::write(const unsigned char _HFAR_ * s, int n) { return write((char _HFAR_ *) s, n); }
;|*** inline  ostream& ostream::write(const signed char _HFAR_ * s, int n) { return write((char _HFAR_ *) s, n); }
;|*** 
;|*** 
;|*** class ostream_withassign : public ostream {
;|***     public:
;|***         ostream_withassign();
;|***         ostream_withassign(streambuf* _is);
;|***         ~ostream_withassign();
;|***     ostream& operator=(const ostream& _os) { return ostream::operator=(_os.rdbuf()); }
;|***     ostream& operator=(streambuf* _sb) { return ostream::operator=(_sb); }
;|*** };
;|*** 
;|*** #ifndef _WINDLL
;|*** extern ostream_withassign cout;
;|*** extern ostream_withassign cerr;
;|*** extern ostream_withassign clog;
;|*** #endif 
;|*** 
;|*** inline ostream& flush(ostream& _outs) { return _outs.flush(); }
; Line 118
	*** 000000	c8 00 00 00 		enter	0,0
	*** 000004	57 			push	di
	*** 000005	56 			push	si
;	_outs = 6
	*** 000006	ff 76 08 		push	WORD PTR [bp+8]
	*** 000009	ff 76 06 		push	WORD PTR [bp+6]	;_outs
	*** 00000c	9a 00 00 00 00 		call	FAR PTR ?flush@ostream@@RECAEV1@XZ	; ostream::flush
	*** 000011	e9 00 00 		jmp	$EX2726
					$EX2726:
	*** 000014	5e 			pop	si
	*** 000015	5f 			pop	di
	*** 000016	c9 			leave	
	*** 000017	cb 			ret	

?flush@@ZAAEVostream@@AEV1@@Z	ENDP
DMMTEST_TEXT	ENDS
END
