;	Static Name Aliases
;
;	$S1666_i	EQU	i
;	$S1667_j	EQU	j
;	$S1426_error_msg	EQU	error_msg
	TITLE   c:\cba\ether.cpp
	.286p
INCLUDELIB      LLIBCE
INCLUDELIB	OLDNAMES.LIB
ETHER_TEXT	SEGMENT  WORD PUBLIC 'CODE'
ETHER_TEXT	ENDS
_DATA	SEGMENT  WORD PUBLIC 'DATA'
_DATA	ENDS
CONST	SEGMENT  WORD PUBLIC 'CONST'
CONST	ENDS
_BSS	SEGMENT  WORD PUBLIC 'BSS'
_BSS	ENDS
DGROUP	GROUP	CONST, _BSS, _DATA
	ASSUME DS: DGROUP, SS: DGROUP
PUBLIC  ?last_function@@3HE
PUBLIC  ?done@@3HE
PUBLIC  ?packets_sent@@3KE
PUBLIC  ?packets_rcvd@@3KE
PUBLIC  ?receiver_calls@@3KE
PUBLIC  ?ax0_counter@@3KE
PUBLIC  ?ax1_counter@@3KE
PUBLIC  ?discards@@3KE
PUBLIC  ?checksum16@@3IE
PUBLIC  ?pc1_addr@@3QIEI
PUBLIC  ?pc2_addr@@3QIEI
PUBLIC  ?pc3_addr@@3QIEI
PUBLIC  ?jim_pc@@3QIEI
PUBLIC  ?broadcast_addr@@3QIEI
PUBLIC  ?merror@@3HE
PUBLIC  ?error_num@@3HE
PUBLIC  ?carry_flag@@3HE
PUBLIC  ?version@@3HE
PUBLIC  ?etherclass@@3HE
PUBLIC  ?type@@3HE
PUBLIC  ?number@@3HE
PUBLIC  ?setmode@@3HE
PUBLIC  ?prxbuf@@3PEEE
PUBLIC  ?getmode@@3HE
PUBLIC  ?functionality@@3HE
PUBLIC  ?rx_flag@@3HE
PUBLIC  ?function@@3HE
EXTRN	_segread:FAR
EXTRN	__int86x:FAR
EXTRN	__segread:FAR
EXTRN	_printf:FAR
EXTRN	?time_stamp@@ZAXPEUTIMER@@@Z:FAR
EXTRN	__fstrnicmp:FAR
EXTRN	_int86:FAR
EXTRN	_int86x:FAR
EXTRN	?cmds_time@@3UTIMER@@E:FWORD
EXTRN	?echo@@3UECHO@@E:BYTE
EXTRN	?cmd_buffer@@3QEEE:BYTE
EXTRN	?obc_mac@@3QIEI:FWORD
EXTRN	?frame@@3KE:DWORD
EXTRN	?time_since_last_command@@3HE:WORD
_DATA      SEGMENT
$S1426_error_msg	DB	'NO_ERROR',  00H
 	DB	6 DUP(0)

	DB	'BAD_HANDLE',  00H
 	DB	4 DUP(0)

	DB	'NO_CLASS',  00H
 	DB	6 DUP(0)

	DB	'NO_TYPE',  00H
 	DB	7 DUP(0)

	DB	'NO_NUMBER',  00H
 	DB	5 DUP(0)

	DB	'BAD_TYPE',  00H
 	DB	6 DUP(0)

	DB	'NO_MULTICAST',  00H
 	DB	2 DUP(0)

	DB	'CANT_TERMINATE',  00H
	DB	'BAD_MODE',  00H
 	DB	6 DUP(0)

	DB	'NO_SPACE',  00H
 	DB	6 DUP(0)

	DB	'TYPE_INUSE',  00H
 	DB	4 DUP(0)

	DB	'BAD_COMMAND',  00H
 	DB	3 DUP(0)

	DB	'CANT_SEND',  00H
 	DB	5 DUP(0)

	DB	'CANT_SET',  00H
 	DB	6 DUP(0)

	DB	'BAD_ADDRESS',  00H
 	DB	3 DUP(0)

	DB	'CANT_RESET',  00H
 	DB	4 DUP(0)

?prxbuf@@3PEEE	DD	DGROUP:?rxbuf@@3QIEI
?pc1_addr@@3QIEI	DB	08H
	DB	00H
	DB	017H
	DB	08H
	DB	087H
	DB	04dH
?pc2_addr@@3QIEI	DB	08H
	DB	00H
	DB	017H
	DB	08H
	DB	06dH
	DB	091H
?pc3_addr@@3QIEI	DB	08H
	DB	00H
	DB	017H
	DB	08H
	DB	078H
	DB	050H
?jim_pc@@3QIEI	DB	00H
	DB	08H
	DB	074H
	DB	03cH
	DB	07H
	DB	0e6H
?broadcast_addr@@3QIEI	DB	0ffH
	DB	0ffH
	DB	0ffH
	DB	0ffH
	DB	0ffH
	DB	0ffH
?merror@@3HE	DW	00H
?error_num@@3HE	DW	00H
?carry_flag@@3HE	DW	00H
?version@@3HE	DW	00H
?etherclass@@3HE	DW	00H
?type@@3HE	DW	00H
?number@@3HE	DW	00H
?setmode@@3HE	DW	00H
?getmode@@3HE	DW	00H
?functionality@@3HE	DW	00H
?rx_flag@@3HE	DW	00H
?function@@3HE	DW	00H
?last_function@@3HE	DW	00H
?done@@3HE	DW	00H
?packets_sent@@3KE	DD	00H
?packets_rcvd@@3KE	DD	00H
?receiver_calls@@3KE	DD	00H
?ax0_counter@@3KE	DD	00H
?ax1_counter@@3KE	DD	00H
?discards@@3KE	DD	00H
?checksum16@@3IE	DW	00H
$SG1692	DB	'Driver_info()',  0aH,  00H
$SG1693	DB	'Version: %d',  0aH,  00H
$SG1694	DB	'Ifclass: %d',  00H
$SG1696	DB	', DIX Bluebook',  0aH,  00H
$SG1698	DB	', IEEE 802.3 w/802.2 headers',  0aH,  00H
$SG1699	DB	'Type: %d',  0aH,  00H
$SG1700	DB	'Number: %d',  0aH,  00H
$SG1701	DB	'Name: %s',  0aH,  00H
$SG1702	DB	'Functionality: %d',  00H
$SG1704	DB	', basic',  0aH,  00H
$SG1706	DB	', basic, extended(*)',  0aH,  00H
$SG1708	DB	', basic, high performance(+)',  0aH,  00H
$SG1710	DB	', basic, high performance(+), extended(*)',  0aH,  00H
$SG1712	DB	', not installed',  0aH,  00H
$SG1865	DB	'%s',  0aH,  00H
$SG1866	DB	0aH,  00H
_DATA      ENDS
_BSS      SEGMENT
	ORG	$+2096
PUBLIC  ?packet_len@@3HE
?packet_len@@3HE	DW 01H DUP (?)
$S1666_i	DW 01H DUP (?)
$S1667_j	DW 01H DUP (?)
PUBLIC  ?msg_rcvd@@3HE
?msg_rcvd@@3HE	DW 01H DUP (?)
	ORG	$-104
PUBLIC  ?name@@3QIDI
?name@@3QIDI	DW 028H DUP (?)
PUBLIC  ?addr_buf@@3QIEI
?addr_buf@@3QIEI	DW 03H DUP (?)
PUBLIC  ?ethertype@@3QIDI
?ethertype@@3QIDI	DB 05H DUP (?)
	ORG	$-2091
PUBLIC  ?rxbuf@@3QIEI
?rxbuf@@3QIEI	DW 03e8H DUP (?)
	ORG	$+92
PUBLIC  ?handle@@3HE
?handle@@3HE	DW 01H DUP (?)
PUBLIC  ?txlen@@3IE
?txlen@@3IE	DW 01H DUP (?)
_BSS      ENDS
ETHER_TEXT      SEGMENT
	ASSUME	CS: ETHER_TEXT
	PUBLIC	?driver_info@@ZAHI@Z	; driver_info
?driver_info@@ZAHI@Z	PROC FAR	; driver_info
;|*** // ether.cpp module for autonomous obc project
;|*** // JTM Code 5600
;|*** // 2/27/2004
;|*** 
;|*** 
;|*** 
;|*** #include <dos.h>
;|*** #include <stdio.h>
;|*** #include <conio.h>
;|*** #include <string.h>
;|*** #include <stdlib.h>
;|*** #include "pktdrv.h"
;|*** #include "ether.h"
;|*** #include "dmmtest.h"
;|*** 
;|*** //unsigned udp_checksum;
;|*** //unsigned char rxbuf[MAX_RXBUF+200];
;|*** unsigned char rxbuf[2000];
;|*** unsigned char far * prxbuf = rxbuf;
;|*** //unsigned char far app_buffer[MAX_RXBUF+200];
;|*** extern unsigned char far cmd_buffer[2008];
;|*** extern unsigned char obc_mac[6];
;|*** extern unsigned char far data_pkt[MAX_RXBUF+200];
;|*** 
;|*** //extern commands;
;|*** extern unsigned long frame;
;|*** extern int time_since_last_command;
;|*** //extern struct SYS sys;
;|*** //extern struct OBS obs;
;|*** //extern struct DYNO dyno;
;|*** //extern struct PROP prop;
;|*** //extern struct LN200 ln200;
;|*** //extern struct ECHO echo;
;|*** //extern struct DS ds;
;|*** //extern struct ADCP adcp; 
;|*** 
;|*** struct COMMANDS  // new 12/8/2004
;|***   {
;|***   unsigned int  sync_word;
;|***   unsigned int  mode;
;|***   unsigned int  rpm;
;|***   unsigned int  rudder;
;|***   unsigned int  stern1;
;|***   unsigned int  stern2;
;|***   unsigned int  fore;  
;|***   unsigned int  ballast;
;|***   unsigned int  ln200_mode;
;|***   unsigned int  ln200_init_heading;
;|***   unsigned int  ln200_init_latitude;
;|***   unsigned int  adcp_reset;
;|***   unsigned int  adcp_heading;
;|***   unsigned int  ds_send_message;
;|***   unsigned int  ds_dmgx;
;|***   unsigned int  ds_dmgy;
;|***   unsigned int  ds_dmgz;        
;|***   unsigned int  spare1;
;|***   };  
;|***  
;|*** extern COMMANDS commands;
;|*** 
;|*** struct TIMER
;|***   {
;|***   unsigned long high;
;|***   unsigned int  low;
;|***   };
;|***   
;|*** struct ECHO            // new 12/08/2004
;|***   {
;|***   unsigned int  new_data;
;|***   unsigned long frame;
;|***   unsigned long time_high;
;|***   unsigned int  time_low;
;|***   unsigned char data[sizeof(commands)];
;|***   };
;|***   
;|*** 
;|*** //extern TIMER cmd_packet_time;
;|*** extern TIMER sys_timer;
;|*** extern TIMER cmds_time;
;|*** 
;|*** extern ECHO  echo;
;|*** 
;|*** char name[80];
;|*** 
;|*** unsigned char addr_buf[6];
;|*** unsigned char pc1_addr[6]       = {0x08, 0x00, 0x17, 0x08, 0x87, 0x4d}; // pc1
;|*** unsigned char pc2_addr[6]       = {0x08, 0x00, 0x17, 0x08, 0x6d, 0x91}; // pc2
;|*** unsigned char pc3_addr[6]       = {0x08, 0x00, 0x17, 0x08, 0x78, 0x50}; // pc3
;|*** unsigned char jim_pc[6]         = {0x00, 0x08, 0x74, 0x3c, 0x07, 0xe6}; // laptop
;|*** unsigned char broadcast_addr[6] = {0xff, 0xff, 0xff, 0xff, 0xff, 0xff};
;|*** //unsigned char control_mac[6]    = {0x00, 0x01, 0x45, 0x00, 0x8a, 0x21};
;|*** //unsigned char micron_mac[6]     = {0x08, 0x00, 0x17, 0x08, 0x87, 0x4d};
;|*** //unsigned char obc_mac[6]        = {0x00, 0x01, 0x45, 0x00, 0x7a, 0x84};
;|*** 
;|*** char ethertype[5];
;|*** int merror = 0;
;|*** int error_num = 0;
;|*** int carry_flag = 0;
;|*** int version = 0;
;|*** int etherclass = 0;
;|*** int type = 0;
;|*** int number = 0;
;|*** int setmode = 0;
;|*** int getmode = 0;
;|*** int functionality = 0;
;|*** int handle;
;|*** unsigned txlen;
;|*** int rx_flag =0;
;|*** int function = 0;
;|*** int last_function = 0;
;|*** int packet_len;
;|*** static int i, j;
;|*** int msg_rcvd;
;|*** int done = 0;
;|*** unsigned long packets_sent = 0;
;|*** unsigned long packets_rcvd = 0;
;|*** unsigned long receiver_calls = 0;
;|*** unsigned long ax0_counter = 0;
;|*** unsigned long ax1_counter = 0;
;|*** unsigned long discards = 0;
;|*** //unsigned ip_id = 0;
;|*** unsigned checksum16 = 0;
;|*** 
;|*** 
;|*** 
;|*** int driver_info(unsigned dhandle)
;|***   {
; Line 127
	*** 000000	c8 70 00 00 		enter	112,0
	*** 000004	57 			push	di
	*** 000005	56 			push	si
;	dhandle = 6
;	regs = -32
;	sregs = -18
;	version = -6
;	iclass = -4
;	type = -8
;	number = -10
;	name = -112
;	functionality = -2
;|***   union REGS regs;
;|***   struct SREGS sregs;
;|***   int version;
;|***   int iclass;
;|***   int type;
;|***   int number;
;|***   char name[80];
;|***   int functionality;
;|*** 
;|***   regs.h.ah = DRIVER_INFO;
; Line 137
	*** 000006	c6 46 e1 01 		mov	BYTE PTR [bp-31],1
;|***   regs.h.al = 255;
; Line 138
	*** 00000a	c6 46 e0 ff 		mov	BYTE PTR [bp-32],255	;00ffH	;regs
;|***   regs.x.bx = dhandle;  //jtm
; Line 139
	*** 00000e	8b 46 06 		mov	ax,WORD PTR [bp+6]	;dhandle
	*** 000011	89 46 e2 		mov	WORD PTR [bp-30],ax
;|***   int86x(PKTDVR, &regs, &regs, &sregs);
; Line 140
	*** 000014	8d 46 ee 		lea	ax,WORD PTR [bp-18]	;sregs
	*** 000017	16 			push	ss
	*** 000018	50 			push	ax
	*** 000019	8d 46 e0 		lea	ax,WORD PTR [bp-32]	;regs
	*** 00001c	16 			push	ss
	*** 00001d	50 			push	ax
	*** 00001e	16 			push	ss
	*** 00001f	50 			push	ax
	*** 000020	6a 7e 			push	126	;007eH
	*** 000022	9a 00 00 00 00 		call	FAR PTR _int86x
	*** 000027	83 c4 0e 		add	sp,14	;000eH
;|***   version = regs.x.bx;
; Line 141
	*** 00002a	8b 46 e2 		mov	ax,WORD PTR [bp-30]
	*** 00002d	89 46 fa 		mov	WORD PTR [bp-6],ax	;version
;|***   iclass = regs.h.ch;
; Line 142
	*** 000030	8a 46 e5 		mov	al,BYTE PTR [bp-27]
	*** 000033	2a e4 			sub	ah,ah
	*** 000035	89 46 fc 		mov	WORD PTR [bp-4],ax	;iclass
;|***   type  = regs.x.dx;
; Line 143
	*** 000038	8b 46 e6 		mov	ax,WORD PTR [bp-26]
	*** 00003b	89 46 f8 		mov	WORD PTR [bp-8],ax	;type
;|***   number = regs.h.cl;
; Line 144
	*** 00003e	8a 46 e4 		mov	al,BYTE PTR [bp-28]
	*** 000041	2a e4 			sub	ah,ah
	*** 000043	89 46 f6 		mov	WORD PTR [bp-10],ax	;number
;|***   _fstrcpy(name, (char far *)MK_FP(sregs.ds, regs.x.si));
; Line 145
	*** 000046	8b 5e e8 		mov	bx,WORD PTR [bp-24]
	*** 000049	8b 4e f4 		mov	cx,WORD PTR [bp-12]
	*** 00004c	8b fb 			mov	di,bx
	*** 00004e	8d 76 90 		lea	si,WORD PTR [bp-112]	;name
	*** 000051	8e c1 			mov	es,cx
	*** 000053	1e 			push	ds
	*** 000054	b9 ff ff 		mov	cx,-1	;ffffH
	*** 000057	33 c0 			xor	ax,ax
	*** 000059	f2 			repnz
	*** 00005a	ae 			scasb
	*** 00005b	f7 d1 			not	cx
	*** 00005d	2b f9 			sub	di,cx
	*** 00005f	87 fe 			xchg	di,si
	*** 000061	1e 			push	ds
	*** 000062	06 			push	es
	*** 000063	1f 			pop	ds
	ASSUME DS: DGROUP
	*** 000064	07 			pop	es
	*** 000065	d1 e9 			shr	cx,1
	*** 000067	f3 			rep
	*** 000068	a5 			movsw
	*** 000069	13 c9 			adc	cx,cx
	*** 00006b	f3 			rep
	*** 00006c	a4 			movsb
	*** 00006d	1f 			pop	ds
	ASSUME DS: DGROUP
;|***   functionality = regs.h.al;
; Line 146
	*** 00006e	8a 46 e0 		mov	al,BYTE PTR [bp-32]	;regs
	*** 000071	89 46 fe 		mov	WORD PTR [bp-2],ax	;functionality
;|***   
;|***   printf("Driver_info()\n");
; Line 148
	*** 000074	1e 			push	ds
	*** 000075	68 00 00 		push	OFFSET DGROUP:$SG1692
	*** 000078	9a 00 00 00 00 		call	FAR PTR _printf
	*** 00007d	83 c4 04 		add	sp,4
;|***   printf("Version: %d\n", version);
; Line 149
	*** 000080	ff 76 fa 		push	WORD PTR [bp-6]	;version
	*** 000083	1e 			push	ds
	*** 000084	68 00 00 		push	OFFSET DGROUP:$SG1693
	*** 000087	9a 00 00 00 00 		call	FAR PTR _printf
	*** 00008c	83 c4 06 		add	sp,6
;|***   printf("Ifclass: %d", iclass);
; Line 150
	*** 00008f	ff 76 fc 		push	WORD PTR [bp-4]	;iclass
	*** 000092	1e 			push	ds
	*** 000093	68 00 00 		push	OFFSET DGROUP:$SG1694
	*** 000096	9a 00 00 00 00 		call	FAR PTR _printf
	*** 00009b	83 c4 06 		add	sp,6
;|***   if(iclass == CL_ETHERNET) printf(", DIX Bluebook\n");
; Line 151
	*** 00009e	83 7e fc 01 		cmp	WORD PTR [bp-4],1	;iclass
	*** 0000a2	75 0c 			jne	$I1695
	*** 0000a4	1e 			push	ds
	*** 0000a5	68 00 00 		push	OFFSET DGROUP:$SG1696
	*** 0000a8	9a 00 00 00 00 		call	FAR PTR _printf
	*** 0000ad	83 c4 04 		add	sp,4
;|***   if(iclass == CL_IEEE8023) printf(", IEEE 802.3 w/802.2 headers\n");
; Line 152
					$I1695:
	*** 0000b0	83 7e fc 0b 		cmp	WORD PTR [bp-4],11	;000bH	;iclass
	*** 0000b4	75 0c 			jne	$I1697
	*** 0000b6	1e 			push	ds
	*** 0000b7	68 00 00 		push	OFFSET DGROUP:$SG1698
	*** 0000ba	9a 00 00 00 00 		call	FAR PTR _printf
	*** 0000bf	83 c4 04 		add	sp,4
;|***   printf("Type: %d\n", type);
; Line 153
					$I1697:
	*** 0000c2	ff 76 f8 		push	WORD PTR [bp-8]	;type
	*** 0000c5	1e 			push	ds
	*** 0000c6	68 00 00 		push	OFFSET DGROUP:$SG1699
	*** 0000c9	9a 00 00 00 00 		call	FAR PTR _printf
	*** 0000ce	83 c4 06 		add	sp,6
;|***   printf("Number: %d\n", number);
; Line 154
	*** 0000d1	ff 76 f6 		push	WORD PTR [bp-10]	;number
	*** 0000d4	1e 			push	ds
	*** 0000d5	68 00 00 		push	OFFSET DGROUP:$SG1700
	*** 0000d8	9a 00 00 00 00 		call	FAR PTR _printf
	*** 0000dd	83 c4 06 		add	sp,6
;|***   printf("Name: %s\n", name);
; Line 155
	*** 0000e0	8d 46 90 		lea	ax,WORD PTR [bp-112]	;name
	*** 0000e3	16 			push	ss
	*** 0000e4	50 			push	ax
	*** 0000e5	1e 			push	ds
	*** 0000e6	68 00 00 		push	OFFSET DGROUP:$SG1701
	*** 0000e9	9a 00 00 00 00 		call	FAR PTR _printf
	*** 0000ee	83 c4 08 		add	sp,8
;|***   printf("Functionality: %d", functionality);
; Line 156
	*** 0000f1	ff 76 fe 		push	WORD PTR [bp-2]	;functionality
	*** 0000f4	1e 			push	ds
	*** 0000f5	68 00 00 		push	OFFSET DGROUP:$SG1702
	*** 0000f8	9a 00 00 00 00 		call	FAR PTR _printf
	*** 0000fd	83 c4 06 		add	sp,6
;|***   if(functionality == 1) printf(", basic\n");
; Line 157
	*** 000100	83 7e fe 01 		cmp	WORD PTR [bp-2],1	;functionality
	*** 000104	75 0c 			jne	$I1703
	*** 000106	1e 			push	ds
	*** 000107	68 00 00 		push	OFFSET DGROUP:$SG1704
	*** 00010a	9a 00 00 00 00 		call	FAR PTR _printf
	*** 00010f	83 c4 04 		add	sp,4
;|***   if(functionality == 2) printf(", basic, extended(*)\n");
; Line 158
					$I1703:
	*** 000112	83 7e fe 02 		cmp	WORD PTR [bp-2],2	;functionality
	*** 000116	75 0c 			jne	$I1705
	*** 000118	1e 			push	ds
	*** 000119	68 00 00 		push	OFFSET DGROUP:$SG1706
	*** 00011c	9a 00 00 00 00 		call	FAR PTR _printf
	*** 000121	83 c4 04 		add	sp,4
;|***   if(functionality == 5) printf(", basic, high performance(+)\n");
; Line 159
					$I1705:
	*** 000124	83 7e fe 05 		cmp	WORD PTR [bp-2],5	;functionality
	*** 000128	75 0c 			jne	$I1707
	*** 00012a	1e 			push	ds
	*** 00012b	68 00 00 		push	OFFSET DGROUP:$SG1708
	*** 00012e	9a 00 00 00 00 		call	FAR PTR _printf
	*** 000133	83 c4 04 		add	sp,4
;|***   if(functionality == 6) printf(", basic, high performance(+), extended(*)\n");
; Line 160
					$I1707:
	*** 000136	83 7e fe 06 		cmp	WORD PTR [bp-2],6	;functionality
	*** 00013a	75 0c 			jne	$I1709
	*** 00013c	1e 			push	ds
	*** 00013d	68 00 00 		push	OFFSET DGROUP:$SG1710
	*** 000140	9a 00 00 00 00 		call	FAR PTR _printf
	*** 000145	83 c4 04 		add	sp,4
;|***   if(functionality == 255) printf(", not installed\n");
; Line 161
					$I1709:
	*** 000148	81 7e fe ff 00 		cmp	WORD PTR [bp-2],255	;00ffH	;functionality
	*** 00014d	75 0c 			jne	$I1711
	*** 00014f	1e 			push	ds
	*** 000150	68 00 00 		push	OFFSET DGROUP:$SG1712
	*** 000153	9a 00 00 00 00 		call	FAR PTR _printf
	*** 000158	83 c4 04 		add	sp,4
;|***   //last_function = function;
;|***   
;|***   if(regs.x.cflag) error_num = regs.h.dh;
; Line 164
					$I1711:
	*** 00015b	83 7e ec 00 		cmp	WORD PTR [bp-20],0
	*** 00015f	74 07 			je	$I1713
	*** 000161	8a 46 e7 		mov	al,BYTE PTR [bp-25]
	*** 000164	2a e4 			sub	ah,ah
	*** 000166	eb 02 			jmp	SHORT $I1714
					$I1713:
	*** 000168	33 c0 			xor	ax,ax
					$I1714:
	*** 00016a	a3 00 00 		mov	WORD PTR ?error_num@@3HE,ax	;error_num
;|***   else error_num = 0;
;|***   return(regs.x.cflag);
; Line 166
	*** 00016d	8b 46 ec 		mov	ax,WORD PTR [bp-20]
;|***   // end driver_info()
;|***   }
; Line 168
	*** 000170	5e 			pop	si
	*** 000171	5f 			pop	di
	*** 000172	c9 			leave	
	*** 000173	cb 			ret	

?driver_info@@ZAHI@Z	ENDP
	PUBLIC	?access_type@@ZAHHHHPEDIP7AXIIIIIIIIIIIII@Z@Z	; access_type
?access_type@@ZAHHHHPEDIP7AXIIIIIIIIIIIII@Z@Z	PROC FAR	; access_type
;|*** 
;|*** int access_type(int if_class, int if_type, int if_number, char far *type,
;|***                      unsigned typelen,   void (interrupt far *a_receiver)
;|***                      (unsigned, unsigned, unsigned, unsigned,
;|***                       unsigned, unsigned, unsigned, unsigned,
;|***                       unsigned, unsigned, unsigned, unsigned,
;|***                       unsigned) )
;|***   {
; Line 176
	*** 000174	c8 16 00 00 		enter	22,0
;	a_receiver = 18
;	regs = -22
;	sregs = -8
;	if_class = 6
;	if_type = 8
;	if_number = 10
;	type = 12
;	typelen = 16
;|***   union  _REGS regs;
;|***   struct _SREGS sregs;
;|*** 
;|***   _segread(&sregs);
; Line 180
	*** 000178	8d 46 f8 		lea	ax,WORD PTR [bp-8]	;sregs
	*** 00017b	16 			push	ss
	*** 00017c	50 			push	ax
	*** 00017d	9a 00 00 00 00 		call	FAR PTR __segread
	*** 000182	83 c4 04 		add	sp,4
;|***   regs.h.ah = ACCESS_TYPE;
; Line 181
	*** 000185	c6 46 eb 02 		mov	BYTE PTR [bp-21],2
;|***   regs.h.al = if_class;
; Line 182
	*** 000189	8a 46 06 		mov	al,BYTE PTR [bp+6]	;if_class
	*** 00018c	88 46 ea 		mov	BYTE PTR [bp-22],al	;regs
;|***   //regs.x.bx = if_type;
;|***   regs.x.bx = 0xffff;
; Line 184
	*** 00018f	c7 46 ec ff ff 		mov	WORD PTR [bp-20],-1	;ffffH
;|***   regs.h.dl = if_number;
; Line 185
	*** 000194	8a 46 0a 		mov	al,BYTE PTR [bp+10]	;if_number
	*** 000197	88 46 f0 		mov	BYTE PTR [bp-16],al
;|***   regs.x.si = FP_OFF(type);
; Line 186
	*** 00019a	8b 46 0c 		mov	ax,WORD PTR [bp+12]	;type
	*** 00019d	89 46 f2 		mov	WORD PTR [bp-14],ax
;|***   sregs.ds = FP_SEG(type);
; Line 187
	*** 0001a0	8b 46 0e 		mov	ax,WORD PTR [bp+14]
	*** 0001a3	89 46 fe 		mov	WORD PTR [bp-2],ax
;|***   //regs.x.cx = typelen;
;|***   regs.x.cx = 0;
; Line 189
	*** 0001a6	c7 46 ee 00 00 		mov	WORD PTR [bp-18],0
;|***   sregs.es =  _FP_SEG(a_receiver);
; Line 190
	*** 0001ab	8b 46 14 		mov	ax,WORD PTR [bp+20]
	*** 0001ae	89 46 f8 		mov	WORD PTR [bp-8],ax	;sregs
;|***   regs.x.di = _FP_OFF(a_receiver);
; Line 191
	*** 0001b1	8b 46 12 		mov	ax,WORD PTR [bp+18]	;a_receiver
	*** 0001b4	89 46 f4 		mov	WORD PTR [bp-12],ax
;|***   _int86x(PKTDVR, &regs, &regs, &sregs);
; Line 192
	*** 0001b7	8d 46 f8 		lea	ax,WORD PTR [bp-8]	;sregs
	*** 0001ba	16 			push	ss
	*** 0001bb	50 			push	ax
	*** 0001bc	8d 46 ea 		lea	ax,WORD PTR [bp-22]	;regs
	*** 0001bf	16 			push	ss
	*** 0001c0	50 			push	ax
	*** 0001c1	16 			push	ss
	*** 0001c2	50 			push	ax
	*** 0001c3	6a 7e 			push	126	;007eH
	*** 0001c5	9a 00 00 00 00 		call	FAR PTR __int86x
	*** 0001ca	83 c4 0e 		add	sp,14	;000eH
;|***   handle = regs.x.ax;    // handle is global
; Line 193
	*** 0001cd	8b 46 ea 		mov	ax,WORD PTR [bp-22]	;regs
	*** 0001d0	a3 00 00 		mov	WORD PTR ?handle@@3HE,ax	;handle
;|***   //printf("handle: %d\n", handle);
;|***   if(regs.x.cflag) error_num = regs.h.dh;
; Line 195
	*** 0001d3	83 7e f6 00 		cmp	WORD PTR [bp-10],0
	*** 0001d7	74 07 			je	$I1741
	*** 0001d9	8a 46 f1 		mov	al,BYTE PTR [bp-15]
	*** 0001dc	2a e4 			sub	ah,ah
	*** 0001de	eb 02 			jmp	SHORT $I1742
					$I1741:
	*** 0001e0	33 c0 			xor	ax,ax
					$I1742:
	*** 0001e2	a3 00 00 		mov	WORD PTR ?error_num@@3HE,ax	;error_num
;|***   else error_num = 0;
;|***   return(regs.x.cflag);
; Line 197
	*** 0001e5	8b 46 f6 		mov	ax,WORD PTR [bp-10]
;|***   }
; Line 198
	*** 0001e8	c9 			leave	
	*** 0001e9	cb 			ret	

?access_type@@ZAHHHHPEDIP7AXIIIIIIIIIIIII@Z@Z	ENDP
	PUBLIC	?release_type@@ZAHH@Z	; release_type
?release_type@@ZAHH@Z	PROC FAR	; release_type
;|*** 
;|*** int release_type(int rhandle)
;|***   {
; Line 201
	*** 0001ea	c8 16 00 00 		enter	22,0
;	rhandle = 6
;	regs = -22
;	sregs = -8
;|***   union REGS regs;
;|***   struct SREGS sregs;
;|*** 
;|***   regs.h.ah = 3;
; Line 205
	*** 0001ee	c6 46 eb 03 		mov	BYTE PTR [bp-21],3
;|***   regs.x.bx = rhandle;
; Line 206
	*** 0001f2	8b 46 06 		mov	ax,WORD PTR [bp+6]	;rhandle
	*** 0001f5	89 46 ec 		mov	WORD PTR [bp-20],ax
;|***   int86x(PKTDVR, &regs, &regs, &sregs);
; Line 207
	*** 0001f8	8d 46 f8 		lea	ax,WORD PTR [bp-8]	;sregs
	*** 0001fb	16 			push	ss
	*** 0001fc	50 			push	ax
	*** 0001fd	8d 46 ea 		lea	ax,WORD PTR [bp-22]	;regs
	*** 000200	16 			push	ss
	*** 000201	50 			push	ax
	*** 000202	16 			push	ss
	*** 000203	50 			push	ax
	*** 000204	6a 7e 			push	126	;007eH
	*** 000206	9a 00 00 00 00 		call	FAR PTR _int86x
	*** 00020b	83 c4 0e 		add	sp,14	;000eH
;|***   last_function = function;
; Line 208
	*** 00020e	a1 00 00 		mov	ax,WORD PTR ?function@@3HE	;function
	*** 000211	a3 00 00 		mov	WORD PTR ?last_function@@3HE,ax	;last_function
;|***   if(regs.x.cflag) error_num = regs.h.dh;
; Line 209
	*** 000214	83 7e f6 00 		cmp	WORD PTR [bp-10],0
	*** 000218	74 08 			je	$I1747
	*** 00021a	8a 46 f1 		mov	al,BYTE PTR [bp-15]
	*** 00021d	2a e4 			sub	ah,ah
	*** 00021f	eb 03 			jmp	SHORT $I1748
	*** 000221	90 			nop	
					$I1747:
	*** 000222	33 c0 			xor	ax,ax
					$I1748:
	*** 000224	a3 00 00 		mov	WORD PTR ?error_num@@3HE,ax	;error_num
;|***   else error_num = 0;
;|***   return(regs.x.cflag);
; Line 211
	*** 000227	8b 46 f6 		mov	ax,WORD PTR [bp-10]
;|***   }
; Line 212
	*** 00022a	c9 			leave	
	*** 00022b	cb 			ret	

?release_type@@ZAHH@Z	ENDP
	PUBLIC	?terminate@@ZAHH@Z	; terminate
?terminate@@ZAHH@Z	PROC FAR	; terminate
;|*** 
;|*** int terminate(int thandle)
;|***   {
; Line 215
	*** 00022c	c8 0e 00 00 		enter	14,0
;	thandle = 6
;	regs = -14
;|***   union REGS regs;
;|*** 
;|***   regs.h.ah = 5;
; Line 218
	*** 000230	c6 46 f3 05 		mov	BYTE PTR [bp-13],5
;|***   regs.x.bx = handle;
; Line 219
	*** 000234	a1 00 00 		mov	ax,WORD PTR ?handle@@3HE	;handle
	*** 000237	89 46 f4 		mov	WORD PTR [bp-12],ax
;|***   int86(PKTDVR, &regs, &regs);
; Line 220
	*** 00023a	8d 46 f2 		lea	ax,WORD PTR [bp-14]	;regs
	*** 00023d	16 			push	ss
	*** 00023e	50 			push	ax
	*** 00023f	16 			push	ss
	*** 000240	50 			push	ax
	*** 000241	6a 7e 			push	126	;007eH
	*** 000243	9a 00 00 00 00 		call	FAR PTR _int86
	*** 000248	83 c4 0a 		add	sp,10	;000aH
;|***   last_function = function;
; Line 221
	*** 00024b	a1 00 00 		mov	ax,WORD PTR ?function@@3HE	;function
	*** 00024e	a3 00 00 		mov	WORD PTR ?last_function@@3HE,ax	;last_function
;|***   if(regs.x.cflag) error_num = regs.h.dh;
; Line 222
	*** 000251	83 7e fe 00 		cmp	WORD PTR [bp-2],0
	*** 000255	74 07 			je	$I1752
	*** 000257	8a 46 f9 		mov	al,BYTE PTR [bp-7]
	*** 00025a	2a e4 			sub	ah,ah
	*** 00025c	eb 02 			jmp	SHORT $I1753
					$I1752:
	*** 00025e	33 c0 			xor	ax,ax
					$I1753:
	*** 000260	a3 00 00 		mov	WORD PTR ?error_num@@3HE,ax	;error_num
;|***   else error_num = 0;
;|***   return(regs.x.cflag);
; Line 224
	*** 000263	8b 46 fe 		mov	ax,WORD PTR [bp-2]
;|***   }
; Line 225
	*** 000266	c9 			leave	
	*** 000267	cb 			ret	

?terminate@@ZAHH@Z	ENDP
	PUBLIC	?get_address@@ZAHHPEEH@Z	; get_address
?get_address@@ZAHHPEEH@Z	PROC FAR	; get_address
;|*** 
;|*** 
;|*** int get_address(int ghandle, unsigned char far * pad_buf, int len)
;|***   {
; Line 229
	*** 000268	c8 16 00 00 		enter	22,0
	*** 00026c	57 			push	di
;	ghandle = 6
;	pad_buf = 8
;	len = 12
;	regs = -22
;	sregs = -8
;|***   union REGS regs;
;|***   struct SREGS sregs;
;|*** 
;|***   for(i=0;i<6;i++)
; Line 233
	*** 00026d	33 c0 			xor	ax,ax
	*** 00026f	a3 00 00 		mov	WORD PTR $S1666_i,ax
	*** 000272	b9 03 00 		mov	cx,3
	*** 000275	bf 00 00 		mov	di,OFFSET DGROUP:?addr_buf@@3QIEI	;addr_buf
	*** 000278	1e 			push	ds
	*** 000279	07 			pop	es
	*** 00027a	f3 			rep
	*** 00027b	ab 			stosw
	*** 00027c	83 06 00 00 06 		add	WORD PTR $S1666_i,6
;|***     {
;|***     addr_buf[i] = 0;
;|***     }
;|***   regs.h.ah = 6;
; Line 237
	*** 000281	c6 46 eb 06 		mov	BYTE PTR [bp-21],6
;|***   regs.x.bx = ghandle;
; Line 238
	*** 000285	8b 46 06 		mov	ax,WORD PTR [bp+6]	;ghandle
	*** 000288	89 46 ec 		mov	WORD PTR [bp-20],ax
;|***   sregs.es = FP_SEG(pad_buf);
; Line 239
	*** 00028b	8b 46 0a 		mov	ax,WORD PTR [bp+10]
	*** 00028e	89 46 f8 		mov	WORD PTR [bp-8],ax	;sregs
;|***   regs.x.di = FP_OFF(pad_buf);
; Line 240
	*** 000291	8b 46 08 		mov	ax,WORD PTR [bp+8]	;pad_buf
	*** 000294	89 46 f4 		mov	WORD PTR [bp-12],ax
;|***   regs.x.cx = 6;
; Line 241
	*** 000297	c7 46 ee 06 00 		mov	WORD PTR [bp-18],6
;|***   int86x(PKTDVR, &regs, &regs, &sregs);
; Line 242
	*** 00029c	8d 46 f8 		lea	ax,WORD PTR [bp-8]	;sregs
	*** 00029f	16 			push	ss
	*** 0002a0	50 			push	ax
	*** 0002a1	8d 46 ea 		lea	ax,WORD PTR [bp-22]	;regs
	*** 0002a4	16 			push	ss
	*** 0002a5	50 			push	ax
	*** 0002a6	16 			push	ss
	*** 0002a7	50 			push	ax
	*** 0002a8	6a 7e 			push	126	;007eH
	*** 0002aa	9a 00 00 00 00 		call	FAR PTR _int86x
	*** 0002af	83 c4 0e 		add	sp,14	;000eH
;|***   /*printf("Address length: %d\n", regs.x.cx);
;|***   printf("ES: %d\n", sregs.es);
;|***   printf("DI: %d\n", regs.x.di);
;|***   printf("FP SEG: %u\n", (unsigned char) FP_SEG(pad_buf));
;|***   printf("FP OFF: %u\n", (unsigned char) FP_OFF(pad_buf));
;|***   printf("Address: ");
;|***   for(i=0; i<6; i++)
;|***     {
;|***     printf("%02x ", addr_buf[i]);
;|***     }
;|***   printf("\n");
;|***   last_function = function;
;|***   */
;|***   if(regs.x.cflag) error_num = regs.h.dh;
; Line 256
	*** 0002b2	83 7e f6 00 		cmp	WORD PTR [bp-10],0
	*** 0002b6	74 08 			je	$I1765
	*** 0002b8	8a 46 f1 		mov	al,BYTE PTR [bp-15]
	*** 0002bb	2a e4 			sub	ah,ah
	*** 0002bd	eb 03 			jmp	SHORT $I1766
	*** 0002bf	90 			nop	
					$I1765:
	*** 0002c0	33 c0 			xor	ax,ax
					$I1766:
	*** 0002c2	a3 00 00 		mov	WORD PTR ?error_num@@3HE,ax	;error_num
;|***   else error_num = 0;
;|***   return(regs.x.cflag);
; Line 258
	*** 0002c5	8b 46 f6 		mov	ax,WORD PTR [bp-10]
;|***   }
; Line 259
	*** 0002c8	5f 			pop	di
	*** 0002c9	c9 			leave	
	*** 0002ca	cb 			ret	
	*** 0002cb	90 			nop	

?get_address@@ZAHHPEEH@Z	ENDP
	PUBLIC	?send_pkt@@ZAHPEEI@Z	; send_pkt
?send_pkt@@ZAHPEEI@Z	PROC FAR	; send_pkt
;|***   
;|*** 
;|*** int send_pkt(unsigned char far *ptbuffer, unsigned tlength)
;|***   {
; Line 263
	*** 0002cc	c8 16 00 00 		enter	22,0
;	ptbuffer = 6
;	tlength = 10
;	regs = -22
;	sregs = -8
;|***   union REGS regs;
;|***   struct SREGS sregs;
;|*** 
;|***   segread(&sregs);
; Line 267
	*** 0002d0	8d 46 f8 		lea	ax,WORD PTR [bp-8]	;sregs
	*** 0002d3	16 			push	ss
	*** 0002d4	50 			push	ax
	*** 0002d5	9a 00 00 00 00 		call	FAR PTR _segread
	*** 0002da	83 c4 04 		add	sp,4
;|***   regs.h.ah = 4;
; Line 268
	*** 0002dd	c6 46 eb 04 		mov	BYTE PTR [bp-21],4
;|***   sregs.ds = FP_SEG(ptbuffer);
; Line 269
	*** 0002e1	8b 46 08 		mov	ax,WORD PTR [bp+8]
	*** 0002e4	89 46 fe 		mov	WORD PTR [bp-2],ax
;|***   regs.x.si = FP_OFF(ptbuffer);
; Line 270
	*** 0002e7	8b 46 06 		mov	ax,WORD PTR [bp+6]	;ptbuffer
	*** 0002ea	89 46 f2 		mov	WORD PTR [bp-14],ax
;|***   regs.x.cx = tlength;
; Line 271
	*** 0002ed	8b 46 0a 		mov	ax,WORD PTR [bp+10]	;tlength
	*** 0002f0	89 46 ee 		mov	WORD PTR [bp-18],ax
;|***   int86x(PKTDVR, &regs, &regs, &sregs);
; Line 272
	*** 0002f3	8d 46 f8 		lea	ax,WORD PTR [bp-8]	;sregs
	*** 0002f6	16 			push	ss
	*** 0002f7	50 			push	ax
	*** 0002f8	8d 46 ea 		lea	ax,WORD PTR [bp-22]	;regs
	*** 0002fb	16 			push	ss
	*** 0002fc	50 			push	ax
	*** 0002fd	16 			push	ss
	*** 0002fe	50 			push	ax
	*** 0002ff	6a 7e 			push	126	;007eH
	*** 000301	9a 00 00 00 00 		call	FAR PTR _int86x
	*** 000306	83 c4 0e 		add	sp,14	;000eH
;|***   //last_function = function;
;|***   if(regs.x.cflag) error_num = regs.h.dh;
; Line 274
	*** 000309	83 7e f6 00 		cmp	WORD PTR [bp-10],0
	*** 00030d	74 07 			je	$I1774
	*** 00030f	8a 46 f1 		mov	al,BYTE PTR [bp-15]
	*** 000312	2a e4 			sub	ah,ah
	*** 000314	eb 02 			jmp	SHORT $I1775
					$I1774:
	*** 000316	33 c0 			xor	ax,ax
					$I1775:
	*** 000318	a3 00 00 		mov	WORD PTR ?error_num@@3HE,ax	;error_num
;|***   else error_num = 0;
;|***   return(regs.x.cflag);
; Line 276
	*** 00031b	8b 46 f6 		mov	ax,WORD PTR [bp-10]
;|***   }
; Line 277
	*** 00031e	c9 			leave	
	*** 00031f	cb 			ret	

?send_pkt@@ZAHPEEI@Z	ENDP
	PUBLIC	?reset_interface@@ZAHH@Z	; reset_interface
?reset_interface@@ZAHH@Z	PROC FAR	; reset_interface
;|*** 
;|*** 
;|*** 
;|*** int reset_interface(int rhandle)
;|***   {
; Line 282
	*** 000320	c8 16 00 00 		enter	22,0
;	rhandle = 6
;	regs = -22
;	sregs = -8
;|***   union REGS regs;
;|***   struct SREGS sregs;
;|*** 
;|***   regs.h.ah = 7;
; Line 286
	*** 000324	c6 46 eb 07 		mov	BYTE PTR [bp-21],7
;|***   regs.x.bx = rhandle;
; Line 287
	*** 000328	8b 46 06 		mov	ax,WORD PTR [bp+6]	;rhandle
	*** 00032b	89 46 ec 		mov	WORD PTR [bp-20],ax
;|***   int86x(PKTDVR, &regs, &regs, &sregs);
; Line 288
	*** 00032e	8d 46 f8 		lea	ax,WORD PTR [bp-8]	;sregs
	*** 000331	16 			push	ss
	*** 000332	50 			push	ax
	*** 000333	8d 46 ea 		lea	ax,WORD PTR [bp-22]	;regs
	*** 000336	16 			push	ss
	*** 000337	50 			push	ax
	*** 000338	16 			push	ss
	*** 000339	50 			push	ax
	*** 00033a	6a 7e 			push	126	;007eH
	*** 00033c	9a 00 00 00 00 		call	FAR PTR _int86x
	*** 000341	83 c4 0e 		add	sp,14	;000eH
;|***   last_function = function;
; Line 289
	*** 000344	a1 00 00 		mov	ax,WORD PTR ?function@@3HE	;function
	*** 000347	a3 00 00 		mov	WORD PTR ?last_function@@3HE,ax	;last_function
;|***   if(regs.x.cflag) error_num = regs.h.dh;
; Line 290
	*** 00034a	83 7e f6 00 		cmp	WORD PTR [bp-10],0
	*** 00034e	74 08 			je	$I1780
	*** 000350	8a 46 f1 		mov	al,BYTE PTR [bp-15]
	*** 000353	2a e4 			sub	ah,ah
	*** 000355	eb 03 			jmp	SHORT $I1781
	*** 000357	90 			nop	
					$I1780:
	*** 000358	33 c0 			xor	ax,ax
					$I1781:
	*** 00035a	a3 00 00 		mov	WORD PTR ?error_num@@3HE,ax	;error_num
;|***   else error_num = 0;
;|***   return(regs.x.cflag);
; Line 292
	*** 00035d	8b 46 f6 		mov	ax,WORD PTR [bp-10]
;|***   }
; Line 293
	*** 000360	c9 			leave	
	*** 000361	cb 			ret	

?reset_interface@@ZAHH@Z	ENDP
	PUBLIC	?get_parameters@@ZAHXZ	; get_parameters
?get_parameters@@ZAHXZ	PROC FAR	; get_parameters
;|*** 
;|*** 
;|*** 
;|*** int get_parameters(void)
;|***   {
; Line 298
	*** 000362	c8 16 00 00 		enter	22,0
;	regs = -22
;	sregs = -8
;	param = -26
;|***   union REGS regs;
;|***   struct SREGS sregs;
;|***   char far * param;
;|*** 
;|***   regs.h.ah = 10;
; Line 303
	*** 000366	c6 46 eb 0a 		mov	BYTE PTR [bp-21],10	;000aH
;|***   int86x(PKTDVR, &regs, &regs, &sregs);
; Line 304
	*** 00036a	8d 46 f8 		lea	ax,WORD PTR [bp-8]	;sregs
	*** 00036d	16 			push	ss
	*** 00036e	50 			push	ax
	*** 00036f	8d 46 ea 		lea	ax,WORD PTR [bp-22]	;regs
	*** 000372	16 			push	ss
	*** 000373	50 			push	ax
	*** 000374	16 			push	ss
	*** 000375	50 			push	ax
	*** 000376	6a 7e 			push	126	;007eH
	*** 000378	9a 00 00 00 00 		call	FAR PTR _int86x
	*** 00037d	83 c4 0e 		add	sp,14	;000eH
;|***   param = (char far *)MK_FP(sregs.es, regs.x.di);
;|***   /*
;|***   printf("major rev: %d\n",          (unsigned char) param[0]);
;|***   printf("minor rev: %d\n",          (unsigned char) param[1]);
;|***   printf("param struct length: %d\n",(unsigned char) param[2]);
;|***   printf("addr length length: %d\n", (unsigned char) param[3]);
;|***   printf("mtu: %d\n",                (unsigned char) param[4] +
;|***                                     ((unsigned char) param[5]) *256);
;|***   printf("multicast aval: %d\n",     (unsigned char) param[6] +
;|***                                     ((unsigned char) param[7]) *256);
;|***   printf("rcv bufs: %d\n",           (unsigned char) param[8] +
;|***                                     ((unsigned char) param[9]) *256);
;|***   printf("xmt bufs: %d\n",           (unsigned char) param[10] +
;|***                                     ((unsigned char) param[11]) *256);
;|***   printf("int num: %d\n",            (unsigned char) param[12] +
;|***                                     ((unsigned char) param[13]) *256);
;|***   last_function = function;
;|***   */
;|***   if(regs.x.cflag) error_num = regs.h.dh;
; Line 323
	*** 000380	83 7e f6 00 		cmp	WORD PTR [bp-10],0
	*** 000384	74 08 			je	$I1792
	*** 000386	8a 46 f1 		mov	al,BYTE PTR [bp-15]
	*** 000389	2a e4 			sub	ah,ah
	*** 00038b	eb 03 			jmp	SHORT $I1793
	*** 00038d	90 			nop	
					$I1792:
	*** 00038e	33 c0 			xor	ax,ax
					$I1793:
	*** 000390	a3 00 00 		mov	WORD PTR ?error_num@@3HE,ax	;error_num
;|***   else error_num = 0;
;|***   return(regs.x.cflag);
; Line 325
	*** 000393	8b 46 f6 		mov	ax,WORD PTR [bp-10]
;|***   }
; Line 326
	*** 000396	c9 			leave	
	*** 000397	cb 			ret	

?get_parameters@@ZAHXZ	ENDP
	PUBLIC	?as_send_pkt@@ZAHPEEIP7AXPEDH@Z@Z	; as_send_pkt
?as_send_pkt@@ZAHPEEIP7AXPEDH@Z@Z	PROC FAR	; as_send_pkt
;|*** 
;|*** 
;|*** int as_send_pkt(unsigned char far *ptbuffer, unsigned tlength, void (far *upcall)(char far *,int))
;|***   {
; Line 330
	*** 000398	c8 16 00 00 		enter	22,0
;	ptbuffer = 6
;	tlength = 10
;	upcall = 12
;	regs = -22
;	sregs = -8
;|***   union REGS regs;
;|***   struct SREGS sregs;
;|*** 
;|***   segread(&sregs);
; Line 334
	*** 00039c	8d 46 f8 		lea	ax,WORD PTR [bp-8]	;sregs
	*** 00039f	16 			push	ss
	*** 0003a0	50 			push	ax
	*** 0003a1	9a 00 00 00 00 		call	FAR PTR _segread
	*** 0003a6	83 c4 04 		add	sp,4
;|***   regs.h.ah = 11;
; Line 335
	*** 0003a9	c6 46 eb 0b 		mov	BYTE PTR [bp-21],11	;000bH
;|***   sregs.ds = FP_SEG(ptbuffer);
; Line 336
	*** 0003ad	8b 46 08 		mov	ax,WORD PTR [bp+8]
	*** 0003b0	89 46 fe 		mov	WORD PTR [bp-2],ax
;|***   regs.x.si = FP_OFF(ptbuffer);
; Line 337
	*** 0003b3	8b 46 06 		mov	ax,WORD PTR [bp+6]	;ptbuffer
	*** 0003b6	89 46 f2 		mov	WORD PTR [bp-14],ax
;|***   regs.x.cx = tlength;
; Line 338
	*** 0003b9	8b 46 0a 		mov	ax,WORD PTR [bp+10]	;tlength
	*** 0003bc	89 46 ee 		mov	WORD PTR [bp-18],ax
;|***   sregs.es = FP_SEG(upcall);
; Line 339
	*** 0003bf	8b 46 0e 		mov	ax,WORD PTR [bp+14]
	*** 0003c2	89 46 f8 		mov	WORD PTR [bp-8],ax	;sregs
;|***   regs.x.di = FP_OFF(upcall);
; Line 340
	*** 0003c5	8b 46 0c 		mov	ax,WORD PTR [bp+12]	;upcall
	*** 0003c8	89 46 f4 		mov	WORD PTR [bp-12],ax
;|***   int86x(PKTDVR, &regs, &regs, &sregs);
; Line 341
	*** 0003cb	8d 46 f8 		lea	ax,WORD PTR [bp-8]	;sregs
	*** 0003ce	16 			push	ss
	*** 0003cf	50 			push	ax
	*** 0003d0	8d 46 ea 		lea	ax,WORD PTR [bp-22]	;regs
	*** 0003d3	16 			push	ss
	*** 0003d4	50 			push	ax
	*** 0003d5	16 			push	ss
	*** 0003d6	50 			push	ax
	*** 0003d7	6a 7e 			push	126	;007eH
	*** 0003d9	9a 00 00 00 00 		call	FAR PTR _int86x
	*** 0003de	83 c4 0e 		add	sp,14	;000eH
;|***   //last_function = function;
;|***   if(regs.x.cflag) error_num = regs.h.dh;
;|***   else error_num = 0;
;|***   //return(regs.x.cflag);
;|***   return error_num;
; Line 346
	*** 0003e1	83 7e f6 00 		cmp	WORD PTR [bp-10],0
	*** 0003e5	74 0b 			je	$I1806
	*** 0003e7	8a 46 f1 		mov	al,BYTE PTR [bp-15]
	*** 0003ea	2a e4 			sub	ah,ah
	*** 0003ec	a3 00 00 		mov	WORD PTR ?error_num@@3HE,ax	;error_num
	*** 0003ef	c9 			leave	
	*** 0003f0	cb 			ret	
	*** 0003f1	90 			nop	
					$I1806:
	*** 0003f2	33 c0 			xor	ax,ax
	*** 0003f4	a3 00 00 		mov	WORD PTR ?error_num@@3HE,ax	;error_num
;|***   }
; Line 347
	*** 0003f7	c9 			leave	
	*** 0003f8	cb 			ret	
	*** 0003f9	90 			nop	

?as_send_pkt@@ZAHPEEIP7AXPEDH@Z@Z	ENDP
	PUBLIC	?upcall@@ZAXPEDH@Z	; upcall
?upcall@@ZAXPEDH@Z	PROC FAR	; upcall
;|*** 
;|*** void upcall(char far *buffer, int result)
;|***   {
; Line 350
;	buffer = 6
;	result = 10
;|***   }
; Line 351
	*** 0003fa	cb 			ret	
	*** 0003fb	90 			nop	

?upcall@@ZAXPEDH@Z	ENDP
ETHER_TEXT      ENDS
CONST      SEGMENT
$T1869	DW SEG ?cmd_buffer@@3QEEE 
$T1870	DW SEG ?echo@@3UECHO@@E 
CONST      ENDS
ETHER_TEXT      SEGMENT
	ASSUME	CS: ETHER_TEXT
	PUBLIC	?receiver@@ZAXIIIIIIIIIIIII@Z	; receiver
?receiver@@ZAXIIIIIIIIIIIII@Z	PROC FAR	; receiver
;|*** 
;|*** void interrupt far receiver(unsigned es, unsigned ds, unsigned di, unsigned si,
;|***                             unsigned bp, unsigned sp, unsigned bx, unsigned dx,
;|***                             unsigned cx, unsigned ax, unsigned ip, unsigned cs,
;|***                             unsigned flags)
;|***   {
; Line 357
	*** 0003fc	60 			pusha
	*** 0003fd	1e 			push	ds
	*** 0003fe	06 			push	es
	*** 0003ff	8b ec 			mov	bp,sp
	*** 000401	1e 			push	ds
	*** 000402	b8 00 00 		mov	ax,DGROUP
	*** 000405	8e d8 			mov	ds,ax
	ASSUME DS: DGROUP
	*** 000407	fc 			cld	
;	es = 0
;	ds = 2
;	di = 4
;	si = 6
;	bp = 8
;	sp = 10
;	bx = 12
;	dx = 14
;	cx = 16
;	ax = 18
;	ip = 20
;	cs = 22
;	flags = 24
;	lsb = -2
;	msb = -4
;|***   unsigned int lsb = 0;
;|***   unsigned int msb = 0;
;|***   
;|***   receiver_calls++;
; Line 361
	*** 000408	83 06 00 00 01 		add	WORD PTR ?receiver_calls@@3KE,1	;receiver_calls
	*** 00040d	83 16 02 00 00 		adc	WORD PTR ?receiver_calls@@3KE+2,0	;receiver_calls
;|***   packet_len = 0;
; Line 362
	*** 000412	c7 06 00 00 00 00 	mov	WORD PTR ?packet_len@@3HE,0	;packet_len
	*** 000418	8b 76 10 		mov	si,WORD PTR [bp+16]	;cx
;|***   if(packet_len || (cx > sizeof(rxbuf)/sizeof(rxbuf[0])))
; Line 363
	*** 00041b	81 fe d0 07 		cmp	si,2000	;07d0H
	*** 00041f	76 03 			jbe	$JCC1055
	*** 000421	e9 b2 00 		jmp	$I1828
					$JCC1055:
	*** 000424	8b 5e 12 		mov	bx,WORD PTR [bp+18]	;ax
;|***     {
;|***     es = di = 0;
;|***     discards++;
;|***     }
;|***   else
;|***     {
;|***     if(ax == 0)
; Line 370
	*** 000427	0b db 			or	bx,bx
	*** 000429	75 15 			jne	$I1830
;|***       {
;|***       es = _FP_SEG(prxbuf);
; Line 372
	*** 00042b	a1 02 00 		mov	ax,WORD PTR ?prxbuf@@3PEEE+2	;prxbuf
	*** 00042e	89 46 00 		mov	WORD PTR [bp],ax	;es
;|***       di = _FP_OFF(prxbuf);
; Line 373
	*** 000431	a1 00 00 		mov	ax,WORD PTR ?prxbuf@@3PEEE	;prxbuf
	*** 000434	89 46 04 		mov	WORD PTR [bp+4],ax	;di
;|***       ax0_counter++;
; Line 374
	*** 000437	83 06 00 00 01 		add	WORD PTR ?ax0_counter@@3KE,1	;ax0_counter
	*** 00043c	11 1e 02 00 		adc	WORD PTR ?ax0_counter@@3KE+2,bx	;ax0_counter
;|***       }
;|***     if(ax == 1)
; Line 376
					$I1830:
	*** 000440	83 fb 01 		cmp	bx,1
	*** 000443	74 03 			je	$JCC1091
	*** 000445	e9 9f 00 		jmp	$EX1824
					$JCC1091:
;|***       {
;|***       packet_len = cx;
; Line 378
	*** 000448	89 36 00 00 		mov	WORD PTR ?packet_len@@3HE,si	;packet_len
;|***       if(  (_fstrnicmp((char *)&rxbuf[0], (char *)&obc_mac[0], 6)==0)
;|***              && (packet_len < 200) )
; Line 380
	*** 00044c	6a 06 			push	6
	*** 00044e	68 00 00 		push	SEG ?obc_mac@@3QIEI	;obc_mac
	*** 000451	68 00 00 		push	OFFSET ?obc_mac@@3QIEI	;obc_mac
	*** 000454	1e 			push	ds
	*** 000455	68 00 00 		push	OFFSET DGROUP:?rxbuf@@3QIEI	;rxbuf
	*** 000458	9a 00 00 00 00 		call	FAR PTR __fstrnicmp
	*** 00045d	83 c4 0a 		add	sp,10	;000aH
	*** 000460	0b c0 			or	ax,ax
	*** 000462	75 62 			jne	$I1836
	*** 000464	81 3e 00 00 c8 00 	cmp	WORD PTR ?packet_len@@3HE,200	;00c8H	;packet_len
	*** 00046a	7d 5a 			jge	$I1836
;|***         {
;|***         _fmemcpy(cmd_buffer, rxbuf, packet_len);
; Line 382
	*** 00046c	8e 06 00 00 		mov	es,WORD PTR $T1869
	*** 000470	8b 0e 00 00 		mov	cx,WORD PTR ?packet_len@@3HE	;packet_len
	*** 000474	bf 00 00 		mov	di,OFFSET ?cmd_buffer@@3QEEE	;cmd_buffer
	*** 000477	be 00 00 		mov	si,OFFSET DGROUP:?rxbuf@@3QIEI	;rxbuf
	*** 00047a	d1 e9 			shr	cx,1
	*** 00047c	f3 			rep
	*** 00047d	a5 			movsw
	*** 00047e	13 c9 			adc	cx,cx
	*** 000480	f3 			rep
	*** 000481	a4 			movsb
;|***         packet_len = 0;
; Line 383
	*** 000482	a3 00 00 		mov	WORD PTR ?packet_len@@3HE,ax	;packet_len
;|***         packets_rcvd++;
; Line 384
	*** 000485	83 06 00 00 01 		add	WORD PTR ?packets_rcvd@@3KE,1	;packets_rcvd
	*** 00048a	11 06 02 00 		adc	WORD PTR ?packets_rcvd@@3KE+2,ax	;packets_rcvd
;|***         ax1_counter++;
; Line 385
	*** 00048e	83 06 00 00 01 		add	WORD PTR ?ax1_counter@@3KE,1	;ax1_counter
	*** 000493	11 06 02 00 		adc	WORD PTR ?ax1_counter@@3KE+2,ax	;ax1_counter
;|***         echo.new_data = 1;
; Line 386
	*** 000497	8e 06 00 00 		mov	es,WORD PTR $T1870
	*** 00049b	26 c7 06 00 00 01 00 	mov	WORD PTR es:?echo@@3UECHO@@E,1	;echo
;|***         echo.frame = frame;
; Line 387
	*** 0004a2	a1 00 00 		mov	ax,WORD PTR ?frame@@3KE	;frame
	*** 0004a5	8b 16 02 00 		mov	dx,WORD PTR ?frame@@3KE+2	;frame
	*** 0004a9	26 a3 02 00 		mov	WORD PTR es:?echo@@3UECHO@@E+2,ax	;echo
	*** 0004ad	26 89 16 04 00 		mov	WORD PTR es:?echo@@3UECHO@@E+4,dx	;echo
;|***         time_stamp(&cmds_time);
; Line 388
	*** 0004b2	68 00 00 		push	SEG ?cmds_time@@3UTIMER@@E	;cmds_time
	*** 0004b5	68 00 00 		push	OFFSET ?cmds_time@@3UTIMER@@E	;cmds_time
	*** 0004b8	9a 00 00 00 00 		call	FAR PTR ?time_stamp@@ZAXPEUTIMER@@@Z	; time_stamp
	*** 0004bd	83 c4 04 		add	sp,4
;|***         time_since_last_command = 0;
; Line 389
	*** 0004c0	c7 06 00 00 00 00 	mov	WORD PTR ?time_since_last_command@@3HE,0	;time_since_last_command
;|***         }
;|***       _fmemset(rxbuf, 0, sizeof(rxbuf));
; Line 391
					$I1836:
	*** 0004c6	33 c0 			xor	ax,ax
	*** 0004c8	bb 00 00 		mov	bx,OFFSET DGROUP:?rxbuf@@3QIEI	;rxbuf
	*** 0004cb	b9 e8 03 		mov	cx,1000	;03e8H
	*** 0004ce	8b fb 			mov	di,bx
	*** 0004d0	1e 			push	ds
	*** 0004d1	07 			pop	es
	*** 0004d2	f3 			rep
	*** 0004d3	ab 			stosw
	*** 0004d4	eb 11 			jmp	SHORT $EX1824
;|***   if(packet_len || (cx > sizeof(rxbuf)/sizeof(rxbuf[0])))
; Line 363
					$I1828:
;|***     {
;|***     es = di = 0;
; Line 365
	*** 0004d6	33 c0 			xor	ax,ax
	*** 0004d8	89 46 04 		mov	WORD PTR [bp+4],ax	;di
	*** 0004db	89 46 00 		mov	WORD PTR [bp],ax	;es
;|***     discards++;
; Line 366
	*** 0004de	83 06 00 00 01 		add	WORD PTR ?discards@@3KE,1	;discards
	*** 0004e3	11 06 02 00 		adc	WORD PTR ?discards@@3KE+2,ax	;discards
;|***     }
;|***   else
;|***     {
;|***     if(ax == 0)
;|***       {
;|***       es = _FP_SEG(prxbuf);
;|***       di = _FP_OFF(prxbuf);
;|***       ax0_counter++;
;|***       }
;|***     if(ax == 1)
;|***       {
;|***       packet_len = cx;
;|***       if(  (_fstrnicmp((char *)&rxbuf[0], (char *)&obc_mac[0], 6)==0)
;|***              && (packet_len < 200) )
;|***         {
;|***         _fmemcpy(cmd_buffer, rxbuf, packet_len);
;|***         packet_len = 0;
;|***         packets_rcvd++;
;|***         ax1_counter++;
;|***         echo.new_data = 1;
;|***         echo.frame = frame;
;|***         time_stamp(&cmds_time);
;|***         time_since_last_command = 0;
;|***         }
;|***       _fmemset(rxbuf, 0, sizeof(rxbuf));
;|***       }
;|***     }
;|***   }
; Line 394
					$EX1824:
	*** 0004e7	8b e5 			mov	sp,bp
	*** 0004e9	07 			pop	es
	*** 0004ea	1f 			pop	ds
	ASSUME DS: DGROUP
	*** 0004eb	61 			popa
	*** 0004ec	cf 			iret	

?receiver@@ZAXIIIIIIIIIIIII@Z	ENDP
	PUBLIC	?set_rcv_mode@@ZAHHH@Z	; set_rcv_mode
?set_rcv_mode@@ZAHHH@Z	PROC FAR	; set_rcv_mode
;|*** 
;|***                            
;|*** int set_rcv_mode(int set_rcv_handle, int set_rcv_mode)
;|***   {
; Line 398
	*** 0004ed	c8 0e 00 00 		enter	14,0
;	set_rcv_handle = 6
;	set_rcv_mode = 8
;	regs = -14
;|***   union REGS regs;
;|*** 
;|***   regs.h.ah = SET_RCV_MODE;
; Line 401
	*** 0004f1	c6 46 f3 14 		mov	BYTE PTR [bp-13],20	;0014H
;|***   regs.x.bx = set_rcv_handle;
; Line 402
	*** 0004f5	8b 46 06 		mov	ax,WORD PTR [bp+6]	;set_rcv_handle
	*** 0004f8	89 46 f4 		mov	WORD PTR [bp-12],ax
;|***   regs.x.cx = set_rcv_mode;
; Line 403
	*** 0004fb	8b 46 08 		mov	ax,WORD PTR [bp+8]	;set_rcv_mode
	*** 0004fe	89 46 f6 		mov	WORD PTR [bp-10],ax
;|***   int86(PKTDVR, &regs, &regs);
; Line 404
	*** 000501	8d 46 f2 		lea	ax,WORD PTR [bp-14]	;regs
	*** 000504	16 			push	ss
	*** 000505	50 			push	ax
	*** 000506	16 			push	ss
	*** 000507	50 			push	ax
	*** 000508	6a 7e 			push	126	;007eH
	*** 00050a	9a 00 00 00 00 		call	FAR PTR _int86
	*** 00050f	83 c4 0a 		add	sp,10	;000aH
;|***   //last_function = function;
;|***   if(regs.x.cflag) error_num = regs.h.dh;
; Line 406
	*** 000512	83 7e fe 00 		cmp	WORD PTR [bp-2],0
	*** 000516	74 08 			je	$I1841
	*** 000518	8a 46 f9 		mov	al,BYTE PTR [bp-7]
	*** 00051b	2a e4 			sub	ah,ah
	*** 00051d	eb 03 			jmp	SHORT $I1842
	*** 00051f	90 			nop	
					$I1841:
	*** 000520	33 c0 			xor	ax,ax
					$I1842:
	*** 000522	a3 00 00 		mov	WORD PTR ?error_num@@3HE,ax	;error_num
;|***   else error_num = 0;
;|***   return(regs.x.cflag);
; Line 408
	*** 000525	8b 46 fe 		mov	ax,WORD PTR [bp-2]
;|***   }
; Line 409
	*** 000528	c9 			leave	
	*** 000529	cb 			ret	

?set_rcv_mode@@ZAHHH@Z	ENDP
	PUBLIC	?get_rcv_mode@@ZAHH@Z	; get_rcv_mode
?get_rcv_mode@@ZAHH@Z	PROC FAR	; get_rcv_mode
;|*** 
;|*** 
;|*** int get_rcv_mode(int get_rcv_handle)
;|***   {
; Line 413
	*** 00052a	c8 0e 00 00 		enter	14,0
;	get_rcv_handle = 6
;	regs = -14
;|***   union REGS regs;
;|*** 
;|***   regs.h.ah = GET_RCV_MODE;
; Line 416
	*** 00052e	c6 46 f3 15 		mov	BYTE PTR [bp-13],21	;0015H
;|***   regs.x.bx = get_rcv_handle;
; Line 417
	*** 000532	8b 46 06 		mov	ax,WORD PTR [bp+6]	;get_rcv_handle
	*** 000535	89 46 f4 		mov	WORD PTR [bp-12],ax
;|***   int86(PKTDVR, &regs, &regs);
; Line 418
	*** 000538	8d 46 f2 		lea	ax,WORD PTR [bp-14]	;regs
	*** 00053b	16 			push	ss
	*** 00053c	50 			push	ax
	*** 00053d	16 			push	ss
	*** 00053e	50 			push	ax
	*** 00053f	6a 7e 			push	126	;007eH
	*** 000541	9a 00 00 00 00 		call	FAR PTR _int86
	*** 000546	83 c4 0a 		add	sp,10	;000aH
;|***   //last_function = function;
;|***   if(regs.x.cflag) error_num = regs.h.dh;
; Line 420
	*** 000549	83 7e fe 00 		cmp	WORD PTR [bp-2],0
	*** 00054d	74 07 			je	$I1846
	*** 00054f	8a 46 f9 		mov	al,BYTE PTR [bp-7]
	*** 000552	2a e4 			sub	ah,ah
	*** 000554	eb 02 			jmp	SHORT $I1847
					$I1846:
	*** 000556	33 c0 			xor	ax,ax
					$I1847:
	*** 000558	a3 00 00 		mov	WORD PTR ?error_num@@3HE,ax	;error_num
;|***   else error_num = 0;
;|***   return(regs.x.cflag);
; Line 422
	*** 00055b	8b 46 fe 		mov	ax,WORD PTR [bp-2]
;|***   }
; Line 423
	*** 00055e	c9 			leave	
	*** 00055f	cb 			ret	

?get_rcv_mode@@ZAHH@Z	ENDP
	PUBLIC	?set_multicast_list@@ZAHPEEH@Z	; set_multicast_list
?set_multicast_list@@ZAHPEEH@Z	PROC FAR	; set_multicast_list
;|*** 
;|*** 
;|*** int set_multicast_list(unsigned char far * addrlst, int len)
;|***   {
; Line 427
	*** 000560	c8 16 00 00 		enter	22,0
;	addrlst = 6
;	len = 10
;	regs = -22
;	sregs = -8
;|***   union REGS regs;
;|***   struct SREGS sregs;
;|*** 
;|***   segread(&sregs);
; Line 431
	*** 000564	8d 46 f8 		lea	ax,WORD PTR [bp-8]	;sregs
	*** 000567	16 			push	ss
	*** 000568	50 			push	ax
	*** 000569	9a 00 00 00 00 		call	FAR PTR _segread
	*** 00056e	83 c4 04 		add	sp,4
;|***   regs.h.ah = SET_MULTICAST_LIST;
; Line 432
	*** 000571	c6 46 eb 16 		mov	BYTE PTR [bp-21],22	;0016H
;|***   regs.x.cx = len;
; Line 433
	*** 000575	8b 46 0a 		mov	ax,WORD PTR [bp+10]	;len
	*** 000578	89 46 ee 		mov	WORD PTR [bp-18],ax
;|***   sregs.es = FP_SEG(addrlst);
; Line 434
	*** 00057b	8b 46 08 		mov	ax,WORD PTR [bp+8]
	*** 00057e	89 46 f8 		mov	WORD PTR [bp-8],ax	;sregs
;|***   regs.x.di = FP_OFF(addrlst);
; Line 435
	*** 000581	8b 46 06 		mov	ax,WORD PTR [bp+6]	;addrlst
	*** 000584	89 46 f4 		mov	WORD PTR [bp-12],ax
;|***   int86x(PKTDVR, &regs, &regs, &sregs);
; Line 436
	*** 000587	8d 46 f8 		lea	ax,WORD PTR [bp-8]	;sregs
	*** 00058a	16 			push	ss
	*** 00058b	50 			push	ax
	*** 00058c	8d 46 ea 		lea	ax,WORD PTR [bp-22]	;regs
	*** 00058f	16 			push	ss
	*** 000590	50 			push	ax
	*** 000591	16 			push	ss
	*** 000592	50 			push	ax
	*** 000593	6a 7e 			push	126	;007eH
	*** 000595	9a 00 00 00 00 		call	FAR PTR _int86x
	*** 00059a	83 c4 0e 		add	sp,14	;000eH
;|***   //last_function = function;
;|***   if(regs.x.cflag) error_num = regs.h.dh;
; Line 438
	*** 00059d	83 7e f6 00 		cmp	WORD PTR [bp-10],0
	*** 0005a1	74 07 			je	$I1855
	*** 0005a3	8a 46 f1 		mov	al,BYTE PTR [bp-15]
	*** 0005a6	2a e4 			sub	ah,ah
	*** 0005a8	eb 02 			jmp	SHORT $I1856
					$I1855:
	*** 0005aa	33 c0 			xor	ax,ax
					$I1856:
	*** 0005ac	a3 00 00 		mov	WORD PTR ?error_num@@3HE,ax	;error_num
;|***   else error_num = 0;
;|***   return(regs.x.cflag);
; Line 440
	*** 0005af	8b 46 f6 		mov	ax,WORD PTR [bp-10]
;|***   }
; Line 441
	*** 0005b2	c9 			leave	
	*** 0005b3	cb 			ret	

?set_multicast_list@@ZAHPEEH@Z	ENDP
	PUBLIC	?get_multicast_list@@ZAHXZ	; get_multicast_list
?get_multicast_list@@ZAHXZ	PROC FAR	; get_multicast_list
;|*** 
;|*** 
;|*** int get_multicast_list(void)
;|***   {
; Line 445
	*** 0005b4	c8 16 00 00 		enter	22,0
;	regs = -22
;	sregs = -8
;|***   union REGS regs;
;|***   struct SREGS sregs;
;|*** 
;|***   regs.h.ah = GET_MULTICAST_LIST;
; Line 449
	*** 0005b8	c6 46 eb 17 		mov	BYTE PTR [bp-21],23	;0017H
;|***   int86x(PKTDVR, &regs, &regs, &sregs);
; Line 450
	*** 0005bc	8d 46 f8 		lea	ax,WORD PTR [bp-8]	;sregs
	*** 0005bf	16 			push	ss
	*** 0005c0	50 			push	ax
	*** 0005c1	8d 46 ea 		lea	ax,WORD PTR [bp-22]	;regs
	*** 0005c4	16 			push	ss
	*** 0005c5	50 			push	ax
	*** 0005c6	16 			push	ss
	*** 0005c7	50 			push	ax
	*** 0005c8	6a 7e 			push	126	;007eH
	*** 0005ca	9a 00 00 00 00 		call	FAR PTR _int86x
	*** 0005cf	83 c4 0e 		add	sp,14	;000eH
;|***   //last_function = function;
;|***   if(regs.x.cflag) error_num = regs.h.dh;
; Line 452
	*** 0005d2	83 7e f6 00 		cmp	WORD PTR [bp-10],0
	*** 0005d6	74 08 			je	$I1861
	*** 0005d8	8a 46 f1 		mov	al,BYTE PTR [bp-15]
	*** 0005db	2a e4 			sub	ah,ah
	*** 0005dd	eb 03 			jmp	SHORT $I1862
	*** 0005df	90 			nop	
					$I1861:
	*** 0005e0	33 c0 			xor	ax,ax
					$I1862:
	*** 0005e2	a3 00 00 		mov	WORD PTR ?error_num@@3HE,ax	;error_num
;|***   else error_num = 0;
;|***   return(regs.x.cflag);
; Line 454
	*** 0005e5	8b 46 f6 		mov	ax,WORD PTR [bp-10]
;|***   }
; Line 455
	*** 0005e8	c9 			leave	
	*** 0005e9	cb 			ret	

?get_multicast_list@@ZAHXZ	ENDP
	PUBLIC	?print_error@@ZAXH@Z	; print_error
?print_error@@ZAXH@Z	PROC FAR	; print_error
;|*** 
;|*** 
;|*** void print_error(int err_num)
;|***   {
; Line 459
	*** 0005ea	55 			push	bp
	*** 0005eb	8b ec 			mov	bp,sp
;	err_num = 6
;|***   printf("%s\n", error_msg[err_num]);
; Line 460
	*** 0005ed	8b 46 06 		mov	ax,WORD PTR [bp+6]	;err_num
	*** 0005f0	8b c8 			mov	cx,ax
	*** 0005f2	c1 e0 04 		shl	ax,4
	*** 0005f5	2b c1 			sub	ax,cx
	*** 0005f7	05 00 00 		add	ax,OFFSET DGROUP:$S1426_error_msg
	*** 0005fa	1e 			push	ds
	*** 0005fb	50 			push	ax
	*** 0005fc	1e 			push	ds
	*** 0005fd	68 00 00 		push	OFFSET DGROUP:$SG1865
	*** 000600	9a 00 00 00 00 		call	FAR PTR _printf
	*** 000605	8b e5 			mov	sp,bp
;|***   err_num = 0;
;|***   printf("\n");
; Line 462
	*** 000607	1e 			push	ds
	*** 000608	68 00 00 		push	OFFSET DGROUP:$SG1866
	*** 00060b	9a 00 00 00 00 		call	FAR PTR _printf
;|***   }
; Line 463
	*** 000610	c9 			leave	
	*** 000611	cb 			ret	

?print_error@@ZAXH@Z	ENDP
ETHER_TEXT	ENDS
END
;|*** 
