;	Static Name Aliases
;
	TITLE   c:\cba\rs232cb8.cpp
	.286p
INCLUDELIB      LLIBCE
INCLUDELIB	OLDNAMES.LIB
RS232CB8_TEXT	SEGMENT  WORD PUBLIC 'CODE'
RS232CB8_TEXT	ENDS
_DATA	SEGMENT  WORD PUBLIC 'DATA'
_DATA	ENDS
CONST	SEGMENT  WORD PUBLIC 'CONST'
CONST	ENDS
_BSS	SEGMENT  WORD PUBLIC 'BSS'
_BSS	ENDS
DGROUP	GROUP	CONST, _BSS, _DATA
	ASSUME DS: DGROUP, SS: DGROUP
PUBLIC  ?tx1_index@@3IE
PUBLIC  ?tx1_counter@@3IE
PUBLIC  ?tx1_len@@3IE
PUBLIC  ?rx1_index@@3IE
PUBLIC  ?tx2_index@@3IE
PUBLIC  ?tx2_counter@@3IE
PUBLIC  ?tx2_len@@3IE
PUBLIC  ?rx2_index@@3IE
PUBLIC  ?tx4_index@@3IE
PUBLIC  ?tx4_counter@@3IE
PUBLIC  ?tx4_len@@3IE
PUBLIC  ?rx4_index@@3IE
EXTRN	?time_stamp@@ZAXPEUTIMER@@@Z:FAR
EXTRN	__dos_setvect:FAR
EXTRN	__dos_getvect:FAR
EXTRN	?adcp_new_data@@3IE:WORD
EXTRN	?adcp_data_frame@@3KE:DWORD
EXTRN	?ds_buffer@@3QIEI:BYTE
EXTRN	?ds_new_data@@3IE:WORD
EXTRN	?ds_data_frame@@3KE:DWORD
EXTRN	?gps_buffer@@3QIEI:BYTE
EXTRN	?gps_new_data@@3IE:WORD
EXTRN	?gps_data_frame@@3KE:DWORD
EXTRN	?com1_tx@@3IE:WORD
EXTRN	?com2_tx@@3IE:WORD
EXTRN	?com4_tx@@3IE:WORD
EXTRN	?frame@@3KE:DWORD
EXTRN	?adcp_time@@3UTIMER@@E:FWORD
EXTRN	?ds_time@@3UTIMER@@E:FWORD
EXTRN	?gps_time@@3UTIMER@@E:FWORD
EXTRN	?adcp_buffer@@3QIEI:WORD
_DATA      SEGMENT
?tx1_index@@3IE	DW	00H
?tx1_counter@@3IE	DW	00H
?tx1_len@@3IE	DW	00H
?rx1_index@@3IE	DW	00H
?tx2_index@@3IE	DW	00H
?tx2_counter@@3IE	DW	00H
?tx2_len@@3IE	DW	00H
?rx2_index@@3IE	DW	00H
?tx4_index@@3IE	DW	00H
?tx4_counter@@3IE	DW	00H
?tx4_len@@3IE	DW	00H
?rx4_index@@3IE	DW	00H
_DATA      ENDS
_BSS      SEGMENT
PUBLIC  ?tx1_message@@3QIEI
?tx1_message@@3QIEI	DW 028H DUP (?)
PUBLIC  ?rx1_message@@3QIEI
?rx1_message@@3QIEI	DW 0200H DUP (?)
PUBLIC  ?tx2_message@@3QIEI
?tx2_message@@3QIEI	DW 028H DUP (?)
PUBLIC  ?rx2_message@@3QIEI
?rx2_message@@3QIEI	DW 02cH DUP (?)
PUBLIC  ?tx4_message@@3QIEI
?tx4_message@@3QIEI	DW 028H DUP (?)
PUBLIC  ?rx4_message@@3QIEI
?rx4_message@@3QIEI	DW 028H DUP (?)
PUBLIC  ?com1_old_vector@@3P7AXXZE
?com1_old_vector@@3P7AXXZE	DW 02H DUP (?)
PUBLIC  ?com2_old_vector@@3P7AXXZE
?com2_old_vector@@3P7AXXZE	DW 02H DUP (?)
PUBLIC  ?com4_old_vector@@3P7AXXZE
?com4_old_vector@@3P7AXXZE	DW 02H DUP (?)
_BSS      ENDS
RS232CB8_TEXT      SEGMENT
	ASSUME	CS: RS232CB8_TEXT
	PUBLIC	?init_com1@@ZAXXZ	; init_com1
?init_com1@@ZAXXZ	PROC FAR	; init_com1
;|*** /* rs323.cpp
;|***    serial port routines for the
;|***    CB8 autonomous obc
;|*** */
;|***    
;|*** #include <stdlib.h>
;|*** #include <stdio.h>
;|*** #include <dos.h>
;|*** #include <conio.h>
;|*** #include <string.h>
;|*** #include <graph.h>
;|*** #include "pc.h"
;|*** #include "rs232.h"
;|*** #include "cba.h"
;|*** #include "dmm32.h"
;|*** 
;|*** // adcp variables
;|*** unsigned char tx1_message[80];
;|*** unsigned tx1_index = 0;
;|*** unsigned tx1_counter = 0;
;|*** unsigned tx1_len = 0;
;|*** unsigned rx1_index = 0;
;|*** unsigned char rx1_message[1024];
;|*** //unsigned char adcp_test[88];
;|*** 
;|*** // desert star variables
;|*** unsigned char tx2_message[80];
;|*** unsigned tx2_index = 0;
;|*** unsigned tx2_counter = 0;
;|*** unsigned tx2_len = 0;
;|*** unsigned rx2_index = 0;
;|*** unsigned char rx2_message[88];
;|*** 
;|*** // gps variables
;|*** unsigned char tx4_message[80];
;|*** unsigned tx4_index = 0;
;|*** unsigned tx4_counter = 0;
;|*** unsigned tx4_len = 0;
;|*** unsigned rx4_index = 0;
;|*** unsigned char rx4_message[80];
;|*** 
;|*** // global variables
;|*** void (interrupt far * com1_old_vector)();
;|*** void (interrupt far * com2_old_vector)();
;|*** void (interrupt far * com4_old_vector)();
;|*** 
;|*** // global flags
;|*** 
;|*** 
;|*** // external variables
;|*** //extern unsigned char adcp_buffer[88];  // for PD4/5 messages
;|*** extern unsigned char adcp_buffer[sizeof(ADCPLEN)];  // for PD0 messages
;|*** extern unsigned      adcp_new_data;
;|*** extern unsigned long adcp_data_frame;
;|*** extern unsigned char ds_buffer[80];
;|*** extern unsigned      ds_new_data;
;|*** extern unsigned long ds_data_frame;
;|*** extern unsigned char gps_buffer[80];
;|*** extern unsigned      gps_new_data;
;|*** extern unsigned long gps_data_frame;
;|*** extern unsigned      com1_tx;
;|*** extern unsigned      com2_tx;
;|*** extern unsigned      com4_tx;
;|*** 
;|*** extern unsigned long frame;
;|*** 
;|*** struct TIMER
;|***   {
;|***   unsigned long high;
;|***   unsigned      low;
;|***   };
;|*** 
;|*** extern TIMER sys_timer;
;|*** extern TIMER adcp_time;
;|*** extern TIMER ds_time;
;|*** extern TIMER gps_time;
;|*** 
;|*** 
;|*** void init_com1(void)
;|***   {
;|***   // disable cpu interrupts
;|***   _disable();
; Line 82
	*** 000000	fa 			cli	
;|***   
;|***   // set vector for COM1, irq4
;|***   com1_old_vector = _dos_getvect(4+8); // irq4
; Line 85
	*** 000001	6a 0c 			push	12	;000cH
	*** 000003	9a 00 00 00 00 		call	FAR PTR __dos_getvect
	*** 000008	83 c4 02 		add	sp,2
	*** 00000b	a3 00 00 		mov	WORD PTR ?com1_old_vector@@3P7AXXZE,ax	;com1_old_vector
	*** 00000e	89 16 02 00 		mov	WORD PTR ?com1_old_vector@@3P7AXXZE+2,dx	;com1_old_vector
;|***   _dos_setvect(4+8, com1_isr);
; Line 86
	*** 000012	68 00 00 		push	SEG ?com1_isr@@ZAXXZ	;com1_isr
	*** 000015	68 00 00 		push	OFFSET ?com1_isr@@ZAXXZ	;com1_isr
	*** 000018	6a 0c 			push	12	;000cH
	*** 00001a	9a 00 00 00 00 		call	FAR PTR __dos_setvect
	*** 00001f	83 c4 06 		add	sp,6
;|***      
;|***   // initialize COM1 16550
;|***   _outp( COM1_LCR, (DLAB1 | NO | STOP1 | EIGHT));
; Line 89
	*** 000022	b8 83 00 		mov	ax,131	;0083H
	*** 000025	ba fb 03 		mov	dx,1019	;03fbH
	*** 000028	ee 			out	dx, al

;|***   _outp( COM1_DLL, BR_9600);
; Line 90
	*** 000029	b8 0c 00 		mov	ax,12	;000cH
	*** 00002c	ba f8 03 		mov	dx,1016	;03f8H
	*** 00002f	ee 			out	dx, al

;|***   //_outp( COM1_DLL, BR_115200);
;|***   //_outp( COM1_DLL, BR_57600);
;|***   //_outp( COM1_DLL, BR_19200);
;|***   _outp( COM1_DLM, 0);
; Line 94
	*** 000030	33 c0 			xor	ax,ax
	*** 000032	ba f9 03 		mov	dx,1017	;03f9H
	*** 000035	ee 			out	dx, al

;|***   _outp( COM1_LCR, (DLAB0 | NO | STOP1 | EIGHT));
; Line 95
	*** 000036	b8 03 00 		mov	ax,3
	*** 000039	ba fb 03 		mov	dx,1019	;03fbH
	*** 00003c	ee 			out	dx, al

;|***   //_outp( COM1_FCR, 0xc1); // enable FIFOs to 14, reset FIFOs
;|***   _outp( COM1_FCR, 0xc7); // enable FIFOs to 14, reset FIFOs
; Line 97
	*** 00003d	b8 c7 00 		mov	ax,199	;00c7H
	*** 000040	ba fa 03 		mov	dx,1018	;03faH
	*** 000043	ee 			out	dx, al

;|***     
;|***   // unmask all com1 uart interrupts
;|***   //_outp( COM1_IER, 0x0f);  //jtm
;|***   _outp( COM1_IER, 0x07);
; Line 101
	*** 000044	b8 07 00 		mov	ax,7
	*** 000047	ba f9 03 		mov	dx,1017	;03f9H
	*** 00004a	ee 			out	dx, al

;|***   
;|***   // clear garbage from the com1 iir
;|***   while((_inp(COM1_IIR) & 0x01) != 1)
; Line 104
	*** 00004b	eb 0d 			jmp	SHORT $L2147
	*** 00004d	90 			nop	
					$FC2015:
;|***     {
;|***     _inp(COM1_RX);
; Line 106
	*** 00004e	ba f8 03 		mov	dx,1016	;03f8H
	*** 000051	ec 			in	al,dx
;|***     _inp(COM1_LSR);
; Line 107
	*** 000052	ba fd 03 		mov	dx,1021	;03fdH
	*** 000055	ec 			in	al,dx
;|***     _inp(COM1_MSR);
; Line 108
	*** 000056	ba fe 03 		mov	dx,1022	;03feH
	*** 000059	ec 			in	al,dx
;|***     }
; Line 109
					$L2147:
	*** 00005a	ba fa 03 		mov	dx,1018	;03faH
	*** 00005d	ec 			in	al,dx
	*** 00005e	24 01 			and	al,1
	*** 000060	fe c8 			dec	al
	*** 000062	75 ea 			jne	$FC2015
;|***   
;|***   // enable com1 irq4 interrupts at the pic
;|***   _outp(0x21, _inp(0x21) & 0xef);
; Line 112
	*** 000064	e4 21 			in	al,33	;0021H
	*** 000066	25 ef 00 		and	ax,239	;00efH
	*** 000069	e6 21 			out	33	;0021H, al

;|*** 
;|***   // turn on the com1 mcr gate (out2)
;|***   _outp( COM1_MCR, _inp(COM1_MCR) | 0x08); 
; Line 115
	*** 00006b	ba fc 03 		mov	dx,1020	;03fcH
	*** 00006e	ec 			in	al,dx
	*** 00006f	0c 08 			or	al,8
	*** 000071	2a e4 			sub	ah,ah
	*** 000073	ee 			out	dx, al

;|***   
;|***   // enable cpu interrupts          
;|***   _enable();
; Line 118
	*** 000074	fb 			sti	
;|***   // done 
;|***   } // end init_com1()
; Line 120
	*** 000075	cb 			ret	

?init_com1@@ZAXXZ	ENDP
	PUBLIC	?init_com2@@ZAXXZ	; init_com2
?init_com2@@ZAXXZ	PROC FAR	; init_com2
;|*** 
;|*** 
;|*** 
;|*** void init_com2(void)
;|***   {
;|***   // disable cpu interrupts
;|***   _disable();
; Line 127
	*** 000076	fa 			cli	
;|***   
;|***   // set vector for COM2, irq3
;|***   com2_old_vector = _dos_getvect(3+8);
; Line 130
	*** 000077	6a 0b 			push	11	;000bH
	*** 000079	9a 00 00 00 00 		call	FAR PTR __dos_getvect
	*** 00007e	83 c4 02 		add	sp,2
	*** 000081	a3 00 00 		mov	WORD PTR ?com2_old_vector@@3P7AXXZE,ax	;com2_old_vector
	*** 000084	89 16 02 00 		mov	WORD PTR ?com2_old_vector@@3P7AXXZE+2,dx	;com2_old_vector
;|***   _dos_setvect(3+8, com2_isr);
; Line 131
	*** 000088	68 00 00 		push	SEG ?com2_isr@@ZAXXZ	;com2_isr
	*** 00008b	68 00 00 		push	OFFSET ?com2_isr@@ZAXXZ	;com2_isr
	*** 00008e	6a 0b 			push	11	;000bH
	*** 000090	9a 00 00 00 00 		call	FAR PTR __dos_setvect
	*** 000095	83 c4 06 		add	sp,6
;|***      
;|***   // initialize COM2 16550
;|***   _outp( COM2_LCR, (DLAB1 | NO | STOP1 | EIGHT));
; Line 134
	*** 000098	b8 83 00 		mov	ax,131	;0083H
	*** 00009b	ba fb 02 		mov	dx,763	;02fbH
	*** 00009e	ee 			out	dx, al

;|***   _outp( COM2_DLL, BR_9600);  // for acoustic modem
; Line 135
	*** 00009f	b8 0c 00 		mov	ax,12	;000cH
	*** 0000a2	ba f8 02 		mov	dx,760	;02f8H
	*** 0000a5	ee 			out	dx, al

;|***   //_outp( COM2_DLL, BR_4800);  // for desert star
;|***   //_outp( COM2_DLL, BR_57600);
;|***   _outp( COM2_DLM, 0);
; Line 138
	*** 0000a6	33 c0 			xor	ax,ax
	*** 0000a8	ba f9 02 		mov	dx,761	;02f9H
	*** 0000ab	ee 			out	dx, al

;|***   _outp( COM2_LCR, (DLAB0 | NO | STOP1 | EIGHT));
; Line 139
	*** 0000ac	b8 03 00 		mov	ax,3
	*** 0000af	ba fb 02 		mov	dx,763	;02fbH
	*** 0000b2	ee 			out	dx, al

;|***   _outp( COM2_FCR, 0xc1); // enable FIFOs to 14, reset FIFOs
; Line 140
	*** 0000b3	b8 c1 00 		mov	ax,193	;00c1H
	*** 0000b6	ba fa 02 		mov	dx,762	;02faH
	*** 0000b9	ee 			out	dx, al

;|***     
;|***   // unmask all com1 uart interrupts
;|***   _outp( COM2_IER, 0x0f);
; Line 143
	*** 0000ba	b8 0f 00 		mov	ax,15	;000fH
	*** 0000bd	ba f9 02 		mov	dx,761	;02f9H
	*** 0000c0	ee 			out	dx, al

;|***   
;|***   // clear garbage from the com1 iir
;|***   while((_inp(COM2_IIR) & 0x01) != 1)
; Line 146
	*** 0000c1	eb 0d 			jmp	SHORT $L2148
	*** 0000c3	90 			nop	
					$FC2020:
;|***     {
;|***     _inp(COM2_RX);
; Line 148
	*** 0000c4	ba f8 02 		mov	dx,760	;02f8H
	*** 0000c7	ec 			in	al,dx
;|***     _inp(COM2_LSR);
; Line 149
	*** 0000c8	ba fd 02 		mov	dx,765	;02fdH
	*** 0000cb	ec 			in	al,dx
;|***     _inp(COM2_MSR);
; Line 150
	*** 0000cc	ba fe 02 		mov	dx,766	;02feH
	*** 0000cf	ec 			in	al,dx
;|***     }
; Line 151
					$L2148:
	*** 0000d0	ba fa 02 		mov	dx,762	;02faH
	*** 0000d3	ec 			in	al,dx
	*** 0000d4	24 01 			and	al,1
	*** 0000d6	fe c8 			dec	al
	*** 0000d8	75 ea 			jne	$FC2020
;|***   
;|***   // enable com2 irq3 interrupts at the pic
;|***   _outp(0x21, _inp(0x21) & 0xf7);
; Line 154
	*** 0000da	e4 21 			in	al,33	;0021H
	*** 0000dc	25 f7 00 		and	ax,247	;00f7H
	*** 0000df	e6 21 			out	33	;0021H, al

;|*** 
;|***   // turn on the com2 mcr gate (out2)
;|***   _outp( COM2_MCR, _inp(COM2_MCR) | 0x08); 
; Line 157
	*** 0000e1	ba fc 02 		mov	dx,764	;02fcH
	*** 0000e4	ec 			in	al,dx
	*** 0000e5	0c 08 			or	al,8
	*** 0000e7	2a e4 			sub	ah,ah
	*** 0000e9	ee 			out	dx, al

;|***   
;|***   // enable cpu interrupts          
;|***   _enable();
; Line 160
	*** 0000ea	fb 			sti	
;|***   // done 
;|***   } // end init_com2()
; Line 162
	*** 0000eb	cb 			ret	

?init_com2@@ZAXXZ	ENDP
	PUBLIC	?init_com4@@ZAXXZ	; init_com4
?init_com4@@ZAXXZ	PROC FAR	; init_com4
;|*** 
;|*** 
;|*** void init_com4(void)
;|***   {
;|***   // disable cpu interrupts
;|***   _disable();
; Line 168
	*** 0000ec	fa 			cli	
;|***   
;|***   // set vector for COM4, irq9
;|***   com4_old_vector = _dos_getvect(9+0x70-8);
; Line 171
	*** 0000ed	6a 71 			push	113	;0071H
	*** 0000ef	9a 00 00 00 00 		call	FAR PTR __dos_getvect
	*** 0000f4	83 c4 02 		add	sp,2
	*** 0000f7	a3 00 00 		mov	WORD PTR ?com4_old_vector@@3P7AXXZE,ax	;com4_old_vector
	*** 0000fa	89 16 02 00 		mov	WORD PTR ?com4_old_vector@@3P7AXXZE+2,dx	;com4_old_vector
;|***   _dos_setvect(9+0x70-8, com4_isr);
; Line 172
	*** 0000fe	68 00 00 		push	SEG ?com4_isr@@ZAXXZ	;com4_isr
	*** 000101	68 00 00 		push	OFFSET ?com4_isr@@ZAXXZ	;com4_isr
	*** 000104	6a 71 			push	113	;0071H
	*** 000106	9a 00 00 00 00 		call	FAR PTR __dos_setvect
	*** 00010b	83 c4 06 		add	sp,6
;|***      
;|***   // initialize COM4 16550
;|***   _outp( COM4_LCR, (DLAB1 | NO | STOP1 | EIGHT));
; Line 175
	*** 00010e	b8 83 00 		mov	ax,131	;0083H
	*** 000111	ba eb 02 		mov	dx,747	;02ebH
	*** 000114	ee 			out	dx, al

;|***   _outp( COM4_DLL, BR_9600);  // for gps
; Line 176
	*** 000115	b8 0c 00 		mov	ax,12	;000cH
	*** 000118	ba e8 02 		mov	dx,744	;02e8H
	*** 00011b	ee 			out	dx, al

;|***   _outp( COM4_DLM, 0);
; Line 177
	*** 00011c	33 c0 			xor	ax,ax
	*** 00011e	ba e9 02 		mov	dx,745	;02e9H
	*** 000121	ee 			out	dx, al

;|***   _outp( COM4_LCR, (DLAB0 | NO | STOP1 | EIGHT));
; Line 178
	*** 000122	b8 03 00 		mov	ax,3
	*** 000125	ba eb 02 		mov	dx,747	;02ebH
	*** 000128	ee 			out	dx, al

;|***   _outp( COM4_FCR, 0xc1); // enable FIFOs to 14, reset FIFOs
; Line 179
	*** 000129	b8 c1 00 		mov	ax,193	;00c1H
	*** 00012c	ba ea 02 		mov	dx,746	;02eaH
	*** 00012f	ee 			out	dx, al

;|***     
;|***   // unmask all com1 uart interrupts
;|***   _outp( COM4_IER, 0x0f);
; Line 182
	*** 000130	b8 0f 00 		mov	ax,15	;000fH
	*** 000133	ba e9 02 		mov	dx,745	;02e9H
	*** 000136	ee 			out	dx, al

;|***   
;|***   // clear garbage from the com1 iir
;|***   while((_inp(COM4_IIR) & 0x01) != 1)
; Line 185
	*** 000137	eb 0d 			jmp	SHORT $L2149
	*** 000139	90 			nop	
					$FC2025:
;|***     {
;|***     _inp(COM4_RX);
; Line 187
	*** 00013a	ba e8 02 		mov	dx,744	;02e8H
	*** 00013d	ec 			in	al,dx
;|***     _inp(COM4_LSR);
; Line 188
	*** 00013e	ba ed 02 		mov	dx,749	;02edH
	*** 000141	ec 			in	al,dx
;|***     _inp(COM4_MSR);
; Line 189
	*** 000142	ba ee 02 		mov	dx,750	;02eeH
	*** 000145	ec 			in	al,dx
;|***     }
; Line 190
					$L2149:
	*** 000146	ba ea 02 		mov	dx,746	;02eaH
	*** 000149	ec 			in	al,dx
	*** 00014a	24 01 			and	al,1
	*** 00014c	fe c8 			dec	al
	*** 00014e	75 ea 			jne	$FC2025
;|***   
;|***   // enable com4 irq9 interrupts at the pic
;|***   _outp(0xa1, _inp(0xa1) & 0xfd);
; Line 193
	*** 000150	e4 a1 			in	al,161	;00a1H
	*** 000152	25 fd 00 		and	ax,253	;00fdH
	*** 000155	e6 a1 			out	161	;00a1H, al

;|*** 
;|***   // turn on the com2 mcr gate (out2)
;|***   _outp( COM4_MCR, _inp(COM4_MCR) | 0x08); 
; Line 196
	*** 000157	ba ec 02 		mov	dx,748	;02ecH
	*** 00015a	ec 			in	al,dx
	*** 00015b	0c 08 			or	al,8
	*** 00015d	2a e4 			sub	ah,ah
	*** 00015f	ee 			out	dx, al

;|***   
;|***   // enable cpu interrupts          
;|***   _enable();
; Line 199
	*** 000160	fb 			sti	
;|*** 
;|***   } // end init_com2()
; Line 201
	*** 000161	cb 			ret	

?init_com4@@ZAXXZ	ENDP
	PUBLIC	?com1_isr@@ZAXXZ	; com1_isr
?com1_isr@@ZAXXZ	PROC FAR	; com1_isr
;|*** 
;|*** 
;|*** void interrupt far com1_isr(void)
;|***   {
; Line 205
	*** 000162	60 			pusha
	*** 000163	1e 			push	ds
	*** 000164	06 			push	es
	*** 000165	8b ec 			mov	bp,sp
	*** 000167	1e 			push	ds
	*** 000168	b8 00 00 		mov	ax,DGROUP
	*** 00016b	8e d8 			mov	ds,ax
	ASSUME DS: DGROUP
	*** 00016d	fc 			cld	
;	lsr_char = -8
;	register si = intr
;	register cx = i
;	msr_char = -6
;|***   // performs ADCP rs232 functions on com1
;|***   unsigned intr;
;|***   unsigned i;
;|***   //unsigned lsb;
;|***   //unsigned msb;
;|***     
;|***   _enable();
; Line 212
	*** 00016e	fb 			sti	
;|***     
;|***   // disable com1 uart interrupts      
;|***   _outp(COM1_MCR, _inp(COM1_MCR) & 0xf7);
; Line 215
	*** 00016f	ba fc 03 		mov	dx,1020	;03fcH
	*** 000172	ec 			in	al,dx
	*** 000173	25 f7 00 		and	ax,247	;00f7H
	*** 000176	ee 			out	dx, al

;|***   
;|***   start_com1_isr:
; Line 217
	*** 000177	e9 12 01 		jmp	$L2152
					$start_com1_isr2031:
;|***   
;|***   // check contents of COM1_IIR  
;|***   intr = _inp(COM1_IIR);
;|***   intr = intr & 0x0f; // mask off b7 to b4
;|***   
;|***   if((intr & 0x01) == 0) // if a valid com1 interrupt is pending
;|***     {   
;|***     // shift IIR value right one bit and test to see which routine is required
;|***     intr = intr >> 1;
;|***   
;|***     // do rs232 input interrupt routine
;|***     if(intr == 0)
; Line 229
	*** 00017a	d1 ee 			shr	si,1
	*** 00017c	0b f6 			or	si,si
	*** 00017e	75 08 			jne	$I2033
;|***       {
;|***       // read the rs232 status register
;|***       unsigned msr_char = _inp(COM1_MSR);
; Line 232
	*** 000180	ba fe 03 		mov	dx,1022	;03feH
					$L2150:
	*** 000183	ec 			in	al,dx
;|***       goto start_com1_isr;
; Line 233
	*** 000184	e9 05 01 		jmp	$L2152
	*** 000187	90 			nop	
;|***       }
;|***      
;|***     // do tx buffer empty interrupt routine
;|***     if(intr == 1)
; Line 237
					$I2033:
	*** 000188	83 fe 01 		cmp	si,1
	*** 00018b	75 53 			jne	$I2035
;|***       {
;|***       // either write to tx FIFO or read int id register again
;|***       
;|***       // the idea here is to continue a tx once it has started,
;|***       // not to start one in the first place
;|***       
;|***       // the tx is started by the main() program writing the first
;|***       // char to the tx buffer, which will send the char out
;|***       
;|***       // once the tx fifo has drained, the tbe bit will be
;|***       // set in the iir, indicating that the tx buffer is ready for more
;|***       
;|***       if(com1_tx==0)  // no message to tx
; Line 250
	*** 00018d	83 3e 00 00 00 		cmp	WORD PTR ?com1_tx@@3IE,0	;com1_tx
	*** 000192	74 ef 			je	$L2150
;|***         {
;|***         _inp(COM1_IIR);
;|***         goto start_com1_isr;
;|***         }
;|***       if(com1_tx==1)  // tx remaining message
; Line 255
	*** 000194	39 36 00 00 		cmp	WORD PTR ?com1_tx@@3IE,si	;com1_tx
	*** 000198	74 03 			je	$JCC408
	*** 00019a	e9 ef 00 		jmp	$L2152
					$JCC408:
;|***         {
;|***         for(i=0; i<16;i++) // load 16 characters into the tx fifo
; Line 257
	*** 00019d	33 c9 			xor	cx,cx
					$F2038:
;|***           {
;|***           if(com1_tx==0) break;
; Line 259
	*** 00019f	83 3e 00 00 00 		cmp	WORD PTR ?com1_tx@@3IE,0	;com1_tx
	*** 0001a4	75 03 			jne	$JCC420
	*** 0001a6	e9 e3 00 		jmp	$L2152
					$JCC420:
;|***           else  // only if more message needs to be sent
;|***             {
;|***             _outp(COM1_TX, tx1_message[tx1_index]); // write the next character
; Line 262
	*** 0001a9	8b 1e 00 00 		mov	bx,WORD PTR ?tx1_index@@3IE	;tx1_index
	*** 0001ad	2a e4 			sub	ah,ah
	*** 0001af	8a 87 00 00 		mov	al,BYTE PTR ?tx1_message@@3QIEI[bx]	;tx1_message
	*** 0001b3	ba f8 03 		mov	dx,1016	;03f8H
	*** 0001b6	ee 			out	dx, al

;|***             tx1_index++;
;|***             tx1_counter++;
; Line 264
	*** 0001b7	ff 06 00 00 		inc	WORD PTR ?tx1_counter@@3IE	;tx1_counter
;|***             if(tx1_index >= tx1_len)  // entire message has been sent
; Line 265
	*** 0001bb	a1 00 00 		mov	ax,WORD PTR ?tx1_len@@3IE	;tx1_len
	*** 0001be	ff 06 00 00 		inc	WORD PTR ?tx1_index@@3IE	;tx1_index
	*** 0001c2	39 06 00 00 		cmp	WORD PTR ?tx1_index@@3IE,ax	;tx1_index
	*** 0001c6	73 0a 			jae	$L2130
	*** 0001c8	41 			inc	cx
	*** 0001c9	83 f9 10 		cmp	cx,16	;0010H
	*** 0001cc	72 d1 			jb	$F2038
	*** 0001ce	e9 bb 00 		jmp	$L2152
	*** 0001d1	90 			nop	
					$L2130:
;|***               {
;|***               tx1_index = 0;
;|***               com1_tx = 0;
;|***               tx1_len = 0;
; Line 269
	*** 0001d2	33 c0 			xor	ax,ax
	*** 0001d4	a3 00 00 		mov	WORD PTR ?tx1_index@@3IE,ax	;tx1_index
	*** 0001d7	a3 00 00 		mov	WORD PTR ?com1_tx@@3IE,ax	;com1_tx
	*** 0001da	a3 00 00 		mov	WORD PTR ?tx1_len@@3IE,ax	;tx1_len
;|***               goto start_com1_isr;  
; Line 270
	*** 0001dd	e9 ac 00 		jmp	$L2152
;|***               }
;|***             }
;|***           }
;|***         }
;|***       goto start_com1_isr;    
;|***       }
;|***       
;|***     // rx data received interrupt routine (>= 14 bytes in receive buffer)
;|***     if(intr == 2)
; Line 279
					$I2035:
	*** 0001e0	83 fe 02 		cmp	si,2
	*** 0001e3	75 27 			jne	$I2044
	*** 0001e5	bb 0c 00 		mov	bx,12	;000cH
;|***       {
;|***       // read rx register
;|***             
;|***       // read 12 bytes from the rx register (still at least 2 bytes left)
;|***       for(i = 0; i < 12; i++)
; Line 284
					$F2045:
;|***         {
;|***         rx1_message[rx1_index] = _inp(COM1_RX);
; Line 286
	*** 0001e8	ba f8 03 		mov	dx,1016	;03f8H
	*** 0001eb	ec 			in	al,dx
	*** 0001ec	8b 36 00 00 		mov	si,WORD PTR ?rx1_index@@3IE	;rx1_index
	*** 0001f0	88 84 00 00 		mov	BYTE PTR ?rx1_message@@3QIEI[si],al	;rx1_message
;|***         rx1_index++;
;|***         if(rx1_index >= sizeof(rx1_message))
; Line 288
	*** 0001f4	ff 06 00 00 		inc	WORD PTR ?rx1_index@@3IE	;rx1_index
	*** 0001f8	81 3e 00 00 00 04 	cmp	WORD PTR ?rx1_index@@3IE,1024	;0400H	;rx1_index
	*** 0001fe	72 06 			jb	$FC2046
;|***           rx1_index = 0;
; Line 289
	*** 000200	c7 06 00 00 00 00 	mov	WORD PTR ?rx1_index@@3IE,0	;rx1_index
;|***       for(i = 0; i < 12; i++)
; Line 284
					$FC2046:
	*** 000206	4b 			dec	bx
	*** 000207	75 df 			jne	$F2045
	*** 000209	e9 80 00 		jmp	$L2152
;|***         {
;|***         rx1_message[rx1_index] = _inp(COM1_RX);
;|***         rx1_index++;
;|***         if(rx1_index >= sizeof(rx1_message))
;|***           rx1_index = 0;
;|***         }
;|***         
;|***       goto start_com1_isr;
;|***       }
;|***     
;|***     // else do serialization error/break routine  
;|***     if(intr == 3)
; Line 296
					$I2044:
	*** 00020c	83 fe 03 		cmp	si,3
	*** 00020f	75 07 			jne	$I2049
;|***       {
;|***       // read serialization/line status register
;|***       unsigned lsr_char = _inp(COM1_LSR);
; Line 299
	*** 000211	ba fd 03 		mov	dx,1021	;03fdH
	*** 000214	e9 6c ff 		jmp	$L2150
	*** 000217	90 			nop	
;|***       goto start_com1_isr;
;|***       }
;|***     
;|***     // do rx character timeout routine: message end
;|***     if(intr == 6)
; Line 304
					$I2049:
	*** 000218	83 fe 06 		cmp	si,6
	*** 00021b	75 6f 			jne	$L2152
;|***       {
;|***       // drain rx fifo
;|***       while((_inp(COM1_LSR) & 0x01) == 1)
; Line 307
	*** 00021d	eb 1f 			jmp	SHORT $L2151
	*** 00021f	90 			nop	
					$FC2053:
;|***         {
;|***         rx1_message[rx1_index] = _inp(COM1_RX);
; Line 309
	*** 000220	ba f8 03 		mov	dx,1016	;03f8H
	*** 000223	ec 			in	al,dx
	*** 000224	8b 1e 00 00 		mov	bx,WORD PTR ?rx1_index@@3IE	;rx1_index
	*** 000228	88 87 00 00 		mov	BYTE PTR ?rx1_message@@3QIEI[bx],al	;rx1_message
;|***         rx1_index++;
;|***         if(rx1_index >= sizeof(rx1_message)) rx1_index = 0;
; Line 311
	*** 00022c	ff 06 00 00 		inc	WORD PTR ?rx1_index@@3IE	;rx1_index
	*** 000230	81 3e 00 00 00 04 	cmp	WORD PTR ?rx1_index@@3IE,1024	;0400H	;rx1_index
	*** 000236	72 06 			jb	$L2151
	*** 000238	c7 06 00 00 00 00 	mov	WORD PTR ?rx1_index@@3IE,0	;rx1_index
;|***         }
; Line 312
					$L2151:
	*** 00023e	ba fd 03 		mov	dx,1021	;03fdH
	*** 000241	ec 			in	al,dx
	*** 000242	24 01 			and	al,1
	*** 000244	fe c8 			dec	al
	*** 000246	74 d8 			je	$FC2053
;|***       
;|***       if(rx1_index >= ADCPLEN) // complete frame received
; Line 314
	*** 000248	81 3e 00 00 d5 00 	cmp	WORD PTR ?rx1_index@@3IE,213	;00d5H	;rx1_index
	*** 00024e	72 36 			jb	$I2056
;|***         {
;|***         // timestamp the adcp message
;|***         _disable();
; Line 317
	*** 000250	fa 			cli	
;|***         time_stamp(&adcp_time);
; Line 318
	*** 000251	68 00 00 		push	SEG ?adcp_time@@3UTIMER@@E	;adcp_time
	*** 000254	68 00 00 		push	OFFSET ?adcp_time@@3UTIMER@@E	;adcp_time
	*** 000257	9a 00 00 00 00 		call	FAR PTR ?time_stamp@@ZAXPEUTIMER@@@Z	; time_stamp
	*** 00025c	83 c4 04 		add	sp,4
;|***         _enable();
; Line 319
	*** 00025f	fb 			sti	
;|*** 
;|***         memcpy(adcp_buffer, rx1_message, ADCPLEN);
; Line 321
	*** 000260	68 d5 00 		push	213	;00d5H
	*** 000263	1e 			push	ds
	*** 000264	68 00 00 		push	OFFSET DGROUP:?rx1_message@@3QIEI	;rx1_message
	*** 000267	68 00 00 		push	SEG ?adcp_buffer@@3QIEI	;adcp_buffer
	*** 00026a	68 00 00 		push	OFFSET ?adcp_buffer@@3QIEI	;adcp_buffer
	*** 00026d	b8 ac 00 		mov	ax,172	;00acH
	*** 000270	ff d0 			call	ax
;|***         //rx1_index = 0;
;|***         adcp_new_data = 1;
; Line 323
	*** 000272	c7 06 00 00 01 00 	mov	WORD PTR ?adcp_new_data@@3IE,1	;adcp_new_data
;|***         adcp_data_frame = frame;
; Line 324
	*** 000278	a1 00 00 		mov	ax,WORD PTR ?frame@@3KE	;frame
	*** 00027b	8b 16 02 00 		mov	dx,WORD PTR ?frame@@3KE+2	;frame
	*** 00027f	a3 00 00 		mov	WORD PTR ?adcp_data_frame@@3KE,ax	;adcp_data_frame
	*** 000282	89 16 02 00 		mov	WORD PTR ?adcp_data_frame@@3KE+2,dx	;adcp_data_frame
;|***         }
;|***       rx1_index = 0;
; Line 326
					$I2056:
	*** 000286	c7 06 00 00 00 00 	mov	WORD PTR ?rx1_index@@3IE,0	;rx1_index
;|***       goto start_com1_isr;      
; Line 327
					$L2152:
	*** 00028c	ba fa 03 		mov	dx,1018	;03faH
	*** 00028f	ec 			in	al,dx
	*** 000290	2a e4 			sub	ah,ah
	*** 000292	8b f0 			mov	si,ax
;|***   if((intr & 0x01) == 0) // if a valid com1 interrupt is pending
; Line 223
	*** 000294	83 e6 0f 		and	si,15	;000fH
	*** 000297	f7 c6 01 00 		test	si,1
	*** 00029b	75 03 			jne	$JCC667
	*** 00029d	e9 da fe 		jmp	$start_com1_isr2031
					$JCC667:
;|***     {   
;|***     // shift IIR value right one bit and test to see which routine is required
;|***     intr = intr >> 1;
;|***   
;|***     // do rs232 input interrupt routine
;|***     if(intr == 0)
;|***       {
;|***       // read the rs232 status register
;|***       unsigned msr_char = _inp(COM1_MSR);
;|***       goto start_com1_isr;
;|***       }
;|***      
;|***     // do tx buffer empty interrupt routine
;|***     if(intr == 1)
;|***       {
;|***       // either write to tx FIFO or read int id register again
;|***       
;|***       // the idea here is to continue a tx once it has started,
;|***       // not to start one in the first place
;|***       
;|***       // the tx is started by the main() program writing the first
;|***       // char to the tx buffer, which will send the char out
;|***       
;|***       // once the tx fifo has drained, the tbe bit will be
;|***       // set in the iir, indicating that the tx buffer is ready for more
;|***       
;|***       if(com1_tx==0)  // no message to tx
;|***         {
;|***         _inp(COM1_IIR);
;|***         goto start_com1_isr;
;|***         }
;|***       if(com1_tx==1)  // tx remaining message
;|***         {
;|***         for(i=0; i<16;i++) // load 16 characters into the tx fifo
;|***           {
;|***           if(com1_tx==0) break;
;|***           else  // only if more message needs to be sent
;|***             {
;|***             _outp(COM1_TX, tx1_message[tx1_index]); // write the next character
;|***             tx1_index++;
;|***             tx1_counter++;
;|***             if(tx1_index >= tx1_len)  // entire message has been sent
;|***               {
;|***               tx1_index = 0;
;|***               com1_tx = 0;
;|***               tx1_len = 0;
;|***               goto start_com1_isr;  
;|***               }
;|***             }
;|***           }
;|***         }
;|***       goto start_com1_isr;    
;|***       }
;|***       
;|***     // rx data received interrupt routine (>= 14 bytes in receive buffer)
;|***     if(intr == 2)
;|***       {
;|***       // read rx register
;|***             
;|***       // read 12 bytes from the rx register (still at least 2 bytes left)
;|***       for(i = 0; i < 12; i++)
;|***         {
;|***         rx1_message[rx1_index] = _inp(COM1_RX);
;|***         rx1_index++;
;|***         if(rx1_index >= sizeof(rx1_message))
;|***           rx1_index = 0;
;|***         }
;|***         
;|***       goto start_com1_isr;
;|***       }
;|***     
;|***     // else do serialization error/break routine  
;|***     if(intr == 3)
;|***       {
;|***       // read serialization/line status register
;|***       unsigned lsr_char = _inp(COM1_LSR);
;|***       goto start_com1_isr;
;|***       }
;|***     
;|***     // do rx character timeout routine: message end
;|***     if(intr == 6)
;|***       {
;|***       // drain rx fifo
;|***       while((_inp(COM1_LSR) & 0x01) == 1)
;|***         {
;|***         rx1_message[rx1_index] = _inp(COM1_RX);
;|***         rx1_index++;
;|***         if(rx1_index >= sizeof(rx1_message)) rx1_index = 0;
;|***         }
;|***       
;|***       if(rx1_index >= ADCPLEN) // complete frame received
;|***         {
;|***         // timestamp the adcp message
;|***         _disable();
;|***         time_stamp(&adcp_time);
;|***         _enable();
;|*** 
;|***         memcpy(adcp_buffer, rx1_message, ADCPLEN);
;|***         //rx1_index = 0;
;|***         adcp_new_data = 1;
;|***         adcp_data_frame = frame;
;|***         }
;|***       rx1_index = 0;
;|***       goto start_com1_isr;      
;|***       } // end rx character timeout routine
;|***         
;|***     goto start_com1_isr;
;|***     }  // end if((intr & 0x01) == 0)
;|***   
;|***   //_disable();  
;|***   // enable com1 uart tx interrupts    
;|***   _outp(COM1_MCR, _inp(COM1_MCR) | 0x08);
; Line 335
	*** 0002a0	ba fc 03 		mov	dx,1020	;03fcH
	*** 0002a3	ec 			in	al,dx
	*** 0002a4	0c 08 			or	al,8
	*** 0002a6	ee 			out	dx, al

;|***   _outp(0x20, 0x20);  // non-specific return from interrupt
; Line 336
	*** 0002a7	ba 20 00 		mov	dx,32	;0020H
	*** 0002aa	8b c2 			mov	ax,dx
	*** 0002ac	ee 			out	dx, al

;|***   _disable();
; Line 337
	*** 0002ad	fa 			cli	
;|***   
;|***   }  // end com1_isr()
; Line 339
	*** 0002ae	8b e5 			mov	sp,bp
	*** 0002b0	07 			pop	es
	*** 0002b1	1f 			pop	ds
	ASSUME DS: DGROUP
	*** 0002b2	61 			popa
	*** 0002b3	cf 			iret	

?com1_isr@@ZAXXZ	ENDP
	PUBLIC	?com2_isr@@ZAXXZ	; com2_isr
?com2_isr@@ZAXXZ	PROC FAR	; com2_isr
;|*** 
;|*** 
;|*** 
;|*** void interrupt far com2_isr(void)
;|***   {
; Line 344
	*** 0002b4	60 			pusha
	*** 0002b5	1e 			push	ds
	*** 0002b6	06 			push	es
	*** 0002b7	8b ec 			mov	bp,sp
	*** 0002b9	83 ec 02 		sub	sp,2
	*** 0002bc	1e 			push	ds
	*** 0002bd	b8 00 00 		mov	ax,DGROUP
	*** 0002c0	8e d8 			mov	ds,ax
	ASSUME DS: DGROUP
	*** 0002c2	fc 			cld	
;	register si = intr
;	register cx = i
;	msr_char = -6
;	lsr_char = -8
;|***   // performs rs232 functions on com2
;|***   unsigned intr;
;|***   unsigned i;
;|***     
;|***   _enable();
; Line 349
	*** 0002c3	fb 			sti	
;|***     
;|***   // disable com2 uart interrupts      
;|***   _outp(COM2_MCR, _inp(COM2_MCR) & 0xf7);
; Line 352
	*** 0002c4	ba fc 02 		mov	dx,764	;02fcH
	*** 0002c7	ec 			in	al,dx
	*** 0002c8	25 f7 00 		and	ax,247	;00f7H
	*** 0002cb	ee 			out	dx, al

;|***   
;|***   start_com2_isr:
; Line 354
	*** 0002cc	e9 1e 01 		jmp	$L2155
	*** 0002cf	90 			nop	
					$start_com2_isr2061:
;|***   
;|***   // check contents of COM2_IIR  
;|***   intr = _inp(COM2_IIR);
;|***   intr = intr & 0x0f; // mask off b7 to b4
;|***   
;|***   if((intr & 0x01) == 0) // if a valid com2 interrupt is pending
;|***     {   
;|***     // shift IIR value right one bit and test to see which routine is required
;|***     intr = intr >> 1;
;|***   
;|***     // do rs232 input interrupt routine
;|***     if(intr == 0)
; Line 366
	*** 0002d0	d1 ee 			shr	si,1
	*** 0002d2	0b f6 			or	si,si
	*** 0002d4	75 08 			jne	$I2063
;|***       {
;|***       // read the rs232 status register
;|***       unsigned msr_char = _inp(COM2_MSR);
; Line 369
	*** 0002d6	ba fe 02 		mov	dx,766	;02feH
					$L2153:
	*** 0002d9	ec 			in	al,dx
;|***       goto start_com2_isr;
; Line 370
	*** 0002da	e9 10 01 		jmp	$L2155
	*** 0002dd	90 			nop	
;|***       }
;|***      
;|***     // do tx buffer empty interrupt routine
;|***     if(intr == 1)
; Line 374
					$I2063:
	*** 0002de	83 fe 01 		cmp	si,1
	*** 0002e1	75 53 			jne	$I2065
;|***       {
;|***       // either write to tx FIFO or read int id register again
;|***       
;|***       // the idea here is to continue a tx once it has started,
;|***       // not to start one in the first place
;|***       
;|***       // the tx is started by the main() program writing the first
;|***       // char to the tx buffer, which will send the char out
;|***       
;|***       // once the tx fifo has drained, the tbe bit will be
;|***       // set in the iir, indicating that the tx buffer is ready for more
;|***       
;|***       // we will refill the tx fifo, up to 127 chars, for a total of 128
;|***       if(com2_tx==0)  // no message to tx
; Line 388
	*** 0002e3	83 3e 00 00 00 		cmp	WORD PTR ?com2_tx@@3IE,0	;com2_tx
	*** 0002e8	74 ef 			je	$L2153
;|***         {
;|***         _inp(COM2_IIR);
;|***         goto start_com2_isr;
;|***         }
;|***       if(com2_tx==1)  // tx remaining message
; Line 393
	*** 0002ea	39 36 00 00 		cmp	WORD PTR ?com2_tx@@3IE,si	;com2_tx
	*** 0002ee	74 03 			je	$JCC750
	*** 0002f0	e9 fa 00 		jmp	$L2155
					$JCC750:
;|***         {
;|***         for(i=0; i<16;i++) // load 16 characters into the tx fifo
; Line 395
	*** 0002f3	33 c9 			xor	cx,cx
					$F2068:
;|***           {
;|***           if(com2_tx==0) break;
; Line 397
	*** 0002f5	83 3e 00 00 00 		cmp	WORD PTR ?com2_tx@@3IE,0	;com2_tx
	*** 0002fa	75 03 			jne	$JCC762
	*** 0002fc	e9 ee 00 		jmp	$L2155
					$JCC762:
;|***           else  // only if more message needs to be sent
;|***             {
;|***             _outp(COM2_TX, tx2_message[tx2_index]); // write the next character
; Line 400
	*** 0002ff	8b 1e 00 00 		mov	bx,WORD PTR ?tx2_index@@3IE	;tx2_index
	*** 000303	2a e4 			sub	ah,ah
	*** 000305	8a 87 00 00 		mov	al,BYTE PTR ?tx2_message@@3QIEI[bx]	;tx2_message
	*** 000309	ba f8 02 		mov	dx,760	;02f8H
	*** 00030c	ee 			out	dx, al

;|***             tx2_index++;
;|***             tx2_counter++;
; Line 402
	*** 00030d	ff 06 00 00 		inc	WORD PTR ?tx2_counter@@3IE	;tx2_counter
;|***             if(tx2_index >= tx2_len)  // entire message has been sent
; Line 403
	*** 000311	a1 00 00 		mov	ax,WORD PTR ?tx2_len@@3IE	;tx2_len
	*** 000314	ff 06 00 00 		inc	WORD PTR ?tx2_index@@3IE	;tx2_index
	*** 000318	39 06 00 00 		cmp	WORD PTR ?tx2_index@@3IE,ax	;tx2_index
	*** 00031c	73 0a 			jae	$L2137
	*** 00031e	41 			inc	cx
	*** 00031f	83 f9 10 		cmp	cx,16	;0010H
	*** 000322	72 d1 			jb	$F2068
	*** 000324	e9 c6 00 		jmp	$L2155
	*** 000327	90 			nop	
					$L2137:
;|***               {
;|***               tx2_index = 0;
;|***               com2_tx = 0;
;|***               tx2_len = 0;
; Line 407
	*** 000328	33 c0 			xor	ax,ax
	*** 00032a	a3 00 00 		mov	WORD PTR ?tx2_index@@3IE,ax	;tx2_index
	*** 00032d	a3 00 00 		mov	WORD PTR ?com2_tx@@3IE,ax	;com2_tx
	*** 000330	a3 00 00 		mov	WORD PTR ?tx2_len@@3IE,ax	;tx2_len
;|***               goto start_com2_isr;  
; Line 408
	*** 000333	e9 b7 00 		jmp	$L2155
;|***               }
;|***             }
;|***           }
;|***         }
;|***       goto start_com2_isr;    
;|***       }
;|***       
;|***     // rx data received interrupt routine (>= 14 bytes in receive buffer)
;|***     if(intr == 2)
; Line 417
					$I2065:
	*** 000336	83 fe 02 		cmp	si,2
	*** 000339	75 27 			jne	$I2074
	*** 00033b	bb 0c 00 		mov	bx,12	;000cH
;|***       {
;|***       // read rx register
;|***             
;|***       // read 12 bytes from the rx register (still at least 2 bytes left)
;|***       for(i = 0; i < 12; i++)
; Line 422
					$F2075:
;|***         {
;|***         rx2_message[rx2_index] = _inp(COM2_RX);
; Line 424
	*** 00033e	ba f8 02 		mov	dx,760	;02f8H
	*** 000341	ec 			in	al,dx
	*** 000342	8b 36 00 00 		mov	si,WORD PTR ?rx2_index@@3IE	;rx2_index
	*** 000346	88 84 00 00 		mov	BYTE PTR ?rx2_message@@3QIEI[si],al	;rx2_message
;|***         rx2_index++;
;|***         if(rx2_index >= 80)
; Line 426
	*** 00034a	ff 06 00 00 		inc	WORD PTR ?rx2_index@@3IE	;rx2_index
	*** 00034e	83 3e 00 00 50 		cmp	WORD PTR ?rx2_index@@3IE,80	;0050H	;rx2_index
	*** 000353	72 06 			jb	$FC2076
;|***           rx2_index = 0;
; Line 427
	*** 000355	c7 06 00 00 00 00 	mov	WORD PTR ?rx2_index@@3IE,0	;rx2_index
;|***       for(i = 0; i < 12; i++)
; Line 422
					$FC2076:
	*** 00035b	4b 			dec	bx
	*** 00035c	75 e0 			jne	$F2075
	*** 00035e	e9 8c 00 		jmp	$L2155
	*** 000361	90 			nop	
;|***         {
;|***         rx2_message[rx2_index] = _inp(COM2_RX);
;|***         rx2_index++;
;|***         if(rx2_index >= 80)
;|***           rx2_index = 0;
;|***         }
;|***         
;|***       goto start_com2_isr;
;|***       }
;|***     
;|***     // else do serialization error/break routine  
;|***     if(intr == 3)
; Line 434
					$I2074:
	*** 000362	83 fe 03 		cmp	si,3
	*** 000365	75 07 			jne	$I2079
;|***       {
;|***       // read serialization status register
;|***       unsigned lsr_char = _inp(COM2_LSR);
; Line 437
	*** 000367	ba fd 02 		mov	dx,765	;02fdH
	*** 00036a	e9 6c ff 		jmp	$L2153
	*** 00036d	90 			nop	
;|***       goto start_com2_isr;
;|***       }
;|***     
;|***     // do rx character timeout routine: message end
;|***     if(intr == 6)
; Line 442
					$I2079:
	*** 00036e	83 fe 06 		cmp	si,6
	*** 000371	75 7a 			jne	$L2155
;|***       {
;|***       // drain rx register first
;|***       while((_inp(COM2_LSR) & 0x01) == 1)
; Line 445
	*** 000373	eb 1e 			jmp	SHORT $L2154
	*** 000375	90 			nop	
					$FC2083:
;|***         {
;|***         rx2_message[rx2_index] = _inp(COM2_RX);
; Line 447
	*** 000376	ba f8 02 		mov	dx,760	;02f8H
	*** 000379	ec 			in	al,dx
	*** 00037a	8b 1e 00 00 		mov	bx,WORD PTR ?rx2_index@@3IE	;rx2_index
	*** 00037e	88 87 00 00 		mov	BYTE PTR ?rx2_message@@3QIEI[bx],al	;rx2_message
;|***         rx2_index++;
;|***         if(rx2_index >= 80)
; Line 449
	*** 000382	ff 06 00 00 		inc	WORD PTR ?rx2_index@@3IE	;rx2_index
	*** 000386	83 3e 00 00 50 		cmp	WORD PTR ?rx2_index@@3IE,80	;0050H	;rx2_index
	*** 00038b	72 06 			jb	$L2154
;|***           rx2_index = 0;
; Line 450
	*** 00038d	c7 06 00 00 00 00 	mov	WORD PTR ?rx2_index@@3IE,0	;rx2_index
;|***         }
; Line 451
					$L2154:
	*** 000393	ba fd 02 		mov	dx,765	;02fdH
	*** 000396	ec 			in	al,dx
	*** 000397	24 01 			and	al,1
	*** 000399	fe c8 			dec	al
	*** 00039b	74 d9 			je	$FC2083
;|***       
;|***       if(rx2_index >= 8) // complete frame received
; Line 453
	*** 00039d	83 3e 00 00 08 		cmp	WORD PTR ?rx2_index@@3IE,8	;rx2_index
	*** 0003a2	72 49 			jb	$L2155
;|***         {
;|***         time_stamp(&ds_time);
; Line 455
	*** 0003a4	68 00 00 		push	SEG ?ds_time@@3UTIMER@@E	;ds_time
	*** 0003a7	68 00 00 		push	OFFSET ?ds_time@@3UTIMER@@E	;ds_time
	*** 0003aa	9a 00 00 00 00 		call	FAR PTR ?time_stamp@@ZAXPEUTIMER@@@Z	; time_stamp
	*** 0003af	83 c4 04 		add	sp,4
;|***         memcpy(ds_buffer, rx2_message, sizeof(ds_buffer));
; Line 456
	*** 0003b2	b8 ac 00 		mov	ax,172	;00acH
	*** 0003b5	89 46 fe 		mov	WORD PTR [bp-2],ax
	*** 0003b8	68 00 00 		push	SEG ?ds_buffer@@3QIEI	;ds_buffer
	*** 0003bb	68 00 00 		push	OFFSET ?ds_buffer@@3QIEI	;ds_buffer
	*** 0003be	1e 			push	ds
	*** 0003bf	68 00 00 		push	OFFSET DGROUP:?rx2_message@@3QIEI	;rx2_message
	*** 0003c2	b8 50 00 		mov	ax,80	;0050H
	*** 0003c5	ff 56 fe 		call	WORD PTR [bp-2]
;|***         ds_new_data = 1;
; Line 457
	*** 0003c8	c7 06 00 00 01 00 	mov	WORD PTR ?ds_new_data@@3IE,1	;ds_new_data
;|***         ds_data_frame = frame;
; Line 458
	*** 0003ce	a1 00 00 		mov	ax,WORD PTR ?frame@@3KE	;frame
	*** 0003d1	8b 16 02 00 		mov	dx,WORD PTR ?frame@@3KE+2	;frame
	*** 0003d5	a3 00 00 		mov	WORD PTR ?ds_data_frame@@3KE,ax	;ds_data_frame
	*** 0003d8	89 16 02 00 		mov	WORD PTR ?ds_data_frame@@3KE+2,dx	;ds_data_frame
;|***         rx2_index = 0;
; Line 459
	*** 0003dc	33 c0 			xor	ax,ax
	*** 0003de	a3 00 00 		mov	WORD PTR ?rx2_index@@3IE,ax	;rx2_index
;|***         //for(i=0; i<sizeof(rx2_message); i++)
;|***         //  rx2_message[i] = 0;
;|***         _fmemset(rx2_message, 0, sizeof(rx2_message));
; Line 462
	*** 0003e1	bb 00 00 		mov	bx,OFFSET DGROUP:?rx2_message@@3QIEI	;rx2_message
	*** 0003e4	b9 2c 00 		mov	cx,44	;002cH
	*** 0003e7	8b fb 			mov	di,bx
	*** 0003e9	1e 			push	ds
	*** 0003ea	07 			pop	es
	*** 0003eb	f3 			rep
	*** 0003ec	ab 			stosw
;|***         }
;|*** 
;|***       goto start_com2_isr;      
; Line 465
					$L2155:
	*** 0003ed	ba fa 02 		mov	dx,762	;02faH
	*** 0003f0	ec 			in	al,dx
	*** 0003f1	2a e4 			sub	ah,ah
	*** 0003f3	8b f0 			mov	si,ax
;|***   if((intr & 0x01) == 0) // if a valid com2 interrupt is pending
; Line 360
	*** 0003f5	83 e6 0f 		and	si,15	;000fH
	*** 0003f8	f7 c6 01 00 		test	si,1
	*** 0003fc	75 03 			jne	$JCC1020
	*** 0003fe	e9 cf fe 		jmp	$start_com2_isr2061
					$JCC1020:
;|***     {   
;|***     // shift IIR value right one bit and test to see which routine is required
;|***     intr = intr >> 1;
;|***   
;|***     // do rs232 input interrupt routine
;|***     if(intr == 0)
;|***       {
;|***       // read the rs232 status register
;|***       unsigned msr_char = _inp(COM2_MSR);
;|***       goto start_com2_isr;
;|***       }
;|***      
;|***     // do tx buffer empty interrupt routine
;|***     if(intr == 1)
;|***       {
;|***       // either write to tx FIFO or read int id register again
;|***       
;|***       // the idea here is to continue a tx once it has started,
;|***       // not to start one in the first place
;|***       
;|***       // the tx is started by the main() program writing the first
;|***       // char to the tx buffer, which will send the char out
;|***       
;|***       // once the tx fifo has drained, the tbe bit will be
;|***       // set in the iir, indicating that the tx buffer is ready for more
;|***       
;|***       // we will refill the tx fifo, up to 127 chars, for a total of 128
;|***       if(com2_tx==0)  // no message to tx
;|***         {
;|***         _inp(COM2_IIR);
;|***         goto start_com2_isr;
;|***         }
;|***       if(com2_tx==1)  // tx remaining message
;|***         {
;|***         for(i=0; i<16;i++) // load 16 characters into the tx fifo
;|***           {
;|***           if(com2_tx==0) break;
;|***           else  // only if more message needs to be sent
;|***             {
;|***             _outp(COM2_TX, tx2_message[tx2_index]); // write the next character
;|***             tx2_index++;
;|***             tx2_counter++;
;|***             if(tx2_index >= tx2_len)  // entire message has been sent
;|***               {
;|***               tx2_index = 0;
;|***               com2_tx = 0;
;|***               tx2_len = 0;
;|***               goto start_com2_isr;  
;|***               }
;|***             }
;|***           }
;|***         }
;|***       goto start_com2_isr;    
;|***       }
;|***       
;|***     // rx data received interrupt routine (>= 14 bytes in receive buffer)
;|***     if(intr == 2)
;|***       {
;|***       // read rx register
;|***             
;|***       // read 12 bytes from the rx register (still at least 2 bytes left)
;|***       for(i = 0; i < 12; i++)
;|***         {
;|***         rx2_message[rx2_index] = _inp(COM2_RX);
;|***         rx2_index++;
;|***         if(rx2_index >= 80)
;|***           rx2_index = 0;
;|***         }
;|***         
;|***       goto start_com2_isr;
;|***       }
;|***     
;|***     // else do serialization error/break routine  
;|***     if(intr == 3)
;|***       {
;|***       // read serialization status register
;|***       unsigned lsr_char = _inp(COM2_LSR);
;|***       goto start_com2_isr;
;|***       }
;|***     
;|***     // do rx character timeout routine: message end
;|***     if(intr == 6)
;|***       {
;|***       // drain rx register first
;|***       while((_inp(COM2_LSR) & 0x01) == 1)
;|***         {
;|***         rx2_message[rx2_index] = _inp(COM2_RX);
;|***         rx2_index++;
;|***         if(rx2_index >= 80)
;|***           rx2_index = 0;
;|***         }
;|***       
;|***       if(rx2_index >= 8) // complete frame received
;|***         {
;|***         time_stamp(&ds_time);
;|***         memcpy(ds_buffer, rx2_message, sizeof(ds_buffer));
;|***         ds_new_data = 1;
;|***         ds_data_frame = frame;
;|***         rx2_index = 0;
;|***         //for(i=0; i<sizeof(rx2_message); i++)
;|***         //  rx2_message[i] = 0;
;|***         _fmemset(rx2_message, 0, sizeof(rx2_message));
;|***         }
;|*** 
;|***       goto start_com2_isr;      
;|***       } // end rx character timeout routine
;|***         
;|***     goto start_com2_isr;
;|***     }  // end if((intr & 0x01) == 0)
;|***   
;|***   _disable();  
; Line 471
	*** 000401	fa 			cli	
;|***   // enable com2 uart interrupts    
;|***   _outp(COM2_MCR, _inp(COM2_MCR) | 0x08);
; Line 473
	*** 000402	ba fc 02 		mov	dx,764	;02fcH
	*** 000405	ec 			in	al,dx
	*** 000406	0c 08 			or	al,8
	*** 000408	ee 			out	dx, al

;|***   _outp(0x20, 0x20);  // non-specific return from interrupt
; Line 474
	*** 000409	ba 20 00 		mov	dx,32	;0020H
	*** 00040c	8b c2 			mov	ax,dx
	*** 00040e	ee 			out	dx, al

;|***   }  // end com2_isr()
; Line 475
	*** 00040f	8b e5 			mov	sp,bp
	*** 000411	07 			pop	es
	*** 000412	1f 			pop	ds
	ASSUME DS: DGROUP
	*** 000413	61 			popa
	*** 000414	cf 			iret	

?com2_isr@@ZAXXZ	ENDP
	PUBLIC	?com4_isr@@ZAXXZ	; com4_isr
?com4_isr@@ZAXXZ	PROC FAR	; com4_isr
;|*** 
;|*** 
;|*** 
;|*** void interrupt far com4_isr(void)
;|***   {
; Line 480
	*** 000415	60 			pusha
	*** 000416	1e 			push	ds
	*** 000417	06 			push	es
	*** 000418	8b ec 			mov	bp,sp
	*** 00041a	83 ec 02 		sub	sp,2
	*** 00041d	1e 			push	ds
	*** 00041e	b8 00 00 		mov	ax,DGROUP
	*** 000421	8e d8 			mov	ds,ax
	ASSUME DS: DGROUP
	*** 000423	fc 			cld	
;	register si = intr
;	register cx = i
;	msr_char = -6
;	lsr_char = -8
;|***   // performs rs232 functions on com4
;|***   unsigned intr;
;|***   unsigned i;
;|***     
;|***   _enable();
; Line 485
	*** 000424	fb 			sti	
;|***     
;|***   // disable com4 uart interrupts      
;|***   _outp(COM4_MCR, _inp(COM4_MCR) & 0xf7);
; Line 488
	*** 000425	ba ec 02 		mov	dx,748	;02ecH
	*** 000428	ec 			in	al,dx
	*** 000429	25 f7 00 		and	ax,247	;00f7H
	*** 00042c	ee 			out	dx, al

;|***   
;|***   start_com4_isr:
; Line 490
	*** 00042d	e9 1d 01 		jmp	$L2158
					$start_com4_isr2091:
;|***   
;|***   // check contents of COM4_IIR  
;|***   intr = _inp(COM4_IIR);
;|***   intr = intr & 0x0f; // mask off b7 to b4
;|***   
;|***   if((intr & 0x01) == 0) // if a valid com4 interrupt is pending
;|***     {   
;|***     // shift IIR value right one bit and test to see which routine is required
;|***     intr = intr >> 1;
;|***   
;|***     // do rs232 input interrupt routine
;|***     if(intr == 0)
; Line 502
	*** 000430	d1 ee 			shr	si,1
	*** 000432	0b f6 			or	si,si
	*** 000434	75 08 			jne	$I2093
;|***       {
;|***       // read the rs232 status register
;|***       unsigned msr_char = _inp(COM4_MSR);
; Line 505
	*** 000436	ba ee 02 		mov	dx,750	;02eeH
					$L2156:
	*** 000439	ec 			in	al,dx
;|***       goto start_com4_isr;
; Line 506
	*** 00043a	e9 10 01 		jmp	$L2158
	*** 00043d	90 			nop	
;|***       }
;|***      
;|***     // do tx buffer empty interrupt routine
;|***     if(intr == 1)
; Line 510
					$I2093:
	*** 00043e	83 fe 01 		cmp	si,1
	*** 000441	75 53 			jne	$I2095
;|***       {
;|***       // either write to tx FIFO or read int id register again
;|***       
;|***       // the idea here is to continue a tx once it has started,
;|***       // not to start one in the first place
;|***       
;|***       // the tx is started by the main() program writing the first
;|***       // char to the tx buffer, which will send the char out
;|***       
;|***       // once the tx fifo has drained, the tbe bit will be
;|***       // set in the iir, indicating that the tx buffer is ready for more
;|***       
;|***       // we will refill the tx fifo, up to 127 chars, for a total of 128
;|***       if(com4_tx==0)  // no message to tx
; Line 524
	*** 000443	83 3e 00 00 00 		cmp	WORD PTR ?com4_tx@@3IE,0	;com4_tx
	*** 000448	74 ef 			je	$L2156
;|***         {
;|***         _inp(COM4_IIR);
;|***         goto start_com4_isr;
;|***         }
;|***       if(com4_tx==1)  // tx remaining message
; Line 529
	*** 00044a	39 36 00 00 		cmp	WORD PTR ?com4_tx@@3IE,si	;com4_tx
	*** 00044e	74 03 			je	$JCC1102
	*** 000450	e9 fa 00 		jmp	$L2158
					$JCC1102:
;|***         {
;|***         for(i=0; i<16;i++) // load 16 characters into the tx fifo
; Line 531
	*** 000453	33 c9 			xor	cx,cx
					$F2098:
;|***           {
;|***           if(com4_tx==0) break;
; Line 533
	*** 000455	83 3e 00 00 00 		cmp	WORD PTR ?com4_tx@@3IE,0	;com4_tx
	*** 00045a	75 03 			jne	$JCC1114
	*** 00045c	e9 ee 00 		jmp	$L2158
					$JCC1114:
;|***           else  // only if more message needs to be sent
;|***             {
;|***             _outp(COM4_TX, tx4_message[tx4_index]); // write the next character
; Line 536
	*** 00045f	8b 1e 00 00 		mov	bx,WORD PTR ?tx4_index@@3IE	;tx4_index
	*** 000463	2a e4 			sub	ah,ah
	*** 000465	8a 87 00 00 		mov	al,BYTE PTR ?tx4_message@@3QIEI[bx]	;tx4_message
	*** 000469	ba e8 02 		mov	dx,744	;02e8H
	*** 00046c	ee 			out	dx, al

;|***             tx4_index++;
;|***             tx4_counter++;
; Line 538
	*** 00046d	ff 06 00 00 		inc	WORD PTR ?tx4_counter@@3IE	;tx4_counter
;|***             if(tx4_index >= tx4_len)  // entire message has been sent
; Line 539
	*** 000471	a1 00 00 		mov	ax,WORD PTR ?tx4_len@@3IE	;tx4_len
	*** 000474	ff 06 00 00 		inc	WORD PTR ?tx4_index@@3IE	;tx4_index
	*** 000478	39 06 00 00 		cmp	WORD PTR ?tx4_index@@3IE,ax	;tx4_index
	*** 00047c	73 0a 			jae	$L2144
	*** 00047e	41 			inc	cx
	*** 00047f	83 f9 10 		cmp	cx,16	;0010H
	*** 000482	72 d1 			jb	$F2098
	*** 000484	e9 c6 00 		jmp	$L2158
	*** 000487	90 			nop	
					$L2144:
;|***               {
;|***               tx4_index = 0;
;|***               com4_tx = 0;
;|***               tx4_len = 0;
; Line 543
	*** 000488	33 c0 			xor	ax,ax
	*** 00048a	a3 00 00 		mov	WORD PTR ?tx4_index@@3IE,ax	;tx4_index
	*** 00048d	a3 00 00 		mov	WORD PTR ?com4_tx@@3IE,ax	;com4_tx
	*** 000490	a3 00 00 		mov	WORD PTR ?tx4_len@@3IE,ax	;tx4_len
;|***               goto start_com4_isr;  
; Line 544
	*** 000493	e9 b7 00 		jmp	$L2158
;|***               }
;|***             }
;|***           }
;|***         }
;|***       goto start_com4_isr;    
;|***       }
;|***       
;|***     // rx data received interrupt routine (>= 14 bytes in receive buffer)
;|***     if(intr == 2)
; Line 553
					$I2095:
	*** 000496	83 fe 02 		cmp	si,2
	*** 000499	75 27 			jne	$I2104
	*** 00049b	bb 0c 00 		mov	bx,12	;000cH
;|***       {
;|***       // read rx register
;|***             
;|***       // read 12 bytes from the rx register (still at least 2 bytes left)
;|***       for(i = 0; i < 12; i++)
; Line 558
					$F2105:
;|***         {
;|***         rx4_message[rx4_index] = _inp(COM4_RX);
; Line 560
	*** 00049e	ba e8 02 		mov	dx,744	;02e8H
	*** 0004a1	ec 			in	al,dx
	*** 0004a2	8b 36 00 00 		mov	si,WORD PTR ?rx4_index@@3IE	;rx4_index
	*** 0004a6	88 84 00 00 		mov	BYTE PTR ?rx4_message@@3QIEI[si],al	;rx4_message
;|***         rx4_index++;
;|***         if(rx4_index >= 80) rx4_index = 0;
; Line 562
	*** 0004aa	ff 06 00 00 		inc	WORD PTR ?rx4_index@@3IE	;rx4_index
	*** 0004ae	83 3e 00 00 50 		cmp	WORD PTR ?rx4_index@@3IE,80	;0050H	;rx4_index
	*** 0004b3	72 06 			jb	$FC2106
	*** 0004b5	c7 06 00 00 00 00 	mov	WORD PTR ?rx4_index@@3IE,0	;rx4_index
;|***       for(i = 0; i < 12; i++)
; Line 558
					$FC2106:
	*** 0004bb	4b 			dec	bx
	*** 0004bc	75 e0 			jne	$F2105
	*** 0004be	e9 8c 00 		jmp	$L2158
	*** 0004c1	90 			nop	
;|***         {
;|***         rx4_message[rx4_index] = _inp(COM4_RX);
;|***         rx4_index++;
;|***         if(rx4_index >= 80) rx4_index = 0;
;|***         }
;|***         
;|***       goto start_com4_isr;
;|***       }
;|***     
;|***     // else do serialization error/break routine  
;|***     if(intr == 3)
; Line 569
					$I2104:
	*** 0004c2	83 fe 03 		cmp	si,3
	*** 0004c5	75 07 			jne	$I2109
;|***       {
;|***       // read serialization status register
;|***       unsigned lsr_char = _inp(COM4_LSR);
; Line 572
	*** 0004c7	ba ed 02 		mov	dx,749	;02edH
	*** 0004ca	e9 6c ff 		jmp	$L2156
	*** 0004cd	90 			nop	
;|***       goto start_com4_isr;
;|***       }
;|***     
;|***     // do rx character timeout routine: message end
;|***     if(intr == 6)
; Line 577
					$I2109:
	*** 0004ce	83 fe 06 		cmp	si,6
	*** 0004d1	75 7a 			jne	$L2158
;|***       {
;|***       // drain rx register first
;|***       while((_inp(COM4_LSR) & 0x01) == 1)
; Line 580
	*** 0004d3	eb 1e 			jmp	SHORT $L2157
	*** 0004d5	90 			nop	
					$FC2113:
;|***         {
;|***         rx4_message[rx4_index] = _inp(COM4_RX);
; Line 582
	*** 0004d6	ba e8 02 		mov	dx,744	;02e8H
	*** 0004d9	ec 			in	al,dx
	*** 0004da	8b 1e 00 00 		mov	bx,WORD PTR ?rx4_index@@3IE	;rx4_index
	*** 0004de	88 87 00 00 		mov	BYTE PTR ?rx4_message@@3QIEI[bx],al	;rx4_message
;|***         rx4_index++;
;|***         if(rx4_index >= 80) rx4_index = 0;
; Line 584
	*** 0004e2	ff 06 00 00 		inc	WORD PTR ?rx4_index@@3IE	;rx4_index
	*** 0004e6	83 3e 00 00 50 		cmp	WORD PTR ?rx4_index@@3IE,80	;0050H	;rx4_index
	*** 0004eb	72 06 			jb	$L2157
	*** 0004ed	c7 06 00 00 00 00 	mov	WORD PTR ?rx4_index@@3IE,0	;rx4_index
;|***         }
; Line 585
					$L2157:
	*** 0004f3	ba ed 02 		mov	dx,749	;02edH
	*** 0004f6	ec 			in	al,dx
	*** 0004f7	24 01 			and	al,1
	*** 0004f9	fe c8 			dec	al
	*** 0004fb	74 d9 			je	$FC2113
;|***       
;|***       if(rx4_index >= 77) // complete frame received
; Line 587
	*** 0004fd	83 3e 00 00 4d 		cmp	WORD PTR ?rx4_index@@3IE,77	;004dH	;rx4_index
	*** 000502	72 49 			jb	$L2158
;|***         {
;|***         time_stamp(&gps_time);
; Line 589
	*** 000504	68 00 00 		push	SEG ?gps_time@@3UTIMER@@E	;gps_time
	*** 000507	68 00 00 		push	OFFSET ?gps_time@@3UTIMER@@E	;gps_time
	*** 00050a	9a 00 00 00 00 		call	FAR PTR ?time_stamp@@ZAXPEUTIMER@@@Z	; time_stamp
	*** 00050f	83 c4 04 		add	sp,4
;|***         memcpy(gps_buffer, rx4_message, sizeof(gps_buffer));
; Line 590
	*** 000512	b8 ac 00 		mov	ax,172	;00acH
	*** 000515	89 46 fe 		mov	WORD PTR [bp-2],ax
	*** 000518	68 00 00 		push	SEG ?gps_buffer@@3QIEI	;gps_buffer
	*** 00051b	68 00 00 		push	OFFSET ?gps_buffer@@3QIEI	;gps_buffer
	*** 00051e	1e 			push	ds
	*** 00051f	68 00 00 		push	OFFSET DGROUP:?rx4_message@@3QIEI	;rx4_message
	*** 000522	b8 50 00 		mov	ax,80	;0050H
	*** 000525	ff 56 fe 		call	WORD PTR [bp-2]
;|***         gps_new_data = 1;
; Line 591
	*** 000528	c7 06 00 00 01 00 	mov	WORD PTR ?gps_new_data@@3IE,1	;gps_new_data
;|***         gps_data_frame = frame;
; Line 592
	*** 00052e	a1 00 00 		mov	ax,WORD PTR ?frame@@3KE	;frame
	*** 000531	8b 16 02 00 		mov	dx,WORD PTR ?frame@@3KE+2	;frame
	*** 000535	a3 00 00 		mov	WORD PTR ?gps_data_frame@@3KE,ax	;gps_data_frame
	*** 000538	89 16 02 00 		mov	WORD PTR ?gps_data_frame@@3KE+2,dx	;gps_data_frame
;|***         rx4_index = 0;
; Line 593
	*** 00053c	33 c0 			xor	ax,ax
	*** 00053e	a3 00 00 		mov	WORD PTR ?rx4_index@@3IE,ax	;rx4_index
;|***         _fmemset(rx4_message, 0, sizeof(rx4_message));
; Line 594
	*** 000541	bb 00 00 		mov	bx,OFFSET DGROUP:?rx4_message@@3QIEI	;rx4_message
	*** 000544	b9 28 00 		mov	cx,40	;0028H
	*** 000547	8b fb 			mov	di,bx
	*** 000549	1e 			push	ds
	*** 00054a	07 			pop	es
	*** 00054b	f3 			rep
	*** 00054c	ab 			stosw
;|***         }
;|*** 
;|***       goto start_com4_isr;      
; Line 597
					$L2158:
	*** 00054d	ba ea 02 		mov	dx,746	;02eaH
	*** 000550	ec 			in	al,dx
	*** 000551	2a e4 			sub	ah,ah
	*** 000553	8b f0 			mov	si,ax
;|***   if((intr & 0x01) == 0) // if a valid com4 interrupt is pending
; Line 496
	*** 000555	83 e6 0f 		and	si,15	;000fH
	*** 000558	f7 c6 01 00 		test	si,1
	*** 00055c	75 03 			jne	$JCC1372
	*** 00055e	e9 cf fe 		jmp	$start_com4_isr2091
					$JCC1372:
;|***     {   
;|***     // shift IIR value right one bit and test to see which routine is required
;|***     intr = intr >> 1;
;|***   
;|***     // do rs232 input interrupt routine
;|***     if(intr == 0)
;|***       {
;|***       // read the rs232 status register
;|***       unsigned msr_char = _inp(COM4_MSR);
;|***       goto start_com4_isr;
;|***       }
;|***      
;|***     // do tx buffer empty interrupt routine
;|***     if(intr == 1)
;|***       {
;|***       // either write to tx FIFO or read int id register again
;|***       
;|***       // the idea here is to continue a tx once it has started,
;|***       // not to start one in the first place
;|***       
;|***       // the tx is started by the main() program writing the first
;|***       // char to the tx buffer, which will send the char out
;|***       
;|***       // once the tx fifo has drained, the tbe bit will be
;|***       // set in the iir, indicating that the tx buffer is ready for more
;|***       
;|***       // we will refill the tx fifo, up to 127 chars, for a total of 128
;|***       if(com4_tx==0)  // no message to tx
;|***         {
;|***         _inp(COM4_IIR);
;|***         goto start_com4_isr;
;|***         }
;|***       if(com4_tx==1)  // tx remaining message
;|***         {
;|***         for(i=0; i<16;i++) // load 16 characters into the tx fifo
;|***           {
;|***           if(com4_tx==0) break;
;|***           else  // only if more message needs to be sent
;|***             {
;|***             _outp(COM4_TX, tx4_message[tx4_index]); // write the next character
;|***             tx4_index++;
;|***             tx4_counter++;
;|***             if(tx4_index >= tx4_len)  // entire message has been sent
;|***               {
;|***               tx4_index = 0;
;|***               com4_tx = 0;
;|***               tx4_len = 0;
;|***               goto start_com4_isr;  
;|***               }
;|***             }
;|***           }
;|***         }
;|***       goto start_com4_isr;    
;|***       }
;|***       
;|***     // rx data received interrupt routine (>= 14 bytes in receive buffer)
;|***     if(intr == 2)
;|***       {
;|***       // read rx register
;|***             
;|***       // read 12 bytes from the rx register (still at least 2 bytes left)
;|***       for(i = 0; i < 12; i++)
;|***         {
;|***         rx4_message[rx4_index] = _inp(COM4_RX);
;|***         rx4_index++;
;|***         if(rx4_index >= 80) rx4_index = 0;
;|***         }
;|***         
;|***       goto start_com4_isr;
;|***       }
;|***     
;|***     // else do serialization error/break routine  
;|***     if(intr == 3)
;|***       {
;|***       // read serialization status register
;|***       unsigned lsr_char = _inp(COM4_LSR);
;|***       goto start_com4_isr;
;|***       }
;|***     
;|***     // do rx character timeout routine: message end
;|***     if(intr == 6)
;|***       {
;|***       // drain rx register first
;|***       while((_inp(COM4_LSR) & 0x01) == 1)
;|***         {
;|***         rx4_message[rx4_index] = _inp(COM4_RX);
;|***         rx4_index++;
;|***         if(rx4_index >= 80) rx4_index = 0;
;|***         }
;|***       
;|***       if(rx4_index >= 77) // complete frame received
;|***         {
;|***         time_stamp(&gps_time);
;|***         memcpy(gps_buffer, rx4_message, sizeof(gps_buffer));
;|***         gps_new_data = 1;
;|***         gps_data_frame = frame;
;|***         rx4_index = 0;
;|***         _fmemset(rx4_message, 0, sizeof(rx4_message));
;|***         }
;|*** 
;|***       goto start_com4_isr;      
;|***       } // end rx character timeout routine
;|***         
;|***     goto start_com4_isr;
;|***     }  // end if((intr & 0x01) == 0)
;|***   
;|***   _disable();  
; Line 603
	*** 000561	fa 			cli	
;|***     // enable com4 uart interrupts    
;|***   _outp(COM4_MCR, _inp(COM4_MCR) | 0x08);
; Line 605
	*** 000562	ba ec 02 		mov	dx,748	;02ecH
	*** 000565	ec 			in	al,dx
	*** 000566	0c 08 			or	al,8
	*** 000568	ee 			out	dx, al

;|***   _outp(0xa0, 0x20);  // non-specific return from interrupt slave PIC
; Line 606
	*** 000569	b8 20 00 		mov	ax,32	;0020H
	*** 00056c	e6 a0 			out	160	;00a0H, al

;|***   _outp(0x20, 0x20);  // non-specific return from interrupt master PIC
; Line 607
	*** 00056e	8b d0 			mov	dx,ax
	*** 000570	ee 			out	dx, al

;|***   }  // end com4_isr()
; Line 608
	*** 000571	8b e5 			mov	sp,bp
	*** 000573	07 			pop	es
	*** 000574	1f 			pop	ds
	ASSUME DS: DGROUP
	*** 000575	61 			popa
	*** 000576	cf 			iret	

?com4_isr@@ZAXXZ	ENDP
	PUBLIC	?shutdown_com1@@ZAXXZ	; shutdown_com1
?shutdown_com1@@ZAXXZ	PROC FAR	; shutdown_com1
;|*** 
;|*** 
;|*** void shutdown_com1(void)
;|***   {
;|***   _disable();
; Line 613
	*** 000577	fa 			cli	
;|***   // disable com1 interrupts at the uart
;|***   _outp( COM1_MCR, 0X00);
; Line 615
	*** 000578	33 c0 			xor	ax,ax
	*** 00057a	ba fc 03 		mov	dx,1020	;03fcH
	*** 00057d	ee 			out	dx, al

;|***   _outp( COM1_IER, 0x00);
; Line 616
	*** 00057e	ba f9 03 		mov	dx,1017	;03f9H
	*** 000581	ee 			out	dx, al

;|***   // mask irq4 interrupts at master pic
;|***   _outp(0x21, _inp(0x21) | ~0xef);
; Line 618
	*** 000582	e4 21 			in	al,33	;0021H
	*** 000584	0d 10 ff 		or	ax,-240	;ff10H
	*** 000587	e6 21 			out	33	;0021H, al

;|***   // restore original COM1 vector
;|***   _dos_setvect(4+8, com1_old_vector);
; Line 620
	*** 000589	ff 36 02 00 		push	WORD PTR ?com1_old_vector@@3P7AXXZE+2	;com1_old_vector
	*** 00058d	ff 36 00 00 		push	WORD PTR ?com1_old_vector@@3P7AXXZE	;com1_old_vector
	*** 000591	6a 0c 			push	12	;000cH
	*** 000593	9a 00 00 00 00 		call	FAR PTR __dos_setvect
	*** 000598	83 c4 06 		add	sp,6
;|***   _enable();
; Line 621
	*** 00059b	fb 			sti	
;|***   }
; Line 622
	*** 00059c	cb 			ret	
	*** 00059d	90 			nop	

?shutdown_com1@@ZAXXZ	ENDP
	PUBLIC	?shutdown_com2@@ZAXXZ	; shutdown_com2
?shutdown_com2@@ZAXXZ	PROC FAR	; shutdown_com2
;|***   
;|***   
;|*** void shutdown_com2(void)
;|***   {
;|***   _disable();
; Line 627
	*** 00059e	fa 			cli	
;|***   // disable com2 interrupts at the uart
;|***   _outp( COM2_MCR, 0x00);
; Line 629
	*** 00059f	33 c0 			xor	ax,ax
	*** 0005a1	ba fc 02 		mov	dx,764	;02fcH
	*** 0005a4	ee 			out	dx, al

;|***   _outp( COM2_IER, 0x00);
; Line 630
	*** 0005a5	ba f9 02 		mov	dx,761	;02f9H
	*** 0005a8	ee 			out	dx, al

;|***   // mask irq3 interrupts at master pic
;|***   _outp(0x21, _inp(0x21) | ~0xf7); 
; Line 632
	*** 0005a9	e4 21 			in	al,33	;0021H
	*** 0005ab	0d 08 ff 		or	ax,-248	;ff08H
	*** 0005ae	e6 21 			out	33	;0021H, al

;|***   // restore original COM2 vector
;|***   _dos_setvect(3+8, com2_old_vector);
; Line 634
	*** 0005b0	ff 36 02 00 		push	WORD PTR ?com2_old_vector@@3P7AXXZE+2	;com2_old_vector
	*** 0005b4	ff 36 00 00 		push	WORD PTR ?com2_old_vector@@3P7AXXZE	;com2_old_vector
	*** 0005b8	6a 0b 			push	11	;000bH
	*** 0005ba	9a 00 00 00 00 		call	FAR PTR __dos_setvect
	*** 0005bf	83 c4 06 		add	sp,6
;|***   _enable();
; Line 635
	*** 0005c2	fb 			sti	
;|***   }
; Line 636
	*** 0005c3	cb 			ret	

?shutdown_com2@@ZAXXZ	ENDP
	PUBLIC	?shutdown_com4@@ZAXXZ	; shutdown_com4
?shutdown_com4@@ZAXXZ	PROC FAR	; shutdown_com4
;|***   
;|*** void shutdown_com4(void)
;|***   {
;|***   _disable();
; Line 640
	*** 0005c4	fa 			cli	
;|***   // disable com4 interrupts at the uart
;|***   _outp( COM4_MCR, 0x00);
; Line 642
	*** 0005c5	33 c0 			xor	ax,ax
	*** 0005c7	ba ec 02 		mov	dx,748	;02ecH
	*** 0005ca	ee 			out	dx, al

;|***   _outp( COM4_IER, 0x00);
; Line 643
	*** 0005cb	ba e9 02 		mov	dx,745	;02e9H
	*** 0005ce	ee 			out	dx, al

;|***   // mask irq9 interrupts at slave pic
;|***   _outp(0xa1, _inp(0xa1) | ~0xfd); 
; Line 645
	*** 0005cf	e4 a1 			in	al,161	;00a1H
	*** 0005d1	0d 02 ff 		or	ax,-254	;ff02H
	*** 0005d4	e6 a1 			out	161	;00a1H, al

;|***   // restore original COM2 vector
;|***   _dos_setvect(9+0x70-8, com4_old_vector);
; Line 647
	*** 0005d6	ff 36 02 00 		push	WORD PTR ?com4_old_vector@@3P7AXXZE+2	;com4_old_vector
	*** 0005da	ff 36 00 00 		push	WORD PTR ?com4_old_vector@@3P7AXXZE	;com4_old_vector
	*** 0005de	6a 71 			push	113	;0071H
	*** 0005e0	9a 00 00 00 00 		call	FAR PTR __dos_setvect
	*** 0005e5	83 c4 06 		add	sp,6
;|***   _enable();
; Line 648
	*** 0005e8	fb 			sti	
;|***   
;|***   }
; Line 650
	*** 0005e9	cb 			ret	

?shutdown_com4@@ZAXXZ	ENDP
RS232CB8_TEXT	ENDS
END
;|***   
